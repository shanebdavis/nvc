/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(2);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(3).includeInNamespace(__webpack_require__(18));

	__webpack_require__(114);


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var Neptune, Nvc,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Nvc || Neptune.addNamespace('Nvc', Nvc = (function(superClass) {
	  extend(Nvc, superClass);

	  function Nvc() {
	    return Nvc.__super__.constructor.apply(this, arguments);
	  }

	  return Nvc;

	})(Neptune.Base));


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5);


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	TODO: Make NN ugifly-mangler friendly. In order to do that, we need
	to stop using the function.name attribute.

	I think we can do that with one change: addNamespace needs to
	change to take a name argument: @addNamespace: (name, namespace) ->
	 */
	var Base, Neptune, NeptuneLib, isFunction, isPlainArray,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	__webpack_require__(6);

	__webpack_require__(7);

	isFunction = function(f) {
	  return typeof f === "function";
	};

	isPlainArray = function(o) {
	  return o.constructor === Array;
	};

	NeptuneLib = null;

	Base = (function() {
	  var excludedPropNames;

	  function Base() {}

	  Base.allNamespaces = {};

	  Base.getAllNamespacePaths = function() {
	    return Object.keys(Base.allNamespaces).sort();
	  };

	  Base.toString = function() {
	    return this.namespacePath;
	  };

	  Base.inspect = function() {
	    return this.namespacePath;
	  };

	  Base._name = "Base";

	  Base.namespacePath = "Neptune.Base";

	  Base.namespace = null;

	  Base.namespaces = {};

	  Base.modules = {};

	  Base.getNamespacePath = function() {
	    return this.namespacePath;
	  };

	  Base.getNamespaceNames = function() {
	    return Object.keys(this.namespaces).sort();
	  };

	  Base.getModuleNames = function() {
	    return Object.keys(this.modules).sort();
	  };

	  Base.getNeptuneLib = function() {
	    return NeptuneLib || (NeptuneLib = __webpack_require__(8));
	  };

	  Base.getInspectedObjects = function(includeModules) {
	    var name, namespace, obj;
	    if (includeModules == null) {
	      includeModules = true;
	    }
	    return (
	      obj = {},
	      obj["" + this.namespacePath] = this.getNeptuneLib().merge(this.version ? {
	        version: this.version
	      } : void 0, (function() {
	        var ref, results;
	        ref = this.namespaces;
	        results = [];
	        for (name in ref) {
	          namespace = ref[name];
	          results.push(namespace.getInspectedObjects(includeModules));
	        }
	        return results;
	      }).call(this), includeModules && this.getModuleNames().length > 0 ? {
	        modules: this.getModuleNames().join(', ')
	      } : void 0),
	      obj
	    );
	  };

	  Base.addNamespace = function(name, namespace) {
	    return this.allNamespaces[namespace.namespacePath] = this.namespaces[name] = this[name] = namespace._init(name, this);
	  };

	  Base.addModules = function(map) {
	    var module, name;
	    for (name in map) {
	      module = map[name];
	      this._setChildNamespaceProps(name, module);
	      if (!name.match(/^-/)) {
	        this.modules[name] = this[name] = module;
	      }
	    }
	    return this;
	  };


	  /*
	  IN: any combination of objects or arrays
	    object: all properties in the object are added to the namespace
	  
	    array: [fromObject, property names as one or more strings]
	      for propName in every sub-string in args matching: /[0-9a-z_]+/ig
	        @_addToNamespace propName, fromObject
	  
	      Each string is parsed to find everything that matches: /[0-9a-z_]+/ig
	      All resulting property names are concated into a one list.
	      Every property in fromObject that matches one of the property-names is added to the namespace.
	   */

	  Base.includeInNamespace = function() {
	    var arg, args, fromObject, i, j, k, l, len, len1, propName, ref, ref1, v;
	    args = arguments.length === 1 && isPlainArray(arguments[0]) ? arguments[0] : arguments;
	    for (j = 0, len = args.length; j < len; j++) {
	      arg = args[j];
	      if (arg) {
	        if (isPlainArray(arg)) {
	          fromObject = arg[0];
	          for (i = k = 1, ref = arg.length; 1 <= ref ? k < ref : k > ref; i = 1 <= ref ? ++k : --k) {
	            ref1 = arg[i].match(/[0-9a-z_]+/ig);
	            for (l = 0, len1 = ref1.length; l < len1; l++) {
	              propName = ref1[l];
	              this._addToNamespace(propName, fromObject);
	            }
	          }
	        } else {
	          for (propName in arg) {
	            v = arg[propName];
	            this._addToNamespace(propName, arg);
	          }
	        }
	      }
	    }
	    return this;
	  };


	  /*
	  Every child of a namespace gets these properties:
	  
	    namespace:      pointer to the parent namespace
	    namespacePath:  string path from global to child
	  
	  NOTE: only modules which return a class or function
	    get their namespace-props set.
	   */

	  Base._setChildNamespaceProps = function(name, child) {
	    if (isFunction(child)) {
	      if (isFunction(child["class"])) {
	        this._setChildNamespaceProps(name, child["class"]);
	      }
	      child.namespace = this;
	      return child.namespacePath = this.namespacePath + "." + name;
	    }
	  };


	  /*
	  CoffeeScript classes copy all class props when inheriting,
	  but some props need to be unique to each instance. This
	  function initializes those props.
	   */

	  Base._init = function(name, namespace1) {
	    this.namespace = namespace1;
	    this._name = name;
	    this.modules = {};
	    this.namespaces = {};
	    this.namespace._setChildNamespaceProps(name, this);
	    return this;
	  };

	  excludedPropNames = ["__super__"].concat(Object.keys(Base));


	  /*
	  Helper for includeInNamespace.
	  Add anything to the namespace.
	  
	  IN:
	    propName:   property name to  value will be assigned to in the namespace (string)
	    addingFrom: object
	      used for reporting errors if attempting to overwrite an
	      existing item.
	  
	  EFFECT:
	    Only adds value if @[propName] is not already set.
	    Otherwise, reports error and continues.
	  
	  OUT: value
	   */

	  Base._addToNamespace = function(propName, addingFrom) {
	    var addingFromString, value;
	    if (propName === "inspect" && (value = addingFrom[propName]).length > 0) {
	      return this[propName] = value;
	    }
	    if (indexOf.call(excludedPropNames, propName) >= 0) {
	      return;
	    }
	    if (!(value = addingFrom[propName])) {
	      return;
	    }
	    if (this[propName]) {
	      if (this[propName] !== value) {
	        addingFromString = addingFrom.namespacePath || addingFrom.propName || (Object.keys(addingFrom)).join(', ');
	        console.error(this.namespacePath + " already has key: " + propName + ". Adding from: " + addingFromString);
	      }
	      return this[propName];
	    } else {
	      return this[propName] = value;
	    }
	  };

	  return Base;

	})();

	module.exports = global.Neptune = Neptune = (function(superClass) {
	  var _package;

	  extend(Neptune, superClass);

	  function Neptune() {
	    return Neptune.__super__.constructor.apply(this, arguments);
	  }

	  Neptune.Base = Base;

	  Neptune.namespacePath = "Neptune";

	  Neptune.namespace = null;

	  Neptune.isNamespace = function(klass) {
	    return (klass != null ? klass.prototype : void 0) instanceof Base;
	  };

	  Neptune.isNode = __webpack_require__(16);

	  Neptune["package"] = _package = __webpack_require__(17);

	  Neptune.version = _package.version;

	  return Neptune;

	})(Base);

	Base.namespace = Neptune;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 6 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {if (typeof global !== "undefined" && global !== null) {
	  global.self = global;
	} else if (typeof self !== "undefined" && self !== null) {
	  self.global = self;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 7 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {if ((function() {}).name == null) {
	  Object.defineProperty(global.Function.prototype, 'name', {
	    get: function() {
	      var matches, name;
	      name = (matches = this.toString().match(/^\s*function\s*([^\s(]+)/)) ? matches[1] : "";
	      Object.defineProperty(this, 'name', {
	        value: name
	      });
	      return name;
	    }
	  });
	}

	global.Function.prototype.getName = function() {
	  return this._name || this.name || "anonymousFunction";
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(9);


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(10).includeInNamespace(__webpack_require__(11)).addModules({
	  ArrayCompactFlatten: __webpack_require__(12),
	  Merge: __webpack_require__(14),
	  StringCase: __webpack_require__(13),
	  Types: __webpack_require__(15)
	});


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var Neptune, NeptuneLib,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.NeptuneLib || Neptune.addNamespace('NeptuneLib', NeptuneLib = (function(superClass) {
	  extend(NeptuneLib, superClass);

	  function NeptuneLib() {
	    return NeptuneLib.__super__.constructor.apply(this, arguments);
	  }

	  return NeptuneLib;

	})(Neptune.Base));


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [__webpack_require__(12), __webpack_require__(13), __webpack_require__(14)];


/***/ },
/* 12 */
/***/ function(module, exports) {

	var ArrayCompactFlatten;

	module.exports = ArrayCompactFlatten = (function() {
	  var arraySlice, compact, compactFlattenIfNeeded, deepArrayEach, doFlattenInternal, flatten, isArguments, isArrayOrArguments, keepAll, keepUnlessNullOrUndefined, needsFlatteningOrCompacting;

	  function ArrayCompactFlatten() {}

	  ArrayCompactFlatten.isArguments = isArguments = function(o) {
	    return o.constructor === Object && (typeof o.callee === "function") && (typeof o.length === "number");
	  };

	  ArrayCompactFlatten.isArrayOrArguments = isArrayOrArguments = function(o) {
	    return o && (o.constructor === Array || isArguments(o));
	  };

	  ArrayCompactFlatten.needsFlatteningOrCompacting = needsFlatteningOrCompacting = function(array, keepTester) {
	    var a, i, len;
	    for (i = 0, len = array.length; i < len; i++) {
	      a = array[i];
	      if (isArrayOrArguments(a) || !keepTester(a)) {
	        return true;
	      }
	    }
	    return false;
	  };

	  ArrayCompactFlatten.keepUnlessNullOrUndefined = keepUnlessNullOrUndefined = function(a) {
	    return a !== null && a !== void 0;
	  };


	  /*
	  IN:
	    array: array or arguments-object
	    keepTester: (value) -> true/false
	      OUT: return true if that element should be in the output
	  
	  OUT: array where all elements test true to keepTester
	  NOTE: NOT recursive - just does a shallow pass
	   */

	  ArrayCompactFlatten.compact = compact = function(array, keepTester) {
	    var a, i, len;
	    if (keepTester == null) {
	      keepTester = keepUnlessNullOrUndefined;
	    }
	    for (i = 0, len = array.length; i < len; i++) {
	      a = array[i];
	      if (!keepTester(a)) {
	        return (function() {
	          var j, len1, results;
	          results = [];
	          for (j = 0, len1 = array.length; j < len1; j++) {
	            a = array[j];
	            if (keepTester(a)) {
	              results.push(a);
	            }
	          }
	          return results;
	        })();
	      }
	    }
	    return array;
	  };


	  /*
	  IN: accepts any number of arguments
	  NOTE: RECURSIVE: recurses into all arry or arguments-objects and adds their contents
	    to the top level (flatten)
	   */

	  ArrayCompactFlatten.flatten = flatten = function(firstArg) {
	    return compactFlattenIfNeeded(arguments.length === 1 ? isArrayOrArguments(firstArg) ? firstArg : [firstArg] : arguments);
	  };


	  /*
	  IN: array: any object that has a length
	  
	  EFFECT:
	    itterates over array and recurse over any element which isArrayOrArguments
	    invokes f on every element that is not isArrayOrArguments
	  OUT: array (same as passed in)
	   */

	  ArrayCompactFlatten.deepArrayEach = deepArrayEach = function(array, f) {
	    var el, i, len;
	    for (i = 0, len = array.length; i < len; i++) {
	      el = array[i];
	      if (isArrayOrArguments(el)) {
	        deepArrayEach(el, f);
	      } else {
	        f(el);
	      }
	    }
	    return array;
	  };


	  /*
	  IN:
	    array: array or arguments-object
	    keepTester: (value) -> true/false
	      OUT: return true if that element should be in the output
	  
	  OUT: array where all elements test true to keepTester
	  NOTE: RECURSIVE: recurses into all arry or arguments-objects and adds their contents
	    to the top level (flatten)
	   */

	  ArrayCompactFlatten.compactFlatten = function(array, keepTester) {
	    if (keepTester == null) {
	      keepTester = keepUnlessNullOrUndefined;
	    }
	    return compactFlattenIfNeeded(array, keepTester);
	  };

	  arraySlice = Array.prototype.slice;

	  doFlattenInternal = function(array, keepTester) {
	    var output;
	    output = [];
	    deepArrayEach(array, function(el) {
	      if (keepTester(el)) {
	        return output.push(el);
	      }
	    });
	    return output;
	  };

	  keepAll = function() {
	    return true;
	  };

	  compactFlattenIfNeeded = function(array, keepTester) {
	    if (keepTester == null) {
	      keepTester = keepAll;
	    }
	    if (needsFlatteningOrCompacting(array, keepTester)) {
	      return doFlattenInternal(array, keepTester);
	    } else if (array.constructor !== Array) {
	      return arraySlice.call(array);
	    } else {
	      return array;
	    }
	  };

	  return ArrayCompactFlatten;

	})();


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var StringCase, compactFlatten;

	compactFlatten = __webpack_require__(12).compactFlatten;

	module.exports = StringCase = (function() {
	  function StringCase() {}

	  StringCase.getCodeWords = function(str) {
	    var _words, word, words;
	    _words = str.match(/[a-zA-Z][a-zA-Z0-9]*/g);
	    if (!_words) {
	      return [];
	    }
	    words = (function() {
	      var i, len, results;
	      results = [];
	      for (i = 0, len = _words.length; i < len; i++) {
	        word = _words[i];
	        results.push(word.match(/(?:[A-Z]{2,}(?![a-z]))|[A-Z][a-z0-9]*|[a-z0-9]+/g));
	      }
	      return results;
	    })();
	    return compactFlatten(words);
	  };

	  StringCase.capitalize = function(str) {
	    return str.charAt(0).toUpperCase() + str.slice(1);
	  };

	  StringCase.decapitalize = function(str) {
	    return str.charAt(0).toLowerCase() + str.slice(1);
	  };

	  StringCase.getLowerCaseCodeWords = function(str) {
	    var i, len, ref, results, word;
	    ref = StringCase.getCodeWords(str);
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      word = ref[i];
	      results.push(word.toLowerCase());
	    }
	    return results;
	  };

	  StringCase.upperCamelCase = function(str) {
	    var word;
	    return ((function() {
	      var i, len, ref, results;
	      ref = this.getLowerCaseCodeWords(str);
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        word = ref[i];
	        results.push(this.capitalize(word));
	      }
	      return results;
	    }).call(StringCase)).join("");
	  };

	  StringCase.lowerCamelCase = function(str) {
	    return StringCase.decapitalize(StringCase.upperCamelCase(str));
	  };

	  StringCase.snakeCase = function(str) {
	    return (StringCase.getLowerCaseCodeWords(str)).join("_");
	  };

	  StringCase.dashCase = function(str) {
	    return (StringCase.getLowerCaseCodeWords(str)).join("-");
	  };

	  return StringCase;

	})();


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var Merge, compactFlatten, isPlainObject;

	compactFlatten = __webpack_require__(12).compactFlatten;

	isPlainObject = __webpack_require__(15).isPlainObject;

	module.exports = Merge = (function() {
	  var deepMerge, merge, mergeInto, pureMerge;

	  function Merge() {}


	  /*
	  
	  merge "flattens" its arguments and then adds all keys from all objects in
	  the list into a new object which is returned.
	  
	  return: new object
	  
	  The first object's keys are added first. If two or more objects have the same
	  keys, the value set in the result is the last object's in the list with that key.
	   */

	  Merge.merge = merge = function() {
	    return mergeInto({}, arguments);
	  };


	  /*
	  The same as 'merge' with one difference:
	  
	  Instead of a new object, all objects are merged into the first object in the list.
	  
	  return: first object in the flattened list
	  return: null if no source objects
	   */

	  Merge.mergeInto = mergeInto = function() {
	    var i, j, k, ref, result, source, sources, v;
	    sources = compactFlatten(arguments);
	    if (sources.length === 0) {
	      return null;
	    }
	    result = sources[0] || {};
	    for (i = j = 1, ref = sources.length; j < ref; i = j += 1) {
	      source = sources[i];
	      for (k in source) {
	        v = source[k];
	        result[k] = v;
	      }
	    }
	    return result;
	  };


	  /*
	  Just like mergeInfo except only merge into the result object UNLESs result.hasOwnProperty
	  
	  if
	    mergeInfo a, b is just like merge a, b except it modifies and returns a instead of returning a new object
	  then
	    mergeIntoUnless b, a is just like merge a, b except it modifies and returns b instead of returning a new object
	  
	  Note: mergeIntoUnless a, b, c, d, e, f is like merge f, e, d, c, b, a
	   */

	  Merge.mergeIntoUnless = function() {
	    var i, j, k, ref, result, source, sources, v;
	    sources = compactFlatten(arguments);
	    if (sources.length === 0) {
	      return null;
	    }
	    result = sources[0] || {};
	    for (i = j = 1, ref = sources.length; j < ref; i = j += 1) {
	      source = sources[i];
	      for (k in source) {
	        v = source[k];
	        if (!result.hasOwnProperty(k)) {
	          result[k] = v;
	        }
	      }
	    }
	    return result;
	  };

	  Merge.deepMerge = deepMerge = function() {
	    var k, list, out, v, val;
	    list = compactFlatten(arguments);
	    out = merge(list);
	    for (k in out) {
	      v = out[k];
	      if (isPlainObject(v)) {
	        out[k] = deepMerge((function() {
	          var j, len, results;
	          results = [];
	          for (j = 0, len = list.length; j < len; j++) {
	            val = list[j];
	            results.push(val[k]);
	          }
	          return results;
	        })());
	      }
	    }
	    return out;
	  };

	  Merge.hasAllProps = function(o1, o2) {
	    var k, v;
	    for (k in o1) {
	      v = o1[k];
	      if (!o2.hasOwnProperty(k)) {
	        return false;
	      }
	    }
	    return true;
	  };

	  Merge.pureMerge = pureMerge = function() {
	    var j, last, len, source, sources;
	    sources = compactFlatten(arguments);
	    if (sources.length === 0) {
	      return null;
	    }
	    if (sources.length === 1) {
	      return sources[0];
	    }
	    last = sources[sources.length - 1];
	    for (j = 0, len = sources.length; j < len; j++) {
	      source = sources[j];
	      if (source !== last) {
	        if (!Merge.hasAllProps(source, last)) {
	          return Merge.merge(sources);
	        }
	      }
	    }
	    return last;
	  };


	  /*
	  I might consider adding "o" - which works like Object-Tree constructors:
	    First, it compact-flattens args
	    Second, it gathers up and merges all plain-objects in its arguments list
	    Last, all remaining items get added to the "children" list
	  The question is, what does it return? Options:
	  
	    OPTION: If only plain-objects after compact-flatten, just return the merged object ELSE:
	  
	  Options if both objects and non-object values are present:
	    a. return compactFlatten [plainObject, nonObjectValues]
	    b. return merge plainObject, children: nonObjectValues
	    c. return new MClass plainObject, nonObjectValues
	      class MClass extends BaseObject
	        @properties "props children"
	        constructor: (@props, @children) ->
	   */

	  Merge.m = pureMerge;

	  return Merge;

	})();


/***/ },
/* 15 */
/***/ function(module, exports) {

	var Types;

	module.exports = Types = (function() {
	  var hasOwnProperties, hasProperties, isArray, isClass, isFunction, isJsonAtomicType, isNumber, isObject, isPlainArray, isPlainObject, isString;

	  function Types() {}

	  Types.isPromise = function(obj) {
	    return isFunction(obj != null ? obj.then : void 0);
	  };

	  Types.isRegExp = function(obj) {
	    return obj instanceof RegExp;
	  };

	  Types.isNumber = isNumber = function(obj) {
	    return typeof obj === "number";
	  };


	  /*
	  Maybe we should just the API for array compatibility rather than specific types.
	    typeof obj == "object" &&
	      && isFunction obj.forEach
	      && isFunction obj.indexOf
	      && isNumber obj.length
	   */

	  Types.isArray = isArray = self.Uint8ClampedArray ? function(obj) {
	    return !!obj && (obj.constructor === Array || obj instanceof Uint8ClampedArray || obj instanceof Int8Array || obj instanceof Uint8Array || obj instanceof Int16Array || obj instanceof Uint16Array || obj instanceof Int32Array || obj instanceof Uint32Array || obj instanceof Float32Array || obj instanceof Float64Array);
	  } : function(obj) {
	    return !!obj && (obj.constructor === Array || obj instanceof Int8Array || obj instanceof Uint8Array || obj instanceof Int16Array || obj instanceof Uint16Array || obj instanceof Int32Array || obj instanceof Uint32Array || obj instanceof Float32Array || obj instanceof Float64Array);
	  };

	  Types.isDate = function(obj) {
	    return obj && obj.constructor === Date;
	  };

	  Types.isString = isString = function(obj) {
	    return typeof obj === "string";
	  };

	  Types.isFunction = isFunction = function(obj) {
	    return typeof obj === "function";
	  };

	  Types.isEmptyObject = function(obj) {
	    return Object.keys(obj).length === 0;
	  };

	  Types.isBoolean = function(obj) {
	    return obj === true || obj === false;
	  };

	  Types.isClass = isClass = function(obj) {
	    return !!(typeof obj === "function" && ((typeof obj.__super__ === "object") || (hasOwnProperties(obj)) || (obj.prototype && hasProperties(obj.prototype))));
	  };

	  Types.isJsonAtomicType = isJsonAtomicType = function(a) {
	    return isString(a) || isNumber(a) || a === true || a === false || a === null;
	  };

	  Types.isJsonType = function(a) {
	    return isJsonAtomicType(a) || isPlainObject(a) || isPlainArray(a);
	  };

	  Types.isObject = isObject = function(obj) {
	    return !!obj && typeof obj === "object" && !isPlainArray(obj);
	  };

	  Types.isPlainArray = isPlainArray = function(v) {
	    if (v) {
	      return v.constructor === Array;
	    } else {
	      return false;
	    }
	  };

	  Types.isPlainObject = isPlainObject = function(v) {
	    if (v) {
	      return v.constructor === Object;
	    } else {
	      return false;
	    }
	  };

	  Types.hasProperties = hasProperties = function(o) {
	    var k;
	    for (k in o) {
	      return true;
	    }
	    return false;
	  };

	  Types.hasOwnProperties = hasOwnProperties = function(o) {
	    var k;
	    for (k in o) {
	      if (o.hasOwnProperty(k)) {
	        return true;
	      }
	    }
	    return false;
	  };

	  return Types;

	})();


/***/ },
/* 16 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = false;

	// Only Node.JS has a process variable that is of [[Class]] process
	try {
	 module.exports = Object.prototype.toString.call(global.process) === '[object process]' 
	} catch(e) {}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = {
		"name": "neptune-namespaces",
		"version": "1.5.2",
		"description": "Generate index.coffee and namespace.coffee files from directory structures",
		"scripts": {
			"test": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register -w"
		},
		"author": "Shane Brinkman-Davis Delamore",
		"license": "MIT",
		"preferGlobal": true,
		"bin": {
			"neptune-namespaces": "./neptune-namespaces"
		},
		"repository": {
			"type": "git",
			"url": "https://github.com/Imikimi-LLC/neptune-namespaces"
		},
		"main": "index.coffee",
		"dependencies": {
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.10.0",
			"colors": "^1.1.2",
			"detect-node": "^2.0.3",
			"fs-promise": "^0.5.0",
			"glob": "^7.1.1",
			"commander": "^2.9.0"
		},
		"devDependencies": {
			"chai": "^3.5.0",
			"mocha": "^2.5.3"
		}
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var _package, log;

	log = __webpack_require__(19).log;

	module.exports = [
	  log({
	    "package": _package = __webpack_require__(113),
	    version: _package.version
	  })
	];


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var ref, ref1;

	module.exports = ((ref = global.Neptune) != null ? (ref1 = ref.Art) != null ? ref1.Foundation : void 0 : void 0) || __webpack_require__(20);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(21).includeInNamespace(__webpack_require__(23));

	__webpack_require__(68);

	__webpack_require__(106);

	__webpack_require__(75);

	__webpack_require__(24);

	__webpack_require__(84);


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Foundation,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(22);

	module.exports = Art.Foundation || Art.addNamespace('Foundation', Foundation = (function(superClass) {
	  extend(Foundation, superClass);

	  function Foundation() {
	    return Foundation.__super__.constructor.apply(this, arguments);
	  }

	  return Foundation;

	})(Neptune.Base));


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var _package;

	module.exports = [
	  __webpack_require__(24), __webpack_require__(68), __webpack_require__(75), __webpack_require__(84), {
	    "package": _package = __webpack_require__(105),
	    version: _package.version
	  }
	];


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(25).includeInNamespace(__webpack_require__(26)).addModules({
	  ArrayExtensions: __webpack_require__(32),
	  AsyncExtensions: __webpack_require__(35),
	  CallStack: __webpack_require__(67),
	  Clone: __webpack_require__(65),
	  CommonJs: __webpack_require__(46),
	  Eq: __webpack_require__(36),
	  Function: __webpack_require__(38),
	  Hash: __webpack_require__(37),
	  Log: __webpack_require__(66),
	  Map: __webpack_require__(51),
	  Math: __webpack_require__(33),
	  MinimalBaseObject: __webpack_require__(53),
	  ObjectDiff: __webpack_require__(39),
	  ParseUrl: __webpack_require__(40),
	  Promise: __webpack_require__(27),
	  PromisedFileReader: __webpack_require__(41),
	  Regexp: __webpack_require__(34),
	  Ruby: __webpack_require__(42),
	  ShallowClone: __webpack_require__(43),
	  String: __webpack_require__(44),
	  Time: __webpack_require__(45),
	  Types: __webpack_require__(31),
	  Unique: __webpack_require__(52)
	});

	__webpack_require__(47);


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, StandardLib,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(21);

	module.exports = Foundation.StandardLib || Foundation.addNamespace('StandardLib', StandardLib = (function(superClass) {
	  extend(StandardLib, superClass);

	  function StandardLib() {
	    return StandardLib.__super__.constructor.apply(this, arguments);
	  }

	  return StandardLib;

	})(Neptune.Base));


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [[__webpack_require__(27), "testPromise", "containsPromises", "deepAll"], __webpack_require__(8), __webpack_require__(32), __webpack_require__(35), __webpack_require__(36), __webpack_require__(38), __webpack_require__(39), __webpack_require__(37), __webpack_require__(33), __webpack_require__(40), __webpack_require__(41), __webpack_require__(34), __webpack_require__(42), __webpack_require__(43), __webpack_require__(44), __webpack_require__(45), __webpack_require__(31), __webpack_require__(46), __webpack_require__(47), __webpack_require__(65), __webpack_require__(66), __webpack_require__(67)];


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var ArtPromise, Promise, deepEach, deepMap, isFunction, ref;

	Promise = __webpack_require__(28);

	ref = __webpack_require__(31), deepMap = ref.deepMap, deepEach = ref.deepEach, isFunction = ref.isFunction;


	/*
	ArtPromise extends ES6 Promises in the following ways:

	- constructing a promise with no parameters is allowed
	- promise.resolve and promise.reject are supported as
	  alternative ways to resolve or reject a promise

	If native promises are supported, they are used,
	otherwise a polyfill is used.

	TODO:
	  ES6 says Promises are designed to be extensible:
	  http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects

	  If I properly extend Promise, will my new methods be available on all promise objects... ???
	    At least all promises chained off of one created using my Promise class... ???

	  But I had problems doing that. Maybe it's how CoffeeScript extends things?

	TODO:
	  I want a way to do 'then' and 'catch' without effecting any following 'thens' or 'caches'

	  It's easy to implement, but what to call it? Leaning towards tapThen. If I had Ruby's 'tap', then
	  I could do this effectively with:

	    .tap (a) -> a.then ->
	    but
	    .tapThen ->
	    is even nicer

	  Will it be available on returned promises?
	    (see ES6 Promise extension above)

	  tapThen: (successF, failF) ->
	    @then successF, failF
	    @ # return the current promise, not the one returned from the then-call above
	 */

	module.exports = ArtPromise = (function() {
	  var isPromise, noop;

	  ArtPromise.ES6Promise = Promise;

	  ArtPromise.all = Promise.all;

	  ArtPromise.race = Promise.race;

	  ArtPromise.reject = Promise.reject;

	  ArtPromise.resolve = Promise.resolve;

	  ArtPromise.then = function(f) {
	    return Promise.resolve().then(f);
	  };

	  ArtPromise.isPromise = isPromise = function(f) {
	    return isFunction(f != null ? f.then : void 0);
	  };

	  ArtPromise.testPromise = function(promise) {
	    promise.then(function(v) {
	      return console.log("promise.resolve", v);
	    });
	    return promise["catch"](function(v) {
	      return console.log("promise.reject", v);
	    });
	  };

	  ArtPromise.mapAll = function(map) {
	    var key, keys;
	    keys = Object.keys(map);
	    return Promise.all((function() {
	      var j, len, results;
	      results = [];
	      for (j = 0, len = keys.length; j < len; j++) {
	        key = keys[j];
	        results.push(map[key]);
	      }
	      return results;
	    })()).then(function(values) {
	      var i, j, key, len, out;
	      out = {};
	      for (i = j = 0, len = keys.length; j < len; i = ++j) {
	        key = keys[i];
	        out[key] = values[i];
	      }
	      return out;
	    });
	  };

	  ArtPromise.containsPromises = function(plainStructure) {
	    var containsPromises;
	    containsPromises = false;
	    deepEach(plainStructure, function(v) {
	      return containsPromises || (containsPromises = isPromise(v));
	    });
	    return containsPromises;
	  };

	  ArtPromise.withCallback = function(startPromiseBodyFunction) {
	    return new Promise(function(resolve, reject) {
	      var callback;
	      callback = function(err, data) {
	        if (err) {
	          return reject(err);
	        }
	        return resolve(data);
	      };
	      return startPromiseBodyFunction(callback);
	    });
	  };

	  noop = function(a) {
	    return a;
	  };

	  ArtPromise.deepAll = function(plainStructure, resolvedResultPreprocessor) {
	    var promises;
	    if (resolvedResultPreprocessor == null) {
	      resolvedResultPreprocessor = noop;
	    }
	    promises = [];
	    deepEach(plainStructure, function(v) {
	      if (isPromise(v)) {
	        return promises.push(v);
	      }
	    });
	    return Promise.all(promises).then(function(resolved) {
	      var i;
	      i = 0;
	      return deepMap(plainStructure, function(v) {
	        if (isPromise(v)) {
	          return resolvedResultPreprocessor(resolved[i++]);
	        } else {
	          return v;
	        }
	      });
	    });
	  };


	  /*
	  Serializer makes it easy to ensure promise-returning functions are invoked in order, after each
	  promise is resolved.
	  
	  USAGE:
	  
	     * EXAMPLE 1: Basic - not too different from normal Promise sequences
	    serializer = new ArtPromise.Serializer
	    serializer.then -> doA()
	  
	     * then execute sometime later, possbly asynchronously:
	    serializer.then -> doB()
	  
	     * then execute sometime later, possbly asynchronously:
	    serializer.then (doBResult) ->
	       * doA and doB have completed and any returning promises resolved
	       * the result of the last 'then' is passed in
	  
	     * EXAMPLE 2: apply the same async function serially to each element in list
	     * - list's order is preserved
	     * - each invocation waits for the previous one to complete
	    serializer = new ArtPromise.Serializer
	    list.forEach serializer.serialize f = (element) -> # do something with element, possibly returning a promise
	    serializer.then (lastFResult) ->
	       * do something after the last invocation of f completes
	       * the result of the last invocation of 'f' is passed in
	  
	     * EXAMPLE 3: mix multiple serialized functions and manual @then invocations
	     * - invocation order is perserved
	    serializer = new ArtPromise.Serializer
	    serializedA = serializer.serialize aFunction
	    serializedB = serializer.serialize bFunction
	  
	    serializedB()
	    serializer.then -> @cFunction()
	    serializedB()
	    serializedA()
	    serializedB()
	  
	    serializer.then (lastBFunctionResult) ->
	       * this is invoked AFTER:
	       * evaluating, in order, waiting for any promises:
	       *   bFunction, cFunction, bFunction, aFunction, bFunction
	   */

	  ArtPromise.Serializer = (function() {
	    function Serializer() {
	      this._lastPromise = ArtPromise.resolve();
	    }


	    /*
	    Returns a new function, serializedF, that acts just like 'f'
	      - f is forced to be async:
	        - if f doesn't return a promise, a promise wrapping f's result is returned
	      - invoking serializedF queues f in this serializer instance's sequence via @then
	    IN: any function with any signature
	    OUT: (f's signature) -> promise.then (fResult) ->
	    
	    Example with Comparison:
	    
	       * all asyncActionReturningPromise(element)s get called immediately
	       * and may complete randomly at some later event
	      myArray.forEach (element) ->
	        asyncActionReturningPromise element
	    
	       * VS
	    
	       * asyncActionReturningPromise(element) only gets called
	       * after the previous call completes.
	       * If a previous call failes, the remaining calls never happen.
	      serializer = new Promise.Serializer
	      myArray.forEach serializer.serialize (element) ->
	        asyncActionReturningPromise element
	    
	       * bonus, you can do things when all the promises complete:
	      serializer.then =>
	    
	       * or if anything fails
	      serializer.catch =>
	    
	       * VS - shortcut
	    
	       * Just insert "Promise.serialize" before your forEach function to ensure serial invocations.
	       * However, you don't get the full functionality of the previous example.
	      myArray.forEach Promise.serialize (element) ->
	        asyncActionReturningPromise element
	     */

	    Serializer.prototype.serialize = function(f) {
	      return (function(_this) {
	        return function() {
	          var args;
	          args = arguments;
	          return _this.then(function() {
	            return f.apply(null, args);
	          });
	        };
	      })(this);
	    };

	    Serializer.prototype.then = function(resolved, rejected) {
	      return this._lastPromise = this._lastPromise.then(resolved, rejected);
	    };

	    Serializer.prototype["catch"] = function(rejected) {
	      return this._lastPromise = this._lastPromise["catch"](rejected);
	    };

	    Serializer.prototype.always = function(f) {
	      return this._lastPromise = this._lastPromise["catch"]((function(_this) {
	        return function() {
	          return null;
	        };
	      })(this)).then(f);
	    };


	    /*
	    OUT: promise that resolves / rejects only when there are no more
	      pending tasks queued with the serializer.
	    
	      .then (lastResult) ->
	      .catch (lastError) ->
	    
	    NOTE: allDonePromise could complete, then more tasks could be queued with the serializer.
	      Promises can't be resolved/rejected twice, so when the more-tasks complete, the first
	      allDonePromise won't do anything.
	      However, you can call allDonePromise again once the tasks are queued and get notified
	      when THEY are done.
	     */

	    Serializer.prototype.allDonePromise = function() {
	      var currentLastPromise;
	      currentLastPromise = this._lastPromise;
	      return currentLastPromise.then((function(_this) {
	        return function(lastResult) {
	          if (currentLastPromise === _this._lastPromise) {
	            return lastResult;
	          } else {
	            return _this.allDonePromise();
	          }
	        };
	      })(this))["catch"]((function(_this) {
	        return function(lastError) {
	          if (currentLastPromise === _this._lastPromise) {
	            throw lastError;
	          } else {
	            return _this.allDonePromise();
	          }
	        };
	      })(this));
	    };

	    return Serializer;

	  })();


	  /*
	  OUT: serializedF = -> Promise.resolve f arguments...
	    IN: any arguments
	    EFFECT: f is invoked with arguments passed in AFTER the last invocation of serializedF completes.
	    OUT: promise.then -> results from f
	  
	  NOTE: 'f' can return a promise, but it doesn't have to. If it does return a promise, the next
	    'f' invocation will not start until and if the previous one's promise completes.
	  
	  USAGE:
	    serializedF = Promise.serialize f = -> # do something, possibly returning a promise
	    serializedF()
	    serializedF()
	    serializedF()
	    .then (resultOfLastF)->
	       * executed after f was executed and any returned promises resolved, 3 times, sequentially
	  
	  OR
	    serializedF = Promise.serialize f = (element) -> # do something with element, possibly returning a promise
	    Promise.all (serializedF item for item in list)
	    .then (results) ->
	       * f was excuted list.length times sequentially
	       * results contains the result values from each execution, in order
	   */

	  ArtPromise.serialize = function(f) {
	    return new ArtPromise.Serializer().serialize(f);
	  };

	  function ArtPromise(_function) {
	    this.resolve = this.reject = null;
	    this._nativePromise = null;
	    this._nativePromise = new Promise((function(_this) {
	      return function(resolve1, reject1) {
	        _this.resolve = resolve1;
	        _this.reject = reject1;
	        return typeof _function === "function" ? _function(_this.resolve, _this.reject) : void 0;
	      };
	    })(this));
	  }

	  ArtPromise.prototype.then = function(a, b) {
	    return this._nativePromise.then(a, b);
	  };

	  ArtPromise.prototype["catch"] = function(a) {
	    return this._nativePromise["catch"](a);
	  };

	  return ArtPromise;

	})();

	self.Promise || (self.Promise = ArtPromise);


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {(function (root) {

	  // Store setTimeout reference so promise-polyfill will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var setTimeoutFunc = setTimeout;

	  function noop() {}
	  
	  // Polyfill for Function.prototype.bind
	  function bind(fn, thisArg) {
	    return function () {
	      fn.apply(thisArg, arguments);
	    };
	  }

	  function Promise(fn) {
	    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
	    if (typeof fn !== 'function') throw new TypeError('not a function');
	    this._state = 0;
	    this._handled = false;
	    this._value = undefined;
	    this._deferreds = [];

	    doResolve(fn, this);
	  }

	  function handle(self, deferred) {
	    while (self._state === 3) {
	      self = self._value;
	    }
	    if (self._state === 0) {
	      self._deferreds.push(deferred);
	      return;
	    }
	    self._handled = true;
	    Promise._immediateFn(function () {
	      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
	      if (cb === null) {
	        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
	        return;
	      }
	      var ret;
	      try {
	        ret = cb(self._value);
	      } catch (e) {
	        reject(deferred.promise, e);
	        return;
	      }
	      resolve(deferred.promise, ret);
	    });
	  }

	  function resolve(self, newValue) {
	    try {
	      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
	      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	        var then = newValue.then;
	        if (newValue instanceof Promise) {
	          self._state = 3;
	          self._value = newValue;
	          finale(self);
	          return;
	        } else if (typeof then === 'function') {
	          doResolve(bind(then, newValue), self);
	          return;
	        }
	      }
	      self._state = 1;
	      self._value = newValue;
	      finale(self);
	    } catch (e) {
	      reject(self, e);
	    }
	  }

	  function reject(self, newValue) {
	    self._state = 2;
	    self._value = newValue;
	    finale(self);
	  }

	  function finale(self) {
	    if (self._state === 2 && self._deferreds.length === 0) {
	      Promise._immediateFn(function() {
	        if (!self._handled) {
	          Promise._unhandledRejectionFn(self._value);
	        }
	      });
	    }

	    for (var i = 0, len = self._deferreds.length; i < len; i++) {
	      handle(self, self._deferreds[i]);
	    }
	    self._deferreds = null;
	  }

	  function Handler(onFulfilled, onRejected, promise) {
	    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	    this.promise = promise;
	  }

	  /**
	   * Take a potentially misbehaving resolver function and make sure
	   * onFulfilled and onRejected are only called once.
	   *
	   * Makes no guarantees about asynchrony.
	   */
	  function doResolve(fn, self) {
	    var done = false;
	    try {
	      fn(function (value) {
	        if (done) return;
	        done = true;
	        resolve(self, value);
	      }, function (reason) {
	        if (done) return;
	        done = true;
	        reject(self, reason);
	      });
	    } catch (ex) {
	      if (done) return;
	      done = true;
	      reject(self, ex);
	    }
	  }

	  Promise.prototype['catch'] = function (onRejected) {
	    return this.then(null, onRejected);
	  };

	  Promise.prototype.then = function (onFulfilled, onRejected) {
	    var prom = new (this.constructor)(noop);

	    handle(this, new Handler(onFulfilled, onRejected, prom));
	    return prom;
	  };

	  Promise.all = function (arr) {
	    var args = Array.prototype.slice.call(arr);

	    return new Promise(function (resolve, reject) {
	      if (args.length === 0) return resolve([]);
	      var remaining = args.length;

	      function res(i, val) {
	        try {
	          if (val && (typeof val === 'object' || typeof val === 'function')) {
	            var then = val.then;
	            if (typeof then === 'function') {
	              then.call(val, function (val) {
	                res(i, val);
	              }, reject);
	              return;
	            }
	          }
	          args[i] = val;
	          if (--remaining === 0) {
	            resolve(args);
	          }
	        } catch (ex) {
	          reject(ex);
	        }
	      }

	      for (var i = 0; i < args.length; i++) {
	        res(i, args[i]);
	      }
	    });
	  };

	  Promise.resolve = function (value) {
	    if (value && typeof value === 'object' && value.constructor === Promise) {
	      return value;
	    }

	    return new Promise(function (resolve) {
	      resolve(value);
	    });
	  };

	  Promise.reject = function (value) {
	    return new Promise(function (resolve, reject) {
	      reject(value);
	    });
	  };

	  Promise.race = function (values) {
	    return new Promise(function (resolve, reject) {
	      for (var i = 0, len = values.length; i < len; i++) {
	        values[i].then(resolve, reject);
	      }
	    });
	  };

	  // Use polyfill for setImmediate for performance gains
	  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
	    function (fn) {
	      setTimeoutFunc(fn, 0);
	    };

	  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
	    if (typeof console !== 'undefined' && console) {
	      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
	    }
	  };

	  /**
	   * Set the immediate function to execute callbacks
	   * @param fn {function} Function to execute
	   * @deprecated
	   */
	  Promise._setImmediateFn = function _setImmediateFn(fn) {
	    Promise._immediateFn = fn;
	  };

	  /**
	   * Change the function to execute on unhandled rejection
	   * @param {function} fn Function to execute on unhandled rejection
	   * @deprecated
	   */
	  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
	    Promise._unhandledRejectionFn = fn;
	  };
	  
	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = Promise;
	  } else if (!root.Promise) {
	    root.Promise = Promise;
	  }

	})(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29).setImmediate))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(30).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29).setImmediate, __webpack_require__(29).clearImmediate))

/***/ },
/* 30 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var NeptuneLib, Types, isFunction, isJsonAtomicType, isObject, isPlainArray, isPlainObject, isString, ref;

	NeptuneLib = __webpack_require__(8);

	ref = NeptuneLib.Types, isPlainObject = ref.isPlainObject, isString = ref.isString, isFunction = ref.isFunction, isObject = ref.isObject, isPlainArray = ref.isPlainArray, isJsonAtomicType = ref.isJsonAtomicType;

	module.exports = Types = (function() {
	  var cloneObjectUpToKey, deepEach, deepEachAll, deepMap, deepMapArray, deepMapObject, functionName, noopMapper, objectName, toJsonStructure, toPostMessageStructure;

	  function Types() {}

	  NeptuneLib.mergeInto(Types, NeptuneLib.Types);

	  Types.gt = function(a, b) {
	    if (isFunction(a.gt)) {
	      return a.gt(b);
	    } else {
	      return a > b;
	    }
	  };

	  Types.lt = function(a, b) {
	    if (isFunction(a.lt)) {
	      return a.lt(b);
	    } else {
	      return a < b;
	    }
	  };

	  Types.gte = function(a, b) {
	    if (isFunction(a.gte)) {
	      return a.gte(b);
	    } else {
	      return a >= b;
	    }
	  };

	  Types.lte = function(a, b) {
	    if (isFunction(a.lte)) {
	      return a.lte(b);
	    } else {
	      return a <= b;
	    }
	  };


	  /*
	  like RubyOnRails#present:
	    "An object is present if it's not blank."
	  
	  basic:
	    present null, undefined or "" returns false (or whatever returnIfNotPresent is set to)
	    all other values return something truish - generally themselves
	  
	  custom:
	    for bar where isFunction bar.present
	      present bar returns bar.present()
	  
	  special-case truish results:
	    present 0 or false returns true
	  
	  for any other value foo,
	    present foo returns foo
	  
	  IN:
	    obj:
	      object tested for presence
	    returnIfNotPresent: [false]
	      what to return if not present
	  
	  OUT:
	    returnIfNotPresent, true, or the value passed in
	  
	  If 'obj' has method: obj.present() => obj.present()
	   */

	  Types.present = function(obj, returnIfNotPresent) {
	    var present;
	    if (returnIfNotPresent == null) {
	      returnIfNotPresent = false;
	    }
	    present = isFunction(obj != null ? obj.getPresent : void 0) ? obj.getPresent() : isFunction(obj != null ? obj.present : void 0) ? obj.present() : isString(obj) ? !obj.match(/^\s*$/) : obj !== void 0 && obj !== null;
	    if (present) {
	      return obj || true;
	    } else {
	      return returnIfNotPresent;
	    }
	  };

	  Types.functionName = functionName = function(f) {
	    var matched;
	    return f.name || ((matched = ("" + f).match(/function ([a-zA-Z]+)\(/)) && matched[1]) || "function";
	  };

	  Types.objectName = objectName = function(obj) {
	    var a, name, ref1;
	    if (!obj) {
	      return "" + obj;
	    } else if (a = typeof obj.getNamespacePath === "function" ? obj.getNamespacePath() : void 0) {
	      return a;
	    } else if (a = obj.classPathName) {
	      return a;
	    } else if (obj.constructor === Object) {
	      return "Object";
	    } else if (isFunction(obj)) {
	      return functionName(obj);
	    } else if (isString(name = (ref1 = obj.constructor) != null ? ref1.name : void 0) && name.length > 0) {
	      return name;
	    } else if (obj instanceof Object) {
	      return "(anonymous instanceof Object)";
	    } else {
	      return "(objectName unknown)";
	    }
	  };

	  Types.isBrowserObject = function(obj) {
	    var name;
	    if (!Types.isObject(obj)) {
	      return false;
	    }
	    name = Types.objectName(obj);
	    return name.slice(0, 4) === "HTML" || name.slice(0, 22) === "CanvasRenderingContext";
	  };


	  /*
	  IN:
	    f: (value, [key]) ->
	      f is called on every non-plainObject and non-plainArray reachable by traversing
	      the plainObject/plainArray structure
	      If f is called on a propery of a plainObject, the key for that property is also passed in.
	   */

	  Types.deepEach = deepEach = function(v, f, key) {
	    var j, k, len, subV;
	    if (isPlainArray(v)) {
	      for (j = 0, len = v.length; j < len; j++) {
	        subV = v[j];
	        deepEach(subV, f);
	      }
	    } else if (isPlainObject(v)) {
	      for (k in v) {
	        subV = v[k];
	        deepEach(subV, f, k);
	      }
	    } else {
	      f(v, key);
	    }
	    return v;
	  };


	  /*
	  deepEachAll: just like deepEach except 'f' gets called on every value found including the initial value.
	   */

	  Types.deepEachAll = deepEachAll = function(v, f, key) {
	    var j, k, len, subV;
	    f(v, key);
	    if (isPlainArray(v)) {
	      for (j = 0, len = v.length; j < len; j++) {
	        subV = v[j];
	        deepEachAll(subV, f);
	      }
	    } else if (isPlainObject(v)) {
	      for (k in v) {
	        subV = v[k];
	        deepEachAll(subV, f, k);
	      }
	    } else {

	    }
	    return v;
	  };


	  /*
	  only creates a new array if the children changed
	   */

	  deepMapArray = function(array, mapper, options) {
	    var i, j, len, r, res, v;
	    res = null;
	    for (i = j = 0, len = array.length; j < len; i = ++j) {
	      v = array[i];
	      r = deepMap(v, mapper, options);
	      if (r !== v) {
	        res || (res = array.slice());
	        res[i] = r;
	      }
	    }
	    return res || array;
	  };

	  cloneObjectUpToKey = function(obj, k) {
	    var k2, res, v;
	    res = {};
	    for (k2 in obj) {
	      v = obj[k2];
	      if (k2 === k) {
	        break;
	      }
	      res[k2] = v;
	    }
	    return res;
	  };

	  deepMapObject = function(obj, mapper, options) {
	    var k, r, res, v;
	    res = null;
	    for (k in obj) {
	      v = obj[k];
	      r = deepMap(v, mapper, options);
	      if (r !== v || res) {
	        res || (res = cloneObjectUpToKey(obj, k));
	        res[k] = r;
	      }
	    }
	    return res || obj;
	  };

	  noopMapper = function(v) {
	    return v;
	  };


	  /*
	  Applies "f" to every -value- in a nested structure of plain arrays and objects.
	  Pure functional efficient:
	    If an array or object, and all its sub values, didn't change, the original array/object is reused.
	  
	  NOTE: deepMap only yields values to 'mapper' which are NOT plain arrays nor plain objects.
	   */

	  Types.deepMap = deepMap = function(v, mapper, options) {
	    var arrayMapper, objectMapper;
	    arrayMapper = (options != null ? options.arrays : void 0) || noopMapper;
	    objectMapper = (options != null ? options.objects : void 0) || noopMapper;
	    mapper || (mapper = noopMapper);
	    if (isPlainArray(v)) {
	      return deepMapArray(arrayMapper(v), mapper, options);
	    } else if (isPlainObject(v)) {
	      return deepMapObject(objectMapper(v), mapper, options);
	    } else {
	      return mapper(v);
	    }
	  };

	  Types.toPlainStructure = function(o) {
	    return deepMap(o, function(o) {
	      if (isObject(o)) {
	        if (o.toPlainStructure) {
	          return o.toPlainStructure();
	        } else {
	          return objectName(o);
	        }
	      } else {
	        return o;
	      }
	    });
	  };


	  /*
	  similar to toPlainStructure, except all non-JSON types are converted to strings
	   */

	  Types.toJsonStructure = toJsonStructure = function(o) {
	    return deepMap(o, function(o) {
	      if (isObject(o)) {
	        if (o.toJsonStructure) {
	          return o.toJsonStructure();
	        } else {
	          return toJsonStructure(o.toPlainStructure ? o.toPlainStructure() : "" + o);
	        }
	      } else if (isJsonAtomicType(o)) {
	        return o;
	      } else {
	        return "" + o;
	      }
	    });
	  };

	  Types.toPostMessageStructure = toPostMessageStructure = function(o) {
	    return deepMap(o, function(o) {
	      switch (o.constructor) {
	        case ArrayBuffer:
	        case Date:
	        case RegExp:
	        case Blob:
	        case File:
	        case FileList:
	        case ImageData:
	        case Boolean:
	        case String:
	          return o;
	        default:
	          if (isObject(o)) {
	            if (o.toPostMessageStructure) {
	              return o.toPostMessageStructure();
	            } else {
	              if (o.toPlainStructure) {
	                return toPostMessageStructure(o.toPlainStructure());
	              } else {
	                return "" + o;
	              }
	            }
	          } else {
	            return "" + o;
	          }
	      }
	    });
	  };

	  return Types;

	})();


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var ArrayExtensions, bound, exactlyOneWordRegex, intRand, isNumber, isString, max, modulo, ref, ref1, ref2, wordsRegex,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	ref = __webpack_require__(33), bound = ref.bound, max = ref.max, intRand = ref.intRand, modulo = ref.modulo;

	ref1 = __webpack_require__(31), isNumber = ref1.isNumber, isString = ref1.isString;

	ref2 = __webpack_require__(34), wordsRegex = ref2.wordsRegex, exactlyOneWordRegex = ref2.exactlyOneWordRegex;

	module.exports = ArrayExtensions = (function() {
	  var _moveArrayElementLargeArray, _moveArrayElementSmallArray, a, arrayWithElementMoved, basicCompareFunction, indexOfOrLength, keepAll, keepIfRubyTrue, leftOfIndex, longestCommonSubsequence, moveArrayElement, randomElement, rightOfIndex, w;

	  function ArrayExtensions() {}


	  /*
	  Useful compact and compactFlatten keepTester functions
	   */

	  ArrayExtensions.keepAll = keepAll = function() {
	    return true;
	  };

	  ArrayExtensions.keepIfRubyTrue = keepIfRubyTrue = function(a) {
	    return a !== void 0 && a !== null && a !== false;
	  };

	  ArrayExtensions.reverseForEach = function(array, f) {
	    var p, v;
	    for (p = array.length - 1; p >= 0; p += -1) {
	      v = array[p];
	      f(v);
	    }
	    return array;
	  };

	  ArrayExtensions.arrayToTruthMap = function(array) {
	    var a, len1, p, res;
	    res = {};
	    for (p = 0, len1 = array.length; p < len1; p++) {
	      a = array[p];
	      res[a] = true;
	    }
	    return res;
	  };

	  ArrayExtensions.arrayToFalseMap = function(array) {
	    var a, len1, p, res;
	    res = {};
	    for (p = 0, len1 = array.length; p < len1; p++) {
	      a = array[p];
	      res[a] = false;
	    }
	    return res;
	  };

	  ArrayExtensions.concatInto = function(array, b) {
	    return array.push.apply(array, b);
	  };

	  ArrayExtensions.uniqueValues = function(sortedArray, eqF) {
	    var i, len1, p, results, v;
	    if (eqF == null) {
	      eqF = (function(a, b) {
	        return a === b;
	      });
	    }
	    results = [];
	    for (i = p = 0, len1 = sortedArray.length; p < len1; i = ++p) {
	      v = sortedArray[i];
	      if (i === 0 || !eqF(v, sortedArray[i - 1])) {
	        results.push(v);
	      }
	    }
	    return results;
	  };


	  /*
	  IN:
	    array: an array or falsy value
	    element: anything
	  OUT:
	    array containing element as the last element
	  
	  EFFECT:
	    if array was falsy, a new length-1 array is returned
	    else, array was mutated by pushing the current element
	  
	  WHY?
	    Why write this when arrays alread have push?
	  
	    1) if array is null, this works as desired
	    2) this returns array, not array.length
	      Returning the array is what Ruby's push does.
	      It makes chaining pushes easy.
	   */

	  ArrayExtensions.push = function(array, element) {
	    if (array) {
	      array.push(element);
	      return array;
	    } else {
	      return [element];
	    }
	  };

	  ArrayExtensions.peek = function(array, offset) {
	    if (offset == null) {
	      offset = -1;
	    }
	    if (array) {
	      return array[array.length + offset];
	    } else {
	      return void 0;
	    }
	  };

	  basicCompareFunction = function(a, b) {
	    return a - b;
	  };

	  ArrayExtensions.leftOfIndex = leftOfIndex = function(array, index) {
	    if (!array) {
	      return array;
	    }
	    return array.slice(0, index);
	  };

	  ArrayExtensions.rightOfIndex = rightOfIndex = function(array, index) {
	    if (!array) {
	      return array;
	    }
	    if (index < 0) {
	      index += array.length;
	    }
	    return array.slice(index + 1);
	  };

	  indexOfOrLength = function(array, value) {
	    var i;
	    if (0 > (i = array.indexOf(value))) {
	      return array.length;
	    } else {
	      return i;
	    }
	  };

	  ArrayExtensions.leftOf = function(array, value) {
	    return leftOfIndex(array, indexOfOrLength(array, value));
	  };

	  ArrayExtensions.rightOf = function(array, value) {
	    return rightOfIndex(array, indexOfOrLength(array, value));
	  };

	  ArrayExtensions.splitArray = function(array, value) {
	    var index;
	    index = indexOfOrLength(array, value);
	    return [leftOfIndex(array, index), rightOfIndex(array, index)];
	  };


	  /*
	  findSortedFirst
	  
	  Acts as-if it sorted the array and returned the first element.
	  
	  Details:
	    tests each element in the array againts the current "smallest"
	    returns the element for which tests "smaller" than every other
	    element a is "smaller" than b if compareFunction(a, b) returns >0 value
	  
	  IN:
	    array - the array to search or null
	    compareFunction - (a, b) -> # standard compare function
	      returns:
	        0: if a and b are equal
	        <0: if b is greater than a
	        >0: if a is greater than b
	      default: (a, b) -> a - b
	  
	  OUT:
	    largest value in array or undefined if array is null or length 0
	   */

	  ArrayExtensions.findSortedFirst = function(array, compareFunction) {
	    var element, i, p, ref3, returnElement;
	    if (compareFunction == null) {
	      compareFunction = basicCompareFunction;
	    }
	    if (!((array != null ? array.length : void 0) > 0)) {
	      return void 0;
	    }
	    returnElement = array[0];
	    for (i = p = 1, ref3 = array.length; p < ref3; i = p += 1) {
	      if (0 < compareFunction(returnElement, element = array[i])) {
	        returnElement = element;
	      }
	    }
	    return returnElement;
	  };

	  ArrayExtensions.first = function(array) {
	    return array[0];
	  };

	  ArrayExtensions.second = function(array) {
	    return array[1];
	  };

	  ArrayExtensions.third = function(array) {
	    return array[2];
	  };

	  ArrayExtensions.forth = function(array) {
	    return array[3];
	  };

	  ArrayExtensions.fifth = function(array) {
	    return array[4];
	  };

	  ArrayExtensions.last = function(array) {
	    if (array) {
	      return array[array.length - 1];
	    } else {
	      return void 0;
	    }
	  };

	  ArrayExtensions.pushIfNotPresent = function(array, item) {
	    if (indexOf.call(array, item) >= 0) {
	      return false;
	    } else {
	      array.push(item);
	      return true;
	    }
	  };

	  ArrayExtensions.randomElement = randomElement = function(array, fromFirstN) {
	    if (fromFirstN == null) {
	      fromFirstN = array.length;
	    }
	    return array[Math.random() * fromFirstN | 0];
	  };

	  ArrayExtensions.randomSort = function(array) {
	    var a, i, j, len, p, ref3;
	    len = array.length;
	    for (i = p = ref3 = len - 1; p >= 0; i = p += -1) {
	      j = intRand(i);
	      a = array[i];
	      array[i] = array[j];
	      array[j] = a;
	    }
	    return array;
	  };

	  ArrayExtensions.insert = function(array, index, item) {
	    if (index < 0) {
	      index = array.length + index + 1;
	    }
	    array.splice(index, 0, item);
	    return array;
	  };

	  ArrayExtensions.withInserted = function(array, index, item) {
	    return ArrayExtensions.insert(array.slice(), index, item);
	  };

	  ArrayExtensions.withSort = function(array, sortFunction) {
	    array = array.slice();
	    return array.sort(sortFunction);
	  };

	  ArrayExtensions.remove = function(array, index, amount) {
	    if (amount == null) {
	      amount = 1;
	    }
	    if (index < 0) {
	      index = array.length + index + 1;
	    }
	    array.splice(index, amount);
	    return array;
	  };

	  ArrayExtensions.removeFirstMatch = function(array, toMatchValue) {
	    var index;
	    index = array.indexOf(toMatchValue);
	    if (index >= 0) {
	      return ArrayExtensions.remove(array, index);
	    } else {
	      return array;
	    }
	  };

	  ArrayExtensions.arrayWithout = function(array, index, amount) {
	    if (amount == null) {
	      amount = 1;
	    }
	    if (index == null) {
	      index = array.length - 1;
	    }
	    return ArrayExtensions.remove(array.slice(), index, amount);
	  };

	  ArrayExtensions.arrayWithoutValue = function(array, value) {
	    return ArrayExtensions.remove(array.slice(), array.indexOf(value), 1);
	  };

	  ArrayExtensions.arrayWith = function(array, value) {
	    if (!array) {
	      return [value];
	    }
	    array = array.slice();
	    array.push(value);
	    return array;
	  };

	  ArrayExtensions.truncatedArrayWith = function(array, length, value) {
	    if (!array) {
	      return [value];
	    }
	    array = array.slice(0, length);
	    array.push(value);
	    return array;
	  };

	  ArrayExtensions.poppedArray = function(array) {
	    return array.slice(0, array.length - 1);
	  };

	  ArrayExtensions.arrayWithOne = function(array, value) {
	    if (!array) {
	      return [value];
	    }
	    array = array.slice();
	    if (indexOf.call(array, value) < 0) {
	      array.push(value);
	    }
	    return array;
	  };

	  ArrayExtensions.slice = function(a, b, c) {
	    return arraySlice.call(a, b, c);
	  };

	  ArrayExtensions.shuffleArray = function(a) {
	    var i, j, t;
	    i = a.length;
	    while (--i > 0) {
	      j = ~~(Math.random() * (i + 1));
	      t = a[j];
	      a[j] = a[i];
	      a[i] = t;
	    }
	    return a;
	  };

	  ArrayExtensions._moveArrayElementLargeArray = _moveArrayElementLargeArray = function(array, from, to) {
	    array.splice(to, 0, array.splice(from, 1)[0]);
	    return array;
	  };

	  ArrayExtensions._moveArrayElementSmallArray = _moveArrayElementSmallArray = function(array, from, to) {
	    var i, p, q, ref3, ref4, ref5, ref6, tmp;
	    from = from | 0;
	    to = to | 0;
	    tmp = array[from];
	    if (from < to) {
	      for (i = p = ref3 = from, ref4 = to - 1; p <= ref4; i = p += 1) {
	        array[i] = array[i + 1];
	      }
	    } else {
	      for (i = q = ref5 = from, ref6 = to + 1; q >= ref6; i = q += -1) {
	        array[i] = array[i - 1];
	      }
	    }
	    array[to] = tmp;
	    return array;
	  };

	  ArrayExtensions.moveArrayElement = moveArrayElement = function(array, from, to) {
	    from = modulo(from | 0, array.length);
	    to = modulo(to | 0, array.length);
	    if (Math.abs(from - to) > 300) {
	      _moveArrayElementLargeArray(array, from, to);
	    } else {
	      _moveArrayElementSmallArray(array, from, to);
	    }
	    return array;
	  };

	  ArrayExtensions.arrayWithElementMoved = arrayWithElementMoved = function(array, from, to) {
	    from = modulo(from | 0, array.length);
	    to = modulo(to | 0, array.length);
	    if (from === to) {
	      return array;
	    }
	    array = array.slice();
	    return moveArrayElement(array, from, to);
	  };

	  ArrayExtensions.arrayWithElementValueMoved = function(array, value, to) {
	    var from;
	    from = array.indexOf(value);
	    if (from < 0) {
	      return array;
	    }
	    return arrayWithElementMoved(array, from, to);
	  };

	  ArrayExtensions.arrayWithElementReplaced = function(array, value, index) {
	    array = array.slice();
	    array[index] = value;
	    return array;
	  };

	  ArrayExtensions.stableSort = function(array, compare) {
	    var a, b, i, length, notSorted, p, ref3;
	    compare || (compare = function(a, b) {
	      return a - b;
	    });
	    notSorted = true;
	    length = array.length;
	    while (notSorted) {
	      notSorted = false;
	      for (i = p = 1, ref3 = length; p < ref3; i = p += 1) {
	        if (compare(a = array[i - 1], b = array[i]) > 0) {
	          array[i - 1] = b;
	          array[i] = a;
	          notSorted = true;
	        }
	      }
	    }
	    return array;
	  };

	  ArrayExtensions.longestCommonSubsequence = longestCommonSubsequence = function(a, b) {
	    var c, diag, i, j, latch, lcs, left, m, n, p, q, r, ref3, ref4, ref5, row, s;
	    lcs = [];
	    row = [];
	    c = [];
	    if (m < n) {
	      s = a;
	      a = b;
	      b = s;
	    }
	    m = a.length;
	    n = b.length;
	    for (j = p = 0, ref3 = n; p < ref3; j = p += 1) {
	      row[j] = 0;
	    }
	    for (i = q = 0, ref4 = m; q < ref4; i = q += 1) {
	      c[i] = row = row.slice();
	      diag = 0;
	      for (j = r = 0, ref5 = n - 1; r <= ref5; j = r += 1) {
	        latch = row[j];
	        if (a[i] === b[j]) {
	          row[j] = diag + 1;
	        } else {
	          left = row[j - 1] || 0;
	          if (left > row[j]) {
	            row[j] = left;
	          }
	        }
	        diag = latch;
	      }
	    }
	    i--;
	    j--;
	    while (i > -1 && j > -1) {
	      switch (c[i][j]) {
	        case i && c[i - 1][j]:
	          i--;
	          continue;
	        case j && c[i][j - 1]:
	          j--;
	          break;
	        default:
	          j--;
	          lcs.unshift(a[i]);
	          i--;
	          continue;
	      }
	    }
	    return lcs;
	  };

	  ArrayExtensions.minimumOrderedOverlappingMerge = function(a, b) {
	    var ai, bj, c, ck, i, j, k, l, m, n, o, out;
	    c = longestCommonSubsequence(a, b);
	    m = a.length;
	    n = b.length;
	    o = c.length;
	    out = new Array(n);
	    i = 0;
	    j = 0;
	    k = 0;
	    l = 0;
	    while (i < m && j < n && k < o) {
	      ai = a[i];
	      bj = b[j];
	      ck = c[k];
	      if (ai === ck && bj === ck) {
	        i++;
	        j++;
	        k++;
	        out[l++] = ai;
	      } else if (ai !== ck) {
	        i++;
	        if (indexOf.call(b, ai) < 0) {
	          out[l++] = ai;
	        }
	      } else {
	        j++;
	        out[l++] = bj;
	      }
	    }
	    while (i < m) {
	      ai = a[i++];
	      if (indexOf.call(b, ai) < 0) {
	        out[l++] = ai;
	      }
	    }
	    while (j < n) {
	      out[l++] = b[j++];
	    }
	    return out;
	  };

	  ArrayExtensions.wordsArray = w = function() {
	    var arg, len1, out, p;
	    out = [];
	    for (p = 0, len1 = arguments.length; p < len1; p++) {
	      arg = arguments[p];
	      if (isString(arg) && !arg.match(exactlyOneWordRegex)) {
	        out = out.concat(arg.match(wordsRegex));
	      } else {
	        out.push(arg);
	      }
	    }
	    return out;
	  };

	  ArrayExtensions.wordArray = ArrayExtensions.wordsArray;

	  ArrayExtensions.w = ArrayExtensions.wordsArray;

	  ArrayExtensions.a = a = function() {
	    var arg, len1, out, p;
	    out = [];
	    for (p = 0, len1 = arguments.length; p < len1; p++) {
	      arg = arguments[p];
	      out.push(arg);
	    }
	    return out;
	  };

	  return ArrayExtensions;

	})();


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, Math, Regexp, abs, ceil, float32Precision, float64Precision, floor, inverseFloat64Precision, inverstFlaot32Precision, max, min, numberRegexp, pow, random, ref, round;

	Foundation = __webpack_require__(25);

	Regexp = __webpack_require__(34);

	numberRegexp = Regexp.numberRegexp;

	float64Precision = 0.0000000001;

	float32Precision = 0.0000001;

	inverseFloat64Precision = 1 / float64Precision;

	inverstFlaot32Precision = 1 / float32Precision;

	ref = self.Math, abs = ref.abs, min = ref.min, max = ref.max, ceil = ref.ceil, floor = ref.floor, round = ref.round, random = ref.random, pow = ref.pow;

	module.exports = Math = (function() {
	  var bound;

	  function Math() {}

	  Math.nearInfinity = pow(10, 100);

	  Math.nearInfinityResult = pow(10, 50);

	  Math.float32Precision = float32Precision;

	  Math.float64Precision = float64Precision;

	  Math.modulo = function(a, b) {
	    var r;
	    r = a % b;
	    if (r < 0) {
	      return r + b;
	    } else {
	      return r;
	    }
	  };

	  Math.stringToNumberArray = function(string) {
	    var a, i, j, len, match, v;
	    a = string.split(",");
	    for (i = j = 0, len = a.length; j < len; i = ++j) {
	      v = a[i];
	      match = v.match(numberRegexp);
	      a[i] = match != null ? match[0] - 0 : 0;
	    }
	    return a;
	  };

	  Math.minMagnitude = function(a, magnitude) {
	    if (a < 0) {
	      return min(a, -magnitude);
	    } else {
	      return max(a, magnitude);
	    }
	  };

	  Math.maxMagnitude = function(a, magnitude) {
	    return bound(-magnitude, a, magnitude);
	  };

	  Math.maxChange = function(newValue, oldValue, maxChangeV) {
	    return bound(oldValue - maxChangeV, newValue, oldValue + maxChangeV);
	  };

	  Math.bound = bound = function(a, b, c) {
	    if (isNaN(b)) {
	      return a;
	    }
	    if (b < a) {
	      return a;
	    } else if (b > c) {
	      return c;
	    } else {
	      return b;
	    }
	  };

	  Math.absGt = function(a, b) {
	    return abs(a) > abs(b);
	  };

	  Math.absLt = function(a, b) {
	    return abs(a) < abs(b);
	  };

	  Math.absGte = function(a, b) {
	    return abs(a) >= abs(b);
	  };

	  Math.absLte = function(a, b) {
	    return abs(a) <= abs(b);
	  };

	  Math.abs = abs;

	  Math.min = min;

	  Math.max = max;

	  Math.round = round;

	  Math.ceil = function(v, m) {
	    if (m == null) {
	      m = 1;
	    }
	    return ceil(v / m) * m;
	  };

	  Math.floor = function(v, m) {
	    if (m == null) {
	      m = 1;
	    }
	    return floor(v / m) * m;
	  };

	  Math.round = function(v, m) {
	    if (m == null) {
	      m = 1;
	    }
	    return round(v / m) * m;
	  };

	  Math.simplifyNum = function(num) {
	    return round(num * inverseFloat64Precision) * float64Precision;
	  };

	  Math.floatEq = function(n1, n2) {
	    return n1 === n2 || float64Precision > abs(n1 - n2);
	  };

	  Math.float32Eq = function(n1, n2) {
	    return n1 === n2 || float32Precision > abs(n1 - n2);
	  };

	  Math.floatEq0 = function(n) {
	    return n === 0 || float64Precision > abs(n);
	  };

	  Math.float32Eq0 = function(n) {
	    return n === 0 || float32Precision > abs(n);
	  };

	  Math.floatTrue0 = function(n) {
	    if (n === 0 || float64Precision > abs(n)) {
	      return 0;
	    } else {
	      return n;
	    }
	  };

	  Math.float32True0 = function(n) {
	    if (n === 0 || float32Precision > abs(n)) {
	      return 0;
	    } else {
	      return n;
	    }
	  };

	  Math.random = random;

	  Math.intRand = function(max) {
	    return random() * max | 0;
	  };

	  Math.iPart = function(v) {
	    return v - (v % 1);
	  };

	  Math.fPart = function(v) {
	    return v % 1;
	  };

	  Math.commaize = function(x) {
	    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
	  };

	  Math.cyclingSequenceFunction = function(sequence) {
	    var sequencePos;
	    sequencePos = sequence.length;
	    return function() {
	      sequencePos++;
	      if (sequencePos >= sequence.length) {
	        sequencePos = 0;
	      }
	      return sequence[sequencePos];
	    };
	  };

	  return Math;

	})();


/***/ },
/* 34 */
/***/ function(module, exports) {

	var Regexp;

	module.exports = Regexp = (function() {
	  function Regexp() {}

	  Regexp.escapeRegExp = function(string) {
	    return string.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
	  };

	  Regexp.findUrlProtocolRegexp = /([\w-]+)(:\/\/)/;

	  Regexp.findDomainRegexp = /localhost|[\w]+(?:-[\w]+)*(?:\.[\w]+(?:-[\w]+)*)*(?:\.[a-z]{2,20})/;

	  Regexp.urlQueryParamsRegexp = /(?:[-+=&*._\w]|%[a-f\d]{2})+/i;

	  Regexp.findUrlPathRegexp = /(?:\/~?(?:[-+*._\w]|%[a-f\d]{2})*)*/;

	  Regexp.findUrlPortRegexp = /(\:)(\d+)/;

	  Regexp.findEmailRegexp = RegExp("([_\\w-]+(?:\\.[_\\w]+)*)@(" + Regexp.findDomainRegexp.source + ")", "i");

	  Regexp.emailRegexp = RegExp("^" + Regexp.findEmailRegexp.source + "$", "i");

	  Regexp.numberRegexp = /([-]?\.[0-9]+)|([-]?[0-9]+(\.[0-9]+)?)/;

	  Regexp.urlProtocolRegexp = RegExp("^" + Regexp.findUrlProtocolRegexp.source + "$", "i");

	  Regexp.domainRegexp = RegExp("^" + Regexp.findDomainRegexp.source + "$", "i");

	  Regexp.urlPathRegexp = RegExp("^" + Regexp.findUrlPathRegexp.source + "$", "i");

	  Regexp.urlQueryRegexp = RegExp("^" + Regexp.urlQueryParamsRegexp.source + "$", "i");

	  Regexp.isoDateRegexp = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;

	  Regexp.hex16ColorRegex = /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i;

	  Regexp.hex256ColorRegex = /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i;

	  Regexp.rgbColorRegex = /rgb *\( *(\d+%?) *, *(\d+%?) *, *(\d+%?) *\)/;

	  Regexp.rgbaColorRegex = /rgba *\( *(\d+%?) *, *(\d+%?) *, *(\d+%?) *, *(\d*\.?\d*)\)/;

	  Regexp.colorRegex = new RegExp("(" + Regexp.hex16ColorRegex.source + ")|(" + Regexp.hex256ColorRegex.source + ")|(" + Regexp.rgbColorRegex.source + ")|(" + Regexp.rgbaColorRegex.source + ")");

	  Regexp.wordsRegex = /[^\s]+/g;

	  Regexp.exactlyOneWordRegex = /^[^\s]+$/;


	  /*
	  match OUTPUT: [url, protocol, '://', domain, ':', port, path, '?', query]
	  
	  USAGE:
	    [__, protocol, __, domain, __, port, path, __, query] = str.match findUrlRegexp
	  
	  DESIGN NOTE:
	    The reason why I included the fixed strings ('://', ':' and '?') was so that
	    you can take the matchResult, alter individual elements and create a value url easily by:
	  
	      matchResult.slice(1).join ''
	   */

	  Regexp.findUrlRegexp = RegExp("(?:" + Regexp.findUrlProtocolRegexp.source + ")(" + Regexp.findDomainRegexp.source + ")(?:" + Regexp.findUrlPortRegexp.source + ")?(" + Regexp.findUrlPathRegexp.source + ")?(?:(\\?)(" + Regexp.urlQueryParamsRegexp.source + ")?)?", "i");

	  Regexp.findSourceReferenceUrlRegexp = RegExp("(" + Regexp.findUrlProtocolRegexp.source + ")(" + Regexp.findDomainRegexp.source + ")?(?:" + Regexp.findUrlPortRegexp.source + ")?(" + Regexp.findUrlPathRegexp.source + ")?(?:(\\?)(" + Regexp.urlQueryParamsRegexp.source + ")?)?(?:\\:(\\d+))?(?:\\:(\\d+))?", "i");

	  Regexp.urlRegexp = RegExp("^" + Regexp.findUrlRegexp.source + "$", "i");

	  return Regexp;

	})();


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var AsyncExtensions, Promise;

	Promise = __webpack_require__(27);

	module.exports = AsyncExtensions = (function() {
	  var timeout;

	  function AsyncExtensions() {}

	  AsyncExtensions.timeout = timeout = function(ms, f) {
	    return new Promise(function(resolve) {
	      return setTimeout(function() {
	        if (typeof f === "function") {
	          f();
	        }
	        return resolve();
	      }, ms);
	    });
	  };

	  AsyncExtensions.requestAnimationFrame = self.requestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || self.msRequestAnimationFrame || function(f) {
	    return setTimeout(f, 1000 / 60);
	  };

	  AsyncExtensions.nextTick = function(f) {
	    return Promise.resolve().then(f);
	  };

	  AsyncExtensions.throwErrorOutOfStack = function(e) {
	    return timeout(0, function() {
	      throw e;
	    });
	  };

	  AsyncExtensions.evalAndThrowErrorsOutOfStack = function(f) {
	    var e;
	    try {
	      return f();
	    } catch (error) {
	      e = error;
	      Neptune.Art.Foundation.log.error("evalAndThrowErrorsOutOfStack", e);
	      return AsyncExtensions.throwErrorOutOfStack(e);
	    }
	  };

	  return AsyncExtensions;

	})();


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var Eq, floatTrue0, isNumber, isString, min, objectKeyCount, ref, remove,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	remove = __webpack_require__(32).remove;

	objectKeyCount = __webpack_require__(37).objectKeyCount;

	floatTrue0 = __webpack_require__(33).floatTrue0;

	ref = __webpack_require__(31), isString = ref.isString, isNumber = ref.isNumber;

	min = Math.min;

	module.exports = Eq = (function() {
	  var plainObjectsDeepDiff, plainObjectsDeepEq;

	  function Eq() {}


	  /*
	  IN: see @compare
	  OUT:
	    true: if a and b are structurally equal
	    false: otherwise
	   */

	  Eq.eq = function(a, b) {
	    return 0 === Eq.compare(a, b, true);
	  };

	  Eq.neq = function(a, b) {
	    return 0 !== Eq.compare(a, b, true);
	  };

	  Eq.fastEq = function(a, b) {
	    return 0 === Eq.compare(a, b, false);
	  };

	  Eq.fastNeq = function(a, b) {
	    return 0 !== Eq.compare(a, b, false);
	  };

	  Eq._compareArray = function(a, b, recursionBlockArray) {
	    var aLength, av, bLength, bv, i, j, ref1, val;
	    aLength = a.length;
	    bLength = b.length;
	    for (i = j = 0, ref1 = Math.min(aLength, bLength); j < ref1; i = j += 1) {
	      av = a[i];
	      bv = b[i];
	      if (0 !== (val = Eq._compare(av, bv, recursionBlockArray))) {
	        return val;
	      }
	    }
	    return aLength - bLength;
	  };

	  Eq._compareObject = function(a, b, recursionBlockArray) {
	    var aLength, av, bv, compared, k, val;
	    aLength = 0;
	    compared = 0;
	    for (k in a) {
	      av = a[k];
	      aLength++;
	      av = a[k];
	      bv = b[k];
	      if (bv !== void 0 || b.hasOwnProperty(k)) {
	        compared++;
	        if (0 !== (val = Eq._compare(av, bv, recursionBlockArray))) {
	          return val;
	        }
	      }
	    }
	    if (aLength === compared && compared === objectKeyCount(b)) {
	      return 0;
	    } else {
	      return 0/0;
	    }
	  };


	  /*
	  compare is recursive. However, it only recurses for 'plain' objects and arrays.
	  
	  If you want to compare custom objects deeply, you must add an .eq or .compare function to your custom objects.
	    signature: a.eq b, recursionBlockArray => truthy if a equals b
	    signature: a.compare b, recursionBlockArray => NaN / <0 / 0 / >0 for incomparable / a<b / a==b / a>b respectively
	    IN:
	      a: => this/@
	      b: compared with a
	      recursionBlockArray: an array of objects already on the stack being tested, pass this to
	    It is an array of every object recursively currently being tested - don't test an object in this array
	    recursionBlockArray can be altered, but should be returned in its original state. It may be null.
	  
	  IN:
	    a and b: compare a and b
	    recursionBlockEnabled:
	      truthy: recursive structures will be handled correctly
	      falsey: (default) faster, but recursive structures result in infinite recursion
	  OUT:
	    NaN:
	      a and b are different types
	      a and b are otherwise not comparable
	  
	    <0: a < b
	    0:  a == b
	    >0: a > b
	   */

	  Eq.compare = function(a, b, recursionBlockEnabled) {
	    return Eq._compare(a, b, recursionBlockEnabled && []);
	  };

	  Eq._compare = function(a, b, recursionBlockArray) {
	    var _constructor;
	    if (a === b) {
	      return 0;
	    }
	    if ((a != null) && (b != null) && a.constructor === (_constructor = b.constructor)) {
	      if (isString(a)) {
	        return a.localeCompare(b);
	      }
	      if (isNumber(a)) {
	        return floatTrue0(a - b);
	      }
	      if (recursionBlockArray) {
	        if (indexOf.call(recursionBlockArray, a) >= 0 || indexOf.call(recursionBlockArray, b) >= 0) {
	          return 0;
	        }
	        recursionBlockArray.push(a);
	        recursionBlockArray.push(b);
	      }
	      if (a.compare) {
	        return a.compare(b, recursionBlockArray);
	      }
	      if (_constructor === Array) {
	        return Eq._compareArray(a, b, recursionBlockArray);
	      }
	      if (_constructor === Object) {
	        return Eq._compareObject(a, b, recursionBlockArray);
	      }
	      if (a.eq && a.eq(b, recursionBlockArray)) {
	        return 0;
	      }
	      if (recursionBlockArray) {
	        remove(recursionBlockArray, recursionBlockArray.length - 2, 2);
	      }
	    }
	    return 0/0;
	  };

	  Eq.plainObjectsDeepEqArray = function(a, b) {
	    var av, i, j, len1;
	    if (a.length !== b.length) {
	      return false;
	    }
	    for (i = j = 0, len1 = a.length; j < len1; i = ++j) {
	      av = a[i];
	      if (!Eq.plainObjectsDeepEq(av, b[i])) {
	        return false;
	      }
	    }
	    return true;
	  };

	  Eq.plainObjectsDeepEqObject = function(a, b) {
	    var aLength, av, bv, k;
	    aLength = 0;
	    for (k in a) {
	      av = a[k];
	      aLength++;
	      bv = b[k];
	      if (!((bv !== void 0 || b.hasOwnProperty(k)) && Eq.plainObjectsDeepEq(av, bv))) {
	        return false;
	      }
	    }
	    return aLength === objectKeyCount(b);
	  };

	  Eq.plainObjectsDeepEq = plainObjectsDeepEq = function(a, b) {
	    var _constructor;
	    if (a === b) {
	      return true;
	    } else if (a && b && a.constructor === (_constructor = b.constructor)) {
	      if (a.eq) {
	        return a.eq(b);
	      } else if (_constructor === Array) {
	        return Eq.plainObjectsDeepEqArray(a, b);
	      } else if (_constructor === Object) {
	        return Eq.plainObjectsDeepEqObject(a, b);
	      } else {
	        return false;
	      }
	    } else {
	      return false;
	    }
	  };

	  Eq.propsEq = plainObjectsDeepEq;

	  Eq.plainObjectsDeepDiffArray = function(before, after) {
	    var diff, i, j, l, len, m, ref1, ref2, ref3, ref4, ref5, res;
	    res = null;
	    len = min(before.length, after.length);
	    for (i = j = 0, ref1 = len; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
	      if (!(diff = plainObjectsDeepDiff(before[i], after[i]))) {
	        continue;
	      }
	      res || (res = {});
	      res[i] = diff;
	    }
	    if (len < before.length) {
	      for (i = l = ref2 = len, ref3 = before.length; ref2 <= ref3 ? l < ref3 : l > ref3; i = ref2 <= ref3 ? ++l : --l) {
	        res || (res = {});
	        res[i] = {
	          removed: before[i]
	        };
	      }
	    }
	    if (len < after.length) {
	      for (i = m = ref4 = len, ref5 = after.length; ref4 <= ref5 ? m < ref5 : m > ref5; i = ref4 <= ref5 ? ++m : --m) {
	        res || (res = {});
	        res[i] = {
	          added: after[i]
	        };
	      }
	    }
	    return res;
	  };

	  Eq.plainObjectsDeepDiffObject = function(before, after) {
	    var afterV, beforeV, diff, k, res;
	    res = null;
	    for (k in before) {
	      beforeV = before[k];
	      if (after.hasOwnProperty(k)) {
	        if (diff = plainObjectsDeepDiff(beforeV, after[k])) {
	          res || (res = {});
	          res[k] = diff;
	        }
	      } else {
	        res || (res = {});
	        res[k] = {
	          removed: beforeV
	        };
	      }
	    }
	    for (k in after) {
	      afterV = after[k];
	      if (!(!before.hasOwnProperty(k))) {
	        continue;
	      }
	      res || (res = {});
	      res[k] = {
	        added: afterV
	      };
	    }
	    return res;
	  };

	  Eq.plainObjectsDeepDiff = plainObjectsDeepDiff = function(before, after) {
	    var _constructor;
	    if (before === after) {
	      return null;
	    } else if (before && after && before.constructor === (_constructor = after.constructor)) {
	      if (before.eq) {
	        if (before.eq(after)) {
	          return null;
	        } else {
	          return {
	            before: before,
	            after: after
	          };
	        }
	      } else if (_constructor === Array) {
	        return Eq.plainObjectsDeepDiffArray(before, after);
	      } else if (_constructor === Object) {
	        return Eq.plainObjectsDeepDiffObject(before, after);
	      } else {
	        return {
	          before: before,
	          after: after
	        };
	      }
	    } else {
	      return {
	        before: before,
	        after: after
	      };
	    }
	  };

	  Eq.diff = plainObjectsDeepDiff;

	  Eq.shallowEq = function(a, b) {
	    return a === b || (a && b && a.eq && a.eq(b));
	  };

	  return Eq;

	})();


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var Hash, compactFlatten, deepArrayEach, isArrayOrArguments, isFunction, isPlainArray, isPlainObject, mergeInto, ref, ref1,
	  slice = [].slice,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	ref = Neptune.NeptuneLib, compactFlatten = ref.compactFlatten, deepArrayEach = ref.deepArrayEach, isArrayOrArguments = ref.isArrayOrArguments, mergeInto = ref.mergeInto;

	ref1 = __webpack_require__(31), isPlainObject = ref1.isPlainObject, isFunction = ref1.isFunction, isPlainArray = ref1.isPlainArray;

	module.exports = Hash = (function() {
	  var inject, newObjectFromEach, objectKeyCount, toObjectInternal;

	  function Hash() {}

	  Hash.countKeys = function(o) {
	    return Object.keys(o).length;
	  };

	  Hash.objectKeyCount = objectKeyCount = function(o) {
	    var count, k, v;
	    count = 0;
	    for (k in o) {
	      v = o[k];
	      count++;
	    }
	    return count;
	  };

	  Hash.objectLength = objectKeyCount;


	  /*
	  NOTE:
	    null and undefined keys are NOT SUPPORTED
	  
	    They should be converted to strings, first,
	    which is what they would become anyway.
	  
	  IN: 0 or more arguments
	    out = {}
	    list = arguments
	  
	    for element in list
	      objects: merge into out
	      arrays or argument lists: recurse using element as the list
	      null or undefined: skip
	      else out[element] = next element (or undefined if none)
	  
	  OUT: plain object
	   */

	  toObjectInternal = function(list, out) {
	    var element, i, key, len;
	    key = null;
	    for (i = 0, len = list.length; i < len; i++) {
	      element = list[i];
	      if (key) {
	        out[key] = element;
	        key = null;
	      } else if (isPlainObject(element)) {
	        mergeInto(out, element);
	      } else if (isArrayOrArguments(element)) {
	        toObjectInternal(element, out);
	      } else if (element != null) {
	        key = element;
	      }
	    }
	    if (key) {
	      return out[key] = void 0;
	    }
	  };

	  Hash.toObject = function() {
	    var out;
	    console.error("toObject is DEPRICATED. Use toPlainObjects.");
	    out = {};
	    toObjectInternal(arguments, out);
	    return out;
	  };


	  /*
	  IN:
	    inputArray: any array
	    transformFunction: (element) -> [key, value]
	      default: transforms an array of the form: [[key1, value1], [key2, value2], etc...]
	   */

	  Hash.arrayToMap = function(inputArray, transformFunction) {
	    var element, i, key, len, outputMap, ref2, value;
	    if (transformFunction == null) {
	      transformFunction = function(element) {
	        return element;
	      };
	    }
	    outputMap = {};
	    for (i = 0, len = inputArray.length; i < len; i++) {
	      element = inputArray[i];
	      ref2 = transformFunction(element), key = ref2[0], value = ref2[1];
	      outputMap[key] = value;
	    }
	    return outputMap;
	  };


	  /*
	  IN:
	    input: array or object
	    memo: [optional] initial value; if not set, the first element is used, if no elements, null is used and returned
	    block: (memo, value) -> newMemo OR
	    block: (memo, key, value) -> newMemo
	      key is the index for arrays
	  
	      Why value or key, value? Mostly consistent with CoffeeScripts:
	        for...in and for...of signatures
	      Different from CoffeeScript?
	        for arrays, if block has two arguments, the signature is the SAME as
	        objects where indexes in arrays are equivelent to keys in objects: (memo, index, value) ->
	      Why different from CoffeeScript?
	        So two-input blocks work the same regardless of if an array or object is input.
	   */

	  Hash.inject = inject = function(input, a, b) {
	    var block, i, k, len, log, memo, memoSet, twoInputBlock, v;
	    log = Neptune.Art.Foundation.log;
	    block = arguments.length === 2 ? (memoSet = false, memo = null, a) : (memo = a, memoSet = true, b);
	    twoInputBlock = block.length >= 3;
	    if (isPlainObject(input)) {
	      for (k in input) {
	        v = input[k];
	        if (!memoSet) {
	          memo = v;
	          memoSet = true;
	        } else {
	          memo = twoInputBlock ? block(memo, k, v) : block(memo, v);
	        }
	      }
	    } else {
	      for (k = i = 0, len = input.length; i < len; k = ++i) {
	        v = input[k];
	        if (!memoSet) {
	          memo = v;
	          memoSet = true;
	        } else {
	          memo = twoInputBlock ? block(memo, k, v) : block(memo, v);
	        }
	      }
	    }
	    return memo;
	  };


	  /*
	  IN:
	    input: array or object
	    block: (map, k, v) -> OR
	    block: (k, v) -> OR
	    block: (v) -> newV
	      for arrays, k is the index
	   */

	  Hash.newObjectFromEach = newObjectFromEach = function(input, block) {
	    if (block == null) {
	      block = function(map, k, v) {
	        return map[k] = v;
	      };
	    }
	    return inject(input, {}, (function() {
	      if (isPlainArray(input)) {
	        switch (block.length) {
	          case 0:
	          case 1:
	            return function(memo, k, v) {
	              memo[v] = block(v);
	              return memo;
	            };
	          case 2:
	            return function(memo, k, v) {
	              memo[v] = block(k, v);
	              return memo;
	            };
	          case 3:
	            return function(memo, k, v) {
	              block(memo, k, v);
	              return memo;
	            };
	          default:
	            throw new Error("expecting block-function with 0, 1, 2 or 3 arguments");
	        }
	      } else {
	        switch (block.length) {
	          case 0:
	          case 1:
	            return function(memo, k, v) {
	              memo[k] = block(v);
	              return memo;
	            };
	          case 2:
	            return function(memo, k, v) {
	              memo[k] = block(k, v);
	              return memo;
	            };
	          case 3:
	            return function(memo, k, v) {
	              block(memo, k, v);
	              return memo;
	            };
	          default:
	            throw new Error("expecting block-function with 0, 1, 2 or 3 arguments");
	        }
	      }
	    })());
	  };

	  Hash.newMapFromEach = newObjectFromEach;


	  /*
	  IN:
	    obj: the object to select fields from
	  
	    2nd argument can be:
	      selectFunction: (value, key) -> true / false
	  
	    OR obj can be followed by any number of strings or arrays in any nesting, possibly with null fields
	   */

	  Hash.select = function(obj, a) {
	    var i, k, len, prop, properties, result, v;
	    if (!obj) {
	      return {};
	    }
	    result = {};
	    if (isFunction(a)) {
	      if (a.length === 1) {
	        for (k in obj) {
	          v = obj[k];
	          if (a(v)) {
	            result[k] = v;
	          }
	        }
	      } else {
	        for (k in obj) {
	          v = obj[k];
	          if (a(k, v)) {
	            result[k] = v;
	          }
	        }
	      }
	    } else {
	      properties = compactFlatten(Array.prototype.slice.call(arguments, 1));
	      for (i = 0, len = properties.length; i < len; i++) {
	        prop = properties[i];
	        if (v = obj[prop] || obj.hasOwnProperty(prop)) {
	          result[prop] = v;
	        }
	      }
	    }
	    return result;
	  };

	  Hash.selectAll = function() {
	    var i, len, obj, prop, properties, ref2, result;
	    obj = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (!obj) {
	      return {};
	    }
	    result = {};
	    ref2 = compactFlatten(properties);
	    for (i = 0, len = ref2.length; i < len; i++) {
	      prop = ref2[i];
	      result[prop] = obj[prop];
	    }
	    return result;
	  };

	  Hash.objectWithout = function() {
	    var anythingToDo, i, len, obj, prop, properties, result, v;
	    obj = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (properties.length === 1 && !(typeof properties[0] === "string")) {
	      properties = properties[0];
	    }
	    anythingToDo = false;
	    for (i = 0, len = properties.length; i < len; i++) {
	      prop = properties[i];
	      if (obj.hasOwnProperty(prop)) {
	        anythingToDo = true;
	        break;
	      }
	    }
	    if (anythingToDo) {
	      result = {};
	      for (prop in obj) {
	        v = obj[prop];
	        if (indexOf.call(properties, prop) < 0) {
	          result[prop] = v;
	        }
	      }
	      return result;
	    } else {
	      return obj;
	    }
	  };

	  return Hash;

	})();


/***/ },
/* 38 */
/***/ function(module, exports) {

	var Function;

	module.exports = Function = (function() {
	  function Function() {}

	  Function.fastBind = function(fn, _this) {
	    switch (fn.length) {
	      case 0:
	        return function() {
	          return fn.call(_this);
	        };
	      case 1:
	        return function(a) {
	          return fn.call(_this, a);
	        };
	      case 2:
	        return function(a, b) {
	          return fn.call(_this, a, b);
	        };
	      case 3:
	        return function(a, b, c) {
	          return fn.call(_this, a, b, c);
	        };
	      case 4:
	        return function(a, b, c, d) {
	          return fn.call(_this, a, b, c, d);
	        };
	      case 5:
	        return function(a, b, c, d, e) {
	          return fn.call(_this, a, b, c, d, e);
	        };
	      case 6:
	        return function(a, b, c, d, e, f) {
	          return fn.call(_this, a, b, c, d, e, f);
	        };
	      case 7:
	        return function(a, b, c, d, e, f, g) {
	          return fn.call(_this, a, b, c, d, e, f, g);
	        };
	      case 8:
	        return function(a, b, c, d, e, f, g, h) {
	          return fn.call(_this, a, b, c, d, e, f, g, h);
	        };
	      case 9:
	        return function(a, b, c, d, e, f, g, h, i) {
	          return fn.call(_this, a, b, c, d, e, f, g, h, i);
	        };
	      case 10:
	        return function(a, b, c, d, e, f, g, h, i, j) {
	          return fn.call(_this, a, b, c, d, e, f, g, h, i, j);
	        };
	      default:
	        return function() {
	          return fn.apply(_this, arguments);
	        };
	    }
	  };

	  return Function;

	})();


	/*
	TODO:

	The above options are not hot-reload compatible. However, this alternative would be:

	  name = fn.name
	  -> _this[name].apply _this, arguments

	I need to perf-test this. Or, I need to finally start using a global "debug" mode that could use this
	in debug mode and the faster(?), non hot-reload options in production mode.
	 */


/***/ },
/* 39 */
/***/ function(module, exports) {

	var ObjectDiff;

	module.exports = ObjectDiff = (function() {
	  var defaultEq;

	  function ObjectDiff() {}

	  defaultEq = function(a, b) {
	    return a === b;
	  };


	  /*
	  SBD this has been thouroughly benchmarked on Safari and Chrome as of 2015-11-06
	  This is as fast as I could make it.
	  
	  IN:
	    newObj:   the changed-to object   (must be set)
	    oldObj:   the changed-from object (default: {})
	    added:    (key, newValue) -> null
	              called for each key in newObj that was not in oldObj
	    removed:  (key, oldValue) -> null
	              called for each key in oldObj that is not in newObj
	    changed:  (key, newValue, oldValue) -> null
	              called for each key in both where the value changed
	    noChange: (key, value) -> null
	              called for each key in both where the value stayed the same
	    eq:       (a, b) -> true if a is equal to b
	              DEFAULT: use javascript ===
	              provided for custom concepts of equality
	    oldObjKeyCount: null or a the number of keys in oldObj
	      This last field provides an opportunity for further performance improvement.
	      If you have previously computed the number of keys in oldObj, pass it in.
	      Counting the number of keys in an object can be slow. If we know the number
	      of keys this routine can be more efficient.
	  
	      NOTE that this function returns the key-count of the new object. That way if you
	      are calling objecfDiff several times over a sequence of object changes, can you keep
	      the results from this function, you already have the oldObjKeyCount for the next call.
	  
	  OUT: newObjKeyCount - number of keys in the new object
	   */

	  ObjectDiff.objectDiff = function(newObj, oldObj, added, removed, changed, noChange, eq, oldObjKeyCount) {
	    var k, newObjKeyCount, newValue, oldObjKeyCountIsAtLeast, oldValue;
	    if (eq == null) {
	      eq = defaultEq;
	    }
	    newObjKeyCount = 0;
	    if (!oldObj) {
	      for (k in newObj) {
	        newValue = newObj[k];
	        newObjKeyCount++;
	        added(k, newValue);
	      }
	      return newObjKeyCount;
	    }
	    oldObjKeyCountIsAtLeast = 0;
	    for (k in newObj) {
	      newValue = newObj[k];
	      newObjKeyCount++;
	      if (typeof (oldValue = oldObj[k]) !== "undefined" || oldObj.hasOwnProperty(k)) {
	        oldObjKeyCountIsAtLeast++;
	        if (!eq(newValue, oldValue)) {
	          changed(k, newValue, oldValue);
	        } else {
	          if (typeof noChange === "function") {
	            noChange(k, newValue);
	          }
	        }
	      } else {
	        added(k, newValue);
	      }
	    }
	    if (!(oldObjKeyCount != null) || oldObjKeyCountIsAtLeast !== oldObjKeyCount) {
	      for (k in oldObj) {
	        if (!(typeof newObj[k] !== "undefined" || newObj.hasOwnProperty(k))) {
	          removed(k, oldObj[k]);
	        }
	      }
	    }
	    return newObjKeyCount;
	  };

	  return ObjectDiff;

	})();


/***/ },
/* 40 */
/***/ function(module, exports) {

	var ParseUrl;

	module.exports = ParseUrl = (function() {
	  function ParseUrl() {}

	  ParseUrl.parseQuery = function(qs) {
	    var i, j, key, len, obj, pair, ref, ref1, val;
	    if (qs == null) {
	      qs = (ref = self.location) != null ? ref.search : void 0;
	    }
	    obj = {};
	    ref1 = qs.replace('?', '').split('&');
	    for (j = 0, len = ref1.length; j < len; j++) {
	      pair = ref1[j];
	      i = pair.indexOf('=');
	      key = pair.slice(0, i);
	      val = pair.slice(i + 1);
	      if (key.length > 0) {
	        obj[key] = decodeURIComponent(val);
	      }
	    }
	    return obj;
	  };

	  ParseUrl.parseUrl = function(url) {
	    var __, a, anchor, fileName, host, hostWithPort, m, password, path, pathName, port, protocol, query, username;
	    m = url.match(/(([A-Za-z]+):(\/\/)?)?(([\-;&=\+\$,\w]+)(:([\-;:&=\+\$,\w]+))?@)?([A-Za-z0-9\.\-]+)(:([0-9]+))?(\/[\+~%\/\.\w\-]*)?(\?([\-\+=&;%@\.\w,]*))?(\#([\.\!\/\\\w]*))?/);
	    if (!m) {
	      return void 0;
	    }
	    __ = m[0], __ = m[1], protocol = m[2], __ = m[3], __ = m[4], username = m[5], __ = m[6], password = m[7], host = m[8], __ = m[9], port = m[10], pathName = m[11], __ = m[12], query = m[13], __ = m[14], anchor = m[15];
	    if (pathName) {
	      a = pathName.split("/");
	      fileName = a[a.length - 1];
	      path = (a.slice(0, a.length - 1)).join("/");
	    }
	    host = host.toLowerCase();
	    hostWithPort = host;
	    if (port) {
	      hostWithPort += ":" + port;
	    }
	    return {
	      protocol: protocol,
	      username: username,
	      password: password,
	      hostWithPort: hostWithPort,
	      host: host,
	      port: port,
	      pathName: pathName,
	      path: path,
	      fileName: fileName,
	      query: query && ParseUrl.parseQuery(query),
	      anchor: anchor
	    };
	  };

	  return ParseUrl;

	})();


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var Promise, PromisedFileReader;

	Promise = __webpack_require__(27);

	module.exports = PromisedFileReader = (function() {
	  function PromisedFileReader() {}

	  PromisedFileReader.readFileAsDataUrl = function(file) {
	    return new Promise(function(resolve, reject) {
	      var reader;
	      reader = new FileReader;
	      reader.readAsDataURL(file);
	      reader.onload = (function(_this) {
	        return function(e) {
	          return resolve(e.target.result);
	        };
	      })(this);
	      return reader.onerror = (function(_this) {
	        return function(e) {
	          return reject(error);
	        };
	      })(this);
	    });
	  };

	  PromisedFileReader.readFileAsArrayBuffer = function(file) {
	    return new Promise(function(resolve, reject) {
	      var reader;
	      reader = new FileReader;
	      reader.readAsArrayBuffer(file);
	      reader.onload = (function(_this) {
	        return function(e) {
	          return resolve(e.target.result);
	        };
	      })(this);
	      return reader.onerror = (function(_this) {
	        return function(e) {
	          return reject(error);
	        };
	      })(this);
	    });
	  };

	  return PromisedFileReader;

	})();


/***/ },
/* 42 */
/***/ function(module, exports) {

	var Ruby,
	  hasProp = {}.hasOwnProperty;

	module.exports = Ruby = (function() {
	  var rubyTrue;

	  function Ruby() {}

	  Ruby.rubyTrue = rubyTrue = function(a) {
	    return a !== void 0 && a !== null && a !== false;
	  };

	  Ruby.rubyFalse = function(a) {
	    return a === void 0 || a === null || a === false;
	  };

	  Ruby.rubyOr = function(a, b) {
	    var i, len;
	    if (arguments.length === 2) {
	      if (rubyTrue(a)) {
	        return a;
	      } else {
	        return b;
	      }
	    } else {
	      for (i = 0, len = arguments.length; i < len; i++) {
	        a = arguments[i];
	        if (rubyTrue(a)) {
	          break;
	        }
	      }
	      return a;
	    }
	  };

	  Ruby.rubyAnd = function(a, b) {
	    var i, len;
	    if (arguments.length === 2) {
	      if (rubyTrue(a)) {
	        return b;
	      } else {
	        return a;
	      }
	    } else {
	      for (i = 0, len = arguments.length; i < len; i++) {
	        a = arguments[i];
	        if (!rubyTrue(a)) {
	          break;
	        }
	      }
	      return a;
	    }
	  };

	  Ruby.reopenInstanceProps = function(klass, instanceProps) {
	    var k, results, v;
	    results = [];
	    for (k in instanceProps) {
	      if (!hasProp.call(instanceProps, k)) continue;
	      v = instanceProps[k];
	      results.push(klass.prototype[k] = v);
	    }
	    return results;
	  };

	  Ruby.reopenClassProps = function(klass, classProps) {
	    var k, results, v;
	    results = [];
	    for (k in classProps) {
	      if (!hasProp.call(classProps, k)) continue;
	      v = classProps[k];
	      results.push(klass[k] = v);
	    }
	    return results;
	  };

	  return Ruby;

	})();


/***/ },
/* 43 */
/***/ function(module, exports) {

	
	/*
	This current iteration of clone relies on some singleton variables shared across all invocations of clone.
	This is fine as long as javascript stays single-threaded.
	It also introduces a little bit of uglyness initializing clonedMap necessitating the "top" variable.

	FUTURE
	A potentially better solution would be to create a new closer each time clone is called at the top-most level,
	but when recursing, pass in a new function bound to that closure which is different from the global clone function.

	populateClone would need to take an additional argument - the clone function to use for recursive cloning.
	 */
	var ShallowClone;

	module.exports = ShallowClone = (function() {
	  function ShallowClone() {}

	  ShallowClone.extendClone = function(obj) {
	    if (obj.constructor === Array) {
	      return obj.slice();
	    } else {
	      return Object.create(obj);
	    }
	  };

	  ShallowClone.shallowClone = function(obj) {
	    var k, ret, v;
	    if (!obj) {
	      return obj;
	    }
	    if (obj.constructor === Array) {
	      return obj.slice();
	    } else {
	      ret = {};
	      for (k in obj) {
	        v = obj[k];
	        ret[k] = v;
	      }
	      return ret;
	    }
	  };

	  return ShallowClone;

	})();


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	var FoundationMath, StringExtensions, Types, compactFlatten, escapedDoubleQuoteRegex, floor, intRand, isArray, isNumber, isPlainObject, isString, wordsRegex;

	FoundationMath = __webpack_require__(33);

	Types = __webpack_require__(31);

	wordsRegex = __webpack_require__(34).wordsRegex;

	intRand = FoundationMath.intRand;

	isString = Types.isString, isNumber = Types.isNumber, isPlainObject = Types.isPlainObject, isArray = Types.isArray;

	compactFlatten = Neptune.NeptuneLib.compactFlatten;

	escapedDoubleQuoteRegex = /[\\]["]/g;

	floor = Math.floor;

	module.exports = StringExtensions = (function() {
	  var consistentJsonStringify, escapeDoubleQuoteJavascriptString, escapeJavascriptString, getPadding, pluralize, repeat, standardIndent;

	  function StringExtensions() {}


	  /*
	  IN: an array and optionally a string, in any order
	    joiner: the string
	    array-to-flatten-and-join: the array
	  
	  OUT:
	    compactFlatten(array).join joiner || ""
	  
	  NOTE: this uses Ruby's default value for joining - the empty array, not ',' which is JavaScripts
	   */

	  StringExtensions.compactFlattenJoin = function(a, b) {
	    var array, joiner;
	    array = null;
	    joiner = isString(a) ? (array = b, a) : (array = a, b || "");
	    return compactFlatten(array).join(joiner);
	  };

	  StringExtensions.randomString = function(length, chars) {
	    var charsLength, i, result;
	    if (length == null) {
	      length = 32;
	    }
	    if (chars == null) {
	      chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	    }
	    result = '';
	    charsLength = chars.length;
	    return ((function() {
	      var j, ref, results;
	      results = [];
	      for (i = j = 0, ref = length; j < ref; i = j += 1) {
	        results.push(chars[intRand(charsLength)]);
	      }
	      return results;
	    })()).join('');
	  };

	  StringExtensions.pluralize = pluralize = function(a, b, pluralForm) {
	    if (typeof a === "number") {
	      return a + " " + (a === 1 ? b : pluralForm || pluralize(b));
	    } else {
	      return a + "s";
	    }
	  };

	  StringExtensions.replaceLast = function(str, find, replaceWith) {
	    var index;
	    index = str.lastIndexOf(find);
	    if (index >= 0) {
	      return str.substring(0, index) + replaceWith + str.substring(index + find.length);
	    } else {
	      return str.toString();
	    }
	  };

	  StringExtensions.getPadding = getPadding = function(length, padding) {
	    if (padding == null) {
	      padding = " ";
	    }
	    return Array(length).join(padding);
	  };

	  StringExtensions.pad = function(str, length, padding, alignRight) {
	    var exactPadding;
	    str = String(str);
	    if (str.length >= length) {
	      return str;
	    }
	    exactPadding = getPadding(Math.max(length - str.length + 1, 0), padding);
	    if (alignRight) {
	      return exactPadding + str;
	    } else {
	      return str + exactPadding;
	    }
	  };

	  StringExtensions.escapeDoubleQuoteJavascriptString = escapeDoubleQuoteJavascriptString = function(str) {
	    var s;
	    s = String(str).replace(/[\\"]/g, "\\$&").replace(/[\0\b\f\n\r\t\v\u2028\u2029]/g, function(x) {
	      switch (x) {
	        case '\0':
	          return "\\0";
	        case '\b':
	          return "\\b";
	        case '\f':
	          return "\\f";
	        case '\n':
	          return "\\n";
	        case '\r':
	          return "\\r";
	        case '\t':
	          return "\\t";
	        case '\v':
	          return "\\v";
	        case '\u2028':
	          return "\\u2028";
	        case '\u2029':
	          return "\\u2029";
	      }
	    });
	    return s = '"' + s + '"';
	  };


	  /*
	  SBD for a while I only had JSON.stringify here, but I hate seeing: "I said, \"hello.\""
	  when I could be seeing: 'I said, "hello."'
	  
	  Is this going to break anything? I figure if you really need "" only, just use stringify.
	   */

	  StringExtensions.escapeJavascriptString = escapeJavascriptString = function(str) {
	    var s;
	    s = JSON.stringify(str);
	    if (s.match(escapedDoubleQuoteRegex)) {
	      return "'" + (s.replace(escapedDoubleQuoteRegex, '"').replace(/'/g, "\\'").slice(1, -1)) + "'";
	    } else {
	      return s;
	    }
	  };

	  StringExtensions.allIndexes = function(str, regex) {
	    var indexes, lastIndex, result;
	    indexes = [];
	    if (!((regex instanceof RegExp) && regex.global)) {
	      throw new Error("regex must be a global RegExp");
	    }
	    regex.lastIndex = 0;
	    while (result = regex.exec(str)) {
	      indexes.push(result.index);
	      lastIndex = result;
	    }
	    return indexes;
	  };

	  StringExtensions.repeat = repeat = " ".repeat ? function(str, times) {
	    return str.repeat(times);
	  } : function(str, count) {
	    var result;
	    count === floor(count);
	    result = '';
	    if (count > 0 && str.length > 0) {
	      while (true) {
	        if ((count & 1) === 1) {
	          result += str;
	        }
	        count >>>= 1;
	        if (count === 0) {
	          break;
	        }
	        str += str;
	      }
	    }
	    return result;
	  };

	  StringExtensions.rightAlign = function(str, width) {
	    if (str.length >= width) {
	      return str;
	    } else {
	      return repeat(" ", width - str.length) + str;
	    }
	  };

	  StringExtensions.eachMatch = function(str, regex, f) {
	    var result;
	    regex.lastIndex = 0;
	    while (result = regex.exec(str)) {
	      f(result);
	    }
	    return null;
	  };

	  standardIndent = {
	    joiner: ', ',
	    openObject: '{',
	    openArray: '[',
	    closeObject: "}",
	    closeArray: "]"
	  };

	  StringExtensions.consistentJsonStringify = consistentJsonStringify = function(object, indent) {
	    var closeArray, closeObject, error, indentObject, joiner, k, lastTotalIndent, openArray, openObject, out, totalIndent, v;
	    return out = (function() {
	      var ref;
	      if (object === false || object === true || object === null || isNumber(object)) {
	        return "" + object;
	      } else if (isString(object)) {
	        return escapeJavascriptString(object);
	      } else {
	        indentObject = indent ? typeof indent === "string" ? {
	          joiner: ",\n" + indent,
	          openObject: "{\n" + indent,
	          openArray: "[\n" + indent,
	          closeObject: "\n}",
	          closeArray: "\n]",
	          totalIndent: indent,
	          indent: indent
	        } : {
	          totalIndent: totalIndent = indent.indent + (lastTotalIndent = indent.totalIndent),
	          joiner: ",\n" + totalIndent,
	          openObject: "{\n" + totalIndent,
	          openArray: "[\n" + totalIndent,
	          closeObject: "\n" + lastTotalIndent + "}",
	          closeArray: "\n" + lastTotalIndent + "]",
	          indent: indent.indent
	        } : void 0;
	        ref = indentObject || standardIndent, joiner = ref.joiner, openObject = ref.openObject, openArray = ref.openArray, closeObject = ref.closeObject, closeArray = ref.closeArray;
	        if (isPlainObject(object)) {
	          return openObject + ((function() {
	            var j, len, ref1, results;
	            ref1 = (Object.keys(object)).sort();
	            results = [];
	            for (j = 0, len = ref1.length; j < len; j++) {
	              k = ref1[j];
	              if (object[k] !== void 0) {
	                results.push(escapeJavascriptString(k) + ": " + consistentJsonStringify(object[k], indentObject));
	              }
	            }
	            return results;
	          })()).join(joiner) + closeObject;
	        } else if (isArray(object)) {
	          return openArray + ((function() {
	            var j, len, results;
	            results = [];
	            for (j = 0, len = object.length; j < len; j++) {
	              v = object[j];
	              results.push(consistentJsonStringify(v, indentObject));
	            }
	            return results;
	          })()).join(joiner) + closeArray;
	        } else {
	          Neptine.Art.Foundation.log.error(error = "invalid object type for Json. Expecting: null, false, true, number, string, plain-object or array", object);
	          throw new Error(error);
	        }
	      }
	    })();
	  };

	  StringExtensions.splitRuns = function(str) {
	    var ch, chCount, i, j, lastCh, ref, result;
	    if (str.length === 0) {
	      return [];
	    }
	    lastCh = str[0];
	    chCount = 1;
	    result = [];
	    for (i = j = 1, ref = str.length; j < ref; i = j += 1) {
	      ch = str[i];
	      if (ch === lastCh) {
	        chCount++;
	      } else {
	        result.push([lastCh, chCount]);
	        chCount = 1;
	      }
	      lastCh = ch;
	    }
	    result.push([lastCh, chCount]);
	    return result;
	  };

	  StringExtensions.eachRunAsCharCodes = function(str, f) {
	    var ch, chCount, i, j, lastCh, ref;
	    lastCh = str.charCodeAt(0);
	    chCount = 1;
	    for (i = j = 1, ref = str.length; j < ref; i = j += 1) {
	      ch = str.charCodeAt(i);
	      if (ch === lastCh) {
	        chCount++;
	      } else {
	        f(lastCh, chCount);
	        chCount = 1;
	      }
	      lastCh = ch;
	    }
	    f(lastCh, chCount);
	    return null;
	  };


	  /*
	  TODO: I think this can be generalized to cover most all ellipsies and word-wrap scenarios:
	    a) have an options object with options:
	      maxLength: number         # similar to current maxLength
	      minLength: number         # currently implied to be maxLength / 2, in additional customizable, it would also be optional
	      brokenWordEllipsis: ""   # used when only part of a word is included
	      moreWordsEllipsis: ""    # used when there are more words, but the last word is whole
	      wordLengthFunction: (string) -> string.length
	         * can be replaced with, say, the font pixel-width for a string
	         * in this way, this function can be used by text-layout
	         * minLength and maxLength would then be in pixels
	      breakWords: false         # currently, this is effectively true - will break the last word on line in most situations
	      breakOnlyWord: true       # even if breakWords is false, if this is the only word on the line and it doesn't fit, should we break it?
	                                 * should this even be an option?
	       * future:
	      wordBreakFunction: (word, maxLength) -> shorterWord
	         * given a word and the maximum length of that word, returns
	         * a word <= maxLength according to wordLengthFunction
	  
	    b) Use cases
	      - TextLayout - uses pixels for length rather than characters
	      - Art.Engine.Element 'flow' layout
	        - if the input was an array of "words" and
	        - wordLengthFunction returns the Element's width...
	        I think this works. We'd need a way to handle margins though. I think this works:
	          spaceLength: (leftWord, rightWord) -> 1
	      - Shortend user display names:
	        Options:
	          wordBreakFunction: (word, maxLength) -> word[0]
	          brokenWordEllipsis: "." or ""
	        Example Output:
	          "Shane Delamore", 10 > "Shane D." or
	          "Shane Delamore", 10 > "Shane D"
	        Or, just leave breakwords: false and get:
	          "Shane Delamore", 10 > "Shane"
	  
	    c) returns both the output string and the "string remaining" - everything not included
	    d) alternate input: an array of strings already broken up by words - the "remainging" return value would then also be an array of "words"
	      (this would be for efficiency when doing multi-line layout)
	  
	  Right now, it works as follows:
	  The output string is guaranteed to be:
	    <= maxLength
	    >= maxLength / 2 in almost all secenarios as long as inputString is >= maxLength / 2
	   */

	  StringExtensions.humanFriendlyShorten = function(inputString, maxLength) {
	    var j, len, minLength, part, string, stringParts;
	    if (!(maxLength > 0)) {
	      throw new error("maxLength must be > 0");
	    }
	    inputString = inputString.trim();
	    if (!(inputString.length > maxLength)) {
	      return inputString;
	    }
	    minLength = maxLength / 2;
	    stringParts = inputString.split(/\s+/);
	    string = "";
	    for (j = 0, len = stringParts.length; j < len; j++) {
	      part = stringParts[j];
	      if (string.length === 0) {
	        string = part;
	      } else if ((string.length < minLength) || string.length + part.length + 2 <= maxLength) {
	        string += " " + part;
	      } else {
	        break;
	      }
	    }
	    if (string.length > maxLength) {
	      string = string.slice(0, maxLength - 1).trim();
	    }
	    return string + "";
	  };

	  StringExtensions.stripTrailingWhitespace = function(a) {
	    return a.split(/[ ]*\n/).join("\n").split(/[ ]*$/)[0].replace(/\n+$/, '');
	  };

	  return StringExtensions;

	})();


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var Time, base, commaize, dateSecondMinusPerformanceSecond, initDateSecond, initPerformanceSecond;

	commaize = __webpack_require__(33).commaize;

	self.performance || (self.performance = {});

	(base = self.performance).now || (base.now = self.performance.mozNow || self.performance.msNow || self.performance.oNow || self.performance.webkitNow || function() {
	  return new Date().getTime();
	});

	initPerformanceSecond = self.performance.now() / 1000;

	initDateSecond = new Date().getTime() / 1000;

	dateSecondMinusPerformanceSecond = initDateSecond - initPerformanceSecond;

	module.exports = Time = (function() {
	  var currentSecond, multiples, timerStack;

	  function Time() {}

	  multiples = [["mo", 30 * 24 * 60 * 60], ["d", 24 * 60 * 60], ["h", 60 * 60], ["m", 60], ["s", 1], ["ms", .001], ["s", .000001], ["ns", .000000001]];

	  Time.dateSecondToPerformanceSecond = function(dateSecond) {
	    return dateSecond - dateSecondMinusPerformanceSecond;
	  };

	  Time.performanceSecondToDateSecond = function(performanceSecond) {
	    return performanceSecond + dateSecondMinusPerformanceSecond;
	  };

	  Time.timeStampToPerformanceSecond = function(htmlEventTimeStamp) {
	    return htmlEventTimeStamp / 1000 - dateSecondMinusPerformanceSecond;
	  };

	  Time.durationString = function(seconds) {
	    var i, len, multiplier, name, ref;
	    for (i = 0, len = multiples.length; i < len; i++) {
	      ref = multiples[i], name = ref[0], multiplier = ref[1];
	      if (seconds >= multiplier) {
	        return "" + ((seconds / multiplier) | 0) + name;
	      }
	    }
	    return "0";
	  };

	  Time.dateAgeInSeconds = function(date) {
	    return ((new Date) - date) * .001;
	  };

	  Time.dateToSeconds = function(date) {
	    return post.getTime() * .001;
	  };

	  Time.perTimeString = function(secondsPerRun) {
	    var perTime;
	    perTime = 1 / secondsPerRun;
	    if (perTime > 100) {
	      return (commaize(perTime | 0)) + "/s";
	    } else if (perTime * 60 > 100) {
	      return (commaize(perTime * 60 | 0)) + "/m";
	    } else {
	      return (commaize(perTime * 3600 | 0)) + "/h";
	    }
	  };

	  Time.currentMillisecond = function() {
	    return self.performance.now();
	  };

	  Time.currentSecond = currentSecond = function() {
	    return self.performance.now() / 1000;
	  };

	  Time.currentDateSecond = function() {
	    return new Date().getTime() / 1000;
	  };

	  Time.time = function(a, b) {
	    var f, fResult, start, timeResult;
	    f = b || a;
	    start = currentSecond();
	    fResult = f();
	    timeResult = currentSecond() - start;
	    if (b) {
	      Neptune.Art.Foundation.log("time: " + a + " took " + (Time.durationString(timeResult)));
	      return fResult;
	    } else {
	      return timeResult;
	    }
	  };

	  timerStack = [];

	  Time.stackTime = function(f) {
	    var start, subTimeTotal, timeResult, tsl;
	    start = currentSecond();
	    timerStack.push(0);
	    f();
	    subTimeTotal = timerStack.pop();
	    timeResult = currentSecond() - start;
	    if ((tsl = timerStack.length) > 0) {
	      timerStack[tsl - 1] += timeResult;
	    }
	    return {
	      count: 1,
	      total: timeResult,
	      subTimeTotal: subTimeTotal,
	      remainder: timeResult - subTimeTotal
	    };
	  };

	  Time.logTimeSinceLast = function(a) {
	    var time;
	    time = Time.currentSecond();
	    console.log(a + " (" + (Time.lastTime ? Time.durationString(time - Time.lastTime) : void 0) + ")");
	    return Time.lastTime = time;
	  };

	  return Time;

	})();


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	var CommonJs, isClass, isFunction, ref;

	ref = __webpack_require__(31), isClass = ref.isClass, isFunction = ref.isFunction;

	module.exports = CommonJs = (function() {
	  var definingModule;

	  function CommonJs() {}

	  definingModule = null;

	  CommonJs.getModuleBeingDefined = function() {
	    return definingModule;
	  };


	  /*
	  IN:
	    defineFunciton ||
	   */

	  CommonJs.defineModule = function(_module, a) {
	    var lastModule, mod, result;
	    lastModule = definingModule;
	    definingModule = _module;
	    mod = isFunction(a) ? isClass(a) ? a : a() : a;
	    result = _module.exports = (mod != null ? typeof mod.createWithPostCreate === "function" ? mod.createWithPostCreate(mod) : void 0 : void 0) || mod;
	    definingModule = lastModule;
	    return result;
	  };

	  return CommonJs;

	})();


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(48).includeInNamespace(__webpack_require__(49)).addModules({
	  FormattedInspect: __webpack_require__(54),
	  InspectedObjectLiteral: __webpack_require__(56),
	  Inspector: __webpack_require__(50),
	  Inspector2: __webpack_require__(58),
	  ToInspectedObjects: __webpack_require__(55),
	  ToPlainObjects: __webpack_require__(57)
	});

	__webpack_require__(59);


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	var Inspect, StandardLib,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(25);

	module.exports = StandardLib.Inspect || StandardLib.addNamespace('Inspect', Inspect = (function(superClass) {
	  extend(Inspect, superClass);

	  function Inspect() {
	    return Inspect.__super__.constructor.apply(this, arguments);
	  }

	  return Inspect;

	})(Neptune.Base));


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	TODO: refactor so nothing in inspect/* uses BaseObject
	Then, move into StandardLib.
	 */
	module.exports = [[__webpack_require__(50), "shallowInspect inspectLean inspect"], __webpack_require__(54), __webpack_require__(55), __webpack_require__(57), __webpack_require__(56)];


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var Inspector, Map, escapeJavascriptString, isArray, isBrowserObject, isClass, isFunction, isObject, isPlainArray, isPlainObject, isString, objectName, ref,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

	Map = __webpack_require__(51);

	escapeJavascriptString = __webpack_require__(44).escapeJavascriptString;

	ref = __webpack_require__(31), objectName = ref.objectName, isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, isObject = ref.isObject, isClass = ref.isClass, isBrowserObject = ref.isBrowserObject, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray;

	module.exports = Inspector = (function() {
	  var inspect;

	  Inspector.unquotablePropertyRegex = /^([0-9]+|[_a-zA-Z][_0-9a-zA-Z]*)$/;

	  Inspector.customInspectable = function(obj) {
	    return obj.inspect && !(typeof obj === "function");
	  };

	  Inspector.parentString = function(distance) {
	    switch (distance) {
	      case 0:
	        return "parent";
	      case 1:
	        return "grandparent";
	      case 2:
	        return "great grandparent";
	      default:
	        return "great^" + (distance - 1) + " grandparent";
	    }
	  };

	  function Inspector(options) {
	    if (options == null) {
	      options = {};
	    }
	    this.inspect = bind(this.inspect, this);
	    this.inspectInternal = bind(this.inspectInternal, this);
	    this.inspectObject = bind(this.inspectObject, this);
	    this.inspectArray = bind(this.inspectArray, this);
	    this.maxLength = options.maxLength || 1000;
	    this.allowCustomInspectors = !options.noCustomInspectors;
	    this.maxDepth = options.maxDepth != null ? options.maxDepth : 10;
	    this.outArray = [];
	    this.length = 0;
	    this.depth = 0;
	    this.inspectingMap = new Map;
	    this.done = false;
	  }

	  Inspector.inspect = inspect = function(obj, options) {
	    var inspector;
	    if (options == null) {
	      options = {};
	    }
	    if (this !== global) {
	      return Neptune.Base.inspect.call(this);
	    }
	    inspector = new Inspector(options);
	    inspector.inspect(obj);
	    return inspector.getResult();
	  };

	  Inspector.shallowInspect = function(obj) {
	    if (obj == null) {
	      return "" + obj;
	    } else if (Inspector.customInspectable(obj)) {
	      return Inspector.inspect(obj);
	    } else if (isString(obj)) {
	      return escapeJavascriptString(obj);
	    } else if (isArray(obj)) {
	      return "<<Array length: " + obj.length + ">>";
	    } else if (isFunction(obj) && obj.name === "") {
	      return "<<function args: " + obj.length + ">>";
	    } else {
	      return "<<" + (typeof obj) + ": " + (obj.name || obj) + ">>";
	    }
	  };

	  Inspector.inspectLean = function(object, options) {
	    var fullInspect, match;
	    fullInspect = inspect(object, options);
	    if (!isFunction(object != null ? object.inspect : void 0) && (isPlainObject(object) || (isPlainArray(object) && (object.length > 1 || (options != null ? options.forArgs : void 0))))) {
	      match = fullInspect.match(/^\[(.+)\]$|^\{(.+)\}$/);
	      if (match) {
	        return match[1] || match[2] || match[3];
	      } else {
	        return fullInspect;
	      }
	    } else {
	      return fullInspect;
	    }
	  };

	  Inspector.prototype.put = function(s) {
	    if (this.done) {
	      return;
	    }
	    this.outArray.push(this.length + s.length > this.maxLength ? (this.done = true, "...") : (this.length += s.length, s));
	    return s;
	  };

	  Inspector.prototype.getResult = function() {
	    return this.outArray.join("");
	  };

	  Inspector.prototype.maxDepthOutput = function(obj) {
	    var keys, name;
	    switch (typeof obj) {
	      case "string":
	      case "number":
	      case "boolean":
	      case "undefined":
	        return this.inspectInternal(obj);
	      case "function":
	        return this.put(objectName(obj));
	      case "object":
	        return this.put(obj === null ? "null" : isArray(obj) ? "[" + obj.length + " elements]" : (keys = Object.keys(obj), name = objectName(obj), name === "Object" ? "{" + keys.length + " keys}" : keys.length > 0 ? "{" + name + " " + keys.length + " keys}" : name));
	    }
	  };

	  Inspector.prototype.inspectArray = function(array) {
	    var first, i, len, obj;
	    this.put("[");
	    first = true;
	    for (i = 0, len = array.length; i < len; i++) {
	      obj = array[i];
	      if (!first) {
	        this.put(", ");
	      }
	      this.inspect(obj);
	      first = false;
	    }
	    return this.put("]");
	  };

	  Inspector.prototype.inspectObject = function(obj) {
	    var attributes, first, i, k, keys, len, name, v;
	    attributes = [];
	    keys = Object.keys(obj);
	    name = objectName(obj);
	    if (isFunction(obj) && keys.length === 0) {
	      return this.put(name + "()");
	    } else if (isBrowserObject(obj)) {
	      return this.put("{" + name + "}");
	    } else {
	      this.put("{");
	      if (obj.constructor !== Object) {
	        this.put(name + " ");
	      }
	      first = true;
	      for (i = 0, len = keys.length; i < len; i++) {
	        k = keys[i];
	        if (!(k !== "__uniqueId")) {
	          continue;
	        }
	        if (!first) {
	          this.put(", ");
	        }
	        v = obj[k];
	        if (Inspector.unquotablePropertyRegex.test(k)) {
	          this.put(k);
	        } else {
	          this.inspect(k);
	        }
	        this.put(": ");
	        this.inspect(v);
	        first = false;
	      }
	      return this.put("}");
	    }
	  };

	  Inspector.prototype.inspectInternal = function(obj) {
	    if (obj == null) {
	      return this.put("" + obj);
	    } else if (isString(obj)) {
	      return this.put(escapeJavascriptString(obj));
	    } else if (isArray(obj)) {
	      return this.inspectArray(obj);
	    } else if (isClass(obj)) {
	      return this.put(objectName(obj));
	    } else if (this.allowCustomInspectors && Inspector.customInspectable(obj)) {
	      if (obj.inspect.length > 0) {
	        return obj.inspect(this);
	      } else {
	        return this.put(obj.inspect());
	      }
	    } else if (obj instanceof RegExp) {
	      return this.put("" + obj);
	    } else if (isObject(obj) || isFunction(obj)) {
	      return this.inspectObject(obj);
	    } else {
	      return this.put("" + obj);
	    }
	  };

	  Inspector.prototype.inspect = function(obj) {
	    var objDepth;
	    if (this.done) {
	      return;
	    }
	    if (objDepth = this.inspectingMap.get(obj)) {
	      this.put("<" + (Inspector.parentString(this.depth - objDepth)) + ">");
	      return null;
	    }
	    if (this.depth >= this.maxDepth) {
	      this.maxDepthOutput(obj);
	    } else {
	      this.depth++;
	      this.inspectingMap.set(obj, this.depth);
	      this.inspectInternal(obj);
	      this.inspectingMap["delete"](obj);
	      this.depth--;
	    }
	    return null;
	  };

	  return Inspector;

	})();

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	TODO: This is almost identical to ES6's Map: Switch to using a Polyfill like:
	  https://github.com/paulmillr/es6-shim

	Map is a Key-Value map which preserves order.

	Unlike Javascript objects, you can use any object or value as keys. This includes:

	  Strings
	  Numbers
	  null
	  undefined
	  Arrays
	  Objects

	Arrays and Objects are assigned a unique id using the Foundation.Unique library.
	"0", "", null, undefined and 0 are all different unique keys and can each have unique values.
	 */
	var Map, MinimalBaseObject, Node, Unique,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Unique = __webpack_require__(52);

	MinimalBaseObject = __webpack_require__(53);

	Node = (function() {
	  function Node(key, value, prev, next) {
	    this.key = key;
	    this.value = value;
	    this.prev = prev || null;
	    this.next = next || null;
	    if (prev) {
	      prev.next = this;
	    }
	    if (next) {
	      next.prev = this;
	    }
	  }

	  Node.prototype.remove = function() {
	    var n, p;
	    n = this.next;
	    p = this.prev;
	    if (p) {
	      p.next = n;
	      this.prev = null;
	    }
	    if (n) {
	      n.prev = p;
	      return this.next = null;
	    }
	  };

	  return Node;

	})();

	module.exports = Map = (function(superClass) {
	  extend(Map, superClass);

	  Map.inverseMap = function(array) {
	    var i, k, len, result, v;
	    result = new Map;
	    for (k = i = 0, len = array.length; i < len; k = ++i) {
	      v = array[k];
	      result.set(v, k);
	    }
	    return result;
	  };

	  function Map() {
	    this._length = 0;
	    this._map = {};
	    this._first = this._last = null;
	  }

	  Map.getter({
	    length: function() {
	      return this._length;
	    },
	    nodes: function() {
	      var n, result;
	      result = [];
	      n = this._first;
	      while (n) {
	        result.push(n);
	        n = n.next;
	      }
	      return result;
	    },
	    keys: function() {
	      var i, len, node, ref, results;
	      ref = this.nodes;
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        node = ref[i];
	        results.push(node.key);
	      }
	      return results;
	    },
	    values: function() {
	      var i, len, node, ref, results;
	      ref = this.nodes;
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        node = ref[i];
	        results.push(node.value);
	      }
	      return results;
	    }
	  });

	  Map.prototype.get = function(key) {
	    var node;
	    node = this._map[Unique.id(key)];
	    return node && node.value;
	  };

	  Map.prototype.set = function(key, value) {
	    var id;
	    id = Unique.id(key);
	    if (this._map[id]) {
	      this._map[id].value = value;
	    } else {
	      this._length++;
	      this._last = this._map[id] = new Node(key, value, this._last);
	      if (!this._first) {
	        this._first = this._last;
	      }
	    }
	    return value;
	  };

	  Map.prototype._remove = function(key) {
	    var id, n;
	    id = Unique.id(key);
	    if (n = this._map[id]) {
	      this._length--;
	      delete this._map[id];
	      if (this._first === n) {
	        this._first = n.next;
	      }
	      if (this._last === n) {
	        this._last = n.prev;
	      }
	      n.remove();
	      return n;
	    } else {
	      return void 0;
	    }
	  };

	  Map.prototype.remove = function(key) {
	    var n;
	    if (n = this._remove(key)) {
	      return n.value;
	    } else {
	      return void 0;
	    }
	  };

	  Map.prototype["delete"] = function(key) {
	    return !!this._remove(key);
	  };

	  Map.prototype.exists = function(key) {
	    return this._map[Unique.id(key)];
	  };

	  Map.prototype.forEach = function(f) {
	    var i, len, node, ref;
	    ref = this.nodes;
	    for (i = 0, len = ref.length; i < len; i++) {
	      node = ref[i];
	      f(node.value);
	    }
	    return this;
	  };

	  Map.prototype.findFirst = function(testF) {
	    var i, len, node, ref;
	    ref = this.nodes;
	    for (i = 0, len = ref.length; i < len; i++) {
	      node = ref[i];
	      if (testF(node.value)) {
	        return node.value;
	      }
	    }
	    return void 0;
	  };

	  Map.prototype.each = function(f) {
	    var i, len, node, ref;
	    ref = this.nodes;
	    for (i = 0, len = ref.length; i < len; i++) {
	      node = ref[i];
	      f(node.key, node.value);
	    }
	    return this;
	  };

	  Map.prototype.map = function(f) {
	    var i, len, node, ref, results;
	    ref = this.nodes;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      node = ref[i];
	      results.push(f(node.key, node.value));
	    }
	    return results;
	  };

	  Map.prototype.inspect = function(inspector) {
	    var _inspect, first;
	    Neptune.Art.Foundation.log("inspect map");
	    if (!inspector) {
	      return Neptune.Art.Foundation.inspect(this);
	    }
	    _inspect = function(o) {
	      if (typeof o === "string" && o.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
	        return inspector.put(o);
	      } else {
	        return inspector.inspect(o);
	      }
	    };
	    inspector.put("{Map ");
	    first = true;
	    this.map(function(k, v) {
	      if (!first) {
	        inspector.put(", ");
	      }
	      _inspect(k);
	      inspector.put(": ");
	      inspector.inspect(v);
	      return first = false;
	    });
	    return inspector.put("}");
	  };

	  Map.prototype.verifyNodes = function() {
	    var inspect, length, node, prev;
	    inspect = Neptune.Art.Foundation.inspect;
	    if ((this._first == null) && (this._last == null) && this._length === 0) {
	      return;
	    }
	    if (this._length === 0 && this._first) {
	      throw new Error("length == " + this.length + " but @_first is not null");
	    }
	    if (this._length === 0 && this._last) {
	      throw new Error("length == " + this.length + " but @_last is not null");
	    }
	    if (!this._first) {
	      throw new Error("length == " + this.length + " and @_first is null");
	    }
	    if (!this._last) {
	      throw new Error("length == " + this.length + " and @_last is null");
	    }
	    if (this._first.prev) {
	      throw new Error("@_first has prev");
	    }
	    if (this._last.next) {
	      throw new Error("@_last has next");
	    }
	    length = 0;
	    prev = null;
	    node = this._first;
	    while (node) {
	      length++;
	      if (node.prev !== prev) {
	        throw new Error("node.prev != prev. " + (inspect({
	          lenght: length,
	          nodePrev: node.prev,
	          prev: prev
	        }, 1)));
	      }
	      prev = node;
	      node = node.next;
	    }
	    if (this.length !== length) {
	      throw new Error("@length is " + this.length + ", but it should be " + length);
	    }
	  };

	  return Map;

	})(MinimalBaseObject);


/***/ },
/* 52 */
/***/ function(module, exports) {

	var Unique, nextId;

	nextId = 1;

	module.exports = Unique = (function() {
	  var nextUniqueObjectId, objectId;

	  function Unique() {}

	  Unique.nextUniqueObjectId = nextUniqueObjectId = function() {
	    return "object_" + nextId++;
	  };

	  Unique.objectId = objectId = function(o) {
	    if (o.hasOwnProperty("__uniqueId")) {
	      return o.__uniqueId || (o.__uniqueId = nextUniqueObjectId());
	    } else {
	      Object.defineProperty(o, "__uniqueId", {
	        enumerable: false,
	        value: nextUniqueObjectId()
	      });
	      return o.__uniqueId;
	    }
	  };

	  Unique.id = function(key) {
	    if (typeof key === "object" || typeof key === "function") {
	      if (key) {
	        if (typeof key.getUniqueId === "function") {
	          return key.getUniqueId();
	        } else {
	          return objectId(key);
	        }
	      } else {
	        return "null";
	      }
	    } else if (typeof key === "number") {
	      return "" + key;
	    } else if (typeof key === "string") {
	      return "string_" + key;
	    } else if (typeof key === "boolean") {
	      if (key) {
	        return "true";
	      } else {
	        return "false";
	      }
	    } else if (key === void 0) {
	      return "undefined";
	    } else {
	      return (typeof key) + "_" + key;
	    }
	  };

	  return Unique;

	})();


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var MinimalBaseObject, capitalize, isFunction, isPlainObject, isString, ref;

	capitalize = Neptune.NeptuneLib.capitalize;

	ref = __webpack_require__(31), isFunction = ref.isFunction, isString = ref.isString, isPlainObject = ref.isPlainObject;

	module.exports = MinimalBaseObject = (function() {
	  var addGetter, addGetters, addProperties, addSetter, addSetters, defProperties, defProperty, propGetterName, propInternalName, propListStringToArray, propSetterName;

	  function MinimalBaseObject() {}

	  MinimalBaseObject.propInternalName = propInternalName = function(prop) {
	    return "_" + prop;
	  };


	  /*
	  IN: arguments is a list of strings or objects
	    strings: are just the names of the properties
	    objects: map from prop names to getter/setter functions
	   */

	  MinimalBaseObject.getter = function() {
	    return defProperties(this.prototype, arguments, true, false);
	  };

	  MinimalBaseObject.setter = function() {
	    return defProperties(this.prototype, arguments, false, true);
	  };

	  MinimalBaseObject.addGetter = function(prop, getter) {
	    return this._addGetter(this.prototype, prop, getter);
	  };

	  MinimalBaseObject.addSetter = function(prop, setter) {
	    return this._addSetter(this.prototype, prop, setter);
	  };

	  MinimalBaseObject.addClassGetter = function(prop, getter) {
	    return this._addGetter(this, prop, getter);
	  };

	  MinimalBaseObject.addClassSetter = function(prop, setter) {
	    return this._addSetter(this, prop, setter);
	  };


	  /*
	  IN: arguments is a list of strings or objects
	    strings: are just the names of the properties
	    objects: map from prop names to initializers
	   */

	  MinimalBaseObject.property = function() {
	    return defProperties(this.prototype, arguments, true, true);
	  };

	  MinimalBaseObject.classGetter = function() {
	    return defProperties(this, arguments, true, false);
	  };

	  MinimalBaseObject.classSetter = function() {
	    return defProperties(this, arguments, false, true);
	  };

	  MinimalBaseObject.classProperty = function() {
	    return defProperties(this, arguments, true, true);
	  };

	  MinimalBaseObject._propGetterName = propGetterName = function(prop) {
	    return "get" + capitalize(prop);
	  };

	  MinimalBaseObject._propSetterName = propSetterName = function(prop) {
	    return "set" + capitalize(prop);
	  };

	  MinimalBaseObject._addGetter = addGetter = function(obj, prop, getter) {
	    obj[propGetterName(prop)] = getter;
	    if (!isFunction(getter)) {
	      getter = (function() {
	        return getter;
	      });
	    }
	    Object.defineProperty(obj, prop, {
	      get: getter,
	      configurable: true
	    });
	    return prop;
	  };

	  MinimalBaseObject._addSetter = addSetter = function(obj, prop, setter) {
	    obj[propSetterName(prop)] = setter;
	    Object.defineProperty(obj, prop, {
	      set: setter,
	      configurable: true
	    });
	    return prop;
	  };

	  MinimalBaseObject._addGetters = addGetters = function(obj, map) {
	    var getter, prop;
	    for (prop in map) {
	      getter = map[prop];
	      addGetter(obj, prop, getter);
	    }
	    return map;
	  };

	  MinimalBaseObject._addSetters = addSetters = function(obj, map) {
	    var prop, setter;
	    for (prop in map) {
	      setter = map[prop];
	      addSetter(obj, prop, setter);
	    }
	    return map;
	  };

	  MinimalBaseObject._addProperties = addProperties = function(obj, map) {
	    var initializer, prop;
	    for (prop in map) {
	      initializer = map[prop];
	      defProperty(obj, prop, true, true, initializer);
	    }
	    return map;
	  };

	  MinimalBaseObject._defProperty = defProperty = function(obj, prop, defineGetter, defineSetter, initializer) {
	    var propName;
	    propName = propInternalName(prop);
	    if (defineGetter) {
	      addGetter(obj, prop, obj[propGetterName(prop)] = isFunction(initializer) ? function() {
	        if (this[propName] != null) {
	          return this[propName];
	        } else {
	          return this[propName] = initializer();
	        }
	      } : initializer != null ? function() {
	        if (this[propName] != null) {
	          return this[propName];
	        } else {
	          return this[propName] = initializer;
	        }
	      } : function() {
	        return this[propName];
	      });
	    }
	    if (defineSetter) {
	      return addSetter(obj, prop, function(v) {
	        return this[propName] = v;
	      });
	    }
	  };

	  MinimalBaseObject._defProperties = defProperties = function(obj, props, defineGetter, defineSetter) {
	    var i, len, prop, propFromString, propMap, results;
	    results = [];
	    for (i = 0, len = props.length; i < len; i++) {
	      prop = props[i];
	      if (isPlainObject(propMap = prop)) {
	        if (defineGetter && defineSetter) {
	          results.push(addProperties(obj, propMap));
	        } else if (defineGetter) {
	          results.push(addGetters(obj, propMap));
	        } else {
	          results.push(addSetters(obj, propMap));
	        }
	      } else if (isString(prop)) {
	        results.push((function() {
	          var j, len1, ref1, results1;
	          ref1 = propListStringToArray(prop);
	          results1 = [];
	          for (j = 0, len1 = ref1.length; j < len1; j++) {
	            propFromString = ref1[j];
	            results1.push(defProperty(obj, propFromString, defineGetter, defineSetter, null));
	          }
	          return results1;
	        })());
	      } else {
	        throw new Error("invalid value. Expected string or plain-object:", prop);
	      }
	    }
	    return results;
	  };

	  MinimalBaseObject._propListStringToArray = propListStringToArray = function(propList) {
	    return propList.match(/[_a-z][_a-z0-9]*/gi);
	  };

	  return MinimalBaseObject;

	})();


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var FormattedInspect, alignTabStopsByBlocks, alignTabs, escapeJavascriptString, formatMultilineSubStructure, formatMultilineSubStructureForObject, formattedInspectRecursive, inspect, isFunction, isNumber, isPlainArray, isPlainObject, isString, max, newLineWithNiceNodeInspectIndent, niceNodeInspectIndent, pad, ref, ref1, stripTrailingWhitespace, toInspectedObjects;

	ref = __webpack_require__(31), isString = ref.isString, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isFunction = ref.isFunction, isNumber = ref.isNumber;

	max = Math.max;

	ref1 = __webpack_require__(44), pad = ref1.pad, stripTrailingWhitespace = ref1.stripTrailingWhitespace, escapeJavascriptString = ref1.escapeJavascriptString;

	inspect = __webpack_require__(50).inspect;

	toInspectedObjects = __webpack_require__(55).toInspectedObjects;

	niceNodeInspectIndent = '  ';

	newLineWithNiceNodeInspectIndent = "\n" + niceNodeInspectIndent;

	formatMultilineSubStructure = function(m, inspected, implicitRepresentationOk) {
	  if (!inspected.match(/\n/)) {
	    return inspected;
	  }
	  return inspected.replace(/\n/g, newLineWithNiceNodeInspectIndent);
	};

	formatMultilineSubStructureForObject = function(m, inspected, implicitRepresentationOk) {
	  if (!inspected.match(/\n/)) {
	    return inspected;
	  }
	  if (inspected.match(/^- /)) {
	    return "\n" + inspected + "\n";
	  } else {
	    return newLineWithNiceNodeInspectIndent + inspected.replace(/\n/g, newLineWithNiceNodeInspectIndent);
	  }
	};

	formattedInspectRecursive = function(m, options, implicitRepresentationOk) {
	  var _isPlainObject, containsConsecutiveArrays, containsConsecutiveObjects, finalInspectedValues, forceMultilineOutput, i, indentedInspectedArray, index, inspected, inspectedEl, inspectedLength, inspectedValue, inspectedValues, k, key, keyCount, lastWasArray, lastWasObject, maxLineLength, shouldBeOnOwnLine, v, value;
	  maxLineLength = options.maxLineLength;
	  if (isPlainObject(m)) {
	    inspectedLength = 0;
	    forceMultilineOutput = false;
	    shouldBeOnOwnLine = false;
	    keyCount = 0;
	    inspectedValues = (function() {
	      var results;
	      results = [];
	      for (key in m) {
	        value = m[key];
	        keyCount++;
	        inspectedValue = formatMultilineSubStructureForObject(value, formattedInspectRecursive(value, options));
	        if (!key.match(/^[-._a-zA-Z[_a-zA-Z0-9]*$/)) {
	          key = inspect(key);
	        }
	        inspectedLength += inspectedValue.length + key.length + 2;
	        forceMultilineOutput || (forceMultilineOutput = shouldBeOnOwnLine);
	        shouldBeOnOwnLine = !inspectedValue.match(/^([^,:]|\(.*\)|\{.*\}|\".*\"|\'.*\'|\[.*\])*$/);
	        results.push([key, inspectedValue]);
	      }
	      return results;
	    })();
	    if (keyCount === 0) {
	      return "{}";
	    }
	    index = 0;
	    finalInspectedValues = (function() {
	      var j, len, ref2, results;
	      results = [];
	      for (j = 0, len = inspectedValues.length; j < len; j++) {
	        ref2 = inspectedValues[j], k = ref2[0], v = ref2[1];
	        results.push(k + ":\t" + v);
	      }
	      return results;
	    })();
	    return finalInspectedValues.join(!forceMultilineOutput && maxLineLength >= inspectedLength + (inspectedValues.length - 1) * 2 ? ",\t" : "\n");
	  } else if (isPlainArray(m)) {
	    inspectedLength = 0;
	    lastWasObject = false;
	    lastWasArray = false;
	    containsConsecutiveObjects = false;
	    containsConsecutiveArrays = false;
	    inspectedValues = (function() {
	      var j, len, results;
	      results = [];
	      for (j = 0, len = m.length; j < len; j++) {
	        value = m[j];
	        implicitRepresentationOk = true;
	        if (_isPlainObject = isPlainObject(value)) {
	          containsConsecutiveObjects || (containsConsecutiveObjects = lastWasObject);
	          lastWasObject = true;
	        } else {
	          lastWasObject = false;
	        }
	        if (isPlainArray(value)) {
	          implicitRepresentationOk = false;
	          containsConsecutiveArrays || (containsConsecutiveArrays = lastWasArray);
	          lastWasArray = true;
	        }
	        inspected = formattedInspectRecursive(value, options, implicitRepresentationOk);
	        inspected = formatMultilineSubStructure(value, inspected, implicitRepresentationOk);
	        inspectedLength += inspected.length;
	        results.push(inspected);
	      }
	      return results;
	    })();
	    if (!containsConsecutiveArrays && !containsConsecutiveObjects && maxLineLength >= inspectedLength + (inspectedValues.length - 1) * 2) {
	      if (inspectedValues.length === 0) {
	        return "[]";
	      } else if (inspectedValues.length <= 1) {
	        return "- " + (inspectedValues.join(",\t"));
	      } else {
	        return inspectedValues.join(",\t");
	      }
	    } else {
	      indentedInspectedArray = (function() {
	        var j, len, results;
	        results = [];
	        for (i = j = 0, len = inspectedValues.length; j < len; i = ++j) {
	          inspectedEl = inspectedValues[i];
	          results.push("- " + inspectedEl);
	        }
	        return results;
	      })();
	      return "" + (indentedInspectedArray.join("\n"));
	    }
	  } else if (isString(m)) {
	    if (m.length > 10 && m.match(/\n/) && !m.match(/\ (\n|$)/)) {
	      return ['"""', m.replace(/"""/, '""\\"'), '"""'].join('\n');
	    } else {
	      return escapeJavascriptString(m);
	    }
	  } else {
	    return inspect(m);
	  }
	};

	alignTabs = function(maxLineLength, linesString) {
	  var alignedLines, el, elements, i, j, l, len, len1, line, lines, maxColumnSizes, maxColumnWidth, numColumnsToPad, r, tabStops, totalPad;
	  tabStops = 1;
	  lines = linesString.split("\n");
	  numColumnsToPad = null;
	  maxColumnSizes = [];
	  maxColumnWidth = maxLineLength / 2;
	  for (j = 0, len = lines.length; j < len; j++) {
	    line = lines[j];
	    if (!((elements = line.split("\t")).length > 1)) {
	      continue;
	    }
	    if (numColumnsToPad == null) {
	      numColumnsToPad = elements.length - 1;
	    } else if (numColumnsToPad !== elements.length - 1) {
	      numColumnsToPad = 1;
	    }
	    for (i = l = 0, len1 = elements.length; l < len1; i = ++l) {
	      el = elements[i];
	      if (!(i < elements.length - 1 && (i === 0 || el.length < maxColumnWidth))) {
	        continue;
	      }
	      if (maxColumnSizes.length === i) {
	        maxColumnSizes.push(0);
	      }
	      maxColumnSizes[i] = max(maxColumnSizes[i], el.length + 1);
	    }
	  }
	  alignedLines = (function() {
	    var len2, n, results;
	    results = [];
	    for (n = 0, len2 = lines.length; n < len2; n++) {
	      line = lines[n];
	      elements = line.split("\t");
	      r = (function() {
	        var len3, o, results1;
	        if (elements.length > 1) {
	          totalPad = 0;
	          results1 = [];
	          for (i = o = 0, len3 = elements.length; o < len3; i = ++o) {
	            el = elements[i];
	            totalPad += maxColumnSizes[i] || 0;
	            if (maxColumnSizes[i]) {
	              results1.push(pad(el, maxColumnSizes[i]));
	            } else {
	              results1.push(el + " ");
	            }
	          }
	          return results1;
	        } else {
	          return elements;
	        }
	      })();
	      results.push(r.join(""));
	    }
	    return results;
	  })();
	  return alignedLines.join("\n");
	};

	alignTabStopsByBlocks = function(maxLineLength, linesString) {
	  return alignTabs(maxLineLength, linesString);
	};

	module.exports = FormattedInspect = (function() {
	  function FormattedInspect() {}

	  FormattedInspect.formattedInspect = function(m, options) {
	    if (options == null) {
	      options = {};
	    }
	    if (isNumber(options)) {
	      options = {
	        maxLineLength: options
	      };
	    }
	    if (options.maxLineLength == null) {
	      options.maxLineLength = 80;
	    }
	    return stripTrailingWhitespace(alignTabStopsByBlocks(options.maxLineLength, formattedInspectRecursive(toInspectedObjects(m), options)));
	  };

	  return FormattedInspect;

	})();


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var InspectedObjects, deepMap, escapeJavascriptString, inspectedObjectLiteral, isFunction, isPlainArray, isPlainObject, isPromise, isString, ref;

	ref = __webpack_require__(31), deepMap = ref.deepMap, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject, isString = ref.isString, isFunction = ref.isFunction, isPromise = ref.isPromise;

	escapeJavascriptString = __webpack_require__(44).escapeJavascriptString;

	inspectedObjectLiteral = __webpack_require__(56).inspectedObjectLiteral;

	module.exports = InspectedObjects = (function() {
	  var toInspectedObjects;

	  function InspectedObjects() {}

	  InspectedObjects.toInspectedObjects = toInspectedObjects = function(m) {
	    var functionString, oldm, out, reducedFunctionString;
	    if (m == null) {
	      return m;
	    }
	    oldm = m;
	    if (m === global) {
	      return inspectedObjectLiteral("global");
	    } else if (out = typeof m.getInspectedObjects === "function" ? m.getInspectedObjects() : void 0) {
	      return out;
	    } else if (isPromise(m)) {
	      return inspectedObjectLiteral("Promise");
	    } else if (isPlainObject(m) || isPlainArray(m)) {
	      return deepMap(m, function(v) {
	        return toInspectedObjects(v);
	      });
	    } else if (m instanceof Error) {
	      return inspectedObjectLiteral(m.stack || m.toString(), true);
	    } else if (isFunction(m)) {
	      functionString = "" + m;
	      reducedFunctionString = functionString.replace(/\s+/g, ' ').replace(/^function (\([^)]*\))/, "$1 ->").replace(/^\(\)\s*/, '');
	      return inspectedObjectLiteral(reducedFunctionString.length < 80 ? reducedFunctionString : functionString.slice(0, 5 * 80));
	    } else {
	      return m;
	    }
	  };

	  return InspectedObjects;

	})();

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var InspectedObjectLiteral, compare;

	compare = __webpack_require__(36).compare;

	module.exports = InspectedObjectLiteral = (function() {
	  InspectedObjectLiteral.inspectedObjectLiteral = function(literal, isError) {
	    return new InspectedObjectLiteral(literal, isError);
	  };

	  function InspectedObjectLiteral(literal1, isError1) {
	    this.literal = literal1;
	    this.isError = isError1;
	  }

	  InspectedObjectLiteral.prototype.getInspectedObjects = function() {
	    return this;
	  };

	  InspectedObjectLiteral.prototype.inspect = function() {
	    return this.literal;
	  };

	  InspectedObjectLiteral.prototype.compare = function(b) {
	    return compare(this.literal, b.literal);
	  };

	  return InspectedObjectLiteral;

	})();


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var PlainObjects, deepMap, inspectedObjectLiteral, isFunction, isPlainArray, isPlainObject, ref;

	ref = __webpack_require__(31), deepMap = ref.deepMap, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject, isFunction = ref.isFunction;

	inspectedObjectLiteral = __webpack_require__(56).inspectedObjectLiteral;

	module.exports = PlainObjects = (function() {
	  var toPlainObjects;

	  function PlainObjects() {}

	  PlainObjects.toPlainObjects = toPlainObjects = function(m) {
	    var functionString, oldm, out, reducedFunctionString;
	    if (m == null) {
	      return m;
	    }
	    oldm = m;
	    if (out = typeof m.getPlainObjects === "function" ? m.getPlainObjects() : void 0) {
	      return out;
	    } else if (isPlainObject(m) || isPlainArray(m)) {
	      return deepMap(m, function(v) {
	        return toPlainObjects(v);
	      });
	    } else if (isFunction(m)) {
	      functionString = "" + m;
	      reducedFunctionString = functionString.replace(/\s+/g, ' ').replace(/^function (\([^)]*\))/, "$1 ->").replace(/^\(\)\s*/, '');
	      return inspectedObjectLiteral(reducedFunctionString.length < 80 ? reducedFunctionString : functionString.slice(0, 5 * 80));
	    } else {
	      return m;
	    }
	  };

	  return PlainObjects;

	})();


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var Inspected, Inspector2, Map, MinimalBaseObject, escapeJavascriptString, isArray, isBrowserObject, isClass, isDate, isFunction, isHTMLImageElement, isObject, isPlainObject, isRegExp, isString, objectName, parentString, ref,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	MinimalBaseObject = __webpack_require__(53);

	Map = __webpack_require__(51);

	Inspected = __webpack_require__(59);

	escapeJavascriptString = __webpack_require__(44).escapeJavascriptString;

	ref = __webpack_require__(31), isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, isObject = ref.isObject, isPlainObject = ref.isPlainObject, isClass = ref.isClass, isDate = ref.isDate, isRegExp = ref.isRegExp, objectName = ref.objectName, isBrowserObject = ref.isBrowserObject;

	isHTMLImageElement = self.HTMLImageElement ? function(obj) {
	  return obj instanceof HTMLImageElement;
	} : function() {
	  return false;
	};

	parentString = (function(_this) {
	  return function(distance) {
	    switch (distance) {
	      case 0:
	        return "parent";
	      case 1:
	        return "grandparent";
	      case 2:
	        return "great grandparent";
	      default:
	        return "great^" + (distance - 1) + " grandparent";
	    }
	  };
	})(this);

	module.exports = Inspector2 = (function(superClass) {
	  extend(Inspector2, superClass);

	  function Inspector2(options) {
	    if (options == null) {
	      options = {};
	    }
	    this.inspectObject = bind(this.inspectObject, this);
	    this.inspectWithToImage = bind(this.inspectWithToImage, this);
	    this.inspectHTMLImageElement = bind(this.inspectHTMLImageElement, this);
	    this.inspectArray = bind(this.inspectArray, this);
	    this.withImages = options.withImages;
	    this.maxLength = options.maxLength || 1000;
	    this.allowCustomInspectors = !options.noCustomInspectors;
	    this.maxDepth = options.maxDepth != null ? options.maxDepth : 10;
	    this.outArray = [];
	    this.length = 0;
	    this.depth = 0;
	    this.inspectingMap = new Map;
	  }

	  Inspector2.prototype.inspectArray = function(array) {
	    var a;
	    return new Inspected.Array((function() {
	      var i, len, results;
	      results = [];
	      for (i = 0, len = array.length; i < len; i++) {
	        a = array[i];
	        results.push(this.inspectInternal(a));
	      }
	      return results;
	    }).call(this));
	  };

	  Inspector2.prototype.inspectHTMLImageElement = function(obj) {
	    var res;
	    res = new Inspected.Object({}, "HTMLImageElement", obj);
	    if (!(res.image = obj).complete) {
	      this.addPendingTask();
	      obj.onload = (function(_this) {
	        return function() {
	          return _this.completePendingTask();
	        };
	      })(this);
	    }
	    return res;
	  };

	  Inspector2.prototype.inspectWithToImage = function(obj) {
	    var name, res;
	    name = objectName(obj);
	    if (typeof obj.classPathName === "string") {
	      name = obj.classPathName;
	    }
	    if (name === "Object") {
	      name = null;
	    }
	    res = new Inspected.Object({}, name, obj);
	    this.addPendingTask();
	    obj.toImage().then((function(_this) {
	      return function(image) {
	        res.image = image;
	        return _this.completePendingTask();
	      };
	    })(this));
	    return res;
	  };

	  Inspector2.prototype.inspectObject = function(obj, recurse) {
	    var attributes, i, k, keys, len, name, res, result;
	    if (recurse == null) {
	      recurse = true;
	    }
	    attributes = [];
	    keys = Object.keys(obj);
	    name = objectName(obj);
	    if (isFunction(obj) && keys.length === 0) {
	      return new Inspected.Core(name + "()");
	    } else {
	      if (typeof obj.classPathName === "string") {
	        name = obj.classPathName;
	      }
	      if (name === "Object") {
	        name = null;
	      }
	      result = {};
	      if (recurse) {
	        for (i = 0, len = keys.length; i < len; i++) {
	          k = keys[i];
	          result[k] = this.inspectInternal(obj[k]);
	        }
	      }
	      res = new Inspected.Object(result, name, obj);
	      if (isFunction(obj.inspect)) {
	        res.inspected = obj.inspect();
	      }
	      return res;
	    }
	  };

	  Inspector2.prototype.addPendingTask = function() {
	    return this.pendingTasks++;
	  };

	  Inspector2.prototype.completePendingTask = function() {
	    this.pendingTasks--;
	    if (this.pendingTasks === 0) {
	      return this.completionCallBack();
	    }
	  };

	  Inspector2.prototype.inspectByType = function(obj) {
	    if (isFunction(obj != null ? obj.getInspectedObjects : void 0)) {
	      obj = obj.getInspectedObjects();
	    }
	    if (obj === null || obj === void 0 || obj === true || obj === false || typeof obj === "number") {
	      return new Inspected.Core(obj);
	    } else if (obj === self) {
	      return new Inspected.Core("self");
	    } else if (isRegExp(obj)) {
	      return new Inspected.Core(obj.toString());
	    } else if (isString(obj)) {
	      return new Inspected.String(obj);
	    } else if (isArray(obj)) {
	      return this.inspectArray(obj);
	    } else if (isClass(obj)) {
	      return new Inspected.Core(objectName(obj));
	    } else if (isHTMLImageElement(obj)) {
	      return this.inspectHTMLImageElement(obj);
	    } else if (isDate(obj)) {
	      return new Inspected.Core(obj.toString());
	    } else if (isBrowserObject(obj)) {
	      return new Inspected.Core(objectName(obj));
	    } else if (this.withImages && typeof obj.toImage === "function" && !isFunction(obj)) {
	      return this.inspectWithToImage(obj);
	    } else if (isPlainObject(obj) || isFunction(obj)) {
	      return this.inspectObject(obj);
	    } else if (isObject(obj)) {
	      return this.inspectObject(obj, false);
	    } else {
	      return new Inspected.Core(objectName(obj));
	    }
	  };

	  Inspector2.prototype.inspectInternal = function(obj) {
	    var objDepth, res;
	    if (objDepth = this.inspectingMap.get(obj)) {
	      return new Inspected.Core("<" + (parentString(this.depth - objDepth)) + ">");
	    } else if (this.depth >= this.maxDepth) {
	      return new Inspected.Core("<maxDepth reached: " + this.maxDepth + ">");
	    } else {
	      this.depth++;
	      this.inspectingMap.set(obj, this.depth);
	      res = this.inspectByType(obj);
	      this.inspectingMap["delete"](obj);
	      this.depth--;
	      return res;
	    }
	  };

	  Inspector2.prototype.inspect = function(obj, callBack) {
	    var res;
	    this.pendingTasks = 0;
	    if (this.withImages && typeof callBack !== "function") {
	      throw new Error("callBack required if withImages requested");
	    }
	    this.completionCallBack = (function(_this) {
	      return function() {
	        return callBack && callBack(res);
	      };
	    })(this);
	    res = this.inspectInternal(obj);
	    if (this.pendingTasks === 0) {
	      this.completionCallBack();
	    }
	    return res;
	  };

	  return Inspector2;

	})(MinimalBaseObject);


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(60).addModules({
	  Array: __webpack_require__(61),
	  Core: __webpack_require__(62),
	  Object: __webpack_require__(63),
	  String: __webpack_require__(64)
	});


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	var Inspect, Inspected,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Inspect = __webpack_require__(48);

	module.exports = Inspect.Inspected || Inspect.addNamespace('Inspected', Inspected = (function(superClass) {
	  extend(Inspected, superClass);

	  function Inspected() {
	    return Inspected.__super__.constructor.apply(this, arguments);
	  }

	  return Inspected;

	})(Neptune.Base));


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var Array, MinimalBaseObject,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	MinimalBaseObject = __webpack_require__(53);

	module.exports = Array = (function(superClass) {
	  extend(Array, superClass);

	  function Array(inspectedArray) {
	    Array.__super__.constructor.apply(this, arguments);
	    this.array = inspectedArray;
	  }

	  Array.getter({
	    arrayOfStrings: function() {
	      var i, len, ref, results, v;
	      ref = this.array;
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        v = ref[i];
	        results.push(v.toString());
	      }
	      return results;
	    },
	    children: function() {
	      return this.array.slice();
	    }
	  });

	  Array.prototype.delimitedString = function(delimiter) {
	    if (delimiter == null) {
	      delimiter = ", ";
	    }
	    return this.arrayOfStrings.join(", ");
	  };

	  Array.prototype.toString = function() {
	    return "[" + (this.delimitedString()) + "]";
	  };

	  return Array;

	})(MinimalBaseObject);


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var Core, MinimalBaseObject,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	MinimalBaseObject = __webpack_require__(53);

	module.exports = Core = (function(superClass) {
	  extend(Core, superClass);

	  function Core(value) {
	    Core.__super__.constructor.apply(this, arguments);
	    this.value = value;
	    if (value && value.constructor.name === "HTMLImageElement") {
	      this.image = value;
	    }
	  }

	  Core.getter({
	    children: function() {
	      return null;
	    }
	  });

	  Core.prototype.toString = function() {
	    return "" + this.value;
	  };

	  return Core;

	})(MinimalBaseObject);


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var MinimalBaseObject, Object,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	MinimalBaseObject = __webpack_require__(53);

	module.exports = Object = (function(superClass) {
	  extend(Object, superClass);

	  function Object(properties, instanceOf, originalObject) {
	    this.properties = properties;
	    this.instanceOf = instanceOf;
	    this.originalObject = originalObject;
	    Object.__super__.constructor.apply(this, arguments);
	    this.length = this.properties ? self.Object.keys(this.properties).length : 0;
	  }

	  Object.getter({
	    arrayOfStrings: function() {
	      var k, ref, results, v;
	      ref = this.properties;
	      results = [];
	      for (k in ref) {
	        v = ref[k];
	        results.push(k + ": " + v);
	      }
	      return results;
	    },
	    children: function() {
	      var k, ref, ret, v;
	      ret = {};
	      ref = this.properties;
	      for (k in ref) {
	        v = ref[k];
	        ret[k] = v;
	      }
	      return ret;
	    }
	  });

	  Object.prototype.delimitedString = function(delimiter) {
	    if (delimiter == null) {
	      delimiter = ", ";
	    }
	    return this.arrayOfStrings.join(", ");
	  };

	  Object.prototype.toString = function() {
	    if (this.inspected) {
	      return this.inspected;
	    } else if (this.instanceOf) {
	      return "{" + this.instanceOf + " " + (this.delimitedString()) + "}";
	    } else {
	      return "{" + (this.delimitedString()) + "}";
	    }
	  };

	  return Object;

	})(MinimalBaseObject);


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	var MinimalBaseObject, String, escapeJavascriptString,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	MinimalBaseObject = __webpack_require__(53);

	escapeJavascriptString = __webpack_require__(44).escapeJavascriptString;

	module.exports = String = (function(superClass) {
	  extend(String, superClass);

	  function String(clonedString) {
	    String.__super__.constructor.apply(this, arguments);
	    this.string = clonedString;
	  }

	  String.prototype.toString = function() {
	    return escapeJavascriptString(this.string);
	  };

	  return String;

	})(MinimalBaseObject);


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	This current iteration of clone relies on some singleton variables shared across all invocations of clone.
	This is fine as long as javascript stays single-threaded.
	It also introduces a little bit of uglyness initializing clonedMap necessitating the "top" variable.

	FUTURE
	A potentially better solution would be to create a new closer each time clone is called at the top-most level,
	but when recursing, pass in a new function bound to that closure which is different from the global clone function.

	populateClone would need to take an additional argument - the clone function to use for recursive cloning.
	 */
	var Clone, Foundation, Map, Unique, byProperties, byStructure, clonedMap, inspect, topObject, uniquePropertyName;

	Foundation = __webpack_require__(25);

	Map = __webpack_require__(51);

	Unique = __webpack_require__(52);

	inspect = __webpack_require__(47).inspect;

	uniquePropertyName = Unique.PropertyName;

	clonedMap = null;

	byStructure = false;

	byProperties = false;

	topObject = null;

	module.exports = Clone = (function() {
	  var clone, cloneArray, cloneByProperties, cloneByStructure, cloneObject, emptyClone;

	  function Clone() {}

	  cloneArray = function(array) {
	    var clonedArray, i, index, len, value;
	    clonedArray = clonedMap.set(array, array.slice());
	    for (index = i = 0, len = clonedArray.length; i < len; index = ++i) {
	      value = clonedArray[index];
	      clonedArray[index] = clone(value);
	    }
	    return clonedArray;
	  };

	  cloneObject = function(obj) {
	    var clonedObject, k, v;
	    clonedObject = clonedMap.set(obj, emptyClone(obj));
	    if ((obj !== topObject || !byProperties) && obj.populateClone) {
	      obj.populateClone(clonedObject);
	    } else {
	      for (k in obj) {
	        v = obj[k];
	        clonedObject[k] = clone(v);
	      }
	    }
	    return clonedObject;
	  };

	  Clone.emptyClone = emptyClone = function(obj) {
	    if (obj.constructor === Array) {
	      return [];
	    } else {
	      return Object.create(Object.getPrototypeOf(obj));
	    }
	  };

	  Clone.clone = clone = function(obj, mode) {
	    var clonedObject, got;
	    switch (mode) {
	      case "byStructure":
	        byStructure = true;
	        break;
	      case "byProperties":
	        byProperties = true;
	    }
	    if (obj === null || obj === void 0 || typeof obj !== "object") {
	      return obj;
	    }
	    if (byStructure && (obj.constructor !== Array && obj.constructor !== Object)) {
	      return obj;
	    }
	    if (clonedMap) {
	      if (got = clonedMap.get(obj)) {
	        return got;
	      }
	    } else {
	      topObject = obj;
	      clonedMap = new Map;
	    }
	    clonedObject = obj.constructor === Array ? cloneArray(obj) : cloneObject(obj);
	    if (topObject === obj) {
	      byStructure = false;
	      byProperties = false;
	      topObject = null;
	      clonedMap = null;
	    }
	    return clonedObject;
	  };

	  Clone.cloneByProperties = cloneByProperties = function(obj) {
	    return clone(obj, "byProperties");
	  };

	  Clone.cloneByStructure = cloneByStructure = function(obj) {
	    return clone(obj, "byStructure");
	  };

	  return Clone;

	})();


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var Inspect, Log, callStack, isString, peek,
	  slice = [].slice;

	Inspect = __webpack_require__(48);

	callStack = __webpack_require__(67).callStack;

	isString = __webpack_require__(31).isString;

	peek = __webpack_require__(32).peek;

	module.exports = Log = (function() {
	  var noOptions;

	  function Log() {}

	  Log.contextString = function(stack, defaultContext) {
	    var caller, context;
	    if (stack && (caller = stack[1])) {
	      if (caller.original) {
	        return caller.original;
	      } else {
	        context = caller["function"] ? caller["class"] ? caller["class"] + "::" + caller["function"] + "()" : caller["function"] + "()" : defaultContext ? defaultContext + ":" : "";
	        if (caller.sourceFileName) {
	          return "at " + caller.sourceFileName + ("-" + caller.sourceLine + ": ") + context;
	        }
	      }
	    } else {
	      return "at " + (defaultContext || "(unknown context)");
	    }
	  };

	  Log.autoSizedIndepect = function(toInspect, maxLength, maxDepth) {
	    var depth, inspected;
	    if (maxLength == null) {
	      maxLength = 512;
	    }
	    if (maxDepth == null) {
	      maxDepth = 10;
	    }
	    inspected = null;
	    depth = maxDepth;
	    while ((inspected = Inspect.inspectLean(toInspect, {
	        maxDepth: depth,
	        maxLength: maxLength
	      })).match(/\.\.\.$/)) {
	      depth--;
	    }
	    return inspected;
	  };

	  Log.loggedParamsString = function(params) {
	    if (typeof params === "string") {
	      return params;
	    } else {
	      return Log.autoSizedIndepect(params);
	    }
	  };

	  Log.hideLogging = function() {
	    return Log.loggingHidden = true;
	  };

	  Log.showLogging = function() {
	    return Log.loggingHidden = false;
	  };

	  Log.rawLog = function() {
	    if (!Log.loggingHidden) {
	      return console.log.apply(console, arguments);
	    }
	  };

	  Log.rawErrorLog = function() {
	    if (!Log.loggingHidden) {
	      return console.error.apply(console, arguments);
	    }
	  };

	  noOptions = {};

	  Log.logCore = function(m, stack, options) {
	    var className, isError, logger;
	    if (options == null) {
	      options = noOptions;
	    }
	    className = options.className, isError = options.isError;
	    if (Log.alternativeLogger) {
	      Log.alternativeLogger.logCore(m, stack, options);
	    }
	    logger = isError ? Log.rawErrorLog : Log.rawLog;
	    if (Neptune.isNode) {
	      return logger(isString(m) ? m : Inspect.formattedInspect(m));
	    } else {
	      return logger(m, "\n# Foundation.log called " + Log.contextString(stack, className));
	    }
	  };

	  Log.log = function() {
	    var args, m, stack;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    m = args.length === 1 ? args[0] : args;
	    stack = callStack();
	    Log.logCore(m, stack);
	    return peek(args);
	  };


	  /*
	  
	  IN:
	    labelString, value
	    OR object with one or more properties (usually just one)
	      returns the last value of the objects last key-value pair
	  
	  EX:
	    log.withLabel foo: myObject
	     * out: myObject
	  
	    log.withLabel "foo", myObject
	     * out: myObject
	   */

	  Log.log.withLabel = function(a, b) {
	    var k, obj, ret, v;
	    if (isString(a)) {
	      obj = {};
	      obj[a] = b;
	      Log.log(obj);
	      return b;
	    } else {
	      ret = null;
	      for (k in a) {
	        v = a[k];
	        ret = v;
	      }
	      Log.log(obj);
	      return ret;
	    }
	  };

	  Log.log.labeled = Log.log.withLabel;

	  Log.log.error = function() {
	    var args, m, stack;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    m = args.length === 1 ? args[0] : args;
	    stack = callStack();
	    Log.logCore(m, stack, {
	      isError: true
	    });
	    return peek(args);
	  };

	  Log.logL = function(obj) {
	    var k, ret, v;
	    console.warn("DEPRICATED: logL. USE log.labeled");
	    ret = null;
	    for (k in obj) {
	      v = obj[k];
	      ret = v;
	    }
	    Log.log(obj);
	    return ret;
	  };

	  return Log;

	})();


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var CallStack, inspect, isString, parseUrl;

	isString = __webpack_require__(31).isString;

	parseUrl = __webpack_require__(40).parseUrl;

	inspect = __webpack_require__(47).inspect;

	module.exports = CallStack = (function() {
	  var CallStackLine;

	  function CallStack() {}

	  CallStack.errorToString = function(error) {
	    return (error != null ? error.error : void 0) || (error != null ? error.message : void 0) || (isString(error) && error) || Neptune.Art.Foundation.formattedInspect(error);
	  };

	  CallStack.CallStackLine = CallStackLine = (function() {
	    CallStackLine.getter = function(map) {
	      var getter, prop, results;
	      results = [];
	      for (prop in map) {
	        getter = map[prop];
	        results.push(Object.defineProperty(this.prototype, prop, {
	          get: getter,
	          configurable: true
	        }));
	      }
	      return results;
	    };

	    CallStackLine.setter = function(map) {
	      var prop, results, setter;
	      results = [];
	      for (prop in map) {
	        setter = map[prop];
	        results.push(Object.defineProperty(this.prototype, prop, {
	          set: setter,
	          configurable: true
	        }));
	      }
	      return results;
	    };

	    function CallStackLine(line) {
	      this.original = line;
	      this["function"] = null;
	      this.source = null;
	      this["class"] = null;
	      this.classPath = null;
	      this.sourceFileName = null;
	      this.sourcePath = null;
	      this.sourceHostWithPort = null;
	      this.sourceLine = 0;
	      this.sourceColumn = 0;
	      if (this.parseLineWithFunction(line)) {

	      } else {
	        this.parseLineWithoutFunction(line);
	      }
	      this.subParseFunction();
	      this.subParseSource();
	    }

	    CallStackLine.prototype.toString = function() {
	      return this.original;
	    };

	    CallStackLine.getter({
	      fileWithLocation: function() {
	        return this._fileWithLocation || (this._fileWithLocation = this.sourceFileName ? this.sourcePath + "/" + this.sourceFileName + ":" + this.sourceLine + ":" + this.sourceColumn : this.original);
	      }
	    });

	    CallStackLine.prototype.parseLineWithFunction = function(line) {
	      var r;
	      if (r = line.match(/\s*at\s((new\s)?[a-zA-Z0-9_.<>]+)\s\(([^)]*):([0-9]+):([0-9]+)\)/)) {
	        this["function"] = r[1];
	        this.source = r[3];
	        this.sourceLine = r[4] | 0;
	        return this.sourceColumn = r[5] | 0;
	      }
	    };

	    CallStackLine.prototype.parseLineWithoutFunction = function(line) {
	      var r;
	      if (r = line.match(/\s*at\s([^)]*):([0-9]+):([0-9]+)/)) {
	        this.source = r[1];
	        this.sourceLine = r[2] | 0;
	        return this.sourceColumn = r[3] | 0;
	      }
	    };

	    CallStackLine.prototype.subParseSource = function() {
	      var url;
	      if (this.source) {
	        url = parseUrl(this.source);
	        this.sourceFileName = url.fileName;
	        this.sourcePath = url.path;
	        return this.sourceHostWithPort = url.hostWithPort;
	      }
	    };

	    CallStackLine.prototype.subParseFunction = function() {
	      var f;
	      if (this["function"]) {
	        f = this["function"].split(".");
	        this["function"] = f[f.length - 1];
	        if (this["function"] === "<anonymous>") {
	          this["function"] = void 0;
	        }
	        this["class"] = f[f.length - 2];
	        return this.classPath = f.slice(0, f.length - 2);
	      }
	    };

	    return CallStackLine;

	  })();

	  CallStack.rawCallStack = (new Error).stack ? function(ignoreTop) {
	    if (ignoreTop == null) {
	      ignoreTop = 0;
	    }
	    return (new Error).stack.split(/\n  */).slice(ignoreTop + 2);
	  } : function(ignoreTop) {
	    var e;
	    if (ignoreTop == null) {
	      ignoreTop = 0;
	    }
	    try {
	      throw new Error;
	    } catch (error1) {
	      e = error1;
	      return e.stack.split(/\n  */).slice(ignoreTop + 2);
	    }
	  };

	  CallStack.callStack = function(ignoreTop) {
	    var i, len, line, ref, results;
	    if (ignoreTop == null) {
	      ignoreTop = 0;
	    }
	    ref = CallStack.rawCallStack(ignoreTop + 1);
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      line = ref[i];
	      results.push(new CallStackLine(line));
	    }
	    return results;
	  };

	  return CallStack;

	})();


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(69).includeInNamespace(__webpack_require__(70)).addModules({
	  BinaryString: __webpack_require__(73),
	  DataUri: __webpack_require__(81),
	  EncodedImage: __webpack_require__(82),
	  File: __webpack_require__(72),
	  Stream: __webpack_require__(80),
	  TypedarraySlicePolyfill: __webpack_require__(71),
	  Utf8: __webpack_require__(74),
	  WriteStream: __webpack_require__(83)
	});


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	var Binary, Foundation,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(21);

	module.exports = Foundation.Binary || Foundation.addNamespace('Binary', Binary = (function(superClass) {
	  extend(Binary, superClass);

	  function Binary() {
	    return Binary.__super__.constructor.apply(this, arguments);
	  }

	  return Binary;

	})(Neptune.Base));


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(71);

	module.exports = [
	  __webpack_require__(72), {
	    stream: (__webpack_require__(80)).stream
	  }, [__webpack_require__(73), "binary binaryFromBlob"]
	];


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var base, base1, base10, base11, base2, base3, base4, base5, base6, base7, base8, base9, bound, genericSlice, ref, ref1;

	bound = __webpack_require__(24).bound;

	(base = Uint8Array.prototype).slice || (base.slice = genericSlice = function(start, end) {
	  var i, j, length, out, outIndex, ref, ref1;
	  if (end == null) {
	    end = this.length;
	  }
	  if (start < 0) {
	    start += this.length;
	  }
	  if (end < 0) {
	    end += this.length;
	  }
	  start = bound(0, start, this.length);
	  end = bound(0, end, this.length);
	  out = new Uint8Array(length = end - start);
	  outIndex = 0;
	  for (i = j = ref = start, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
	    out[outIndex++] = this[i];
	  }
	  return out;
	});

	(base1 = Int8Array.prototype).slice || (base1.slice = genericSlice);

	(base2 = Uint8Array.prototype).slice || (base2.slice = genericSlice);

	(base3 = Int16Array.prototype).slice || (base3.slice = genericSlice);

	(base4 = Uint16Array.prototype).slice || (base4.slice = genericSlice);

	(base5 = Int32Array.prototype).slice || (base5.slice = genericSlice);

	(base6 = Uint32Array.prototype).slice || (base6.slice = genericSlice);

	(base7 = Float32Array.prototype).slice || (base7.slice = genericSlice);

	(base8 = Float64Array.prototype).slice || (base8.slice = genericSlice);

	if ((ref = self.Uint8ClampedArray) != null) {
	  (base9 = ref.prototype).slice || (base9.slice = genericSlice);
	}

	if ((ref1 = self.CanvasPixelArray) != null) {
	  (base10 = ref1.prototype).slice || (base10.slice = genericSlice);
	}

	(base11 = ArrayBuffer.prototype).slice || (base11.slice = function(start, end) {
	  return (new Uint8Array(this)).slice(start, end).buffer;
	});


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var BinaryString, File, Promise, StandardLib;

	StandardLib = __webpack_require__(24);

	Promise = StandardLib.Promise;

	BinaryString = __webpack_require__(73);

	module.exports = File = (function() {
	  var readAsArrayBuffer;

	  function File() {}

	  File._readWithPromise = function(readFunction) {
	    return function(file) {
	      return new Promise(function(resolve, reject) {
	        var fr;
	        fr = new FileReader;
	        fr[readFunction](file);
	        fr.onerror = reject;
	        return fr.onload = (function(_this) {
	          return function(event) {
	            return resolve(event.target.result);
	          };
	        })(this);
	      });
	    };
	  };

	  File.readAsArrayBuffer = readAsArrayBuffer = File._readWithPromise("readAsArrayBuffer");

	  File.readAsDataURL = File._readWithPromise("readAsDataURL");

	  File.readAsBinaryString = function(file) {
	    return readAsArrayBuffer(file).then(function(arrayBuffer) {
	      return new BinaryString(arrayBuffer);
	    });
	  };

	  return File;

	})();


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Binary, BinaryString, ClassSystem, StandardLib, Utf8, compactFlatten, encodings, inspect, isFunction, isPlainArray, isString, log, min, pad, readFileAsArrayBuffer, readFileAsDataUrl,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Binary = __webpack_require__(69);

	Utf8 = __webpack_require__(74);

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	isString = StandardLib.isString, isFunction = StandardLib.isFunction, isPlainArray = StandardLib.isPlainArray, log = StandardLib.log, min = StandardLib.min, inspect = StandardLib.inspect, readFileAsDataUrl = StandardLib.readFileAsDataUrl, readFileAsArrayBuffer = StandardLib.readFileAsArrayBuffer, compactFlatten = StandardLib.compactFlatten, pad = StandardLib.pad;

	BaseObject = ClassSystem.BaseObject, inspect = ClassSystem.inspect;

	encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	module.exports = BinaryString = (function(superClass) {
	  var binary;

	  extend(BinaryString, superClass);

	  BinaryString.binary = binary = function(arg) {
	    if (arg instanceof BinaryString) {
	      return arg;
	    } else {
	      return new BinaryString(arg);
	    }
	  };

	  BinaryString.binaryFromBlob = function(blob) {
	    return readFileAsArrayBuffer(blob).then(function(ab) {
	      return binary(ab);
	    });
	  };

	  BinaryString.cloneUint8Array = function(srcU8A) {
	    var dstU8A;
	    dstU8A = new Uint8Array(new ArrayBuffer(src.length));
	    dstU8A.set(srcU8A);
	    return dstU8A;
	  };

	  function BinaryString(arg) {
	    this.bytes = (function() {
	      if (arg instanceof BinaryString) {
	        return BinaryString.cloneUint8Array(arg.bytes);
	      } else if (isFunction(arg != null ? arg.uint8Array : void 0)) {
	        return arg.uint8Array();
	      } else if (isPlainArray(arg)) {
	        return new Uint8Array(arg);
	      } else if (arg instanceof ArrayBuffer) {
	        return new Uint8Array(arg);
	      } else if (arg instanceof Uint8Array) {
	        return arg;
	      } else if (isString(arg)) {
	        return Utf8.toBuffer(arg);
	      } else if (isFunction(arg.toString)) {
	        return Utf8.toBuffer(arg.toString());
	      } else {
	        throw new Error("invalid Binary string constructor argument: " + (inspect(arg)));
	      }
	    })();
	    this.length = this.bytes.length;
	  }

	  BinaryString.prototype.slice = function(a, b) {
	    return new BinaryString(this.bytes.slice(a, b));
	  };

	  BinaryString.fromBase64 = function(base64encoding) {
	    var byteString, i, j, len, ref, uint8Array;
	    byteString = atob(base64encoding);
	    len = byteString.length;
	    uint8Array = new Uint8Array(new ArrayBuffer(len));
	    for (i = j = 0, ref = len; j < ref; i = j += 1) {
	      uint8Array[i] = byteString.charCodeAt(i);
	    }
	    return new BinaryString(uint8Array);
	  };

	  BinaryString.prototype.toDataUri = function() {
	    return readFileAsDataUrl(new Blob([this.bytes]));
	  };

	  BinaryString.fromDataUri = function(dataURI) {
	    var base64encoding, splitDataURI;
	    splitDataURI = dataURI.split(',');
	    base64encoding = splitDataURI[1];
	    return this.fromBase64(base64encoding);
	  };

	  BinaryString.prototype.toString = function() {
	    return Utf8.toString(this.bytes);
	  };

	  BinaryString.prototype.toArrayBuffer = function() {
	    return this.bytes.buffer;
	  };

	  BinaryString.prototype.toBlob = function() {
	    return new Blob([this.bytes]);
	  };

	  BinaryString.prototype.eq = function(b) {
	    return this.compare(b) === 0;
	  };

	  BinaryString.prototype.compare = function(b) {
	    var bytesA, bytesB, diff, i, j, ref;
	    bytesA = this.bytes;
	    bytesB = b.bytes;
	    for (i = j = 0, ref = min(this.length, b.length); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      if (0 !== (diff = bytesA[i] - bytesB[i])) {
	        return diff;
	      }
	    }
	    return this.length - b.length;
	  };

	  BinaryString.prototype.inspect = function() {
	    return this.getInspectedString();
	  };

	  BinaryString.getter({
	    uint8Array: function() {
	      return this.bytes;
	    },
	    arrayBuffer: function() {
	      return this.bytes.buffer;
	    },
	    blob: function() {
	      return new Blob([this.bytes]);
	    },
	    plainArray: function() {
	      var b, j, len1, ref, results;
	      ref = this.bytes;
	      results = [];
	      for (j = 0, len1 = ref.length; j < len1; j++) {
	        b = ref[j];
	        results.push(b);
	      }
	      return results;
	    },
	    byteLength: function() {
	      return this.length;
	    },
	    inspectedString: function(stride, maxBytes) {
	      var characters, count, line, offset;
	      if (stride == null) {
	        stride = 8;
	      }
	      if (maxBytes == null) {
	        maxBytes = 64;
	      }
	      count = 0;
	      characters = [];
	      if (this.length < maxBytes) {
	        maxBytes = this.length;
	      }
	      line = new Array(stride);
	      return compactFlatten([
	        "BinaryString length: " + this.length + " bytes", maxBytes < this.length ? "First " + maxBytes + " bytes:" : void 0, (function() {
	          var j, ref, ref1, results;
	          results = [];
	          for (offset = j = 0, ref = maxBytes, ref1 = stride; ref1 > 0 ? j < ref : j > ref; offset = j += ref1) {
	            results.push(this._inspectLine(offset, stride, maxBytes));
	          }
	          return results;
	        }).call(this)
	      ]).join('\n');
	    }
	  });

	  BinaryString.prototype._inspectLine = function(offset, length, maxBytes) {
	    var b, characters, end, hexCharacters, i, y;
	    end = min(this.length, offset + length);
	    if (maxBytes >= 0) {
	      end = min(end, maxBytes);
	    }
	    characters = (function() {
	      var j, ref, ref1, results;
	      results = [];
	      for (i = j = ref = offset, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
	        b = this.bytes[i];
	        if (b >= 31 && b <= 127) {
	          results.push(String.fromCharCode(b));
	        } else {
	          results.push('');
	        }
	      }
	      return results;
	    }).call(this);
	    hexCharacters = (function() {
	      var j, ref, ref1, results;
	      results = [];
	      for (i = j = ref = offset, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
	        b = this.bytes[i];
	        y = b.toString(16);
	        if (y.length < 2) {
	          y = "0" + y;
	        }
	        results.push(y);
	      }
	      return results;
	    }).call(this);
	    return (pad(hexCharacters.join(' '), length * 3)) + " '" + (characters.join('')) + "'";
	  };


	  /*
	  toBase64 performance
	  see: http://localhost:8080/webpack-dev-server/perf?grep=BinaryString
	  as-of 2016-02-14, the manual string manipulation version is surprisingly the best on average for FF, Chrome and Safari
	    For shorter lengths, toBase64Custom is by far the fastest, but
	    toBase64ToDataUri starts to be faster at longer lengths.
	   */

	  BinaryString.prototype.toBase64 = function() {
	    if (this.length > 16 * 1024) {
	      return this.toBase64ToDataUri();
	    } else {
	      return this.toBase64Custom();
	    }
	  };

	  BinaryString.prototype.toBase64ToDataUri = function() {
	    return this.toDataUri().then(function(dataUri) {
	      return dataUri.split(',')[1];
	    });
	  };

	  BinaryString.prototype.toBase64Custom = function() {
	    var a, b, base64, byteLength, byteRemainder, bytes, c, chunk, d, i, j, mainLength, ref;
	    bytes = this.bytes;
	    base64 = '';
	    byteLength = bytes.byteLength;
	    byteRemainder = byteLength % 3;
	    mainLength = byteLength - byteRemainder;
	    for (i = j = 0, ref = mainLength - 1; j <= ref; i = j += 3) {
	      chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
	      a = (chunk & 16515072) >> 18;
	      b = (chunk & 258048) >> 12;
	      c = (chunk & 4032) >> 6;
	      d = chunk & 63;
	      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
	    }
	    return Promise.resolve((function() {
	      switch (byteRemainder) {
	        case 0:
	          return base64;
	        case 1:
	          chunk = bytes[mainLength];
	          a = (chunk & 252) >> 2;
	          b = (chunk & 3) << 4;
	          return base64 + encodings[a] + encodings[b] + '==';
	        case 2:
	          chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
	          a = (chunk & 64512) >> 10;
	          b = (chunk & 1008) >> 4;
	          c = (chunk & 15) << 2;
	          return base64 + encodings[a] + encodings[b] + encodings[c] + '=';
	      }
	    })());
	  };

	  return BinaryString;

	})(BaseObject);


/***/ },
/* 74 */
/***/ function(module, exports) {

	var Utf8;

	module.exports = Utf8 = (function() {
	  function Utf8() {}

	  Utf8.toBuffer = function(string) {
	    return new Uint8Array(this.toArray(string));
	  };

	  Utf8.toArray = function(string) {
	    var char, i, out, uriEncoded;
	    uriEncoded = encodeURIComponent(string);
	    i = 0;
	    out = (function() {
	      var results;
	      results = [];
	      while (i < uriEncoded.length) {
	        char = uriEncoded.charCodeAt(i++);
	        if (char === 0x25) {
	          i += 2;
	          results.push(parseInt(uriEncoded.substr(i - 2, 2), 16));
	        } else {
	          results.push(char);
	        }
	      }
	      return results;
	    })();
	    return out;
	  };

	  Utf8.toString = function(a) {
	    var error, x, y;
	    if (a === void 0) {
	      return "<undefined>";
	    }
	    if (a === null) {
	      return "<null>";
	    }
	    try {
	      if (a instanceof ArrayBuffer) {
	        a = new Uint8Array(a);
	      }
	      return decodeURIComponent(((function() {
	        var j, len, results;
	        results = [];
	        for (j = 0, len = a.length; j < len; j++) {
	          x = a[j];
	          y = x.toString(16);
	          if (y.length < 2) {
	            y = "0" + y;
	          }
	          y = "%" + y;
	          results.push(y);
	        }
	        return results;
	      })()).join(''));
	    } catch (error1) {
	      error = error1;
	      console.warn(error.toString(), error);
	      return "<" + a.length + " binary bytes>";
	    }
	  };

	  return Utf8;

	})();


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(76).includeInNamespace(__webpack_require__(77)).addModules({
	  BaseObject: __webpack_require__(78),
	  WebpackHotLoader: __webpack_require__(79)
	});


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	var ClassSystem, Foundation,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(21);

	module.exports = Foundation.ClassSystem || Foundation.addNamespace('ClassSystem', ClassSystem = (function(superClass) {
	  extend(ClassSystem, superClass);

	  function ClassSystem() {
	    return ClassSystem.__super__.constructor.apply(this, arguments);
	  }

	  return ClassSystem;

	})(Neptune.Base));


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [[__webpack_require__(78), "mixInto createAllClass createWithPostCreate createHotWithPostCreate"]];


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Log, MinimalBaseObject, StandardLib, Unique, WebpackHotLoader, callStack, capitalize, clone, concatInto, decapitalize, extendClone, functionName, getModuleBeingDefined, inspectedObjectLiteral, isFunction, isPlainArray, isPlainObject, isString, log, mergeInto, nextUniqueObjectId, objectName,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  slice = [].slice,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	StandardLib = __webpack_require__(24);

	WebpackHotLoader = __webpack_require__(79);

	capitalize = StandardLib.capitalize, decapitalize = StandardLib.decapitalize, log = StandardLib.log, extendClone = StandardLib.extendClone, clone = StandardLib.clone, isFunction = StandardLib.isFunction, objectName = StandardLib.objectName, isPlainObject = StandardLib.isPlainObject, functionName = StandardLib.functionName, isString = StandardLib.isString, isPlainArray = StandardLib.isPlainArray, Unique = StandardLib.Unique, callStack = StandardLib.callStack, Log = StandardLib.Log, inspectedObjectLiteral = StandardLib.inspectedObjectLiteral, MinimalBaseObject = StandardLib.MinimalBaseObject, getModuleBeingDefined = StandardLib.getModuleBeingDefined, concatInto = StandardLib.concatInto, mergeInto = StandardLib.mergeInto, isString = StandardLib.isString;

	nextUniqueObjectId = Unique.nextUniqueObjectId;

	module.exports = BaseObject = (function(superClass) {
	  var arrayPropertyExtender, createWithPostCreate, excludedKeys, getOwnProperty, imprintObject, mixInto, objectPropertyExtender, warnedAboutIncludeOnce;

	  extend(BaseObject, superClass);

	  BaseObject.objectsCreated = 0;

	  BaseObject.objectsCreatedByType = {};

	  BaseObject.resetStats = function() {
	    BaseObject.objectsCreated = 0;
	    return BaseObject.objectsCreatedByType = {};
	  };

	  BaseObject._name = null;


	  /*
	  NOTE: only hasOwnProperties are considered! Inherited properties are not touched.
	  IN:
	    toObject:   object will be altered to be an "imprint" of fromObject
	    fromObject: object pattern used to imprint toObject
	    preserveState:
	      false:
	        toObject has every property updated to exactly match fromObject
	  
	        This includes:
	          1. delete properties in toObject that are not in fromObject
	          2. add every property in fromObject but not in toObject
	          3. overwriting every property in toObject also in fromObject
	  
	      true:
	        Attempts to preserve the state of toObject while updating its functionality.
	        This means properties which are functions in either object are updated.
	  
	        WARNING: This is a grey area for JavaScript. It is not entirely clear what is
	          state and what is 'functionality'. I, SBD, have made the following heuristic decisions:
	  
	        Imprint actions taken when preserving State:
	  
	        1. DO NOTHING to properties in toObject that are not in fromObject
	        2. add every property in fromObject but not in toObject
	        3. properties in toObject that are also in fromObject are updated
	          if one of the following are true:
	          - isFunction fromObject[propName]
	          - isFunction toObject[propName]
	          - !toObject.hasOwnProperty propName
	          - propName does NOT start with "_"
	   */

	  BaseObject.imprintObject = imprintObject = function(toObject, fromObject, preserveState) {
	    var fromValue, k, v;
	    if (preserveState == null) {
	      preserveState = false;
	    }
	    if (!preserveState) {
	      for (k in toObject) {
	        v = toObject[k];
	        if (!fromObject.hasOwnProperty(k)) {
	          delete toObject[k];
	        }
	      }
	    }
	    for (k in fromObject) {
	      fromValue = fromObject[k];
	      if (fromObject.hasOwnProperty(k)) {
	        if (!preserveState || isFunction(fromValue) || isFunction(toObject[k]) || !k.match(/^_/) || !toObject.hasOwnProperty(k)) {
	          toObject[k] = fromValue;
	        }
	      }
	    }
	    return fromObject;
	  };


	  /*
	  imprints both the class and its prototype.
	  
	  preserved in spite of imprintObject's rules:
	    @namespace
	    @::constructor
	   */

	  BaseObject.imprintFromClass = function(updatedKlass) {
	    var _name, namespace, namespacePath, oldConstructor, ref;
	    if (updatedKlass !== this) {
	      ref = this, namespace = ref.namespace, namespacePath = ref.namespacePath, _name = ref._name;
	      oldConstructor = this.prototype.constructor;
	      imprintObject(this, updatedKlass, true);
	      imprintObject(this.prototype, updatedKlass.prototype, false);
	      this.prototype.constructor = oldConstructor;
	      this.namespace = namespace;
	      this.namespacePath = namespacePath;
	      this._name = _name;
	    }
	    return this;
	  };


	  /*
	  IN:
	    _module should be the CommonJS 'module'
	    klass: class object which extends BaseObject
	  
	  liveClass:
	    On the first load, liveClass gets set.
	    Each subsequent hot-load UPDATES liveClass,
	    but liveClass always points to the initially created class object.
	  
	  OUT: the result of the call to liveClass.postCreate()
	  
	  postCreate is passed:
	    hotReloaded:            # true if this is anything but the initial load
	    classModuleState:
	      liveClass:            # the original liveClass
	      hotUpdatedFromClass:  # the most recently hot-loaded class
	      hotReloadVersion:     # number starting at 0 and incremented with each hot reload
	    _module:                # the CommonJs module
	  
	  EFFECTS:
	    The following two methods are invoked on liveClass:
	  
	      if hot-reloading
	        liveClass.imprintFromClass klass
	  
	       * always:
	      liveClass.postCreate hotReloaded, classModuleState, _module
	   */

	  BaseObject.createWithPostCreate = createWithPostCreate = function(a, b) {
	    var _module, klass;
	    klass = b ? (_module = a, b) : a;
	    _module || (_module = getModuleBeingDefined());
	    if (!(klass != null ? klass.postCreate : void 0)) {
	      return klass;
	    }
	    if (!(_module != null ? _module.hot : void 0)) {
	      return klass.postCreate({
	        hotReloadEnabled: false,
	        hotReloaded: false,
	        classModuleState: {},
	        module: _module
	      }) || klass;
	    }
	    return WebpackHotLoader.runHot(_module, function(moduleState) {
	      var classModuleState, hotReloaded, liveClass;
	      if (classModuleState = moduleState[klass.getName()]) {
	        liveClass = classModuleState.liveClass;
	        hotReloaded = true;
	        classModuleState.hotReloadVersion++;
	        classModuleState.hotUpdatedFromClass = klass;
	        liveClass.namespace._setChildNamespaceProps(liveClass.getName(), klass);
	        klass._name = liveClass._name;
	        liveClass.imprintFromClass(klass);
	        Log.log({
	          "Foundation.BaseObject: class hot-reload": {
	            "class": liveClass.getNamespacePath(),
	            version: classModuleState.hotReloadVersion
	          }
	        });
	      } else {
	        hotReloaded = false;
	        klass._hotClassModuleState = moduleState[klass.getName()] = classModuleState = {
	          liveClass: liveClass = klass,
	          hotUpdatedFromClass: null,
	          hotReloadVersion: 0
	        };
	      }
	      return liveClass.postCreate({
	        hotReloadEnabled: true,
	        hotReloaded: hotReloaded,
	        classModuleState: classModuleState,
	        module: _module
	      });
	    });
	  };

	  BaseObject.createHotWithPostCreate = function(a, b) {
	    log.error("createHotWithPostCreate is DEPRICATED");
	    return createWithPostCreate(a, b);
	  };


	  /*
	  called every load
	  IN: options:
	    NOTE: hot-loading inputs are only set if this class created as follows:
	      createHotWithPostCreate module, class Foo extends BaseObject
	  
	    hotReload: true/false
	      true if this class was hot-reloaded
	  
	    hotReloadEnabled: true/false
	  
	    classModuleState:
	      liveClass:            the first-loaded version of the class.
	                            This is the official version of the class at all times.
	                            The hot-reloaded version of the class is "imprinted" onto the liveClass
	                            but otherwise is not used (but can be accessed via classModuleState.hotUpdatedFromClass)
	      hotUpdatedFromClass:  The most recently loaded version of the class.
	      hotReloadVersion:     number, starting at 1, and counting up each load
	  
	      classModuleState is a plain-object specific to the class and its CommonJS module. If there is
	      more than one hot-loaded class in the same module, each will have its own classModuleState.
	  
	      SBD NOTE: Though we could allow clients to add fields to classModuleState, I think it works
	      just as well, and is cleaner, if any state is stored in the actual class objects and
	      persisted via postCreate.
	  
	    module: the CommonJs module object.
	  
	  {hotReloadEnabled, hotReloaded, classModuleState, module} = options
	   */

	  BaseObject.postCreate = function(options) {
	    if (this.getIsAbstractClass()) {
	      return this.postCreateAbstractClass(options);
	    } else {
	      return this.postCreateConcreteClass(options);
	    }
	  };

	  BaseObject.postCreateAbstractClass = function(options) {
	    return this;
	  };

	  BaseObject.postCreateConcreteClass = function(options) {
	    return this;
	  };

	  excludedKeys = ["__super__", "namespace", "namespacePath"].concat(Object.keys(Neptune.Base));

	  BaseObject.mixInto = mixInto = function() {
	    var i, intoClass, k, keys, klass, len, v;
	    intoClass = arguments[0], klass = arguments[1], keys = 3 <= arguments.length ? slice.call(arguments, 2) : [];
	    log.error("DEPRICATED: mixInto");
	    if (keys.length === 0) {
	      keys = Object.keys(klass);
	    }
	    for (i = 0, len = keys.length; i < len; i++) {
	      k = keys[i];
	      if (!(indexOf.call(excludedKeys, k) < 0)) {
	        continue;
	      }
	      v = klass[k];
	      if (intoClass[k]) {
	        log.error("Foundation.mixInto - mix " + (getClassName(klass)) + " into " + (getClassName(intoClass)) + ": " + k + " already exists.");
	      }
	      intoClass[k] = v;
	    }
	    return intoClass;
	  };

	  BaseObject.createAllClass = function() {
	    var All, arg, args, i, len, namespace;
	    namespace = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    log.error("DEPRICATED: createAllClass. Use Neptune-Namespace feature: create file in directory that is the same name as the directory.");
	    for (i = 0, len = args.length; i < len; i++) {
	      arg = args[i];
	      if (arg.prototype instanceof BaseObject) {
	        log.error("createAllClass arguments cannot be subclasses of BaseObject: " + (getClassName(namespace)) + ":" + (getClassName(arg)));
	      }
	      mixInto(namespace, arg);
	    }
	    return All = (function(superClass1) {
	      extend(All, superClass1);

	      function All() {
	        return All.__super__.constructor.apply(this, arguments);
	      }

	      return All;

	    })(namespace);
	  };

	  function BaseObject() {
	    this.__uniqueId = null;
	  }

	  BaseObject.implementsInterface = function(object, methods) {
	    var i, len, method;
	    for (i = 0, len = methods.length; i < len; i++) {
	      method = methods[i];
	      if (typeof object[method] !== "function") {
	        return false;
	      }
	    }
	    return true;
	  };


	  /*
	  mix-in class methods
	  Define getters/setters example:
	    class MyMixin
	      included: ->
	        @getter foo: -> @_foo
	        @setter foo: (v) -> @_foo = v
	  
	  NOTE! This will NOT include any properties you defined with getter or setter!
	  NOTE! This only copies over values if there aren't already values in the included-into class
	    This somewhat mirrors Ruby's include where the included-into-class's methods take precidence.
	    However, if you include two modules in a row, the first module gets priority here.
	    In ruby the second module gets priority (I believe).
	  
	  DEPRICATED!!!
	  Time to do it "right" - and it's just a simple pattern:
	    Justin Fagnani figured this out. Thanks!
	    Read More:
	      http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/
	  
	  To define a mixin:
	  
	    MyMixin = (superClass) ->
	      class MyMixin extends superClass
	        ... write your mixin as-if it were part of the normal inheritance hierachy
	  
	  To use a mixin:
	  
	    class MyClass extends MyMixin MySuperClass
	  
	  To use two mixins:
	  
	    class MyClass extends MyMixin1 MyMixin2 MySuperClass
	   */

	  warnedAboutIncludeOnce = false;

	  BaseObject.include = function(obj) {
	    var key, ref, value;
	    log.error("DEPRICATED: BaseObject.include. Use pattern.");
	    if (!warnedAboutIncludeOnce) {
	      warnedAboutIncludeOnce = true;
	      console.warn("Mixin pattern:\n\n  To define a mixin:\n\n    MyMixin = (superClass) ->\n      class MyMixin extends superClass\n        ... write your mixin as-if it were part of the normal inheritance hierachy\n\n  To use a mixin:\n\n    class MyClass extends MyMixin MySuperClass\n\n  To use two mixins:\n\n    class MyClass extends MyMixin1 MyMixin2 MySuperClass");
	    }
	    for (key in obj) {
	      value = obj[key];
	      if (key !== 'included') {
	        if (!this[key]) {
	          this[key] = value;
	        }
	      }
	    }
	    ref = obj.prototype;
	    for (key in ref) {
	      value = ref[key];
	      if (key) {
	        if (!this.prototype[key]) {
	          this.prototype[key] = value;
	        }
	      }
	    }
	    if (typeof obj.included === "function") {
	      obj.included(this);
	    }
	    return this;
	  };


	  /*
	  Allows you to define properties on the prototype that inherit their data from
	  their super-classes prototype.
	  
	  By default, uses extendClone to init. extendClone has these semantics:
	    Object properties actually create a parallel inheritance structure such that
	      later-changes on the super-object are reflected in the inheriting object.
	      They ARE updated with later parent-changes
	    Array properties inherit the values in the super-class array at declaration time,
	      They ARE NOT updated with any later parent-changes!
	      If we ever need that functionality, we'll need to make a special Object-type
	      that extendClone recognizes that handles the logic of "ExtendableArray".
	   */

	  BaseObject.getPrototypePropertyExtendedByInheritance = function(propertyName, defaultStructure, _clone) {
	    if (_clone == null) {
	      _clone = extendClone;
	    }
	    log.error("DEPRICATED: getPrototypePropertyExtendedByInheritance. use extendableProperty");
	    return getOwnProperty(this.prototype, propertyName, function(object) {
	      return _clone(object[propertyName] || defaultStructure);
	    });
	  };


	  /*
	  IN
	    object: any object
	    property: string, property name
	    init:
	      (object) -> returning initial value for object
	      OR
	        initial value is computed by:
	        clone object[property] || init
	  
	  EFFECT:
	    if object.hasOwnProperty property, return its current value
	    otherwise, initialize and return it with init()
	   */

	  BaseObject.getOwnProperty = getOwnProperty = function(object, property, init) {
	    if (object.hasOwnProperty(property)) {
	      return object[property];
	    } else {
	      return object[property] = isFunction(init) ? init(object) : clone(object[property] || init);
	    }
	  };


	  /*
	  objectPropertyExtender
	  
	  IN: @ is set to the property-value to extend
	  
	  API 1:
	    IN: map
	    EFFECT: mergeInto propValue, map
	  
	  API 2:
	    IN: key, value
	    EFFECT: propValue[key] = valuee
	  
	  OUT: ignore
	   */

	  BaseObject.objectPropertyExtender = objectPropertyExtender = function(mapOrKey, value) {
	    if (isString(mapOrKey)) {
	      return this[mapOrKey] = value;
	    } else if (isPlainObject(mapOrKey)) {
	      return mergeInto(this, mapOrKey);
	    } else {
	      throw new Error("first value argument must be a plain object or string");
	    }
	  };


	  /*
	  arrayPropertyExtender
	  
	  IN: @ is set to the property-value to extend
	  
	  API 1:
	    IN: array
	    EFFECT: concatInto propValue, array
	  
	  API 2:
	    IN: value
	    EFFECT: propValue.push value
	  
	  NOTE: if you want to concat an array-as-a-value to the end of propValue, do this:
	    arrayPropertyExtender.call propValue, [arrayAsValue]
	  
	  OUT: ignore
	   */

	  BaseObject.arrayPropertyExtender = arrayPropertyExtender = function(arrayOrValue) {
	    if (isPlainArray(arrayOrValue)) {
	      return concatInto(this, arrayOrValue);
	    } else {
	      return this.push(arrayOrValue);
	    }
	  };


	  /*
	  Extendable Properties
	  
	  EXAMPLE:
	    class Foo extends BaseObject
	      @extendableProperty foo: {}
	  
	  Extendable properties work like inheritance:
	  
	    When any subclass or instance extends an extendable property, they
	    inherit a clone of the property from up the inheritance tree, and then
	    add their own extensions without effecting the parent copy.
	  
	    With Object property types, this can just be a parallel prototype chain.
	    (It isn't currently: if you modify a parent after extending it to a child,
	    the child won't get updates.)
	  
	    BUT, you can also have array or other types of extend-properties, which
	    JavaScript doesn't have any built-in mechanisms for inheriting.
	  
	  BASIC API:
	  @extendableProperty: (map, propertyExtender = defaultPropertyExtender) -> ...
	  
	  IN: map
	  IN: propertyExtender = (args...) ->
	    IN: @ is propValue
	    IN: 1 or more args
	    EFFECT: modifies propValue (passed as @), extending it, based on args...
	  
	  EFFECT: for each {foo: defaultValue} in map, extendableProperty:
	    defines standard getters:
	      @class.getFoo()
	      @prototype.getFoo()
	      @prototype.foo # getter
	      WARNING:
	        !!! Don't modify the object returned by a getter !!!
	  
	        Getters only return the current, most-extended property value. It may not be extended to the
	        current subclass or instance! Instead, call @extendFoo() if you wish to manually modify
	        the extended property.
	  
	    defines extender functions:
	      @class.extendFoo value      # extends the property on the PROTOTYPE object
	      @prototype.extendFoo value  # extends the property on the INSTANCE object (which inherits from the prototype)
	  
	      EFFECT: extends the property if not already extended
	      OUT: extendedPropValue
	  
	      API 1: IN: 0 args
	      API 2: IN: 1 or more args
	        ADDITIONAL EFFECT: calls: propExtender extendedPropValue, args...
	  
	    NOTE: gthe prototype getters call the class getter for extension purposes.
	      The result is each instance won't get its own version of the property.
	      E.G. Interitance is done at the Class level, not the Instance level.
	   */

	  BaseObject.extendableProperty = function(map, propertyExtender) {
	    var defaultValue, prop, results;
	    results = [];
	    for (prop in map) {
	      defaultValue = map[prop];
	      if (!(isPlainArray(defaultValue) || isPlainObject(defaultValue))) {
	        throw new Error("only plain objects or plain arrays supported for defaultValue");
	      }
	      results.push((function(_this) {
	        return function(prop, defaultValue) {
	          var extenderName, getterName, internalName, propExtender, ucProp;
	          propExtender = propertyExtender || (function() {
	            if (isPlainObject(defaultValue)) {
	              return objectPropertyExtender;
	            } else if (isPlainArray(defaultValue)) {
	              return arrayPropertyExtender;
	            } else {
	              throw new Error("Unsupported property type for extendableProperty: " + (inspect(defaultValue)) + ". Please specify a custom propertyExtender function.");
	            }
	          })();
	          internalName = _this.propInternalName(prop);
	          ucProp = capitalize(prop);
	          getterName = "get" + ucProp;
	          extenderName = "extend" + ucProp;
	          _this[getterName] = function() {
	            return this.prototype[internalName] || defaultValue;
	          };
	          _this.addGetter(prop, function() {
	            return this[internalName] || defaultValue;
	          });
	          _this[extenderName] = function(value) {
	            var propValue;
	            propValue = getOwnProperty(this.prototype, internalName, defaultValue);
	            if (arguments.length > 0) {
	              propExtender.apply(propValue, arguments);
	            }
	            return propValue;
	          };
	          return _this.prototype[extenderName] = function(value) {
	            var propValue;
	            propValue = getOwnProperty(this, internalName, defaultValue);
	            if (arguments.length > 0) {
	              propExtender.apply(propValue, arguments);
	            }
	            return propValue;
	          };
	        };
	      })(this)(prop, defaultValue));
	    }
	    return results;
	  };

	  BaseObject.getNamespacePath = function() {
	    var ref;
	    if (!this.namespacePath) {
	      return this.namespacePath = (this.getName()) + " extends " + (this.__super__["class"].getNamespacePath());
	    } else if (((ref = this.__super__) != null ? ref["class"].namespacePath : void 0) === this.namespacePath) {
	      return this.namespacePath = (this.getName()) + " extends " + (this.__super__["class"].getNamespacePath());
	    } else {
	      return this.namespacePath;
	    }
	  };

	  BaseObject.getClassName = function(klass) {
	    if (klass == null) {
	      klass = this;
	    }
	    return (typeof klass.getName === "function" ? klass.getName() : void 0) || klass.name;
	  };


	  /*
	  inspect: ->
	  IN: ()
	  OUT: string
	  
	  Can override with same or alternate, recursion-block-supported signature:
	    IN: (inspector) ->
	    OUT: if inspector then null else string
	  
	    To handle the case where the inspector is not set, we
	    recommneded declaring your 'inspect' as follows:
	      inspect: (inspector) ->
	        return Foundation.inspect @ unless inspector
	         * ...
	         * custom code which writes all output to inspector.put
	         * and uses inspector.inspect for inspecting sub-objects
	         * ...
	        null
	  
	    EFFECT:
	      call inspector.put one or multiple times with strings to add to the inspected output
	      call inspector.inspect foo to sub-inspect other objects WITH RECURSION BLOCK
	  
	   * Example 1:
	  inspect: (inspector) ->
	    return Foundation.inspect @ unless inspector
	    inspector.put @getNamespacePath()
	  
	   * Example 2:
	  inspect: ->
	    @getNamespacePath()
	   */

	  BaseObject.inspect = function() {
	    return this.getNamespacePath();
	  };

	  BaseObject.prototype.inspect = function() {
	    return "<" + this["class"].namespacePath + ">";
	  };


	  /*
	  getInspectedObjects: -> plainObjects
	  
	  usually implemented this way:
	  @getter inspectedObjects: -> plainObjects or objects which implement "inspect"
	  
	  TODO: I think I want to refactor inspectedObjects to ONLY return near-JSON-compatible objects:
	    1. strings
	    2. maps
	    3. arrays
	  
	    Everything else should be rendered to a string. In general, strings should Eval to the object
	    they represent:
	  
	      toInspectedObject(null):                    'null' # null becomes a string
	      toInspectedObject(true):                    'true' # true becomes a string
	      toInspectedObject(false):                   'false' # false becomes a string
	      toInspectedObject(undefined):               'undefined' # undefined becomes a string
	      toInspectedObject('hi'):                    '"hi"' # ESCAPED
	      toInspectedObject((a) -> a):                'function(a){return a;}'
	      toInspectedObject(rgbColor())               "rgbColor('#000000')"
	  
	    NOTE: inspectedObjects differs from plainObjects. The latter should be 100% JSON,
	      and should return actual values where JSON allows, otherwise, return JSON data structures
	      that encode the object's information in a human-readable format, ideally one that can be
	      used as an input to the constructor of the object's class to recreate the original object.
	  
	      plainObjects:
	        null:         null
	        true:         true
	        false:        false
	        'str':        'str' # NOT escaped
	        undefined:    null
	        ((a) -> a):   'function(a){return a;}'
	        rgbColor():   r: 0, g: 0, b: 0, a: 0
	  
	  You can provide this function for fine-grained control of what Inspector2 outputs and hence
	  what DomConsole displays.
	  
	  If you would like for a string to appear without quotes, use:
	    {inspect: -> 'your string without quotes here'}
	   */

	  BaseObject.getter({
	    inspectObjects: function() {
	      console.warn("inspectObjects/getInspectObjects is DEPRICATED. Use: inspectedObjects/getInspectedObjects");
	      return this.getInspectedObjects();
	    },
	    inspectedObjects: function() {
	      return inspectedObjectLiteral("<" + (this["class"].getNamespacePath()) + ">");
	    }
	  });

	  BaseObject.classGetter({
	    inspectedObjects: function() {
	      return inspectedObjectLiteral(this.getNamespacePath());
	    }
	  });


	  /*
	  Define this class as an abstract class. Implicitly it means
	  any class it extends is also abstract, at least in this context.
	  
	  Definition: Abstract classes are not intended to every be instantiated.
	    i.e.: never do: new MyAbstractClass
	  
	  TODO: in Debug mode, in the constructor:
	    throw new Error "cannot instantiate abstract classes" if @class.getIsAbstractClass()
	   */

	  BaseObject.abstractClass = function() {
	    if (this.getIsSingletonClass()) {
	      throw new Error("abstract classes cannot also be singleton");
	    }
	    return this._firstAbstractAncestor = this;
	  };

	  BaseObject.classGetter({
	    isAbstractClass: function() {
	      return !(this.prototype instanceof this._firstAbstractAncestor);
	    },
	    abstractPrototype: function() {
	      return this._firstAbstractAncestor.prototype;
	    },
	    firstAbstractAncestor: function() {
	      return this._firstAbstractAncestor;
	    },
	    isSingletonClass: function() {
	      return !!this.getSingleton;
	    }
	  });

	  BaseObject.getAbstractClass = function() {
	    return this._firstAbstractAncestor;
	  };

	  BaseObject.abstractClass();

	  BaseObject.propertyIsAbstract = function(methodName) {
	    return this.getAbstractClass().prototype[methodName] === this.prototype[methodName];
	  };

	  BaseObject.propertyIsConcrete = function(methodName) {
	    return this.getAbstractClass().prototype[methodName] !== this.prototype[methodName];
	  };


	  /*
	  creates the classGetter "singleton" which returns a single instance of the current class.
	  
	  IN: args are passed to the singleton constructor
	  OUT: null
	  
	  The singleton instance is created on demand the first time it is accessed.
	   */

	  BaseObject.singletonClass = function() {
	    var args, map;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    if (this.getIsAbstractClass()) {
	      throw new Error("singleton classes cannot be abstract");
	    }
	    map = {
	      singleton: function() {
	        var ref;
	        if (((ref = this._singleton) != null ? ref["class"] : void 0) === this) {
	          return this._singleton;
	        } else {
	          return this._singleton = (function(func, args, ctor) {
	            ctor.prototype = func.prototype;
	            var child = new ctor, result = func.apply(child, args);
	            return Object(result) === result ? result : child;
	          })(this, args, function(){});
	        }
	      }
	    };
	    map[decapitalize(functionName(this))] = function() {
	      return this.getSingleton();
	    };
	    this.classGetter(map);
	    return null;
	  };

	  BaseObject.getter({
	    className: function() {
	      return this["class"].getClassName();
	    },
	    "class": function() {
	      return this.constructor;
	    },
	    keys: function() {
	      return Object.keys(this);
	    },
	    namespacePath: function() {
	      return this["class"].getNamespacePath();
	    },
	    classPathNameAndId: function() {
	      return this.classPathName + ":" + this.objectId;
	    },
	    uniqueId: function() {
	      return this.__uniqueId || (this.__uniqueId = nextUniqueObjectId());
	    },
	    objectId: function() {
	      return this.__uniqueId || (this.__uniqueId = nextUniqueObjectId());
	    }
	  });

	  BaseObject.prototype.implementsInterface = function(methods) {
	    return Function.BaseObject.implementsInterface(this, methods);
	  };

	  BaseObject.prototype.tap = function(f) {
	    f(this);
	    return this;
	  };

	  BaseObject.rawLog = function() {
	    return Log.rawLog.apply(Log, arguments);
	  };

	  BaseObject.log = function() {
	    var a, stack, toLog;
	    stack = callStack();
	    toLog = (function() {
	      var i, len, results;
	      if (arguments.length > 1) {
	        results = [];
	        for (i = 0, len = arguments.length; i < len; i++) {
	          a = arguments[i];
	          results.push(a);
	        }
	        return results;
	      } else {
	        return arguments[0];
	      }
	    }).apply(this, arguments);
	    Log.logCore(toLog, stack, {
	      className: this.className
	    });
	    return arguments[arguments.length - 1];
	  };

	  BaseObject.prototype.log = BaseObject.log;

	  BaseObject.prototype.rawLog = BaseObject.rawLog;

	  return BaseObject;

	})(MinimalBaseObject);


/***/ },
/* 79 */
/***/ function(module, exports) {

	var WebpackHotLoader;

	module.exports = WebpackHotLoader = (function() {
	  function WebpackHotLoader() {}


	  /*
	  IN:
	    _module should be the CommonJS 'module'
	    modulePostLoadAction: (moduleState) -> ignored internally, returned from @runHot
	  
	  OUT: modulePostLoadAction moduleState
	  
	  EFFECT:
	    modulePostLoadAction is run every time the module is loaded.
	  
	    Initially, moduleState is {}.
	  
	    moduleState is the same object every load:
	      modulePostLoadAction can modify moduleState and it will persist through every reload.
	  
	    modulePostLoadAction is responsible for any and all
	    update actions required due to the module load.
	  
	  NOTE:
	    If _module is not hot, modulePostLoadAction will be invoked once with an empty {}.
	   */

	  WebpackHotLoader.runHot = function(_module, modulePostLoadAction) {
	    var base, moduleState;
	    if (!(_module != null ? _module.hot : void 0)) {
	      return modulePostLoadAction({});
	    }
	    moduleState = (((base = _module.hot).data || (base.data = {
	      moduleState: {}
	    }))).moduleState;
	    _module.hot.accept();
	    _module.hot.dispose(function(data) {
	      return data.moduleState = moduleState;
	    });
	    return modulePostLoadAction(moduleState);
	  };

	  return WebpackHotLoader;

	})();


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Binary, ClassSystem, Stream, binary,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ClassSystem = __webpack_require__(75);

	Binary = __webpack_require__(69);

	BaseObject = ClassSystem.BaseObject;

	binary = __webpack_require__(73).binary;

	module.exports = Stream = (function(superClass) {
	  extend(Stream, superClass);

	  Stream.stream = function(arg) {
	    if (arg instanceof Stream) {
	      return arg;
	    } else if (arg instanceof ArrayBuffer) {
	      return Stream.fromArrayBuffer(arg);
	    } else if (arg instanceof Uint8Array) {
	      return new Stream(arg);
	    } else {
	      return new Stream(binary(arg).bytes);
	    }
	  };

	  Stream.fromArrayBuffer = function(arrayBuffer) {
	    return new Stream(new Uint8Array(arrayBuffer, 0, arrayBuffer.byteLength));
	  };

	  function Stream(byteView) {
	    this.byteView = byteView;
	    this.pos = 0;
	  }

	  Stream.prototype.readByte = function() {
	    return this.byteView[this.pos++];
	  };

	  Stream.prototype.readAsi = function() {
	    var ret, shift, val;
	    ret = 0;
	    shift = 0;
	    val = 128;
	    while (val >= 128) {
	      val = this.readByte();
	      ret += (val % 128) << shift;
	      shift += 7;
	    }
	    return ret;
	  };

	  Stream.prototype.uint8Array = function() {
	    return this.byteView;
	  };

	  Stream.prototype.read = function(length) {
	    var begin, end;
	    begin = this.pos;
	    this.pos += length;
	    end = this.pos;
	    return new Stream(this.byteView.subarray(begin, end));
	  };

	  Stream.prototype.inspect = function() {
	    return "{Stream pos=" + this.pos + " byteOffset=" + this.byteView.byteOffset + " length=" + this.byteView.length + "}";
	  };

	  Stream.prototype.readAsiString = function() {
	    return this.read(this.readAsi());
	  };

	  Stream.prototype.done = function() {
	    return this.pos >= this.byteView.length;
	  };

	  Stream.getter({
	    isDone: function() {
	      return this.pos >= this.byteView.length;
	    },
	    binaryString: function() {
	      return binary(this.byteView);
	    },
	    inspectedString: function() {
	      return this.binaryString.inspectedString;
	    }
	  });

	  Stream.prototype.toString = function() {
	    return this.binaryString.toString();
	  };

	  return Stream;

	})(BaseObject);


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var DataUri, Promise, StandardLib, binary, isString, readAsDataURL;

	StandardLib = __webpack_require__(24);

	binary = __webpack_require__(73).binary;

	readAsDataURL = __webpack_require__(72).readAsDataURL;

	Promise = StandardLib.Promise, isString = StandardLib.isString;

	module.exports = DataUri = (function() {
	  var isDataUri;

	  function DataUri() {}

	  DataUri.isDataUri = isDataUri = function(dataString) {
	    return isString(dataString) && dataString.slice(0, 5) === "data:";
	  };


	  /*
	  IN: data can be any of
	    File: HTML File object is read as ArrayBuffer
	    DataURI string: if it is already a data-uri string it is just returned as a successful promise
	    any type 'binary' accepts
	  
	  OUT:
	    promise.then (dataUri) ->
	    , (errorEventOrErrorObject) ->
	   */

	  DataUri.toDataUri = function(data) {
	    if (!data) {
	      throw new Error("data not set");
	    }
	    if (data instanceof self.File) {
	      return readAsDataURL(data);
	    }
	    if (isDataUri(data)) {
	      return Promise.resolve(data);
	    }
	    return binary(data).toBase64().then(function(base64) {
	      return "data:image/png;base64," + base64;
	    });
	  };

	  return DataUri;

	})();


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var EncodedImage, Promise, StandardLib, readFileAsDataUrl, toDataUri;

	StandardLib = __webpack_require__(24);

	toDataUri = __webpack_require__(81).toDataUri;

	Promise = StandardLib.Promise, readFileAsDataUrl = StandardLib.readFileAsDataUrl;

	module.exports = EncodedImage = (function() {
	  var get;

	  function EncodedImage() {}


	  /*
	  OUT:
	    promise.then (fullyLoadedHtmlImage) ->
	    , (htmlImageOnerrorEvent) ->
	   */

	  EncodedImage.get = get = function(url, options) {
	    return Promise.resolve().then(function() {
	      if (options) {
	        return Neptune.Art.Foundation.RestClient.getArrayBuffer(url, options).then(function(arrayBuffer) {
	          return readFileAsDataUrl(new Blob([arrayBuffer]));
	        }).then((function(_this) {
	          return function(dataUri) {
	            return url = dataUri;
	          };
	        })(this));
	      }
	    }).then(function() {
	      return new Promise(function(resolve, reject) {
	        var image;
	        image = new Image;
	        if (!url.match(/^(file|data)\:/i)) {
	          image.crossOrigin = "Anonymous";
	        }

	        /*
	        crossOrigin = "Anonymous" required to getImageData and avoid this error
	          "The canvas has been tainted by cross-origin data."
	        
	        NOTE:
	          file: urls break with crossOrigin in WkWebKit
	          data: urls break with crossOrigin in Safari
	         */
	        image.onload = function() {
	          return resolve(image);
	        };
	        image.onerror = reject;
	        return image.src = url;
	      });
	    });
	  };

	  EncodedImage.loadImage = function(url) {
	    console.warn(this.namespacePath + "#loadImage DEPRICATED. Use #get");
	    return get(url);
	  };

	  EncodedImage.toImage = function(encodedImageData) {
	    return toDataUri(encodedImageData).then((function(_this) {
	      return function(dataUri) {
	        return get(dataUri);
	      };
	    })(this));
	  };

	  return EncodedImage;

	})();


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, Promise, StandardLib, WriteStream, binary, bound, bufferSize, log, readFileAsArrayBuffer,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	binary = __webpack_require__(73).binary;

	Promise = StandardLib.Promise, readFileAsArrayBuffer = StandardLib.readFileAsArrayBuffer, bound = StandardLib.bound;

	BaseObject = ClassSystem.BaseObject, log = ClassSystem.log;

	bufferSize = 1024;

	module.exports = WriteStream = (function(superClass) {
	  extend(WriteStream, superClass);

	  function WriteStream() {
	    this._written = [];
	    this._writeBuffer = new Uint8Array(bufferSize);
	    this._pos = 0;
	    this._writtenLength = 0;
	  }

	  WriteStream.prototype.writeByte = function(byte) {
	    if (this._pos === bufferSize) {
	      this._commitHead();
	    }
	    return this._writeBuffer[this._pos++] = byte;
	  };

	  WriteStream.prototype.writeAsi = function(number) {
	    var nextByte, results;
	    if (!(number >= 0)) {
	      throw new Error("expected number >= 0");
	    }
	    results = [];
	    while (true) {
	      nextByte = number & 0x7F;
	      number >>= 7;
	      if (number > 0) {
	        results.push(this.writeByte(nextByte | 0x80));
	      } else {
	        this.writeByte(nextByte);
	        break;
	      }
	    }
	    return results;
	  };

	  WriteStream.prototype.write = function(string) {
	    var binaryString;
	    binaryString = binary(string);
	    if (this._pos + binaryString.length <= bufferSize) {
	      this._writeBuffer.set(binaryString.uint8Array, this._pos);
	      return this._pos += binaryString.length;
	    } else {
	      this._commitHead();
	      this._writtenLength += binaryString.length;
	      return this._written.push(binaryString.uint8Array);
	    }
	  };

	  WriteStream.prototype.writeAsiString = function(string) {
	    var binaryString;
	    binaryString = binary(string);
	    this.writeAsi(binaryString.length);
	    return this.write(binaryString);
	  };

	  WriteStream.getter({
	    arrayBufferPromise: function() {
	      return this._compact().then(function(uint8Array) {
	        return uint8Array.buffer;
	      });
	    },
	    binaryStringPromise: function() {
	      return this.arrayBufferPromise.then(function(ab) {
	        return binary(ab);
	      });
	    },
	    length: function() {
	      return this._pos + this._writtenLength;
	    }
	  });


	  /*
	  Using new Blob is much faster, thus we use Promises since it is async
	    http://jsperf.com/appending-arraybuffers
	  
	  OUT: promise.then (compactedUint8Array) ->
	  EFFECT:
	    head was committed
	    if @_written.length <= 1 then it isn't changed
	    else @_written = [compactedUint8Array]
	   */

	  WriteStream.prototype._compact = function() {
	    this._commitHead();
	    switch (this._written.length) {
	      case 0:
	        return new Promise(function(resolve) {
	          return resolve(new Uint8Array(0));
	        });
	      case 1:
	        return new Promise((function(_this) {
	          return function(resolve) {
	            return resolve(_this._written[0]);
	          };
	        })(this));
	      default:
	        return readFileAsArrayBuffer(new Blob(this._written)).then((function(_this) {
	          return function(ab) {
	            _this._written = [new Uint8Array(ab)];
	            return _this._written[0];
	          };
	        })(this));
	    }
	  };

	  WriteStream.prototype._commitHead = function() {
	    if (!(this._pos > 0)) {
	      return;
	    }
	    this._writtenLength += this._pos;
	    this._written.push(this._writeBuffer.slice(0, this._pos));
	    return this._pos = 0;
	  };

	  return WriteStream;

	})(BaseObject);


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(85).includeInNamespace(__webpack_require__(86)).addModules({
	  Analytics: __webpack_require__(91),
	  AsyncLocalStorage: __webpack_require__(92),
	  BatchLoader: __webpack_require__(95),
	  CommunicationStatus: __webpack_require__(96),
	  Epoch: __webpack_require__(97),
	  GlobalCounts: __webpack_require__(89),
	  InstanceFunctionBindingMixin: __webpack_require__(98),
	  JsonStore: __webpack_require__(99),
	  ObjectTreeFactory: __webpack_require__(90),
	  ProgressAdapter: __webpack_require__(87),
	  RestClient: __webpack_require__(100),
	  SingleObjectTransaction: __webpack_require__(101),
	  Stat: __webpack_require__(102),
	  Transaction: __webpack_require__(103),
	  Validator: __webpack_require__(104),
	  WebWorker: __webpack_require__(88),
	  WorkerRpc: __webpack_require__(94)
	});


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, Tools,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(21);

	module.exports = Foundation.Tools || Foundation.addNamespace('Tools', Tools = (function(superClass) {
	  extend(Tools, superClass);

	  function Tools() {
	    return Tools.__super__.constructor.apply(this, arguments);
	  }

	  return Tools;

	})(Neptune.Base));


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [[__webpack_require__(87), "executePromiseSequence"], __webpack_require__(88), __webpack_require__(89), __webpack_require__(90)];


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, ProgressAdapter, StandardLib, isArray, isFunction, isNumber, log, max, min,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	BaseObject = ClassSystem.BaseObject;

	isNumber = StandardLib.isNumber, isFunction = StandardLib.isFunction, isArray = StandardLib.isArray, log = StandardLib.log, max = StandardLib.max, min = StandardLib.min;

	module.exports = ProgressAdapter = (function(superClass) {
	  extend(ProgressAdapter, superClass);


	  /*
	  IN:
	    stepWeights can be a positive integer or an aray of positive, real numbers.
	  
	      integer N: specifies progress will be made in N even steps from 0 to 1
	  
	      array of numbers A: specifies progress will be made in A.length steps which
	        may not be even. Each step has its own "weight."
	  
	        Example: stepWeights = [850, 50, 100]
	        Will become:
	          steps:
	            0: 0.00 to 0.85
	            1: 0.85 to 0.90
	            2: 0.90 to 1.00
	  
	        Example: stepWeights = [1, 2, 1]
	        Will become:
	          steps:
	            0: 0.00 to 0.25
	            1: 0.25 to 0.75
	            2: 0.75 to 1.00
	  
	    progressCallback: progressCallback is a function which is invoked with a number
	      between 0 and 1. It is invoked immediatly with 0, then it is invoked by makeProgress()
	      and makeProgressCallback()(). It always increments or stays the same. It will
	      never go backwards.
	   */

	  function ProgressAdapter(stepWeights, progressCallback1) {
	    this.stepWeights = stepWeights;
	    this.progressCallback = progressCallback1;
	    if (!(isFunction(this.progressCallback) && (isArray(this.stepWeights) || isNumber(this.stepWeights)))) {
	      throw new Error("invalid params");
	    }
	    this._currentStep = 0;
	    this._generateSteps();
	    this._currentProgress = 0;
	    this._warningCount = 0;
	    this.setCurrentProgress(0);
	  }

	  ProgressAdapter.getter("steps currentStep currentProgress warningCount", {
	    currentProgressPercent: function() {
	      return (this._currentProgress * 100 | 0) + "%";
	    },
	    currentProgressBase: function() {
	      if (this._currentStep <= 0) {
	        return 0;
	      } else if (this._currentStep >= this._steps.length) {
	        return 1;
	      } else {
	        return this._steps[this._currentStep];
	      }
	    }
	  });

	  ProgressAdapter.setter({
	    currentProgress: function(p) {
	      return typeof this.progressCallback === "function" ? this.progressCallback(min(1, this._currentProgress = max(p, this._currentProgress))) : void 0;
	    }
	  });

	  ProgressAdapter.prototype.makeProgress = function() {
	    this._currentStep++;
	    if (this._currentStep > this._steps.length) {
	      this._warningCount++;
	      console.warn("ProgressAdapter: makeProgress/Callback called too many times!", {
	        currentStep: this._currentStep,
	        steps: this._steps,
	        stepWeights: this.stepWeights
	      });
	    }
	    return this.setCurrentProgress(this.currentProgressBase);
	  };

	  ProgressAdapter.prototype.makeProgressCallback = function() {
	    var rangeEnd, rangeStart;
	    this._finishLastProgress();
	    rangeStart = this.currentProgressBase;
	    this._currentStep++;
	    rangeEnd = this.currentProgressBase;
	    return (function(_this) {
	      return function(progress) {
	        return _this.setCurrentProgress(rangeStart + (rangeEnd - rangeStart) * progress);
	      };
	    })(this);
	  };

	  ProgressAdapter.prototype._finishLastProgress = function() {
	    var progress;
	    if (this._currentProgress < (progress = this.currentProgressBase)) {
	      return this.setCurrentProgress(progress);
	    }
	  };

	  ProgressAdapter.prototype._executePromiseSequence = function(sequence, lastResult, index, resolve) {
	    if (index >= sequence.length) {
	      this._finishLastProgress();
	      return resolve(lastResult);
	    }
	    return Promise.resolve(sequence[index](lastResult, this.makeProgressCallback())).then((function(_this) {
	      return function(nextResult) {
	        return _this._executePromiseSequence(sequence, nextResult, index + 1, resolve);
	      };
	    })(this));
	  };

	  ProgressAdapter.prototype.executePromiseSequence = function(sequence) {
	    return new Promise((function(_this) {
	      return function(resolve) {
	        return _this._executePromiseSequence(sequence, null, 0, resolve);
	      };
	    })(this));
	  };


	  /*
	  IN: (progressCallback, promiseSequence) ->
	     * stepWeights implicitly == promiseSequence.length
	  IN: (progressCallback, stepWeights, promiseSequence) ->
	   */

	  ProgressAdapter.executePromiseSequence = function(progressCallback, a, b) {
	    var pa, sequence, weights;
	    if (b) {
	      weights = a;
	      sequence = b;
	    } else {
	      sequence = a;
	      weights = sequence.length;
	    }
	    pa = new ProgressAdapter(weights, progressCallback);
	    return pa.executePromiseSequence(sequence);
	  };

	  ProgressAdapter.prototype._generateSteps = function() {
	    var i, j, len, numSteps, ref, s, step, total, w;
	    if (isNumber(numSteps = this.stepWeights)) {
	      return this._steps = (function() {
	        var j, ref, results;
	        results = [];
	        for (i = j = 0, ref = numSteps; j < ref; i = j += 1) {
	          results.push(i / numSteps);
	        }
	        return results;
	      })();
	    } else {
	      total = 0;
	      ref = this.stepWeights;
	      for (j = 0, len = ref.length; j < len; j++) {
	        w = ref[j];
	        total += w;
	      }
	      step = 0;
	      return this._steps = (function() {
	        var k, len1, ref1, results;
	        ref1 = this.stepWeights;
	        results = [];
	        for (k = 0, len1 = ref1.length; k < len1; k++) {
	          w = ref1[k];
	          s = step;
	          step += w / total;
	          results.push(s);
	        }
	        return results;
	      }).call(this);
	    }
	  };

	  return ProgressAdapter;

	})(BaseObject);


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var StandardLib, WebWorker, log;

	StandardLib = __webpack_require__(24);

	log = StandardLib.log;


	/*
	SRC:
	  http://jsfiddle.net/uqcFM/49/
	  http://stackoverflow.com/a/10372280/2121000
	 */

	module.exports = WebWorker = (function() {
	  var startWorkerFromJsString;

	  function WebWorker() {}

	  WebWorker.echoWebWorker = "self.onmessage=function(e){postMessage('Worker: '+e.data);}";

	  WebWorker.isBrowser = !!(self.window && self.navigator && self.document);

	  WebWorker.isWebWorker = !WebWorker.isBrowser && self.importScripts;

	  WebWorker.startWorkerFromJsString = startWorkerFromJsString = function(workerSource) {
	    return new Worker(URL.createObjectURL(new Blob([workerSource], {
	      type: 'application/javascript'
	    })));
	  };

	  WebWorker.startWorkerFromFunction = function(workerFunction) {
	    return startWorkerFromJsString("(" + workerFunction + ")();");
	  };

	  return WebWorker;

	})();


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	var GlobalCounts, StandardLib, currentSecond, isPlainObject, log;

	StandardLib = __webpack_require__(24);

	isPlainObject = StandardLib.isPlainObject, currentSecond = StandardLib.currentSecond, log = StandardLib.log;

	module.exports = GlobalCounts = (function() {
	  var globalTime;

	  function GlobalCounts() {}

	  GlobalCounts.globalCounts = {};

	  globalTime = null;

	  GlobalCounts.resetGlobalCounts = function() {
	    globalTime = currentSecond();
	    return GlobalCounts.globalCounts = {};
	  };

	  GlobalCounts.globalCount = function(name, amount) {
	    var k, last, results, v;
	    if (amount == null) {
	      amount = 1;
	    }
	    if (isPlainObject(amount)) {
	      if (last = GlobalCounts.globalCounts[name]) {
	        results = [];
	        for (k in amount) {
	          v = amount[k];
	          results.push(last[k] += v);
	        }
	        return results;
	      } else {
	        return GlobalCounts.globalCounts[name] = amount;
	      }
	    } else {
	      return GlobalCounts.globalCounts[name] = (GlobalCounts.globalCounts[name] || 0) + amount;
	    }
	  };

	  GlobalCounts.countStep = function() {
	    var nextTime;
	    nextTime = currentSecond();
	    if (nextTime - globalTime > .002) {
	      log.error("GlobalCounts gap");
	    }
	    globalTime = nextTime;
	    return GlobalCounts.globalCount("step");
	  };

	  return GlobalCounts;

	})();


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	var ObjectTreeFactory, compactFlatten, fastBind, isFunction, mergeIntoBasic, ref, upperCamelCase;

	ref = __webpack_require__(8), compactFlatten = ref.compactFlatten, upperCamelCase = ref.upperCamelCase;

	mergeIntoBasic = function(into, source) {
	  var k, v;
	  for (k in source) {
	    v = source[k];
	    into[k] = v;
	  }
	  return into;
	};

	isFunction = __webpack_require__(31).isFunction;

	fastBind = __webpack_require__(38).fastBind;

	module.exports = ObjectTreeFactory = (function() {
	  var compactFlattenObjectTreeNodeNames, deepArgsProcessing, nodeNameRegexp, preprocessElementBasic;

	  function ObjectTreeFactory() {}

	  deepArgsProcessing = function(array, children) {
	    var el, i, len;
	    for (i = 0, len = array.length; i < len; i++) {
	      el = array[i];
	      if (el) {
	        if (el.constructor === Array) {
	          deepArgsProcessing(el, children);
	        } else {
	          children.push(el);
	        }
	      }
	    }
	    return null;
	  };


	  /*
	  IN:
	    options:
	      mergePropsInto: (props, ...) ->
	        function to merge arguments 1 on into props
	        default: mergeIntoBasic
	  
	      inspectedName: string
	        for introspection:
	          Factory.getName() == inspectedName
	  
	      class: a class
	        if specified, additioanl properties will be set on the Factory function:
	          Factory.class = class
	          Factory._name = class.getName() + "Factory"
	  
	          all concrete class-methods are made available in the Factory
	          (see BaseObject.abstractClass)
	  
	      bind: string or array of strings
	        NODE: class must be set
	        list of method-names to bind from class onto the factory
	  
	      preprocessElement: (element) -> element
	        can do custom preprocssing of each argument to the factory.
	  
	  
	        defualt: preprocessElementBasic (no-op)
	    nodeFactory: ->
	      IN:
	        props:    plain object mapping props to prop-values
	        children: flat, compacted array of children nodes
	      OUT:
	        node
	  
	  OUT: objectTreeFactory = ->
	    IN:
	      Arguments are compacted and flattened
	      The resulting list of arguments can be any combination of:
	        plainObjects for props (merged in the order they appear)
	        other objects which become the 'children'
	  
	    OUT:
	      object-tree-node generated by the nodeFactory
	   */

	  preprocessElementBasic = function(a) {
	    return a;
	  };

	  ObjectTreeFactory.createObjectTreeFactory = function(options, nodeFactory) {
	    var Factory, abstractClass, bindList, i, inspectedName, k, klass, len, mergePropsInto, preprocessElement, v;
	    if (!nodeFactory) {
	      nodeFactory = options;
	      options = {};
	    }
	    mergePropsInto = options.mergePropsInto, inspectedName = options.inspectedName, preprocessElement = options.preprocessElement;
	    mergePropsInto || (mergePropsInto = mergeIntoBasic);
	    preprocessElement || (preprocessElement = preprocessElementBasic);
	    Factory = function() {
	      var children, el, i, len, oneProps, props;
	      oneProps = null;
	      props = null;
	      children = [];
	      for (i = 0, len = arguments.length; i < len; i++) {
	        el = arguments[i];
	        if (el = preprocessElement(el)) {
	          switch (el.constructor) {
	            case Object:
	              if (oneProps) {
	                props = {};
	                mergePropsInto(props, oneProps);
	                oneProps = null;
	              }
	              if (props) {
	                mergePropsInto(props, el);
	              } else {
	                oneProps = el;
	              }
	              break;
	            case Array:
	              deepArgsProcessing(el, children);
	              break;
	            default:
	              children.push(el);
	          }
	        }
	      }
	      props || (props = oneProps || {});
	      return nodeFactory(props, children);
	    };
	    if (klass = options["class"]) {
	      Factory["class"] = klass;
	      abstractClass = klass.getAbstractClass();
	      bindList = compactFlatten([
	        (function() {
	          var results;
	          results = [];
	          for (k in klass) {
	            v = klass[k];
	            if (!abstractClass[k] && isFunction(v)) {
	              results.push(k);
	            }
	          }
	          return results;
	        })(), options.bind
	      ]);
	      inspectedName || (inspectedName = klass.getName() + "Factory");
	      for (i = 0, len = bindList.length; i < len; i++) {
	        k = bindList[i];
	        Factory[k] = fastBind(klass[k], klass);
	      }
	    }
	    if (inspectedName) {
	      Factory._name = inspectedName;
	    }
	    Factory.inspect = function() {
	      return "<" + (inspectedName || 'ObjectTreeFactory') + ">";
	    };
	    return Factory;
	  };


	  /*
	  IN:
	    list: a string or abitrary structure of arrays, nulls and strings
	      each string is split into tokens and each token is used as the nodeTypeName to create a Tree-factory
	    nodeFactory: (nodeTypeName, props, children) -> node
	      IN:
	        nodeTypeName: node-type name
	        props:    plain object mapping props to prop-values
	        children: flat, compacted array of children nodes
	      OUT:
	        node
	  OUT:
	    map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory
	  
	  TODO:
	    PERFORMANCE TEST:
	      createObjectTreeFactoriesFromFactories
	      vs
	      createObjectTreeFactoriesFromFactoryFactories
	  
	      The latter is probably faster. It is also more powerful and generally cleaner.
	   */

	  ObjectTreeFactory.createObjectTreeFactories = function(options, list, nodeFactory) {
	    var ref1;
	    if (!nodeFactory) {
	      ref1 = [options, list], list = ref1[0], nodeFactory = ref1[1];
	      options = {};
	    }
	    if (nodeFactory.length === 1) {
	      return ObjectTreeFactory._createObjectTreeFactoriesFromFactoryFactories(options, list, nodeFactory);
	    } else {
	      return ObjectTreeFactory._createObjectTreeFactoriesFromFactories(options, list, nodeFactory);
	    }
	  };

	  ObjectTreeFactory._createObjectTreeFactoriesFromFactories = function(options, list, nodeFactory) {
	    var fn, i, len, nodeTypeName, out, ref1, suffix;
	    suffix = options.suffix || '';
	    out = {};
	    ref1 = compactFlattenObjectTreeNodeNames(list);
	    fn = function(nodeTypeName) {
	      options.inspectedName = nodeTypeName;
	      return out[upperCamelCase(nodeTypeName) + suffix] = ObjectTreeFactory.createObjectTreeFactory(options, function(props, children) {
	        return nodeFactory(nodeTypeName, props, children);
	      });
	    };
	    for (i = 0, len = ref1.length; i < len; i++) {
	      nodeTypeName = ref1[i];
	      fn(nodeTypeName);
	    }
	    return out;
	  };

	  nodeNameRegexp = /[a-z0-9_]+/ig;

	  ObjectTreeFactory._compactFlattenObjectTreeNodeNames = compactFlattenObjectTreeNodeNames = function(list) {
	    var i, len, out, ref1, str;
	    if (typeof list === "string") {
	      return list.match(nodeNameRegexp);
	    }
	    out = [];
	    ref1 = compactFlatten(list);
	    for (i = 0, len = ref1.length; i < len; i++) {
	      str = ref1[i];
	      out = out.concat(str.match(nodeNameRegexp));
	    }
	    return out;
	  };

	  ObjectTreeFactory._createObjectTreeFactoriesFromFactoryFactories = function(options, list, nodeFactoryFactory) {
	    var i, len, name, nodeFactory, nodeTypeName, out, ref1, suffix;
	    suffix = options.suffix || '';
	    out = {};
	    ref1 = compactFlattenObjectTreeNodeNames(list);
	    for (i = 0, len = ref1.length; i < len; i++) {
	      nodeTypeName = ref1[i];
	      nodeFactory = nodeFactoryFactory(nodeTypeName);
	      name = upperCamelCase(nodeTypeName) + suffix;
	      options.inspectedName = name;
	      out[name] = ObjectTreeFactory.createObjectTreeFactory(options, nodeFactory);
	    }
	    return out;
	  };

	  return ObjectTreeFactory;

	})();


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var Analytics, BaseObject, ClassSystem, StandardLib, inspectLean,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	BaseObject = ClassSystem.BaseObject;

	inspectLean = StandardLib.inspectLean;

	Analytics = (function(superClass) {
	  extend(Analytics, superClass);

	  function Analytics() {
	    return Analytics.__super__.constructor.apply(this, arguments);
	  }

	  Analytics.defaultCategory = "Foundation.Analytics";

	  Analytics.event = function(options) {
	    var action, category, label, noninteraction, value;
	    if (options == null) {
	      options = {};
	    }
	    category = options.category || this.defaultCategory;
	    action = options.action;
	    label = options.label;
	    value = options.value;
	    noninteraction = !!options.noninteraction;
	    if (self._gaq) {
	      self._gaq.push(['_trackEvent', category, action, label, value, noninteraction]);
	      return this.rawLog("ANALYTICS-EVENT: " + (inspectLean(options)));
	    } else {
	      return this.rawLog("(no)ANALYTICS-EVENT: " + (inspectLean(options)));
	    }
	  };

	  return Analytics;

	})(BaseObject);


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {var Promise, defineModule, isWebWorker, log, objectKeyCount, ref, workerRpc;

	ref = __webpack_require__(24), defineModule = ref.defineModule, Promise = ref.Promise, log = ref.log, objectKeyCount = ref.objectKeyCount;

	isWebWorker = __webpack_require__(88).isWebWorker;

	workerRpc = __webpack_require__(94).workerRpc;


	/*
	AsyncLocalStorage defines a consistent API for localStorage across web-workers and the main thread.

	API:
	  AsyncLocalStorage.
	    getItem:    (path)        -> promise.then -> item at path
	    setItem:    (path, value) -> promise.then -> success
	    removeItem: (path)        -> promise.then -> success
	    clear:                    -> promise.then -> success
	 */

	defineModule(module, function() {
	  var AsyncLocalStorage, LocalStorageShimForNode, localStorage;
	  localStorage = global.localStorage;
	  localStorage || (localStorage = LocalStorageShimForNode = (function() {
	    function LocalStorageShimForNode() {}

	    LocalStorageShimForNode.store = {};

	    LocalStorageShimForNode.getItem = function(k) {
	      return LocalStorageShimForNode.store[k];
	    };

	    LocalStorageShimForNode.setItem = function(k, v) {
	      return LocalStorageShimForNode.store[k] = v;
	    };

	    LocalStorageShimForNode.removeItem = function(k) {
	      return delete LocalStorageShimForNode.store[k];
	    };

	    LocalStorageShimForNode.clear = function() {
	      return LocalStorageShimForNode.store = {};
	    };

	    LocalStorageShimForNode.key = function(i) {
	      return Object.keys(LocalStorageShimForNode.store)[i];
	    };

	    LocalStorageShimForNode.getLength = function() {
	      return objectKeyCount(LocalStorageShimForNode.store);
	    };

	    return LocalStorageShimForNode;

	  })());
	  if (isWebWorker) {
	    return workerRpc.bindWithPromises({
	      localStorage: ["getItem", "setItem", "removeItem", "clear", "key"]
	    });
	  } else {
	    workerRpc.register({
	      localStorage: localStorage
	    });
	    return AsyncLocalStorage = (function() {
	      function AsyncLocalStorage() {}

	      AsyncLocalStorage.getItem = function(path) {
	        return Promise.then(function() {
	          return localStorage.getItem(path);
	        });
	      };

	      AsyncLocalStorage.setItem = function(path, value) {
	        return Promise.then(function() {
	          return localStorage.setItem(path, value);
	        });
	      };

	      AsyncLocalStorage.removeItem = function(path) {
	        return Promise.then(function() {
	          return localStorage.removeItem(path);
	        });
	      };

	      AsyncLocalStorage.clear = function() {
	        return Promise.then(function() {
	          return localStorage.clear();
	        });
	      };

	      AsyncLocalStorage.key = function(index) {
	        return Promise.then(function() {
	          return localStorage.key(index);
	        });
	      };

	      AsyncLocalStorage.getLength = function() {
	        return Promise.then(function() {
	          return localStorage.length;
	        });
	      };

	      return AsyncLocalStorage;

	    })();
	  }
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module), (function() { return this; }())))

/***/ },
/* 93 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, Promise, StandardLib, WebWorker, WorkerRpc, debugPrefix, isFunction, isPlainArray, isString, isWebWorker, log, mergeInto,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  slice = [].slice;

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	WebWorker = __webpack_require__(88);

	Promise = StandardLib.Promise, log = StandardLib.log, isPlainArray = StandardLib.isPlainArray, isFunction = StandardLib.isFunction, isString = StandardLib.isString, mergeInto = StandardLib.mergeInto;

	BaseObject = ClassSystem.BaseObject;

	isWebWorker = WebWorker.isWebWorker;


	/*
	WorkerRPC has two modes: singleton and instanced.

	SINGLETON:
	  Including WorkerRPC automatically creates the singleton instance.
	  In a worker, the singleton automatically binds to the worker's self.onmessage and starts listenting.
	  In workers or the browser, any handler registered with the singleton will be available to respond
	  to any message received by the singleton OR ANY OTHER INSTANCE of WorkerRPC in that thread.
	  You can think of the singleton as the global registry for handlers.

	In practice:
	  In browser:
	     * to register all your handlers, call this one or more times:
	    WorkerRpc.register ...

	     * call for each each worker you want to listen for RPC calls from,
	     * and bind any remote procedures you want to be able to invoke on that specific worker-thread
	    aBoundWorker = new WorkerRpc worker,
	      bind: ...
	      bindWithPromises: ...

	     * to make remote-procedure-calls to the worker:
	     * NOTE: if registered with bindWithPromises, will return a promise for the RPC's result.
	    aBoundWorker.MyWorkerNamespace.myWorkerFunction ...

	  In worker:
	     * to register all your handlers, call this one or more times:
	    WorkerRpc.register ...

	     * bind any remote procedures you want to be able to invoke on the browser-thread
	    WorkerRpc.bind ...
	    WorkerRpc.bindWithPromises ...

	NOTES:
	  registered functions are invoked with @/this set to the namespace. That way you can invoke
	  callback functions you previously bound back to the specific worker that invoked the
	  function with: @MyWorkerNamespace.myWorkerFunction()

	Real world example:

	  Suppose you want to access the localStorage object on the browser thread from your worker.
	  The 6 lines of code below create the 'self.asyncLocalStorage' object which works just like
	  'localStorage' except it returns Art.Foundation.Promises for the function results.

	  browser: (before starting the worker)
	    {WorkerRpc} = Art.Foundation
	    WorkerRpc.register localStorage: localStorage
	    new WorkerRpc workerSourcePath

	  worker:
	    {workerRpc} = Art.Foundation.WorkerRpc
	    workerRpc.bindWithPromises localStorage: ["getItem", "setItem", "removeItem", "clear"]
	    self.asyncLocalStorage = workerRpc.localStorage

	  SBD: Isn't that nice! So streamlined!

	General examples:

	Usage with no return value expected:
	  browser thread:

	    new WorkerRpc (new Worker workerUrl),
	      register:
	        MyMainNamespace:
	          doWork: (a) -> ...

	  worker thread:

	    {MyMainNamespace} = new WorkerRpc self,
	      bind:
	        MyMainNamespace: ["doWork"]

	    MyMainNamespace.doWork myStructuredData

	Usage with promises:

	  browser thread:

	    new WorkerRpc (new Worker workerUrl),
	      register:
	        MyMainNamespace:
	          concatStrings: (a, b) ->
	            a + b
	             * equivelent to: Promise.resolve a + b
	             * if the result is not a Promse, Promise.resolve(result) is automatically applied

	  worker thread:

	    {MyMainNamespace} = new WorkerRpc self,
	      bindWithPromises:
	        MyMainNamespace: ["concatStrings"]

	    MyMainNamespace.concatStrings "hi ", "Shane"
	    .then (result) ->
	       * result == "hi Shane"

	Usage with arbitrary response messages:

	  Sometimes you want a handle to the workerRpc instance for the thread that just send
	  you the message inside your registered response functions. You can access that
	  via the global: WorkerRpc.lastMessageReceivedFrom.

	  browser thread:

	    new WorkerRpc (new Worker workerUrl),
	      register:
	        MyMainNamespace:
	          doWorkAndRespond: (key) ->
	            count == 0
	            invokeThreeTimes =>
	              count++
	              WorkerRpc.lastMessageReceivedFrom.MyWorkerNamespace.respond key, count

	  worker thread:

	    {MyMainNamespace} = new WorkerRpc self,
	      register:
	        MyWorkerNamespace:
	          respond: (key, count) -> console.log "MyWorkerNamespace#respond: #{key} #{count}"
	      bind:
	        MyMainNamespace: ["doWorkAndRespond"]

	    MyMainNamespace.doWorkAndRespond "myKey"

	Usage - add to global registery:

	  WorkerRpc.register
	    MyGlobalClass:
	      doSomethingNoMatterWhoCalls: ->
	        ...
	 */

	debugPrefix = isWebWorker ? "WorkerRpc(worker)" : "WorkerRpc(browser)";

	module.exports = WorkerRpc = (function(superClass) {
	  var workerRpcChannelIdString;

	  extend(WorkerRpc, superClass);

	  WorkerRpc.singletonClass();

	  WorkerRpc.workerRpcChannelIdString = workerRpcChannelIdString = "Art.Foundation.WorkerRpcChannel";

	  WorkerRpc.register = function(toRegister) {
	    return WorkerRpc.singleton.register(toRegister);
	  };

	  WorkerRpc.bind = function(toBind) {
	    return WorkerRpc.singleton._bind(toBind, false);
	  };

	  WorkerRpc.bindWithPromises = function(toBind) {
	    return WorkerRpc.singleton._bind(toBind, true);
	  };


	  /*
	  INPUT:
	    thread:
	      must implement onmessage= and postMessage or be null
	      In a webworker, this gets set to self if it is null.
	    options:
	      bind: map # invokes: @bind map
	      bindWithPromises: map # invokes: @bindWithPromises map
	   */

	  function WorkerRpc(thread, options) {
	    if (isString(thread)) {
	      log("WorkerRpc starting worker: " + thread);
	      thread = new Worker(thread);
	      log("WorkerRpc starting worker: " + thread + ", started?:", thread);
	    }
	    if (!(thread || self === self.window)) {
	      thread = self;
	    }
	    this._reset();
	    this._bindOnmessage(this._thread = thread);
	    if (options) {
	      this._applyOptions(options);
	    }
	  }

	  WorkerRpc.prototype.register = function(toRegister) {
	    var functionMap, namespaceName;
	    if (!toRegister) {
	      return;
	    }
	    for (namespaceName in toRegister) {
	      functionMap = toRegister[namespaceName];
	      if (this._registry.hasOwnProperty(namespaceName)) {
	        mergeInto(this._registry[namespaceName], functionMap);
	      } else {
	        this._registry[namespaceName] = functionMap;
	      }
	    }
	    return this._registry;
	  };


	  /*
	  Creates functions to make specific remote-procedure-calls.
	  
	  IN:
	    toBind: map to arrays of strings
	      Each key in the map specifies a namespace.
	      The array of strings specify the names of each RPC you want to be able to invoke.
	  
	  For a given namespaceName and functionName, this binds the function so you can
	  invoke it as follows:
	    @myNamespaceName.myFunctionName()
	  
	  The created functions are one-way. They return null as soon as the message has been sent
	  to the remote thread. If you want the results, see @bindWithPromises
	   */

	  WorkerRpc.prototype.bind = function(toBind) {
	    return this._bind(toBind, false);
	  };


	  /*
	  Same as @bind except each function created will return a promise which will return
	  the results return from the remote procedure call when they are ready.
	   */

	  WorkerRpc.prototype.bindWithPromises = function(toBind) {
	    return this._bind(toBind, true);
	  };

	  WorkerRpc.prototype._bind = function(toBind, withPromises) {
	    var functionName, functionNames, i, len, namespace, namespaceName, ref;
	    if (!isFunction((ref = this._thread) != null ? ref.postMessage : void 0)) {
	      throw new Error("@_thread.postMessage required for remote requests");
	    }
	    if (!toBind) {
	      return;
	    }
	    namespace = null;
	    for (namespaceName in toBind) {
	      functionNames = toBind[namespaceName];
	      if (!this.hasOwnProperty(namespaceName)) {
	        this[namespaceName] = {};
	      }
	      namespace = this[namespaceName];
	      for (i = 0, len = functionNames.length; i < len; i++) {
	        functionName = functionNames[i];
	        namespace[functionName] = withPromises ? this._newRemoteRequestFunctionWithPromise(namespaceName, functionName) : this._newRemoteRequestFunction(namespaceName, functionName);
	      }
	    }
	    return namespace;
	  };

	  WorkerRpc.prototype._reset = function() {
	    return this._registry = {
	      promiseCallback: {
	        success: (function(_this) {
	          return function(promiseId, result) {
	            return WorkerRpc._resolvePromise(promiseId, result);
	          };
	        })(this),
	        error: (function(_this) {
	          return function(promiseId, error) {
	            return WorkerRpc._rejectPromise(promiseId, error);
	          };
	        })(this)
	      }
	    };
	  };

	  WorkerRpc.prototype._applyOptions = function(arg) {
	    var bind, bindWithPromises, register;
	    register = arg.register, bind = arg.bind, bindWithPromises = arg.bindWithPromises;
	    this.register(register);
	    this.bind(bind);
	    this.bindWithPromises(bindWithPromises);
	    return this;
	  };

	  WorkerRpc.prototype._send = function(namespaceName, functionName, promiseId, args) {
	    return this._thread.postMessage([workerRpcChannelIdString, namespaceName, functionName, promiseId, args]);
	  };

	  WorkerRpc.prototype._newRemoteRequestFunctionWithPromise = function(namespaceName, functionName) {
	    return (function(_this) {
	      return function() {
	        var args;
	        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	        return WorkerRpc._bindPromise(function(promiseId) {
	          return _this._send(namespaceName, functionName, promiseId, args);
	        });
	      };
	    })(this);
	  };

	  WorkerRpc.prototype._newRemoteRequestFunction = function(namespaceName, functionName) {
	    return (function(_this) {
	      return function() {
	        var args;
	        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	        return _this._send(namespaceName, functionName, null, args);
	      };
	    })(this);
	  };

	  WorkerRpc.prototype._bindOnmessage = function(thread) {
	    var handler;
	    if (!thread) {
	      return;
	    }
	    handler = (function(_this) {
	      return function(arg) {
	        var args, data, functionName, namespaceName, promiseId, testWorkerRpcChannelIdString;
	        data = arg.data;
	        if (!isPlainArray(data)) {
	          return;
	        }
	        testWorkerRpcChannelIdString = data[0], namespaceName = data[1], functionName = data[2], promiseId = data[3], args = data[4];
	        if (testWorkerRpcChannelIdString !== workerRpcChannelIdString) {
	          return;
	        }
	        return _this._invokeLocalFunction(namespaceName, functionName, promiseId, args);
	      };
	    })(this);
	    if (thread.addEventListener) {
	      return thread.addEventListener('message', handler);
	    } else {
	      return thread.onmessage = handler;
	    }
	  };

	  WorkerRpc.prototype._invokeLocalFunction = function(namespaceName, functionName, promiseId, args) {
	    var localFunction, namespace, singleton;
	    if (!((namespace = this._registry[namespaceName]) && (localFunction = namespace[functionName]))) {
	      singleton = WorkerRpc.singleton;
	      if (this !== singleton && (namespace = singleton._registry[namespaceName])) {
	        localFunction = namespace[functionName];
	      }
	    }
	    if (!localFunction) {
	      console.warn(debugPrefix + "_onmessage: could not find: '" + namespaceName + "." + functionName + "'\n\nnamespaces: " + (Object.keys(this._registry).join(', ')) + "\nglobal namespaces: " + (singleton === this ? "(same)" : Object.keys(singleton._registry).join(', ')));
	    }
	    if (localFunction) {
	      WorkerRpc.lastMessageReceivedFrom = this;
	      return this._resolveOrRejectRemotePromise(promiseId, localFunction.apply(namespace, args));
	    }
	  };

	  WorkerRpc.prototype._resolveOrRejectRemotePromise = function(promiseId, result) {
	    if (promiseId == null) {
	      return;
	    }
	    return Promise.resolve(result).then((function(_this) {
	      return function(result) {
	        return _this._send("promiseCallback", "success", null, [promiseId, result], function(error) {
	          return _this._send("promiseCallback", "error", null, [promiseId, error]);
	        });
	      };
	    })(this));
	  };


	  /*
	  IN:   f: (promiseId) -> ignored
	  OUT:  promise
	  
	  Creates a new promise, addes it to @_promises with a unique id, and invokes f, passing in
	  the promise's id.
	   */

	  WorkerRpc._promises = {};

	  WorkerRpc._nextPromiseId = 0;

	  WorkerRpc._bindPromise = function(f) {
	    var promise, promiseId;
	    this._promises[promiseId = this._nextPromiseId++] = promise = new Promise;
	    f(promiseId);
	    return promise;
	  };

	  WorkerRpc._resolvePromise = function(promiseId, result) {
	    var ref;
	    if ((ref = this._promises[promiseId]) != null) {
	      ref.resolve(result);
	    }
	    return delete this._promises[promiseId];
	  };

	  WorkerRpc._rejectPromise = function(promiseId, error) {
	    var ref;
	    if ((ref = this._promises[promiseId]) != null) {
	      ref.reject(error);
	    }
	    return delete this._promises[promiseId];
	  };

	  return WorkerRpc;

	})(BaseObject);


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, BatchLoader, ClassSystem, StandardLib, inspect, log, nextTick, timeout,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	BaseObject = ClassSystem.BaseObject;

	log = StandardLib.log, inspect = StandardLib.inspect, nextTick = StandardLib.nextTick, timeout = StandardLib.timeout;

	module.exports = BatchLoader = (function(superClass) {
	  extend(BatchLoader, superClass);

	  function BatchLoader(loadFunction) {
	    this.assets = {};
	    this.loadingAssets = {};
	    this.loadFunction = loadFunction;
	  }

	  BatchLoader.prototype.load = function(sources, onLoad) {
	    if (typeof sources === "string") {
	      sources = [sources];
	    }
	    return this.loadAssets(sources, onLoad);
	  };

	  BatchLoader.prototype.addAsset = function(source, asset) {
	    var base;
	    if (asset == null) {
	      throw new Error("not a valid asset: " + (inspect(asset)));
	    }
	    delete this.loadingAssets[source];
	    (base = this.assets)[source] || (base[source] = asset);
	    return this.notifyListeners();
	  };

	  BatchLoader.getter({
	    blankInfo: function() {
	      return {
	        loadedFromCache: 0,
	        loadedAsynchronously: 0,
	        alreadyLoadingAsynchronously: 0
	      };
	    }
	  });

	  BatchLoader.prototype.loadAssets = function(sources, onLoad) {
	    var info;
	    info = this.blankInfo;
	    sources.forEach((function(_this) {
	      return function(src) {
	        if (_this.assets[src] != null) {
	          return info.loadedFromCache++;
	        } else if (_this.loadingAssets[src]) {
	          info.loadedAsynchronously++;
	          return info.alreadyLoadingAsynchronously++;
	        } else {
	          info.loadedAsynchronously++;
	          _this.loadingAssets[src] = true;
	          return _this.loadFunction(src, function(src, asset) {
	            return _this.addAsset(src, asset);
	          });
	        }
	      };
	    })(this));
	    this.addLoaderListener(sources, onLoad, info);
	    return nextTick((function(_this) {
	      return function() {
	        return _this.notifyListeners();
	      };
	    })(this));
	  };

	  BatchLoader.prototype.addLoaderListener = function(sources, onLoad, info) {
	    this.loadingListeners || (this.loadingListeners = []);
	    return this.loadingListeners.push({
	      sources: sources,
	      onLoad: onLoad,
	      info: info
	    });
	  };

	  BatchLoader.prototype.notifyListeners = function() {
	    var allLoaded, i, j, len, len1, listener, oldloadingListeners, ref, source;
	    if (!this.loadingListeners) {
	      return;
	    }
	    oldloadingListeners = this.loadingListeners;
	    this.loadingListeners = [];
	    for (i = 0, len = oldloadingListeners.length; i < len; i++) {
	      listener = oldloadingListeners[i];
	      allLoaded = true;
	      ref = listener.sources;
	      for (j = 0, len1 = ref.length; j < len1; j++) {
	        source = ref[j];
	        if (!this.assets[source]) {
	          allLoaded = false;
	        }
	      }
	      if (allLoaded) {
	        listener.onLoad(this.assets, listener.sources, listener.info);
	      } else {
	        this.loadingListeners.push(listener);
	      }
	    }
	    return this.loadingListeners;
	  };

	  return BatchLoader;

	})(BaseObject);


/***/ },
/* 96 */
/***/ function(module, exports) {

	
	/*
	A core set of status-codes that code can reason about easily.

	Goal:

	  Minimal set of codes so APIs can reason about network requests in a
	  consistant way.

	Why not HTTP Status codes?

	  They cover so much, most of which automatic code cannot do anything about
	  other than report an error, possibly to be viewed by a human later.

	My strategy is to have a small, simple set of status codes for our programs to
	reason about, and, if necessary, allow the communication channel to return
	additional information in the form of a 'message' that humans can look at to
	get more information about any failures.

	Note, these status-codes are used at the core of other Art Libs:

	  ArtFlux
	  ArtEry

	Possible additional statuses to add:

	  (only add if we have a very good use-case that requires it)

	  temporaryFailure: code can retry in a bit and it might work then

	  redirect: request can only be fulfilled at the new location

	    Note, I don't think we should have different statuses for all the  various
	    redirect semantics. It's up to the API to determine if a redirect is
	    temporary or permanent. I could imagine an API which returns a
	    redirectAddress  string as well as a connonicalAddress.
	 */
	var CommunicationStatus;

	module.exports = CommunicationStatus = (function() {
	  function CommunicationStatus() {}


	  /*
	  status: success
	  
	  * An unqualified success.
	  * I guess it could be qualified, with additional information in another field,
	    but the 'expected' data should be present.
	   */

	  CommunicationStatus.success = "success";


	  /*
	  status: pending
	  
	  * The request is proceeding.
	  * No errors so far.
	   */

	  CommunicationStatus.pending = "pending";


	  /*
	  status: missing
	  
	  * The request was properly formatted.
	  * There were no network errors.
	  * There were no server errors.
	  * The only problem is the server could not find the requested resource.
	   */

	  CommunicationStatus.missing = "missing";


	  /*
	  status: failure
	  
	  * All network and server errors.
	  * Provide additional information in 'message' or 'error' parameter.
	   */

	  CommunicationStatus.failure = "failure";


	  /*
	  OUT: true if status is a valid status-string
	   */

	  CommunicationStatus.validStatus = function(status) {
	    return CommunicationStatus[status] === status;
	  };

	  return CommunicationStatus;

	})();


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, Epoch, Foundation, Promise, StandardLib, evalAndThrowErrorsOutOfStack, inspect, requestAnimationFrame,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	Foundation = __webpack_require__(21);

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	BaseObject = ClassSystem.BaseObject;

	inspect = StandardLib.inspect, Promise = StandardLib.Promise, requestAnimationFrame = StandardLib.requestAnimationFrame, evalAndThrowErrorsOutOfStack = StandardLib.evalAndThrowErrorsOutOfStack;

	module.exports = Epoch = (function(superClass) {
	  extend(Epoch, superClass);

	  function Epoch(options) {
	    if (options == null) {
	      options = {};
	    }
	    Epoch.__super__.constructor.apply(this, arguments);
	    this._emptyQueueAfterProcessing = !!options.emptyQueueAfterProcessing;
	    this._queuedItems = [];
	    this._nextReadyQueue = [];
	    this._epochQueued = false;
	    this._processingEpoch = false;
	    this._epochCount = 0;
	    this._frameSecond = 0;
	  }

	  Epoch.getter("processingEpoch epochQueued epochCount emptyQueueAfterProcessing frameSecond", {
	    epochLength: function() {
	      return this._queuedItems.length;
	    }
	  });

	  Epoch.prototype.updateGlobalCounts = function() {
	    Foundation.globalCount(this["class"].name + "_queuedItems", this._queuedItems.length);
	    return Foundation.globalCount(this["class"].name + "_nextReadyQueue", this._nextReadyQueue.length);
	  };


	  /*
	  This guarantess there will be a next "ready" event.
	  If there were no setStates this epoch, then there won't be a next "ready" - unless you use this method.
	  
	  IN:
	    f: an optional function to invoke on-next-ready
	      mostly this is provided as a shortcut:
	        @onNextReady =>
	      is directly equivelent to:
	        @onNextReady().then =>
	  
	  OUT: promise.then (result of calling f() or null if no f) ->
	   */

	  Epoch.prototype.onNextReady = function(f, forceNextEpoch, passThroughArgument) {
	    if (forceNextEpoch == null) {
	      forceNextEpoch = true;
	    }
	    if (forceNextEpoch && !this._processingEpoch) {
	      this.queueNextEpoch();
	    }
	    return new Promise((function(_this) {
	      return function(resolve) {
	        return _this._nextReadyQueue.push(function() {
	          return resolve(f ? f(passThroughArgument) : passThroughArgument);
	        });
	      };
	    })(this));
	  };

	  Epoch.prototype._ready = function() {
	    var f, i, len, nrq, results;
	    if (!((nrq = this._nextReadyQueue).length > 0)) {
	      return;
	    }
	    this._nextReadyQueue = [];
	    results = [];
	    for (i = 0, len = nrq.length; i < len; i++) {
	      f = nrq[i];
	      results.push(evalAndThrowErrorsOutOfStack((function(_this) {
	        return function() {
	          return f();
	        };
	      })(this)));
	    }
	    return results;
	  };

	  Epoch.prototype.queueItem = function(item) {
	    if (item) {
	      this._queuedItems.push(item);
	      this.queueNextEpoch();
	    }
	    return item;
	  };

	  Epoch.prototype.isItemQueued = function(item) {
	    return indexOf.call(this._queuedItems, item) >= 0;
	  };

	  Epoch.prototype.queueNextEpoch = function() {
	    if (!this._epochQueued) {
	      this._epochQueued = true;
	      return requestAnimationFrame((function(_this) {
	        return function(frameTimeMs) {
	          _this._frameSecond = frameTimeMs / 1000;
	          _this._epochQueued = false;
	          return _this.processEpoch();
	        };
	      })(this));
	    }
	  };

	  Epoch.prototype.flushEpochNow = function() {
	    return this.processEpoch();
	  };

	  Epoch.prototype.processEpoch = function() {
	    var items;
	    this._processingEpoch = true;
	    items = this._queuedItems;
	    if (this._emptyQueueAfterProcessing) {
	      this.processEpochItemsWithErrorHandling(items);
	      this._queuedItems = [];
	    } else {
	      this._queuedItems = [];
	      this.processEpochItemsWithErrorHandling(items);
	    }
	    this._processingEpoch = false;
	    this._epochCount++;
	    return this._ready();
	  };

	  Epoch.prototype.processEpochItemsWithErrorHandling = function(items) {
	    return evalAndThrowErrorsOutOfStack((function(_this) {
	      return function() {
	        return _this.processEpochItems(items);
	      };
	    })(this));
	  };

	  Epoch.prototype.processEpochItems = function(items) {
	    var i, item, len, results;
	    results = [];
	    for (i = 0, len = items.length; i < len; i++) {
	      item = items[i];
	      results.push(item());
	    }
	    return results;
	  };

	  return Epoch;

	})(BaseObject);


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var defineModule, fastBind, isFunction, log, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	ref = __webpack_require__(24), defineModule = ref.defineModule, isFunction = ref.isFunction, fastBind = ref.fastBind, log = ref.log;

	defineModule(module, function() {
	  return function(superClass) {
	    var InstanceFunctionBindingMixin;
	    return InstanceFunctionBindingMixin = (function(superClass1) {
	      extend(InstanceFunctionBindingMixin, superClass1);

	      function InstanceFunctionBindingMixin() {
	        return InstanceFunctionBindingMixin.__super__.constructor.apply(this, arguments);
	      }

	      InstanceFunctionBindingMixin.getFunctionsToBindList = function() {
	        if (this.hasOwnProperty("_functionsToBindList")) {
	          return this._functionsToBindList;
	        } else {
	          return this._functionsToBindList = this.getFunctionsToBindList();
	        }
	      };

	      InstanceFunctionBindingMixin.getFunctionsToBindList = function() {
	        var k, ref1, results, v;
	        ref1 = this.prototype;
	        results = [];
	        for (k in ref1) {
	          v = ref1[k];
	          if (k !== "constructor" && isFunction(v) && this.propertyIsConcrete(k) && (!this.nonBindingFunctions || indexOf.call(this.nonBindingFunctions, k) < 0)) {
	            results.push(k);
	          }
	        }
	        return results;
	      };

	      InstanceFunctionBindingMixin.prototype.getBoundFunctionList = function() {
	        return this._boundFunctionList;
	      };

	      InstanceFunctionBindingMixin.prototype.bindFunctionsToInstance = function() {
	        var functionsToBindList, i, j, k, len, len1, prototype, ref1;
	        functionsToBindList = this["class"].getFunctionsToBindList();
	        if (this._boundFunctionList) {
	          ref1 = this._boundFunctionList;
	          for (i = 0, len = ref1.length; i < len; i++) {
	            k = ref1[i];
	            if (indexOf.call(functionsToBindList, k) < 0) {
	              delete this[k];
	            }
	          }
	        }
	        prototype = this["class"].prototype;
	        for (j = 0, len1 = functionsToBindList.length; j < len1; j++) {
	          k = functionsToBindList[j];
	          this[k] = fastBind(prototype[k], this);
	        }
	        return this._boundFunctionList = functionsToBindList;
	      };

	      return InstanceFunctionBindingMixin;

	    })(superClass);
	  };
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	var AsyncLocalStorage, BaseObject, ClassSystem, JsonStore, Promise, isNumber, log, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(24), log = ref.log, Promise = ref.Promise, isNumber = ref.isNumber;

	ClassSystem = __webpack_require__(75);

	AsyncLocalStorage = __webpack_require__(92);

	BaseObject = ClassSystem.BaseObject;

	module.exports = JsonStore = (function(superClass) {
	  extend(JsonStore, superClass);

	  function JsonStore(store) {
	    if (store == null) {
	      store = AsyncLocalStorage;
	    }
	    this.store = store;
	  }

	  JsonStore.prototype.setItem = function(k, v) {
	    return Promise.then((function(_this) {
	      return function() {
	        return _this.store.setItem(k, JSON.stringify(v));
	      };
	    })(this));
	  };

	  JsonStore.prototype.getItem = function(k) {
	    return Promise.resolve(this.store.getItem(k)).then((function(_this) {
	      return function(v) {
	        return JSON.parse(v);
	      };
	    })(this));
	  };

	  JsonStore.prototype.removeItem = function(k) {
	    return Promise.then((function(_this) {
	      return function() {
	        return _this.store.removeItem(k);
	      };
	    })(this));
	  };

	  JsonStore.prototype.clear = function() {
	    return Promise.then((function(_this) {
	      return function() {
	        return _this.store.clear();
	      };
	    })(this));
	  };

	  JsonStore.prototype.key = function(i) {
	    return Promise.then((function(_this) {
	      return function() {
	        return _this.store.key(i);
	      };
	    })(this));
	  };

	  JsonStore.prototype.getLength = function() {
	    return Promise.then((function(_this) {
	      return function() {
	        if (isNumber(_this.store.length)) {
	          return _this.store.length;
	        } else {
	          return _this.store.getLength();
	        }
	      };
	    })(this));
	  };

	  return JsonStore;

	})(BaseObject);


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	var Promise, RestClient, StandardLib, isNumber, log, merge, present, timeout;

	StandardLib = __webpack_require__(24);

	present = StandardLib.present, Promise = StandardLib.Promise, merge = StandardLib.merge, isNumber = StandardLib.isNumber, timeout = StandardLib.timeout, log = StandardLib.log;

	module.exports = RestClient = (function() {
	  function RestClient() {}

	  RestClient.legalVerbs = {
	    get: "GET",
	    GET: "GET",
	    put: "PUT",
	    PUT: "PUT",
	    post: "POST",
	    POST: "POST",
	    "delete": "DELETE",
	    DELETE: "DELETE"
	  };


	  /*
	  get/put/post/delete
	  
	  IN:
	    url: valid url string
	  
	    data: (only on PUT/POST requests)
	      data to send
	      NOTE: must be null if using formData
	  
	    options:
	  
	      formData: plain object of key-value pairs to submit as form-data
	        You can even use this for "get" requests.
	        NOTE: "data" must be null if using "formData"
	  
	      headers: plain object of additional HTTP headers to set
	  
	      onProgress: (restRequestStatus) -> null
	        called each time progress is made
	        NOTE: restRequestStatus.progress contains a 0-to-1 number that indicates how much progress has been made.
	          progress indicates DOWNLOAD progress for GET requests and UPLOAD progress for all others.
	  
	      responseType: "arraybuffer", "blob", "document", "json", or "text"
	        default: "text"
	        NOTE: "json" is handled manually since IE11 and iOS7 don't support the "json" option.
	        https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
	  
	  OUT: Promise:
	    resolved: (responseData) ->
	    rejected: (restRequestStatus) ->
	  
	  responseData:
	    a String, or the type specified by the responseType option
	  
	  restRequestStatus:
	    event:    # the HTML event object
	    request:  # the XMLHttpRequest
	    options:  # the restRequest options: verb, url, data, headers, onProgress, responseType, formData
	    status:   # the HTML status code, if the request completed
	    response: # responseData
	    error:    # Error object or string-explaination of why the request was rejected
	    progress:
	      a value between 0 and 1
	      If the progress is indeterminant, this is 0
	      If this isn't an onProgress event, this is the amount of progress
	      that was made up to the point of the event.
	   */

	  RestClient.get = function(url, options) {
	    return RestClient.restRequest(merge(options, {
	      verb: "GET",
	      url: url
	    }));
	  };

	  RestClient.put = function(url, data, options) {
	    return RestClient.restRequest(merge(options, {
	      verb: "PUT",
	      url: url,
	      data: data
	    }));
	  };

	  RestClient.post = function(url, data, options) {
	    return RestClient.restRequest(merge(options, {
	      verb: "POST",
	      url: url,
	      data: data
	    }));
	  };

	  RestClient["delete"] = function(url, options) {
	    return RestClient.restRequest(merge(options, {
	      verb: "DELETE",
	      url: url
	    }));
	  };

	  RestClient.getArrayBuffer = function(url, options) {
	    return this.get(url, merge(options, {
	      responseType: "arraybuffer"
	    }));
	  };


	  /*
	  get/put/post/deleteJson
	  
	  same as get/put/post/delete above
	  
	  except:
	    sent data should be plain objects which are JSON.stringified
	    response data is automatically JSON.parsed
	  
	    additional options are set:
	      responseType: "json"
	      headers:      Accept: 'application/json'
	   */

	  RestClient.getJson = function(url, options) {
	    return RestClient.restJsonRequest(merge(options, {
	      verb: "get",
	      url: url
	    }));
	  };

	  RestClient.deleteJson = function(url, options) {
	    return RestClient.restJsonRequest(merge(options, {
	      verb: "delete",
	      url: url
	    }));
	  };

	  RestClient.putJson = function(url, data, options) {
	    return RestClient.restJsonRequest(merge(options, {
	      verb: "put",
	      url: url,
	      data: data
	    }));
	  };

	  RestClient.postJson = function(url, data, options) {
	    return RestClient.restJsonRequest(merge(options, {
	      verb: "post",
	      url: url,
	      data: data
	    }));
	  };


	  /*
	  IN:
	    options:
	      verb: "GET", "PUT", "POST"
	      method: alias for verb
	  
	      data: data to restRequest - passed to xmlHttpRequest.restRequest
	  
	      plus all the options for get/put/post listed above
	      showProgressAfter: milliseconds (default: 100)
	        only show progress after # milliseconds
	  
	      onProgress: (requestStatus) ->
	        see "All callbacks" below for details about inputs.
	        Note that onProgress is triggered a little differently than
	        the normal XMLHttpRequest progress events:
	          - it will only be called after showProgressAfter ms
	          - it is guaranteed to be called after showProgressAfter ms if the request hasn't completed
	          - if the request completes before showProgressAfter ms, it will never be called
	  
	  OUT: see get/put/post above
	  
	  All callbacks look like this: (requestStatus) ->
	    requestStatus:
	      request:  XMLHttpRequest
	      progress: number # between 0 and 1
	      options:  options # passed-in options object
	      event:    the most recent event
	      response: # the processed response data, if ready
	      error:    # if any
	      status:   number # HTTP status code, if the request is complete
	  
	  EFFECT:
	   */

	  RestClient.restRequest = function(options) {
	    var data, formData, headers, k, method, onProgress, responseType, showProgressAfter, specifiedVerb, url, v, verb;
	    verb = options.verb, method = options.method, url = options.url, data = options.data, headers = options.headers, onProgress = options.onProgress, responseType = options.responseType, formData = options.formData, showProgressAfter = options.showProgressAfter;
	    if (!isNumber(showProgressAfter)) {
	      showProgressAfter = 100;
	    }
	    verb || (verb = method);
	    if (!(verb = RestClient.legalVerbs[specifiedVerb = verb])) {
	      throw new Error("invalid verb: " + specifiedVerb);
	    }
	    if (formData) {
	      if (data) {
	        throw new Error("can't specify both 'data' and 'formData'");
	      }
	      data = new FormData;
	      for (k in formData) {
	        v = formData[k];
	        data.append(k, v);
	      }
	    } else {
	      data = (data != null ? typeof data.toArrayBuffer === "function" ? data.toArrayBuffer() : void 0 : void 0) || data;
	    }
	    return new Promise(function(resolve, reject) {
	      var getResponse, initialProgressCalled, lastProgressEvent, progressCallbackInternal, request, requestResolved, rescuedGetResponse, restRequestStatus;
	      restRequestStatus = {
	        request: request = new XMLHttpRequest,
	        progress: 0,
	        options: options
	      };
	      rescuedGetResponse = function() {
	        try {
	          return getResponse();
	        } catch (error1) {
	          return request.response;
	        }
	      };
	      getResponse = function() {
	        var response;
	        response = request.response;
	        if (response && responseType === "json") {
	          return response = JSON.parse(response);
	        } else {
	          return response;
	        }
	      };
	      request.open(verb, url, true);
	      if (present(responseType) && responseType !== "json") {
	        request.responseType = responseType;
	      }
	      if (headers) {
	        for (k in headers) {
	          v = headers[k];
	          request.setRequestHeader(k, v);
	        }
	      }
	      requestResolved = false;
	      request.addEventListener("error", function(event) {
	        requestResolved = true;
	        return reject(merge(restRequestStatus, {
	          event: event,
	          response: rescuedGetResponse(),
	          error: "XMLHttpRequest triggered 'error' event"
	        }));
	      });
	      request.addEventListener("load", function(event) {
	        var error, status;
	        requestResolved = true;
	        status = request.status;
	        if ((status / 100 | 0) === 2) {
	          try {
	            return resolve(getResponse());
	          } catch (error1) {
	            error = error1;
	            return reject(merge(restRequestStatus, {
	              event: event,
	              status: status,
	              response: rescuedGetResponse(),
	              error: error
	            }));
	          }
	        } else {
	          return reject(merge(restRequestStatus, {
	            event: event,
	            status: status,
	            response: rescuedGetResponse(),
	            error: "response status was " + status
	          }));
	        }
	      });
	      if (onProgress) {
	        initialProgressCalled = showProgressAfter <= 0;
	        lastProgressEvent = null;
	        timeout(showProgressAfter, function() {
	          initialProgressCalled = true;
	          return progressCallbackInternal(lastProgressEvent || {});
	        });
	        progressCallbackInternal = function(event) {
	          var loaded, ref, total;
	          ref = lastProgressEvent = event, total = ref.total, loaded = ref.loaded;
	          if (initialProgressCalled && !requestResolved) {
	            return typeof onProgress === "function" ? onProgress(restRequestStatus = merge(restRequestStatus, {
	              event: event,
	              progress: total > 0 ? loaded / total : 0
	            })) : void 0;
	          }
	        };
	        if (verb === "GET") {
	          request.addEventListener("progress", progressCallbackInternal);
	        } else {
	          request.upload.addEventListener("progress", progressCallbackInternal);
	        }
	      }
	      return request.send(data);
	    });
	  };

	  RestClient.restJsonRequest = function(options) {
	    return this.restRequest(merge(options, {
	      responseType: "json",
	      headers: merge({
	        Accept: 'application/json'
	      }, options != null ? options.headers : void 0),
	      data: (options != null ? options.data : void 0) && JSON.stringify(options.data)
	    }));
	  };

	  return RestClient;

	})();


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, Map, SingleObjectTransaction, StandardLib, cloneByStructure, eq, inspect, removeFirstMatch, rubyTrue,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	Map = StandardLib.Map, cloneByStructure = StandardLib.cloneByStructure, removeFirstMatch = StandardLib.removeFirstMatch, eq = StandardLib.eq, inspect = StandardLib.inspect, rubyTrue = StandardLib.rubyTrue;

	BaseObject = ClassSystem.BaseObject;

	module.exports = SingleObjectTransaction = (function(superClass) {
	  var setValues;

	  extend(SingleObjectTransaction, superClass);

	  function SingleObjectTransaction(a) {
	    var options;
	    SingleObjectTransaction.__super__.constructor.apply(this, arguments);
	    this.object = (function() {
	      if (a.constructor === Array) {
	        if (a.length !== 2) {
	          throw new Error("new SingleObjectTransaction: expected length-2 array like: [obj, optionsMap]");
	        }
	        this.options = a[1];
	        return a[0];
	      } else {
	        this.options = {};
	        return a;
	      }
	    }).call(this);
	    if (this.object == null) {
	      throw new Error("object must not be null or undefined");
	    }
	    this.props = [];
	    this.from = {};
	    options = this.options;
	    if (options.properties) {
	      this.addProperties(options.properties);
	    }
	    if (options.property) {
	      this.addProp(options.property);
	    }
	    if (options.from) {
	      this.addFromValues(options.from);
	    }
	    if (options.to) {
	      this.addToValues(options.to);
	    }
	  }

	  SingleObjectTransaction.prototype.toString = function() {
	    return (inspect(this.object, 0)) + " from:" + (inspect(this.from, 1)) + " to:" + (inspect(this.to, 1));
	  };

	  SingleObjectTransaction.prototype.inspect = function(inspector) {
	    var i, k, len, ref, results;
	    if (!inspector) {
	      return ClassSystem.Inspect.inspect(this);
	    }
	    inspector.put(this.object.classPathName + ":");
	    ref = this.props;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      k = ref[i];
	      inspector.put("\n    " + k + ": ");
	      if (rubyTrue(this.from && this.from[k])) {
	        inspector.inspect(this.from[k], 1);
	      }
	      inspector.put(" ... ");
	      if (rubyTrue(this.to && this.to[k])) {
	        results.push(inspector.inspect(this.to[k], 1));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };

	  SingleObjectTransaction.getter({
	    properties: function() {
	      return this.props;
	    },
	    hasToValues: function() {
	      return !!this.to;
	    },
	    valuesChanged: function() {
	      var fromValue, k, ref, toValue;
	      ref = this.from;
	      for (k in ref) {
	        fromValue = ref[k];
	        toValue = this.to[k];
	        if (!eq(fromValue, toValue)) {
	          return true;
	        }
	      }
	      return false;
	    }
	  });

	  SingleObjectTransaction.prototype.addFromValues = function(from) {
	    var base, k, v;
	    for (k in from) {
	      v = from[k];
	      this.addProp(k);
	      this.from[k] = v;
	    }
	    return typeof (base = this.object).preprocessProperties === "function" ? base.preprocessProperties(this.from) : void 0;
	  };

	  SingleObjectTransaction.prototype.addToValues = function(to) {
	    var base, k, v;
	    this.to || (this.to = {});
	    for (k in to) {
	      v = to[k];
	      this.addProp(k);
	      this.to[k] = v;
	    }
	    return typeof (base = this.object).preprocessProperties === "function" ? base.preprocessProperties(this.to) : void 0;
	  };

	  SingleObjectTransaction.prototype.addProperties = function(props) {
	    var i, len, prop, results, results1, v;
	    if (props.constructor === Array) {
	      results = [];
	      for (i = 0, len = props.length; i < len; i++) {
	        prop = props[i];
	        results.push(this.addProp(prop));
	      }
	      return results;
	    } else {
	      results1 = [];
	      for (prop in props) {
	        v = props[prop];
	        results1.push(this.addProp(prop));
	      }
	      return results1;
	    }
	  };

	  SingleObjectTransaction.prototype.addProp = function(propName) {
	    if (indexOf.call(this.props, propName) < 0) {
	      return this.props.push(propName);
	    }
	  };

	  SingleObjectTransaction.prototype.deleteProp = function(propName) {
	    removeFirstMatch(this.props, propName);
	    delete this.from[propName];
	    return delete this.to[propName];
	  };

	  SingleObjectTransaction.prototype.saveValues = function(saveTo) {
	    var getterName, i, len, metaProperties, prop, ref, ref1, value;
	    this.clearOptimizations();
	    metaProperties = this.object.metaProperties;
	    ref = this.props;
	    for (i = 0, len = ref.length; i < len; i++) {
	      prop = ref[i];
	      if (!saveTo.hasOwnProperty(prop)) {
	        value = saveTo[prop] = cloneByStructure((getterName = metaProperties != null ? (ref1 = metaProperties[prop]) != null ? ref1.getterName : void 0 : void 0) ? this.object[getterName]() : this.object[prop]);
	      }
	    }
	    return null;
	  };

	  SingleObjectTransaction.prototype.saveFromValues = function() {
	    return this.saveValues(this.from || (this.from = {}));
	  };

	  SingleObjectTransaction.prototype.saveToValues = function() {
	    return this.saveValues(this.to || (this.to = {}));
	  };

	  SingleObjectTransaction._setValues = setValues = function(o, values, f) {
	    var metaProperties, prop, ref, setterName, v;
	    metaProperties = o.metaProperties;
	    for (prop in values) {
	      v = values[prop];
	      if (f) {
	        v = f(prop, v);
	      }
	      if (setterName = metaProperties != null ? (ref = metaProperties[prop]) != null ? ref.setterName : void 0 : void 0) {
	        o[setterName](v);
	      } else {
	        o[prop] = v;
	      }
	    }
	    return null;
	  };

	  SingleObjectTransaction.prototype.rollBack = function() {
	    return setValues(this.object, this.from);
	  };

	  SingleObjectTransaction.prototype.rollForward = function() {
	    return setValues(this.object, this.to);
	  };

	  SingleObjectTransaction.prototype.clearOptimizations = function() {
	    return this.numberDeltas = this.interpolateToObjects = null;
	  };

	  SingleObjectTransaction.prototype.optimizeInterpolation = function() {
	    var field, from, ref, results, to;
	    this.numberDeltas = {};
	    this.interpolateToObjects = {};
	    this.nonInterpolatingFields = {
	      to: {},
	      from: {}
	    };
	    ref = this.from;
	    results = [];
	    for (field in ref) {
	      from = ref[field];
	      to = this.to[field];
	      if (typeof from === "number") {
	        results.push(this.numberDeltas[field] = to - from);
	      } else if (typeof (from != null ? from.interpolate : void 0) === "function") {
	        results.push(this.interpolateToObjects[field] = to);
	      } else {
	        this.nonInterpolatingFields.from[field] = from;
	        results.push(this.nonInterpolatingFields.to[field] = to);
	      }
	    }
	    return results;
	  };

	  SingleObjectTransaction.prototype.interpolateNumberFields = function(p) {
	    return setValues(this.object, this.numberDeltas, (function(_this) {
	      return function(field, delta) {
	        return _this.from[field] + delta * p;
	      };
	    })(this));
	  };

	  SingleObjectTransaction.prototype.interpolateObjectFields = function(p) {
	    var e;
	    try {
	      return setValues(this.object, this.interpolateToObjects, (function(_this) {
	        return function(field, toObject) {
	          return _this.from[field].interpolate(toObject, p);
	        };
	      })(this));
	    } catch (error) {
	      e = error;
	      this.log("Art.Foundation.Transaction#interpolateObjectFields(p=" + p + "): error " + e + " deltas: " + (inspect(this.interpolateToObjects)) + " from:   " + (inspect(this.from)) + " to:     " + (inspect(this.to)));
	      throw e;
	    }
	  };

	  SingleObjectTransaction.prototype.setNonInterpolatingFields = function(p) {
	    return setValues(this.object, this.nonInterpolatingFields[p >= 1 ? "to" : "from"]);
	  };

	  SingleObjectTransaction.prototype.interpolate = function(p) {
	    if (!this.numberDeltas) {
	      this.optimizeInterpolation();
	    }
	    this.interpolateNumberFields(p);
	    this.interpolateObjectFields(p);
	    return this.setNonInterpolatingFields(p);
	  };

	  SingleObjectTransaction.getter({
	    noChanges: function() {
	      return this.props.length === 0;
	    }
	  });

	  SingleObjectTransaction.prototype.optimizeProperties = function() {
	    var i, len, prop, ref, results;
	    this.clearOptimizations();
	    ref = this.props;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      prop = ref[i];
	      if (!this.from.hasOwnProperty(prop) || !this.to.hasOwnProperty(prop) || eq(this.from[prop], this.to[prop])) {
	        results.push(this.deleteProp(prop));
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };

	  return SingleObjectTransaction;

	})(BaseObject);


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, StandardLib, Stat, inspect, max, min, round,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	BaseObject = ClassSystem.BaseObject;

	min = StandardLib.min, max = StandardLib.max, round = StandardLib.round, inspect = StandardLib.inspect;

	module.exports = Stat = (function(superClass) {
	  extend(Stat, superClass);

	  function Stat() {
	    this.reset();
	  }

	  Stat.prototype.reset = function() {
	    this.values = [];
	    this.sum = 0;
	    return this.max = this.min = null;
	  };

	  Stat.getter({
	    length: function() {
	      return this.values.length;
	    },
	    average: function() {
	      return this.sum / this.values.length;
	    },
	    median: function() {
	      return this.values.slice().sort()[this.length / 2 | 0];
	    }
	  });

	  Stat.prototype.percential = function(zeroToOneHundred) {
	    var i, sorted;
	    i = ((this.length - 1) * zeroToOneHundred / 100) | 0;
	    sorted = this.values.slice().sort(function(v1, v2) {
	      return v2 - v1;
	    });
	    return sorted[i];
	  };

	  Stat.prototype.histogram = function(divisions, min, max) {
	    var bin, delta, hist, j, k, len, mul, ref, ref1, v;
	    if (min == null) {
	      min = this.min;
	    }
	    if (max == null) {
	      max = this.max;
	    }
	    delta = max - min;
	    mul = divisions / delta;
	    hist = {};
	    for (v = j = 0, ref = divisions; j < ref; v = j += 1) {
	      hist[min + v / mul] = 0;
	    }
	    ref1 = this.values;
	    for (k = 0, len = ref1.length; k < len; k++) {
	      v = ref1[k];
	      bin = (v - min) * mul | 0;
	      if (bin < 0) {
	        bin = 0;
	      }
	      if (bin >= divisions) {
	        bin = divisions - 1;
	      }
	      hist[min + bin / mul]++;
	    }
	    return hist;
	  };

	  Stat.prototype.toString = function() {
	    return inspect({
	      length: this.length,
	      average: this.average,
	      median: this.median,
	      min: this.min,
	      max: this.max
	    });
	  };

	  Stat.prototype.toInfoMap = function() {
	    return {
	      length: this.length,
	      average: this.average,
	      median: this.median,
	      min: this.min,
	      max: this.max,
	      p90: this.percential(90),
	      p95: this.percential(95),
	      p99: this.percential(99)
	    };
	  };

	  Stat.prototype.toIntInfoMap = function() {
	    return {
	      length: this.length,
	      average: round(this.average),
	      median: round(this.median),
	      min: round(this.min),
	      max: round(this.max),
	      p90: round(this.percential(90)),
	      p95: round(this.percential(95)),
	      p99: round(this.percential(99))
	    };
	  };

	  Stat.prototype.toIntString = function() {
	    return inspect(this.toIntInfoMap());
	  };

	  Stat.prototype.add = function(v) {
	    this.values.push(v);
	    this.sum += v;
	    if (this.values.length === 1) {
	      return this.max = this.min = v;
	    } else {
	      this.max = max(this.max, v);
	      return this.min = min(this.min, v);
	    }
	  };

	  return Stat;

	})(BaseObject);


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	Transaction provides a manual, yet easy way to log the before and after values
	of fields over many objects.

	It is "manual" in that you must:

	  Pre-specify all objects you wish to track.
	  Specify the properties you wish to track for all objects and/or uniquely for each object.
	  Pass in the "from" values or call saveFromValues
	  Pass in the "to" values or call saveToValues

	Once you have capture the "from" and "to" values of the transaction, you can:

	  rollBack and set all properties to their "from" values
	  rollForward and set all properties to their "to" values
	  interpolate(p) and set all properties to their linearly interpolated value
	    between their saved "from" (p=0) and "to" (p=1) values.
	    If you use interpolate:
	      to/from values should be pair-wise the same type
	      only to/from values of the following types will be interpolated:
	        numbers
	        objects implementing: a.add(b), a.sub(b) and a.mul(number)
	      Non-interpolatable types are handled as follows:
	        switch p
	          when 0 then set to "from" values
	          when 1 then set to "to" values
	          else left unchanged

	Example initializers:

	   * example-a: track obj's "foo" and "bar" properties
	  new Transaction obj, properties: ["foo", "bar"]

	   * same as example-a, but also initialize obj's from-values as obj.foo=1 and obj.bar=2
	  new Transaction obj, from: foo:1, bar:2

	   * same as example-a, but also initialize obj's to-values as obj.foo=1 and obj.bar=2
	  new Transaction obj, to: foo:1, bar:2

	   * track obj1 and obj2's "foo" and "bar" properties
	  new Transaction [obj1, obj2], properties: ["foo", "bar"]

	   * track:
	   *   obj1's foo, bar, noo and mar properties, with both from and to values initialized
	   *   obj2's goo, har, noo and mar properties, with both from and to values initialized
	  new Transaction [
	      [obj1,
	        from: foo:1, bar:2
	        to:   foo:2, bar:3
	      ],
	      [obj2,
	        from: goo:1, har:2
	        to:   goo:2, har:3
	      ]
	    ],
	    from: noo:4, mar:5
	    to:   noo:4, mar:5
	 */
	var BaseObject, ClassSystem, Map, SingleObjectTransaction, StandardLib, Transaction, cloneByStructure, eq, inspect, rubyTrue,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	SingleObjectTransaction = __webpack_require__(101);

	rubyTrue = StandardLib.rubyTrue, eq = StandardLib.eq, inspect = StandardLib.inspect, Map = StandardLib.Map, cloneByStructure = StandardLib.cloneByStructure;

	BaseObject = ClassSystem.BaseObject;

	module.exports = Transaction = (function(superClass) {
	  extend(Transaction, superClass);

	  Transaction.SingleObjectTransaction = SingleObjectTransaction;

	  function Transaction(objects, options) {
	    if (options == null) {
	      options = {};
	    }
	    Transaction.__super__.constructor.apply(this, arguments);
	    this._objects = new Map;
	    if (objects.constructor === Array) {
	      this.addObjects(objects);
	    } else {
	      this.addObject(objects);
	    }
	    if (options.properties) {
	      this.addProperties(options.properties);
	    }
	    if (options.property) {
	      this.addProperties([options.property]);
	    }
	    if (options.from) {
	      this.addFromValues(options.from);
	    }
	    if (options.to) {
	      this.addToValues(options.to);
	    }
	    this.saveFromValues();
	  }

	  Transaction.prototype.inspect = function(inspector) {
	    if (!inspector) {
	      return ClassSystem.Inspect.inspect(this);
	    }
	    inspector.put(this.classPathName + ":");
	    return this.inspectParts(inspector);
	  };

	  Transaction.prototype.inspectParts = function(inspector) {
	    return this._objects.each((function(_this) {
	      return function(k, v) {
	        inspector.put("\n  ");
	        return inspector.inspect(v);
	      };
	    })(this));
	  };

	  Transaction.getter({
	    objects: function() {
	      return this._objects.keys;
	    }
	  });

	  Transaction.prototype.properties = function(obj) {
	    return this._objects.get(obj).properties;
	  };

	  Transaction.prototype.from = function(obj) {
	    return this._objects.get(obj).from;
	  };

	  Transaction.prototype.to = function(obj) {
	    return this._objects.get(obj).to;
	  };

	  Transaction.prototype.rollBack = function() {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.rollBack();
	      };
	    })(this));
	  };

	  Transaction.prototype.rollForward = function() {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.rollForward();
	      };
	    })(this));
	  };

	  Transaction.prototype.interpolate = function(p) {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.interpolate(p);
	      };
	    })(this));
	  };

	  Transaction.prototype.optimize = function() {
	    this.optimizeProperties();
	    return this.optimizeObjects();
	  };

	  Transaction.getter({
	    hasToValues: function() {
	      var result;
	      result = false;
	      this._objects.forEach((function(_this) {
	        return function(oi) {
	          if (oi.hasToValues) {
	            return result = true;
	          }
	        };
	      })(this));
	      return result;
	    },
	    valuesChanged: function() {
	      var result;
	      result = false;
	      this._objects.forEach((function(_this) {
	        return function(object) {
	          if (object.valuesChanged) {
	            return result = true;
	          }
	        };
	      })(this));
	      return result;
	    }
	  });

	  Transaction.prototype.toString = function() {
	    return (this.className + "\n  ") + (this._objects.map(function(obj, single) {
	      return single.toString();
	    })).join("  \n");
	  };

	  Transaction.prototype.addFromValues = function(from) {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.addFromValues(from);
	      };
	    })(this));
	  };

	  Transaction.prototype.addToValues = function(to) {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.addToValues(to);
	      };
	    })(this));
	  };

	  Transaction.prototype.addProperties = function(properties) {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.addProperties(properties);
	      };
	    })(this));
	  };

	  Transaction.prototype.addObject = function(obj) {
	    var oi;
	    oi = new SingleObjectTransaction(obj);
	    return this._objects.set(oi.object, oi);
	  };

	  Transaction.prototype.addObjects = function(objects) {
	    var i, len, obj, results;
	    results = [];
	    for (i = 0, len = objects.length; i < len; i++) {
	      obj = objects[i];
	      results.push(this.addObject(obj));
	    }
	    return results;
	  };

	  Transaction.prototype.saveFromValues = function() {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.saveFromValues();
	      };
	    })(this));
	  };

	  Transaction.prototype.saveToValues = function() {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.saveToValues();
	      };
	    })(this));
	  };

	  Transaction.prototype.optimizeProperties = function() {
	    return this._objects.forEach((function(_this) {
	      return function(oi) {
	        return oi.optimizeProperties();
	      };
	    })(this));
	  };

	  Transaction.prototype.optimizeObjects = function() {
	    var objs;
	    objs = this._objects;
	    this._objects = new Map;
	    return objs.forEach((function(_this) {
	      return function(oi) {
	        if (!oi.noChanges) {
	          return _this._objects.set(oi.object, oi);
	        }
	      };
	    })(this));
	  };

	  return Transaction;

	})(BaseObject);


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Promise, StandardLib, Validator, emailRegexp, formattedInspect, isBoolean, isHexColor, isId, isNumber, isPlainArray, isPlainObject, isString, log, merge, mergeIntoUnless, present, select, shallowClone, validStatus, w,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(24);

	merge = StandardLib.merge, log = StandardLib.log, BaseObject = StandardLib.BaseObject, shallowClone = StandardLib.shallowClone, isNumber = StandardLib.isNumber, isString = StandardLib.isString, isPlainObject = StandardLib.isPlainObject, isPlainArray = StandardLib.isPlainArray, Promise = StandardLib.Promise, isBoolean = StandardLib.isBoolean, formattedInspect = StandardLib.formattedInspect, present = StandardLib.present, select = StandardLib.select, emailRegexp = StandardLib.emailRegexp, mergeIntoUnless = StandardLib.mergeIntoUnless, w = StandardLib.w;

	validStatus = __webpack_require__(96).validStatus;


	/*
	NOTES:

	  validators are evaluated before preprocessors

	  preprocessors should NOT throw validation-related errors

	  TODO?: We could add postValidators to allow you to validate AFTER the preprocessor...

	USAGE:
	  new Validator validatorFieldsProps, options

	    IN:
	      validatorFieldsProps:
	        plain object with zero or more field-validations defined:
	          fieldName: fieldProps
	      options:
	        exclusive: true/false
	          if true, only fields listed in validatorFieldsProps are allowed.

	    fieldProps:
	      string or plainObject
	      string: selects fieldProps from one of the standard @fieldTypes (see below)
	      plainObject: (all fields are optional)

	        validate: (v) -> true/false
	          whenever this field is included in an update OR create operation,
	            validate() must return true
	          NOTE: is evaluated BEFORE preprocess

	        preprocess: (v1) -> v2
	          whenever this field is included in an update OR create operation,
	            after validation succeeds,
	            value = preprocess value

	        required: true/false/string
	          if true/string
	            when creating records, this field must be included
	          if string
	            fieldProps = merge fieldProps, fieldTypes[string]

	        present: true/false
	          if true
	            when creating records, this field must be include and 'present' (see Art.Foundation.present)

	        fieldType: string
	          fieldProps = merge fieldTypes[string], fieldProps

	        dataType: string
	          sepecify which of the standard Json data-types this field contains
	          This is not used by Validator itself, but is available for clients to reflect on field-types.
	          Must be one of the values in: @dataTypes

	        instanceof: class
	          in addition to passing validate(), if present, the value must also be an instance of the
	          specified class

	EXAMPLES:
	  new
	 */

	BaseObject = __webpack_require__(75).BaseObject;

	isId = function(v) {
	  return isString(v) && v.match(/^[-_a-z0-9]+$/i);
	};

	isHexColor = function(v) {
	  return isString(v) && v.match(/^#([a-f0-9]{3})|([a-f0-9]{6})/i);
	};

	module.exports = Validator = (function(superClass) {
	  var arrayDataType, booleanDataType, dataTypes, fieldTypes, k, normalizeDepricatedProps, normalizeFieldProps, normalizeFieldTypeProp, normalizeInstanceOfProp, normalizePlainObjectProps, numberDataType, objectDataType, preCreate, preCreateSync, stringDataType, v;

	  extend(Validator, superClass);


	  /*
	  @dataTypes only includes the Standard Json types:
	    except 'null':
	      no field has the type of 'null'
	      instead, it has some other type and can be 'null' unless it is 'required'
	   */

	  Validator.dataTypes = dataTypes = {
	    boolean: {
	      validate: function(a) {
	        return isBoolean(a);
	      }
	    },
	    number: {
	      validate: function(a) {
	        return isNumber(a);
	      }
	    },
	    string: {
	      validate: function(a) {
	        return isString(a);
	      }
	    },
	    object: {
	      validate: function(a) {
	        return isPlainObject(a);
	      }
	    },
	    array: {
	      validate: function(a) {
	        return isPlainArray(a);
	      }
	    }
	  };

	  booleanDataType = "boolean";

	  numberDataType = "number";

	  stringDataType = "string";

	  objectDataType = "object";

	  arrayDataType = "array";


	  /*
	  standard FieldType props:
	    validate: (v) -> true/false
	    preprocess: (v1) -> v2
	    required: true/false
	    dataType: one of @dataTypes, default: 'string'
	  
	  You can add your own, too, but they are ignored by this class.
	   */

	  Validator.fieldTypes = fieldTypes = {
	    boolean: {
	      dataType: booleanDataType
	    },
	    number: {
	      dataType: numberDataType
	    },
	    string: {},
	    object: {
	      dataType: objectDataType
	    },
	    array: {
	      dataType: arrayDataType
	    },
	    count: {
	      dataType: numberDataType
	    },
	    id: {
	      required: true,
	      validate: function(v) {
	        return isId(v);
	      }
	    },
	    date: {
	      validate: function(v) {
	        return isString(v) || (v instanceof Date);
	      },
	      preprocess: function(v) {
	        if (isString(v)) {
	          return new Date(v);
	        } else {
	          return v;
	        }
	      }
	    },
	    timestamp: {
	      dataType: numberDataType,
	      validate: function(v) {
	        return isNumber(v) || (v instanceof Date);
	      },
	      preprocess: function(v) {
	        if (v instanceof Date) {
	          return v - 0;
	        } else {
	          return v;
	        }
	      }
	    },
	    color: {
	      validate: function(v) {
	        return isHexColor(v);
	      }
	    },
	    email: {
	      validate: function(v) {
	        return isString(v) && v.trim().match(emailRegexp);
	      },
	      preprocess: function(v) {
	        return v.trim().toLowerCase();
	      }
	    },
	    url: {
	      validate: function(v) {
	        return isString(v) && v.match(urlRegexp);
	      },
	      preprocess: function(v) {
	        return normalizeUrl(v);
	      }
	    },
	    communicationStatus: {
	      validate: function(v) {
	        return validStatus(v);
	      }
	    },
	    trimmedString: {
	      validate: function(v) {
	        return isString(v);
	      },
	      preprocess: function(v) {
	        return v.trim();
	      }
	    }
	  };

	  for (k in fieldTypes) {
	    v = fieldTypes[k];
	    v.dataType || (v.dataType = stringDataType);
	    v.validate || (v.validate = dataTypes[v.dataType].validate);
	  }

	  normalizeInstanceOfProp = function(ft) {
	    var _instanceof, validate;
	    if (_instanceof = ft["instanceof"]) {
	      validate = ft.validate;
	      return merge(ft, {
	        validate: function(v) {
	          return (v instanceof _instanceof) && (!validate || validate(v));
	        }
	      });
	    } else {
	      return ft;
	    }
	  };

	  normalizePlainObjectProps = function(ft) {
	    var out, subObject;
	    out = null;
	    for (k in ft) {
	      v = ft[k];
	      if (isPlainObject(subObject = v)) {
	        if (!out) {
	          out = shallowClone(ft);
	        }
	        out[k] = true;
	        mergeIntoUnless(out, normalizePlainObjectProps(subObject));
	      }
	    }
	    return out || ft;
	  };

	  normalizeDepricatedProps = function(ft) {
	    if (ft.requiredPresent) {
	      throw new Error("DEPRICATED: requiredPresent. Use: present: true");
	    }
	    if (isString(ft.required)) {
	      throw new Error("DEPRICATED: required can no longer specifiy the field-type. Use: required: fieldType: myFieldTypeString OR 'required myFieldTypeString'");
	    }
	    if (isString(ft.present)) {
	      throw new Error("DEPRICATED: present can no longer specifiy the field-type. Use: present: fieldType: myFieldTypeString OR 'present myFieldTypeString'");
	    }
	    return ft;
	  };

	  normalizeFieldTypeProp = function(ft) {
	    if (ft.fieldType) {
	      return merge(normalizeFieldProps(ft.fieldType), ft);
	    } else {
	      return ft;
	    }
	  };

	  Validator.normalizeFieldProps = normalizeFieldProps = function(ft) {
	    var array, processed, string, strings, subFt;
	    ft = (function() {
	      var i, len, ref;
	      if (isPlainObject(ft)) {
	        return normalizeFieldTypeProp(normalizeInstanceOfProp(normalizeDepricatedProps(normalizePlainObjectProps(ft))));
	      } else if (isPlainArray(array = ft)) {
	        processed = (function() {
	          var i, len, results;
	          results = [];
	          for (i = 0, len = array.length; i < len; i++) {
	            ft = array[i];
	            results.push(normalizeFieldProps(ft));
	          }
	          return results;
	        })();
	        return merge.apply(null, processed);
	      } else if (isString(strings = ft)) {
	        ft = {};
	        ref = w(strings);
	        for (i = 0, len = ref.length; i < len; i++) {
	          string = ref[i];
	          if (subFt = fieldTypes[string]) {
	            mergeIntoUnless(ft, subFt);
	          } else {
	            ft[string] = true;
	          }
	        }
	        return ft;
	      } else {
	        throw new Error("fieldType must be a string or plainObject: " + (formattedInspect(ft)));
	      }
	    })();
	    return merge(fieldTypes[ft.fieldType], ft);
	  };

	  function Validator(fieldDeclarationMap, options) {
	    this._fieldProps = {};
	    this._requiredFieldsMap = {};
	    this.addFields(fieldDeclarationMap);
	    if (options) {
	      this.exclusive = options.exclusive, this.context = options.context;
	    }
	  }

	  Validator.property("exclusive");

	  Validator.prototype.addFields = function(fieldDeclarationMap) {
	    var field, fieldOptions;
	    for (field in fieldDeclarationMap) {
	      fieldOptions = fieldDeclarationMap[field];
	      fieldOptions = this._addField(field, fieldOptions);
	      if (fieldOptions.required) {
	        this._requiredFieldsMap[field] = void 0;
	      }
	    }
	    return null;
	  };


	  /*
	  IN:
	    fields: object with fields to validate OR Promise returning said object
	  
	  OUT:
	    promise.then (validatedPreprocessedFields) ->
	    .catch (validationFailureInfoObject) ->
	   */

	  Validator.prototype.preCreate = preCreate = function(fields, options) {
	    return Promise.resolve(fields).then((function(_this) {
	      return function(fields) {
	        return _this.preCreateSync(fields, options);
	      };
	    })(this));
	  };

	  Validator.prototype.validate = preCreate;


	  /*
	  IN:
	    fields: object with fields to validate OR Promise returning said object
	  
	  OUT:
	    promise.then (validatedPreprocessedFields) ->
	    .catch (validationFailureInfoObject) ->
	   */

	  Validator.prototype.preUpdate = function(fields, options) {
	    return Promise.resolve(fields).then((function(_this) {
	      return function(fields) {
	        return _this.preUpdateSync(fields, options);
	      };
	    })(this));
	  };

	  Validator.prototype.preCreateSync = preCreateSync = function(fields, options) {
	    var info, presentFieldsValid, requiredFieldsPresent, status;
	    requiredFieldsPresent = this.requiredFieldsPresent(fields);
	    presentFieldsValid = this.presentFieldsValid(fields);
	    if (requiredFieldsPresent && presentFieldsValid) {
	      return this.preprocessFields(fields);
	    } else {
	      status = !presentFieldsValid ? !requiredFieldsPresent ? "invalid and missing" : "invalid" : "missing";
	      info = {
	        validationFailure: ((options != null ? options.context : void 0) || this.context || "Validator") + ": create: field(s) are " + status
	      };
	      if (!presentFieldsValid) {
	        info.invalidFields = this.invalidFields(fields);
	      }
	      if (!requiredFieldsPresent) {
	        info.missingFields = this.missingFields(fields);
	      }
	      throw info;
	    }
	  };

	  Validator.prototype.validateSync = preCreateSync;

	  Validator.prototype.preUpdateSync = function(fields, options) {
	    if (this.presentFieldsValid(fields)) {
	      return this.preprocessFields(fields);
	    } else {
	      throw {
	        validationFailure: ((options != null ? options.context : void 0) || this.context || "Validator") + ": update: field(s) are invalid",
	        invalidFields: this.invalidFields(fields)
	      };
	    }
	  };

	  Validator.prototype.presentFieldValid = function(fields, fieldName) {
	    var fieldProps, validate, value;
	    if (fieldProps = this._fieldProps[fieldName]) {
	      validate = fieldProps.validate;
	      return !validate || ((value = fields[fieldName]) == null) || value === null || value === void 0 || validate(value);
	    } else {
	      return !this.exclusive;
	    }
	  };

	  Validator.prototype.requiredFieldPresent = function(fields, fieldName) {
	    var fieldProps;
	    if (!(fieldProps = this._fieldProps[fieldName])) {
	      return true;
	    }
	    if (fieldProps.required && (fields[fieldName] == null)) {
	      return false;
	    }
	    if (fieldProps.present && !present(fields[fieldName])) {
	      return false;
	    }
	    return true;
	  };

	  Validator.prototype.presentFieldsValid = function(fields) {
	    var __, fieldName;
	    for (fieldName in fields) {
	      __ = fields[fieldName];
	      if (!this.presentFieldValid(fields, fieldName)) {
	        return false;
	      }
	    }
	    return true;
	  };

	  Validator.prototype.requiredFieldsPresent = function(fields) {
	    var __, fieldName, ref;
	    ref = this._fieldProps;
	    for (fieldName in ref) {
	      __ = ref[fieldName];
	      if (!this.requiredFieldPresent(fields, fieldName)) {
	        return false;
	      }
	    }
	    return true;
	  };

	  Validator.prototype.preprocessFields = function(fields) {
	    var fieldName, oldV, preprocess, processedFields, ref, value;
	    processedFields = null;
	    ref = this._fieldProps;
	    for (fieldName in ref) {
	      preprocess = ref[fieldName].preprocess;
	      if (preprocess && ((value = fields[fieldName]) != null)) {
	        if ((v = preprocess(oldV = fields[fieldName])) !== oldV) {
	          processedFields || (processedFields = shallowClone(fields));
	          processedFields[fieldName] = v;
	        }
	      }
	    }
	    return processedFields || fields;
	  };

	  Validator.prototype.invalidFields = function(fields) {
	    return select(fields, (function(_this) {
	      return function(key, value) {
	        return !_this.presentFieldValid(fields, key);
	      };
	    })(this));
	  };

	  Validator.prototype.missingFields = function(fields) {
	    fields = merge(this._requiredFieldsMap, fields);
	    return select(fields, (function(_this) {
	      return function(key, value) {
	        return !_this.requiredFieldPresent(fields, key);
	      };
	    })(this));
	  };

	  Validator.prototype._addField = function(field, options) {
	    return this._fieldProps[field] = normalizeFieldProps(options);
	  };

	  return Validator;

	})(BaseObject);


/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"atob": "^2.0.3",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"commander": "^2.9.0",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.5.0",
			"promise-polyfill": "^6.0.2",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"description": "Foundation classes for the Art framework. Javascript extensions.",
		"license": "ISC",
		"name": "art-foundation",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "1.20.1"
	};

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(107).includeInNamespace(__webpack_require__(108)).addModules({
	  Cookie: __webpack_require__(109),
	  DomElementFactories: __webpack_require__(110),
	  Dom: __webpack_require__(111),
	  File: __webpack_require__(112)
	});


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var Browser, Foundation,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(21);

	module.exports = Foundation.Browser || Foundation.addNamespace('Browser', Browser = (function(superClass) {
	  extend(Browser, superClass);

	  function Browser() {
	    return Browser.__super__.constructor.apply(this, arguments);
	  }

	  return Browser;

	})(Neptune.Base));


/***/ },
/* 108 */
/***/ function(module, exports) {

	var Browser;

	module.exports = Browser = (function() {
	  var browserIsMobile, isMobileBrowserRegExp1, isMobileBrowserRegExp2;

	  function Browser() {}

	  isMobileBrowserRegExp1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i;

	  isMobileBrowserRegExp2 = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|agent wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|agent|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)agent|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[agent-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(agent|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-agent|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i;

	  browserIsMobile = null;

	  Browser.isMobileBrowser = function() {
	    var agent, check;
	    if (browserIsMobile != null) {
	      return browserIsMobile;
	    }
	    check = false;
	    agent = navigator.userAgent || navigator.vendor || window.opera;
	    return browserIsMobile = !!(isMobileBrowserRegExp1.test(agent) || isMobileBrowserRegExp2.test(agent.substr(0, 4)));
	  };

	  return Browser;

	})();


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ClassSystem, Cookie, StandardLib, getCookie, isPlainArray, isPlainObject, isString, log, setCookie,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	StandardLib = __webpack_require__(24);

	ClassSystem = __webpack_require__(75);

	log = StandardLib.log, isString = StandardLib.isString, isPlainArray = StandardLib.isPlainArray, isPlainObject = StandardLib.isPlainObject;

	BaseObject = ClassSystem.BaseObject;

	setCookie = function(cookieName, cookieValue, arg) {
	  var cookieString, d, expires, path;
	  expires = arg.expires, path = arg.path;
	  if (!isString(cookieValue)) {
	    if (!(isPlainArray(cookieValue) || isPlainObject(cookieValue))) {
	      throw new Error("cookieValue must be a string, array or object");
	    }
	    cookieValue = JSON.stringify(cookieValue);
	  }
	  cookieString = cookieName + "=" + cookieValue;
	  if (expires) {
	    d = new Date();
	    d.setTime(d.getTime() + expires * 24 * 60 * 60 * 1000);
	    cookieString += "; expires=" + (d.toUTCString());
	  }
	  if (path) {
	    cookieString += "; path=" + path;
	  }
	  return document.cookie = cookieString;
	};

	getCookie = function(cookieName) {
	  var c, ca, i, len, name, value;
	  name = cookieName + "=";
	  ca = document.cookie.split(';');
	  for (i = 0, len = ca.length; i < len; i++) {
	    c = ca[i];
	    while (' ' === c.charAt(0)) {
	      c = c.substring(1);
	    }
	    if (0 === c.indexOf(name)) {
	      value = c.substring(name.length, c.length);
	      if (value.match(/^[{[]/)) {
	        value = JSON.parse(value);
	      }
	      return value;
	    }
	  }
	  return "";
	};

	module.exports = Cookie = (function(superClass) {
	  extend(Cookie, superClass);

	  function Cookie() {
	    return Cookie.__super__.constructor.apply(this, arguments);
	  }

	  Cookie.set = function(name, value, options) {
	    return setCookie(name, value, options);
	  };

	  Cookie.get = function(name) {
	    return getCookie(name);
	  };

	  Cookie.remove = function(name, options) {
	    return setCookie(name, {
	      path: options.path,
	      expires: -1
	    });
	  };

	  return Cookie;

	})(BaseObject);


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var DomElementFactories, supportLibs,
	  slice = [].slice;

	supportLibs = [Neptune.NeptuneLib, __webpack_require__(39), __webpack_require__(90)];


	/*
	DomElementFactories allows for Art.React-style creation of DOM elements.

	 * HOW TO LOAD:
	 * -- IF: you are already using Art.Foundation
	Foundation = require 'art-foundation'
	{DomElementFactories} = Foundation.Browser

	 * -- IF: You have the Art.Foundation NPM but only want DomElementFactories:
	DomElementFactories = require 'art-foundation/dom_element_factories'

	 * -- IF: You just have dom_element_factories.js
	 * first, load it prior via a <script> tag, then:
	 * window.DomElementFactories will be set.

	Usage:

	{Div, Span, B, Em} = DomElementFactories

	mySharedTextStyle =
	  style:
	    fontSize: "16pt"
	    color: "#444"
	    fontFamily: "Times"

	Div
	  class: "foo"
	  id:    "123"

	Span
	  class: "dude"
	  "This is some really"
	  B "bold"
	  "text."
	  "Also, here is some"
	  Em "emphasized"
	  "text."

	Span mySharedTextStyle,
	  internalHTML: "Or you can do <b>this</b> and <em>this</em>."

	Div mySharedTextStyle,
	  style:
	    bottom:          0
	    height:          "50px"
	    left:            "100px"
	    right:           "100px"
	    position:        "fixed"
	    backgroundColor: "white"
	    textAlign:       "center"
	  "Styles are easy, too."

	VERSION HISTORY:
	  1.1.1 - added H2-H6
	  1.1.0 - new-lines in text-children become <BR> tags
	  1.0.0 - initial
	 */

	module.exports = DomElementFactories = (function() {
	  var isPlainObject, isString, j, k, len, mergeInto, ref, supportLib, v;

	  function DomElementFactories() {}

	  DomElementFactories.version = "1.1.1";

	  DomElementFactories.src = "https://github.com/Imikimi-LLC/art-foundation";

	  for (j = 0, len = supportLibs.length; j < len; j++) {
	    supportLib = supportLibs[j];
	    for (k in supportLib) {
	      v = supportLib[k];
	      DomElementFactories[k] = v;
	    }
	  }

	  DomElementFactories.isString = isString = function(obj) {
	    return typeof obj === "string";
	  };

	  DomElementFactories.isPlainObject = isPlainObject = function(obj) {
	    return obj.constructor === Object;
	  };

	  DomElementFactories.mergeInto = mergeInto = function(into, source) {
	    if (into == null) {
	      into = {};
	    }
	    for (k in source) {
	      v = source[k];
	      into[k] = v;
	    }
	    return into;
	  };

	  DomElementFactories.setDomElementProp = function(element, prop, value, oldValue) {
	    var clearStyle, setStyle, style;
	    switch (prop) {
	      case "class":
	        return element.className = value || "";
	      case "id":
	        return element.id = value || "";
	      case "innerHTML":
	        return element.innerHTML = value || "";
	      case "on":
	        if (!isPlainObject(value)) {
	          throw new Error("object expected for 'on' property");
	        }
	        setStyle = function(eventType, newEventListener) {
	          return element.addEventListener(eventType, newEventListener);
	        };
	        clearStyle = function(eventType, oldEventListener) {
	          return element.removeEventListner(eventType, oldEventListener);
	        };
	        return DomElementFactories.objectDiff(value, oldValue, setStyle, clearStyle, setStyle);
	      case "style":
	        if (!isPlainObject(value)) {
	          throw new Error("object expected for 'style' property");
	        }
	        style = element.style;
	        setStyle = function(k, v) {
	          return style[k] = v;
	        };
	        clearStyle = function(k) {
	          return style[k] = "";
	        };
	        return DomElementFactories.objectDiff(value, oldValue, setStyle, clearStyle, setStyle);
	      default:
	        return element.setAttribute(prop, value);
	    }
	  };

	  DomElementFactories.setDomElementProps = function(element, props) {
	    var results;
	    results = [];
	    for (k in props) {
	      v = props[k];
	      results.push(this.setDomElementProp(element, k, v));
	    }
	    return results;
	  };

	  DomElementFactories.setDomElementChildren = function(element, children) {
	    var child, i, l, len1, message, ref, ref1, ref2, results, text;
	    results = [];
	    for (l = 0, len1 = children.length; l < len1; l++) {
	      child = children[l];
	      if (isString(child)) {
	        results.push((function() {
	          var len2, m, ref, results1;
	          ref = child.split("\n");
	          results1 = [];
	          for (i = m = 0, len2 = ref.length; m < len2; i = ++m) {
	            text = ref[i];
	            if (i > 0) {
	              element.appendChild(document.createElement("br"));
	            }
	            results1.push(element.appendChild(document.createTextNode(text)));
	          }
	          return results1;
	        })());
	      } else {
	        if (!(child instanceof Node)) {
	          message = "DomElementFactory:" + nodeName + ": Child is not a string or instance of Node. Child: " + child;
	          (typeof Neptune !== "undefined" && Neptune !== null ? (ref = Neptune.Art) != null ? (ref1 = ref.Foundation) != null ? (ref2 = ref1.log) != null ? typeof ref2.error === "function" ? ref2.error(message, child) : void 0 : void 0 : void 0 : void 0 : void 0) || console.log(message, child);
	          throw new Error(message);
	        }
	        results.push(element.appendChild(child));
	      }
	    }
	    return results;
	  };


	  /*
	  IN: any combination of arrays and strings
	  OUT: All element-names found in all strings are used to generate dom-element-factory-functions
	    for elements with those names.
	    The output is a plain Object where they keys are the upperCamelCase version of the element-names
	    passed in. The values are the element-factories.
	   */

	  DomElementFactories.createDomElementFactories = function() {
	    var list;
	    list = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    return DomElementFactories.createObjectTreeFactories({
	      mergePropsInto: function(into, source) {
	        var results;
	        results = [];
	        for (k in source) {
	          v = source[k];
	          results.push(into[k] = k === "style" ? mergeInto(into[k], v) : v);
	        }
	        return results;
	      }
	    }, list, function(nodeName, props, children) {
	      var element;
	      element = document.createElement(nodeName);
	      DomElementFactories.setDomElementProps(element, props);
	      DomElementFactories.setDomElementChildren(element, children);
	      return element;
	    });
	  };

	  DomElementFactories.allDomElementNames = "A Abbr Acronym Address Applet Area Article Aside Audio B Base BaseFont Bdi Bdo Big BlockQuote Body Br Button Canvas Caption Center Cite Code Col ColGroup DataList Dd Del Details Dfn Dialog Dir Div Dl Dt Em Embed FieldSet FigCaption Figure Font Footer Form Frame FrameSet H1 H2 H3 H4 H5 H6 Head Header Hr Html I IFrame Img Input Ins Kbd KeyGen Label Legend Li Link Main Map Mark Menu MenuItem Meta Meter Nav NoFrames NoScript Object Ol OptGroup Option Output P Param Pre Progress Q Rp Rt Ruby S Samp Script Section Select Small Source Span Strike Strong Style Sub Summary Sup Table TBody Td TextArea TFoot Th THead Time Title Tr Track Tt U Ul Var Video Wbr";

	  ref = DomElementFactories.createDomElementFactories(DomElementFactories.allDomElementNames);
	  for (k in ref) {
	    v = ref[k];
	    DomElementFactories[k] = v;
	  }

	  return DomElementFactories;

	})();


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var Dom, DomElementFactories, isString;

	DomElementFactories = __webpack_require__(110);

	isString = __webpack_require__(24).isString;

	module.exports = Dom = (function() {
	  function Dom() {}

	  Dom.createElementFromHtml = function(html) {
	    var div;
	    div = document.createElement('div');
	    div.innerHTML = html;
	    return div.firstChild;
	  };

	  Dom.createDomElementFactories = DomElementFactories.createDomElementFactories;

	  Dom.getDevicePixelRatio = function() {
	    return ((self.devicePixelRatio != null) && self.devicePixelRatio) || 1;
	  };

	  Dom.zIndex = function(target, setZIndex) {
	    var element, value;
	    if (!(target instanceof HTMLElement)) {
	      target = document.getElementById(target);
	    }
	    if (setZIndex !== void 0) {
	      return target.style.zIndex = setZIndex;
	    }
	    element = target;
	    while (element && element !== document) {
	      switch (element.style.position) {
	        case "absolute":
	        case "relative":
	        case "fixed":
	          value = parseInt(element.style.zIndex);
	          if (value < 0 || value > 0) {
	            return value;
	          }
	      }
	      element = element.parentElement;
	    }
	    return 0;
	  };

	  Dom.domElementOffset = function(element) {
	    var body, box, clientLeft, clientTop, documentElement, left, scrollLeft, scrollTop, top;
	    box = element.getBoundingClientRect();
	    body = document.body, documentElement = document.documentElement;
	    scrollTop = window.pageYOffset || documentElement.scrollTop || body.scrollTop;
	    scrollLeft = window.pageXOffset || documentElement.scrollLeft || body.scrollLeft;
	    clientTop = documentElement.clientTop || body.clientTop || 0;
	    clientLeft = documentElement.clientLeft || body.clientLeft || 0;
	    top = box.top + scrollTop - clientTop;
	    left = box.left + scrollLeft - clientLeft;
	    return {
	      top: Math.round(top),
	      left: Math.round(left)
	    };
	  };

	  return Dom;

	})();


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var File, Promise, StandardLib, createElementFromHtml;

	StandardLib = __webpack_require__(24);

	createElementFromHtml = __webpack_require__(111).createElementFromHtml;

	Promise = StandardLib.Promise;

	module.exports = File = (function() {
	  function File() {}

	  File.request = function(options) {
	    if (options == null) {
	      options = {};
	    }
	    return new Promise(function(resolve, reject) {
	      var accept, body, fileInput, multiple, onChange, ref;
	      accept = options.accept, multiple = options.multiple, onChange = options.onChange;
	      if ((ref = this.hiddenDivForFileInput) != null) {
	        ref.parentNode.removeChild(this.hiddenDivForFileInput);
	      }
	      this.hiddenDivForFileInput = createElementFromHtml("<div style='height: 0px;width: 0px; overflow:hidden; position:absolute;'/>");
	      body = document.body;
	      fileInput = createElementFromHtml("<input type='file' " + (accept ? 'accept=' + accept : void 0) + " " + (multiple ? 'multiple=true' : void 0) + "/>");
	      this.hiddenDivForFileInput.appendChild(fileInput);
	      body.appendChild(this.hiddenDivForFileInput);
	      fileInput.onchange = function(e) {
	        var file, fileList, fileSizes, fileTypes;
	        fileList = (function() {
	          var i, len, ref1, results;
	          ref1 = fileInput.files;
	          results = [];
	          for (i = 0, len = ref1.length; i < len; i++) {
	            file = ref1[i];
	            results.push(file);
	          }
	          return results;
	        })();
	        fileTypes = (function() {
	          var i, len, results;
	          results = [];
	          for (i = 0, len = fileList.length; i < len; i++) {
	            file = fileList[i];
	            results.push(file.type);
	          }
	          return results;
	        })();
	        fileSizes = (function() {
	          var i, len, results;
	          results = [];
	          for (i = 0, len = fileList.length; i < len; i++) {
	            file = fileList[i];
	            results.push(file.size);
	          }
	          return results;
	        })();
	        if (fileList.length > 0 && fileList[0]) {
	          onChange && onChange(fileList);
	          return resolve(fileList);
	        } else {
	          return reject("no files returned");
	        }
	      };
	      return fileInput.click();
	    });
	  };

	  return File;

	})();


/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-suite": "git://github.com/imikimi/art-suite.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.5.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"license": "ISC",
		"name": "nvc_app",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "1.2.1"
	};

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(115).addModules({
	  Main: __webpack_require__(116)
	});

	__webpack_require__(351);

	__webpack_require__(355);

	__webpack_require__(348);

	__webpack_require__(117);


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	var App, Nvc,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Nvc = __webpack_require__(3);

	module.exports = Nvc.App || Nvc.addNamespace('App', App = (function(superClass) {
	  extend(App, superClass);

	  function App() {
	    return App.__super__.constructor.apply(this, arguments);
	  }

	  return App;

	})(Neptune.Base));


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	var App, AppNamespace, FullScreenApp, log, ref;

	AppNamespace = __webpack_require__(115);

	__webpack_require__(117);

	__webpack_require__(348);

	App = __webpack_require__(351).App;

	ref = __webpack_require__(120), FullScreenApp = ref.FullScreenApp, log = ref.log;

	FullScreenApp.init({
	  title: "Needs & Emotions"
	}).then(function() {
	  return App().instantiateAsTopComponent();
	})["catch"](function(e) {
	  return log.error("Failed to init NVC app", e);
	});


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(118).addModules({
	  StyleProps: __webpack_require__(119)
	});


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	var App, Styles,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	App = __webpack_require__(115);

	module.exports = App.Styles || App.addNamespace('Styles', Styles = (function(superClass) {
	  extend(Styles, superClass);

	  function Styles() {
	    return Styles.__super__.constructor.apply(this, arguments);
	  }

	  return Styles;

	})(Neptune.Base));


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var HotStyleProps, StyleProps, defineModule, ref, rgbColor,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(120), defineModule = ref.defineModule, rgbColor = ref.rgbColor, HotStyleProps = ref.HotStyleProps;

	defineModule(module, StyleProps = (function(superClass) {
	  var a;

	  extend(StyleProps, superClass);

	  function StyleProps() {
	    return StyleProps.__super__.constructor.apply(this, arguments);
	  }

	  StyleProps.primaryColor = a = rgbColor("#8ebdf6");

	  StyleProps.leafColor = a;

	  StyleProps.textStyle = {
	    color: "#000a",
	    fontFamily: "sans-serif",
	    fontSize: 18
	  };

	  return StyleProps;

	})(HotStyleProps));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(121);


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(122).includeInNamespace(__webpack_require__(124));


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Suite,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(123);

	module.exports = Art.Suite || Art.addNamespace('Suite', Suite = (function(superClass) {
	  extend(Suite, superClass);

	  function Suite() {
	    return Suite.__super__.constructor.apply(this, arguments);
	  }

	  return Suite;

	})(Neptune.Base));


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var ArtEry, ArtEryFlux, Atomic, Canvas, Engine, Flux, Foundation, React, merge;

	merge = (Foundation = __webpack_require__(19)).merge;

	module.exports = [
	  merge(Foundation, Atomic = __webpack_require__(125), Canvas = __webpack_require__(137), Engine = __webpack_require__(152), React = __webpack_require__(281), Flux = __webpack_require__(302), ArtEry = __webpack_require__(329), ArtEryFlux = __webpack_require__(343), {
	    Foundation: Foundation,
	    Atomic: Atomic,
	    Canvas: Canvas,
	    Engine: Engine,
	    React: React,
	    Flux: Flux,
	    ArtEry: ArtEry,
	    Ery: ArtEry
	  })
	];


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(126);


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(127).includeInNamespace(__webpack_require__(129)).addModules({
	  Base: __webpack_require__(131),
	  Color: __webpack_require__(130),
	  Matrix: __webpack_require__(134),
	  Perimeter: __webpack_require__(135),
	  Point: __webpack_require__(132),
	  Rectangle: __webpack_require__(133)
	});


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Atomic,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(128);

	module.exports = Art.Atomic || Art.addNamespace('Atomic', Atomic = (function(superClass) {
	  extend(Atomic, superClass);

	  function Atomic() {
	    return Atomic.__super__.constructor.apply(this, arguments);
	  }

	  return Atomic;

	})(Neptune.Base));


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var Color, Matrix, Perimeter, Point, Rectangle, _package;

	Color = __webpack_require__(130);

	Point = __webpack_require__(132);

	Rectangle = __webpack_require__(133);

	Matrix = __webpack_require__(134);

	Perimeter = __webpack_require__(135);

	module.exports = [
	  [Color, "newColor", "color", "hslColor", "rgbColor", "colorNames", "colorNamesMap"], [Point, "point", "point0", "point1", "isPoint", "pointWithAspectRatioAndArea"], [Rectangle, "rect", "nothing", "everything"], [Matrix, "matrix", "identityMatrix"], [Perimeter, "perimeter", "perimeter0"], {
	    "package": _package = __webpack_require__(136),
	    version: _package.version
	  }
	];


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var AtomicBase, Color, Foundation, abs, bound, colorFloatEq, float32Eq, float32Eq0, hex16ColorRegex, hex256ColorRegex, inspect, isString, log, max, min, modulo, pad, parseRGBColorComponent, rgbColorRegex, rgbaColorRegex,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	AtomicBase = __webpack_require__(131);

	inspect = Foundation.inspect, bound = Foundation.bound, modulo = Foundation.modulo, pad = Foundation.pad, min = Foundation.min, max = Foundation.max, abs = Foundation.abs, float32Eq = Foundation.float32Eq, isString = Foundation.isString, log = Foundation.log, hex16ColorRegex = Foundation.hex16ColorRegex, hex256ColorRegex = Foundation.hex256ColorRegex, rgbColorRegex = Foundation.rgbColorRegex, rgbaColorRegex = Foundation.rgbaColorRegex, float32Eq0 = Foundation.float32Eq0;

	colorFloatEq = float32Eq;

	parseRGBColorComponent = function(str) {
	  var percentIndex;
	  if ((percentIndex = str.indexOf('%')) !== -1) {
	    return (str.slice(0, percentIndex) | 0) * .01;
	  } else {
	    return (str | 0) * 1 / 255;
	  }
	};

	module.exports = Color = (function(superClass) {
	  var colorNames, colorNamesMap, hexString, hslColor, k, parseCache, rgbColor, v, withSat, zeroString;

	  extend(Color, superClass);

	  function Color() {
	    return Color.__super__.constructor.apply(this, arguments);
	  }

	  Color.defineAtomicClass({
	    fieldNames: "r g b a",
	    constructorFunctionName: "rgbColor"
	  });

	  Color.colorNames = colorNames = ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];

	  Color.colorNamesMap = colorNamesMap = {
	    transparent: "rgba(0,0,0,0)",
	    aliceblue: "#f0f8ff",
	    antiquewhite: "#faebd7",
	    aqua: "#00ffff",
	    aquamarine: "#7fffd4",
	    azure: "#f0ffff",
	    beige: "#f5f5dc",
	    bisque: "#ffe4c4",
	    black: "#000000",
	    blanchedalmond: "#ffebcd",
	    blue: "#0000ff",
	    blueviolet: "#8a2be2",
	    brown: "#a52a2a",
	    burlywood: "#deb887",
	    cadetblue: "#5f9ea0",
	    chartreuse: "#7fff00",
	    chocolate: "#d2691e",
	    coral: "#ff7f50",
	    cornflowerblue: "#6495ed",
	    cornsilk: "#fff8dc",
	    crimson: "#dc143c",
	    cyan: "#00ffff",
	    darkblue: "#00008b",
	    darkcyan: "#008b8b",
	    darkgoldenrod: "#b8860b",
	    darkgrey: "#a9a9a9",
	    darkgray: "#a9a9a9",
	    darkgreen: "#006400",
	    darkkhaki: "#bdb76b",
	    darkmagenta: "#8b008b",
	    darkolivegreen: "#556b2f",
	    darkorange: "#ff8c00",
	    darkorchid: "#9932cc",
	    darkred: "#8b0000",
	    darksalmon: "#e9967a",
	    darkseagreen: "#8fbc8f",
	    darkslateblue: "#483d8b",
	    darkslategrey: "#2f4f4f",
	    darkslategray: "#2f4f4f",
	    darkturquoise: "#00ced1",
	    darkviolet: "#9400d3",
	    deeppink: "#ff1493",
	    deepskyblue: "#00bfff",
	    dimgrey: "#696969",
	    dimgray: "#696969",
	    dodgerblue: "#1e90ff",
	    firebrick: "#b22222",
	    floralwhite: "#fffaf0",
	    forestgreen: "#228b22",
	    fuchsia: "#ff00ff",
	    gainsboro: "#dcdcdc",
	    ghostwhite: "#f8f8ff",
	    gold: "#ffd700",
	    goldenrod: "#daa520",
	    grey: "#808080",
	    gray: "#808080",
	    green: "#008000",
	    greenyellow: "#adff2f",
	    honeydew: "#f0fff0",
	    hotpink: "#ff69b4",
	    indianred: "#cd5c5c",
	    indigo: "#4b0082",
	    ivory: "#fffff0",
	    khaki: "#f0e68c",
	    lavender: "#e6e6fa",
	    lavenderblush: "#fff0f5",
	    lawngreen: "#7cfc00",
	    lemonchiffon: "#fffacd",
	    lightblue: "#add8e6",
	    lightcoral: "#f08080",
	    lightcyan: "#e0ffff",
	    lightgoldenrodyellow: "#fafad2",
	    lightgrey: "#d3d3d3",
	    lightgray: "#d3d3d3",
	    lightgreen: "#90ee90",
	    lightpink: "#ffb6c1",
	    lightsalmon: "#ffa07a",
	    lightseagreen: "#20b2aa",
	    lightskyblue: "#87cefa",
	    lightslategrey: "#778899",
	    lightslategray: "#778899",
	    lightsteelblue: "#b0c4de",
	    lightyellow: "#ffffe0",
	    lime: "#00ff00",
	    limegreen: "#32cd32",
	    linen: "#faf0e6",
	    magenta: "#ff00ff",
	    maroon: "#800000",
	    mediumaquamarine: "#66cdaa",
	    mediumblue: "#0000cd",
	    mediumorchid: "#ba55d3",
	    mediumpurple: "#9370db",
	    mediumseagreen: "#3cb371",
	    mediumslateblue: "#7b68ee",
	    mediumspringgreen: "#00fa9a",
	    mediumturquoise: "#48d1cc",
	    mediumvioletred: "#c71585",
	    midnightblue: "#191970",
	    mintcream: "#f5fffa",
	    mistyrose: "#ffe4e1",
	    moccasin: "#ffe4b5",
	    navajowhite: "#ffdead",
	    navy: "#000080",
	    oldlace: "#fdf5e6",
	    olive: "#808000",
	    olivedrab: "#6b8e23",
	    orange: "#ffa500",
	    orangered: "#ff4500",
	    orchid: "#da70d6",
	    palegoldenrod: "#eee8aa",
	    palegreen: "#98fb98",
	    paleturquoise: "#afeeee",
	    palevioletred: "#db7093",
	    papayawhip: "#ffefd5",
	    peachpuff: "#ffdab9",
	    peru: "#cd853f",
	    pink: "#ffc0cb",
	    plum: "#dda0dd",
	    powderblue: "#b0e0e6",
	    purple: "#800080",
	    red: "#ff0000",
	    rosybrown: "#bc8f8f",
	    royalblue: "#4169e1",
	    saddlebrown: "#8b4513",
	    salmon: "#fa8072",
	    sandybrown: "#f4a460",
	    seagreen: "#2e8b57",
	    seashell: "#fff5ee",
	    sienna: "#a0522d",
	    silver: "#c0c0c0",
	    skyblue: "#87ceeb",
	    slateblue: "#6a5acd",
	    slategrey: "#708090",
	    slategray: "#708090",
	    snow: "#fffafa",
	    springgreen: "#00ff7f",
	    steelblue: "#4682b4",
	    tan: "#d2b48c",
	    teal: "#008080",
	    thistle: "#d8bfd8",
	    tomato: "#ff6347",
	    turquoise: "#40e0d0",
	    violet: "#ee82ee",
	    wheat: "#f5deb3",
	    white: "#ffffff",
	    whitesmoke: "#f5f5f5",
	    yellow: "#ffff00",
	    yellowgreen: "#9acd32"
	  };

	  Color.parseCache = parseCache = {};

	  Color.rgbColor = rgbColor = function(a, b, c, d) {
	    var clr;
	    if ((b == null) && (a instanceof Color)) {
	      return a;
	    }
	    if (isString(a) && (clr = colorNamesMap[a] || parseCache[a])) {
	      return clr;
	    }
	    return new Color(a, b, c, d);
	  };

	  Color.newColor = rgbColor;

	  Color.color = function(a, b, c, d) {
	    log.error("Atomic.color DEPRICATED. Use rgbColor.");
	    return rgbColor(a, b, c, d);
	  };

	  Color.hslColor = hslColor = function(h, s, l, a) {
	    var f, p, phase, q, t;
	    if (a == null) {
	      a = 1;
	    }
	    if (h instanceof Color) {
	      return h;
	    }
	    h = modulo(h, 1);
	    phase = h * 6 | 0;
	    f = h * 6 - phase;
	    p = l * (1 - s);
	    q = l * (1 - f * s);
	    t = l * (1 - (1 - f) * s);
	    h = colorFloatEq(h, 1) ? 1 : h % 1;
	    switch (phase % 6) {
	      case 0:
	        return new Color(l, t, p, a, h, s, l);
	      case 1:
	        return new Color(q, l, p, a, h, s, l);
	      case 2:
	        return new Color(p, l, t, a, h, s, l);
	      case 3:
	        return new Color(p, q, l, a, h, s, l);
	      case 4:
	        return new Color(t, p, l, a, h, s, l);
	      case 5:
	        return new Color(l, p, q, a, h, s, l);
	    }
	  };

	  Color.parse = function(string, existing) {
	    if (existing == null) {
	      existing = null;
	    }
	    if (existing) {
	      throw new Error("existing feature is no longer supported");
	    }
	    return new Artomic.Color(string);
	  };

	  Color.prototype._initFromObject = function(obj) {
	    return this.r = obj.r, this.g = obj.g, this.b = obj.b, this.a = obj.a, obj;
	  };

	  Color.prototype._initFromString = function(string) {
	    var a, b, clr, elements, g, lcString, match, r, x;
	    this.initProperties();
	    parseCache[string] = this;
	    if (match = string.match(hex16ColorRegex)) {
	      x = match[0], r = match[1], g = match[2], b = match[3], a = match[4];
	      if (!a) {
	        this._htmlColorString = string;
	      }
	      a || (a = "f");
	      this.r = parseInt(r, 16) / 15;
	      this.g = parseInt(g, 16) / 15;
	      this.b = parseInt(b, 16) / 15;
	      return this.a = parseInt(a, 16) / 15;
	    } else if (match = string.match(hex256ColorRegex)) {
	      x = match[0], r = match[1], g = match[2], b = match[3], a = match[4];
	      if (!a) {
	        this._htmlColorString = string;
	      }
	      a || (a = "ff");
	      this.r = parseInt(r, 16) / 255;
	      this.g = parseInt(g, 16) / 255;
	      this.b = parseInt(b, 16) / 255;
	      return this.a = parseInt(a, 16) / 255;
	    } else if (elements = string.match(rgbColorRegex)) {
	      this._htmlColorString = string;
	      this.a = 1;
	      this.r = parseRGBColorComponent(elements[1]);
	      this.g = parseRGBColorComponent(elements[2]);
	      return this.b = parseRGBColorComponent(elements[3]);
	    } else if (elements = string.match(rgbaColorRegex)) {
	      this._htmlColorString = string;
	      this.r = parseRGBColorComponent(elements[1]);
	      this.g = parseRGBColorComponent(elements[2]);
	      this.b = parseRGBColorComponent(elements[3]);
	      return this.a = elements[4] - 0;
	    } else if (/^[a-z]+$/i.test(lcString = string.toLowerCase())) {
	      if (!(clr = colorNamesMap[lcString])) {
	        return this.log({
	          parseError: this.parseError = "WARNING: Color.parse failure. Unknown rgbColor name: " + (inspect(string))
	        });
	      }
	      this._htmlColorString = clr._htmlColorString;
	      this.r = clr.r;
	      this.g = clr.g;
	      this.b = clr.b;
	      return this.a = clr.a;
	    } else {
	      return this.log({
	        parseError: this.parseError = "WARNING: Color.parse failure for " + (inspect(string))
	      });
	    }
	  };

	  Color.prototype.initProperties = function() {
	    this.r = this.g = this.b = 0;
	    this.a = 1;
	    this._hue = this._saturation = this._lightness = null;
	    this.parseError = null;
	    return this._htmlColorString = null;
	  };

	  Color.prototype._init = function(a, b, c, d, h, s, l) {
	    this.initProperties();
	    if (h != null) {
	      this._hue = h - 0;
	    }
	    if (s != null) {
	      this._saturation = s - 0;
	    }
	    if (l != null) {
	      this._lightness = l - 0;
	    }
	    if (a == null) {
	      this.r = this.g = this.b = 0;
	      return this.a = 1;
	    } else if (b == null) {
	      if (a > 1) {
	        a /= 255;
	      }
	      this.r = this.g = this.b = a - 0;
	      return this.a = 1 - 0;
	    } else if (c != null) {
	      this.r = a - 0;
	      this.g = b - 0;
	      this.b = c - 0;
	      return this.a = d != null ? d - 0 : 1;
	    }
	  };

	  Color.prototype.interpolate = function(toColor, p) {
	    var a, b, g, oneMinusP, r, ref;
	    ref = this, r = ref.r, g = ref.g, b = ref.b, a = ref.a;
	    toColor = rgbColor(toColor);
	    if (float32Eq0(a)) {
	      r = toColor.r, g = toColor.g, b = toColor.b;
	    }
	    if (float32Eq0(toColor.a)) {
	      toColor = this.withAlpha(0);
	    }
	    oneMinusP = 1 - p;
	    return new Color(toColor.r * p + r * oneMinusP, toColor.g * p + g * oneMinusP, toColor.b * p + b * oneMinusP, toColor.a * p + a * oneMinusP);
	  };

	  Color.prototype.blend = function(color, amount) {
	    var a, b, g, r, ref;
	    color = rgbColor(color);
	    ref = this, r = ref.r, g = ref.g, b = ref.b, a = ref.a;
	    switch (false) {
	      case amount == null:
	        return new Color((color.r - r) * amount + r, (color.g - g) * amount + g, (color.b - b) * amount + b, (color.a - a) * amount + a);
	      case !colorFloatEq(color.a, 1):
	        return color;
	      case !colorFloatEq(color.a, 0):
	        return this;
	      default:
	        amount = color.a;
	        return new Color((color.r - r) * amount + r, (color.g - g) * amount + g, (color.b - b) * amount + b, (1 - a) * amount + a);
	    }
	  };

	  Color.prototype.withAlpha = function(a) {
	    return new Color(this.r, this.g, this.b, a);
	  };

	  Color.prototype.withLightness = function(v) {
	    return hslColor(this.h, this.s, v, this.a);
	  };

	  Color.prototype.withHue = function(v) {
	    return hslColor(v, this.s, this.l, this.a);
	  };

	  Color.prototype.withSat = withSat = function(v) {
	    return hslColor(this.h, v, this.l, this.a);
	  };

	  Color.prototype.withSaturation = withSat;

	  Color.prototype.withChannel = function(c, v) {
	    switch (c) {
	      case "r":
	      case "red":
	        return new Color(v, this.g, this.b, this.a);
	      case "g":
	      case "green":
	        return new Color(this.r, v, this.b, this.a);
	      case "b":
	      case "blue":
	        return new Color(this.r, this.g, v, this.a);
	      case "h":
	      case "hue":
	        return hslColor(v, this.s, this.l, this.a);
	      case "s":
	      case "sat":
	      case "saturation":
	        return hslColor(this.h, v, this.l, this.a);
	      case "l":
	      case "lightness":
	        return this.withLightness(v);
	      case "a":
	      case "alpha":
	        return this.withAlpha(v);
	      default:
	        throw new Error("invalid channel: " + (inspect(c)));
	    }
	  };

	  Color.prototype.withChannels = function(c) {
	    var a, b, g, h, l, r, s;
	    if (c.h || c.s || c.l) {
	      h = c.h != null ? c.h : this.h;
	      s = c.s != null ? c.s : this.s;
	      l = c.l != null ? c.l : this.l;
	      a = c.a != null ? c.a : this.a;
	      return hslColor(h, s, l, a);
	    } else {
	      r = c.r != null ? c.r : this.r;
	      g = c.g != null ? c.g : this.g;
	      b = c.b != null ? c.b : this.b;
	      a = c.a != null ? c.a : this.a;
	      return new Color(r, g, b, a);
	    }
	  };

	  zeroString = "0";

	  hexString = function(number, length) {
	    if (length == null) {
	      length = 2;
	    }
	    return pad(number.toString(16), length, zeroString, true);
	  };

	  Color.getter({
	    arrayRGB: function() {
	      return [this.r, this.g, this.b];
	    },
	    rgbSum: function() {
	      return this.r + this.g + this.b;
	    },
	    rgbSquaredSum: function() {
	      return this.r * this.r + this.g * this.g + this.b * this.b;
	    },
	    clamped: function() {
	      return new Color(bound(0, this.r, 1), bound(0, this.g, 1), bound(0, this.b, 1), bound(0, this.a, 1));
	    },
	    r256: function() {
	      return bound(0, Math.round(this.r * 255), 255);
	    },
	    g256: function() {
	      return bound(0, Math.round(this.g * 255), 255);
	    },
	    b256: function() {
	      return bound(0, Math.round(this.b * 255), 255);
	    },
	    a256: function() {
	      return bound(0, Math.round(this.a * 255), 255);
	    },
	    r16: function() {
	      return bound(0, Math.round(this.r * 15), 15);
	    },
	    g16: function() {
	      return bound(0, Math.round(this.g * 15), 15);
	    },
	    b16: function() {
	      return bound(0, Math.round(this.b * 15), 15);
	    },
	    a16: function() {
	      return bound(0, Math.round(this.a * 15), 15);
	    },
	    h256: function() {
	      return bound(0, Math.round(this.h * 255), 255);
	    },
	    s256: function() {
	      return bound(0, Math.round(this.s * 255), 255);
	    },
	    b256: function() {
	      return bound(0, Math.round(this.b * 255), 255);
	    },
	    rClamped: function() {
	      return bound(0, this.r, 1);
	    },
	    gClamped: function() {
	      return bound(0, this.g, 1);
	    },
	    bClamped: function() {
	      return bound(0, this.b, 1);
	    },
	    aClamped: function() {
	      return bound(0, this.a, 1);
	    },
	    premultiplied: function() {
	      return new Color(this.r * this.a, this.g * this.a, this.b * this.a, this.a);
	    },
	    demultiplied: function() {
	      return new Color(this.r / this.a, this.g / this.a, this.b / this.a, this.a);
	    },
	    cssString: function() {
	      return "rgba(" + [this.r256, this.g256, this.b256, this.aClamped].join(', ') + ")";
	    },
	    rgbaString: function() {
	      return "rgbColor(" + [this.r256, this.g256, this.b256, this.a256].join('/255, ') + "/255)";
	    },
	    hexString: function() {
	      return "#" + hexString(this.r256) + hexString(this.g256) + hexString(this.b256);
	    },
	    hex16String: function() {
	      return "#" + hexString(this.r16, 1) + hexString(this.g16, 1) + hexString(this.b16, 1);
	    },
	    hslHexString: function() {
	      return "#" + hexString(this.h256) + hexString(this.s256) + hexString(this.b256);
	    },
	    rgbaHexString: function() {
	      return "#" + this.getRawRgbaHexString();
	    },
	    rawRgbaHexString: function() {
	      return hexString(this.r256) + hexString(this.g256) + hexString(this.b256) + hexString(this.a256);
	    }
	  });

	  Color.prototype.inspect = function() {
	    var a;
	    a = colorFloatEq(1, this.a) ? this.hexString : this.rgbaHexString;
	    return "rgbColor('" + a + "')";
	  };

	  Color.prototype.toString = function() {
	    return this._htmlColorString || (this._htmlColorString = colorFloatEq(1, this.a) ? this.getHexString() : this.getCssString());
	  };

	  Color.getter({
	    plainObjects: function() {
	      if (this.a < 1) {
	        return this.rgbaHexString;
	      } else {
	        return this.hexString;
	      }
	    },
	    inspectedObjects: function() {
	      if (colorFloatEq(1, this.a)) {
	        return this.hexString;
	      } else {
	        return this.rgbaHexString;
	      }
	    }
	  });

	  Color.getter({
	    h: function() {
	      return this._hue != null ? this._hue : this._hue = this.rgbToHsl() && this._hue;
	    },
	    s: function() {
	      return this._saturation != null ? this._saturation : this._saturation = this.rgbToHsl() && this._saturation;
	    },
	    l: function() {
	      return this._lightness != null ? this._lightness : this._lightness = this.rgbToHsl() && this._lightness;
	    },
	    inverseL: function() {
	      return 1 - this.l;
	    },
	    inverseS: function() {
	      return 1 - this.s;
	    },
	    inverseH: function() {
	      return 1 - this.h;
	    },
	    hue: function() {
	      return this._hue != null ? this._hue : this._hue = this.rgbToHsl() && this._hue;
	    },
	    sat: function() {
	      return this._saturation != null ? this._saturation : this._saturation = this.rgbToHsl() && this._saturation;
	    },
	    lit: function() {
	      return this._lightness != null ? this._lightness : this._lightness = this.rgbToHsl() && this._lightness;
	    },
	    saturation: function() {
	      return this._saturation != null ? this._saturation : this._saturation = this.rgbToHsl() && this._saturation;
	    },
	    lightness: function() {
	      return this._lightness != null ? this._lightness : this._lightness = this.rgbToHsl() && this._lightness;
	    },
	    perceptualLightness: function() {
	      return 0.2126 * this.r + 0.7152 * this.g + 0.0722 * this.b;
	    },
	    satLightness: function() {
	      return (2 - this._saturation) * this._lightness * .5;
	    }
	  });

	  Color.perceptualWeights = {
	    r: 0.2126,
	    g: 0.7152,
	    b: 0.0722
	  };

	  Color.prototype.rgbToHsl = function() {
	    var b, delta, g, maxRGB, minRGB, r, sixth;
	    r = this.r;
	    g = this.g;
	    b = this.b;
	    maxRGB = max(r, g, b);
	    minRGB = min(r, g, b);
	    delta = maxRGB - minRGB;
	    sixth = 1.0 / 6.0;
	    this._lightness = maxRGB;
	    if (maxRGB === minRGB) {
	      this._hue = 0;
	      this._saturation = 0;
	      return true;
	    }
	    if (maxRGB === r) {
	      if (g >= b) {
	        this._hue = sixth * ((g - b) / delta);
	      } else {
	        this._hue = sixth * ((g - b) / delta) + 1;
	      }
	    } else if (maxRGB === g) {
	      this._hue = sixth * ((b - r) / delta) + 1 / 3;
	    } else {
	      this._hue = sixth * ((r - g) / delta) + 2 / 3;
	    }
	    this._saturation = 1 - (minRGB / maxRGB);
	    return true;
	  };

	  for (k in colorNamesMap) {
	    v = colorNamesMap[k];
	    colorNamesMap[k] = rgbColor(v);
	  }

	  return Color;

	})(AtomicBase);


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	var Base, BaseObject, floatEq, inspect, inspectedObjectLiteral, isFunction, isNumber, isPlainArray, isPlainObject, isString, log, lowerCamelCase, ref, stringToNumberArray, upperCamelCase, wordsArray,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(19), inspect = ref.inspect, log = ref.log, isNumber = ref.isNumber, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isString = ref.isString, isFunction = ref.isFunction, stringToNumberArray = ref.stringToNumberArray, BaseObject = ref.BaseObject, lowerCamelCase = ref.lowerCamelCase, upperCamelCase = ref.upperCamelCase, inspectedObjectLiteral = ref.inspectedObjectLiteral, floatEq = ref.floatEq, wordsArray = ref.wordsArray, inspect = ref.inspect;

	module.exports = Base = (function(superClass) {
	  var letterFieldNames, reservedWords;

	  extend(Base, superClass);


	  /*
	  TODO
	  
	  All Atomics follow the same pattern:
	  
	    A fixed, ordered set of fields
	    with fixed names
	    and fixed defaults
	  
	  Most functions could be automatically defined given:
	  
	    An array of field-names
	    An array of default values
	    NOTE: I wish we could just use an object to specifiy those, but
	      the order is not guaranteed, and we need a fixed order.
	  
	  The field-names could be defined with a string.
	  Zero (0) can be the default default-value
	  
	  Point:      @defineAtomic fieldNames: "x y"
	  Matrix:     @defineAtomic fieldNames: "sx shy tx shx sy ty", defaults: [1, 1]
	  Rectangle:  @defineAtomic fieldNames: "x y w h"
	  Perimeter:  @defineAtomic fieldNames: "left right top bottom"
	  
	  nonStandardInitializes
	    Initializing with 1 arg or fields.length args is usually the same for all atomics
	    But, intializing with a number of args in between tends to vary.
	    I suggest overrides:
	    _init0: -> defaults
	    _init1: (a) -> all fields = a
	    _init2:
	    _init3:
	    _init4:
	    _init#{n}: -> each field gets set individually
	  
	  @defineAtomicClass: ({fieldNames, defaults, aliases}) ->
	    fields = wordsArray fields if isString fields
	    @defineSetAll()           # uses fieldNames
	    @defineInit0()            # uses fieldNames and defaults
	    @defineInit1()            # uses fieldNames
	    @defineInterpolate()      # uses fieldNames
	    @defineComparisonOperators()  # uses fieldNames, defines: eq, gt, lt, gte, lte
	    @defineMathOperators()        # uses fieldNames, defines: add, sub, mul, div
	    @defineToArray()          # uses fieldNames
	    @defineInitFromObject()   # uses fieldNames and aliases
	    @defineToObject()         # uses fieldNames
	    @defineGetters()          # uses fieldNames and aliases
	    @defineInto()             # uses fieldNames
	    @defineToString()
	    @defineInspect()
	    @defineToInspectedObjects()
	   */

	  Base.prototype._initFromString = function(string) {
	    return this._init.apply(this, stringToNumberArray(string));
	  };

	  function Base(a, b, c, d, e, f, g) {
	    Base.__super__.constructor.apply(this, arguments);
	    if (isPlainArray(a)) {
	      this._init.apply(this, a);
	    } else if (isString(a)) {
	      this._initFromString(a);
	    } else if (isPlainObject(a)) {
	      this._initFromObject(a);
	    } else if ((a != null) && !isNumber(a) && !(a instanceof Base) && isFunction(a.toString)) {
	      this._initFromString(a.toString());
	    } else {
	      this._init(a, b, c, d, e, f, g);
	    }
	  }

	  Base.prototype.compare = function(b) {
	    if (this.eq(b)) {
	      return 0;
	    }
	    if (this.lte(b)) {
	      return -1;
	    }
	    if (this.gte(b)) {
	      return 1;
	    }
	    return 0/0;
	  };

	  Base.getConstructorFunctionName = function() {
	    return this.constructorFunctionName || (this.constructorFunctionName = lowerCamelCase(this.getName()));
	  };

	  Base.getter({
	    plainObjects: function() {
	      return this.toObject();
	    },
	    inspectedObjects: function() {
	      return inspectedObjectLiteral(this["class"].getConstructorFunctionName() + ("(" + (this.toArray().join(', ')) + ")"));
	    }
	  });

	  Base.prototype.toPlainStructure = function() {
	    return this.getPlainObjects();
	  };

	  Base.prototype.toPlainEvalString = function() {
	    return inspect(this.getPlainObjects());
	  };

	  Base.prototype.inspect = function() {
	    return (this["class"].getConstructorFunctionName()) + "(" + (this.toArray().join(', ')) + ")";
	  };

	  Base.prototype.toJson = function() {
	    return this.toString();
	  };

	  Base.prototype.toString = function(precision) {
	    var a;
	    if (precision) {
	      return "[" + (((function() {
	        var j, len, ref1, results;
	        ref1 = this.toArray();
	        results = [];
	        for (j = 0, len = ref1.length; j < len; j++) {
	          a = ref1[j];
	          results.push(a.toPrecision(precision));
	        }
	        return results;
	      }).call(this)).join(', ')) + "]";
	    } else {
	      return "[" + (this.toArray().join(', ')) + "]";
	    }
	  };

	  Base.prototype.neq = function(b) {
	    return !this.eq(b);
	  };

	  Base.prototype.between = function(a, b) {
	    return this.gte(a) && this.lte(b);
	  };

	  Base.prototype.floatEq = floatEq;

	  Base.prototype.isNumber = isNumber;


	  /*
	  for use by extending children classes
	   */

	  Base.defineAtomicClass = function(arg) {
	    this.fieldNames = arg.fieldNames, this.constructorFunctionName = arg.constructorFunctionName;
	    if (isString(this.fieldNames)) {
	      this.fieldNames = wordsArray(this.fieldNames);
	    }
	    this.getConstructorFunctionName();
	    this._defineCore(this.fieldNames);
	    this._defineComparisonOperators(this.fieldNames);
	    return this._defineMathOperators(this.fieldNames);

	    /*
	    TODO: more standard methods to add:
	    
	     * most init can be standardized
	    _init*
	    
	     * more math methods
	    min max floor ceil average bound round
	    
	     * class methods
	    @isPoint
	     */
	  };

	  reservedWords = {
	    "with": true
	  };

	  Base._definePrototypeMethodViaEval = function(name, paramsList, body) {
	    var nameInEval;
	    nameInEval = reservedWords[name] ? "" : name;
	    return this.prototype[name] = eval(body = "(\nfunction " + nameInEval + "(" + paramsList + ") {\n" + body + "\n}\n)");
	  };


	  /*
	  define: eq, lt, gt, lte, gt
	  With these signatures:
	  
	     * provide numbers for all fields to compare
	    myColor.eq r, g, b, a
	  
	     * provide another instance of @class to compare against
	    myColor.eq myOtherColor
	   */

	  letterFieldNames = wordsArray("a b c d e f");

	  Base._defineComparisonOperators = function(fieldNames) {
	    var comparisonOperators, f, functionName, i, operator, params, paramsList, results;
	    params = letterFieldNames.slice(0, fieldNames.length);
	    paramsList = params.join(', ');
	    this._definePrototypeMethodViaEval("eq", paramsList, "if (this === a) return true;\nif (this.isNumber(a)) {\n  return\n  " + (((function() {
	      var j, len, results;
	      results = [];
	      for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
	        f = fieldNames[i];
	        results.push("this.floatEq(this." + f + ", " + params[i] + ")");
	      }
	      return results;
	    })()).join(" &&\n  ")) + ";\n} else {\n  return a &&\n  " + (((function() {
	      var j, len, results;
	      results = [];
	      for (j = 0, len = fieldNames.length; j < len; j++) {
	        f = fieldNames[j];
	        results.push("this.floatEq(this." + f + ", a." + f + ")");
	      }
	      return results;
	    })()).join(" &&\n  ")) + ";\n}");
	    comparisonOperators = {
	      lt: "<",
	      gt: ">",
	      lte: "<=",
	      gte: ">="
	    };
	    results = [];
	    for (functionName in comparisonOperators) {
	      operator = comparisonOperators[functionName];
	      results.push(this._definePrototypeMethodViaEval(functionName, paramsList, "if (this.isNumber(a)) {\n  return\n  " + (((function() {
	        var j, len, results1;
	        results1 = [];
	        for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
	          f = fieldNames[i];
	          results1.push("this." + f + " " + operator + " " + params[i]);
	        }
	        return results1;
	      })()).join(" &&\n  ")) + ";\n} else {\n  return a &&\n  " + (((function() {
	        var j, len, results1;
	        results1 = [];
	        for (j = 0, len = fieldNames.length; j < len; j++) {
	          f = fieldNames[j];
	          results1.push("this." + f + " " + operator + " a." + f);
	        }
	        return results1;
	      })()).join(" &&\n  ")) + ";\n}"));
	    }
	    return results;
	  };


	  /*
	  define: add, sub, mul and div
	  With these signatures:
	  
	    myColor.add r, g, b, a   # 4 numbers
	  
	    myColor.add myOtherColor, into # add by component
	    myColor.add v, into            # one number to add to all
	  
	    into is optional. if set:
	      it should be an instance of @class
	      into is what is returned; a new instance of @class is not created
	      into's field are set to the result
	      NOTE: Atomic classes are designed to be used Pure-Functionally!
	        SO, only use this if you created 'into' and you are not using it ANYWHERE else.
	   */

	  Base._defineMathOperators = function(fieldNames) {
	    var f, functionName, i, mathOperators, operator, params, results;
	    mathOperators = {
	      add: "+",
	      sub: "-",
	      mul: "*",
	      div: "/"
	    };
	    params = letterFieldNames.slice(0, fieldNames.length);
	    results = [];
	    for (functionName in mathOperators) {
	      operator = mathOperators[functionName];
	      results.push(this._definePrototypeMethodViaEval(functionName, params.join(', '), "if (this.isNumber(b)) {\n  return this._into(\n  null,\n  " + (((function() {
	        var j, len, results1;
	        results1 = [];
	        for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
	          f = fieldNames[i];
	          results1.push("this." + f + " " + operator + " " + params[i]);
	        }
	        return results1;
	      })()).join(",\n  ")) + "\n  );\n} else if (this.isNumber(a)) {\n  return this._into(\n  b,\n  " + (((function() {
	        var j, len, results1;
	        results1 = [];
	        for (j = 0, len = fieldNames.length; j < len; j++) {
	          f = fieldNames[j];
	          results1.push("this." + f + " " + operator + " a");
	        }
	        return results1;
	      })()).join(",\n  ")) + "\n  );\n} else {\n  return this._into(\n  b,\n  " + (((function() {
	        var j, len, results1;
	        results1 = [];
	        for (j = 0, len = fieldNames.length; j < len; j++) {
	          f = fieldNames[j];
	          results1.push("this." + f + " " + operator + " a." + f);
	        }
	        return results1;
	      })()).join(",\n  ")) + "\n  );\n}"));
	    }
	    return results;
	  };

	  Base._defineCore = function(fields) {
	    var f, field, fieldList, j, len;
	    fieldList = fields.join(', ');
	    this._definePrototypeMethodViaEval("_into", "into, " + fieldList, "if (into === true)\n  into = this;\nelse\n  into = into || new this.class;\nreturn into._setAll(" + fieldList + ");");
	    this._definePrototypeMethodViaEval("_setAll", fieldList, (((function() {
	      var j, len, results;
	      results = [];
	      for (j = 0, len = fields.length; j < len; j++) {
	        f = fields[j];
	        results.push("this." + f + " = " + f);
	      }
	      return results;
	    })()).join(";\n")) + ";\nreturn this;");
	    this._definePrototypeMethodViaEval("with", fieldList, "if (this.eq(" + fieldList + "))\n  return this;\nelse\n  return new this.class(" + fieldList + ");");
	    for (j = 0, len = fields.length; j < len; j++) {
	      field = fields[j];
	      this._definePrototypeMethodViaEval("with" + (upperCamelCase(field)), field, "return this.with(\n  " + (((function() {
	        var k, len1, results;
	        results = [];
	        for (k = 0, len1 = fields.length; k < len1; k++) {
	          f = fields[k];
	          results.push(f === field ? f : "this." + f);
	        }
	        return results;
	      })()).join(",\n  ")) + "\n);");
	    }
	    this._definePrototypeMethodViaEval("interpolate", "b, p, into", "var oneMinusP = 1 - p;\nreturn this._into(\ninto,\n" + (((function() {
	      var k, len1, results;
	      results = [];
	      for (k = 0, len1 = fields.length; k < len1; k++) {
	        f = fields[k];
	        results.push("b." + f + " * p + this." + f + " * oneMinusP");
	      }
	      return results;
	    })()).join(",\n")) + "\n);");
	    this._definePrototypeMethodViaEval("toArray", "", "return [" + (((function() {
	      var k, len1, results;
	      results = [];
	      for (k = 0, len1 = fields.length; k < len1; k++) {
	        f = fields[k];
	        results.push("this." + f);
	      }
	      return results;
	    })()).join(", ")) + "];");
	    return this._definePrototypeMethodViaEval("toObject", "", "return {" + (((function() {
	      var k, len1, results;
	      results = [];
	      for (k = 0, len1 = fields.length; k < len1; k++) {
	        f = fields[k];
	        results.push(f + ": this." + f);
	      }
	      return results;
	    })()).join(", ")) + "};");
	  };

	  return Base;

	})(BaseObject);


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	var AtomicBase, Foundation, PI, Point, abs, atan, bound, ceil, floatEq, floor, inspect, inspectedObjectLiteral, isArray, isFunction, isNumber, isString, log, max, min, nearInfinity, round, sqrt, stringToNumberArray,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	AtomicBase = __webpack_require__(131);

	inspect = Foundation.inspect, bound = Foundation.bound, floatEq = Foundation.floatEq, log = Foundation.log, isNumber = Foundation.isNumber, isArray = Foundation.isArray, isString = Foundation.isString, isFunction = Foundation.isFunction, stringToNumberArray = Foundation.stringToNumberArray, nearInfinity = Foundation.nearInfinity, inspectedObjectLiteral = Foundation.inspectedObjectLiteral;

	abs = Math.abs, sqrt = Math.sqrt, atan = Math.atan, PI = Math.PI, floor = Math.floor, ceil = Math.ceil, round = Math.round, min = Math.min, max = Math.max;


	/*
	point() general point constructor

	IN: (p:Point)
	OUT: p

	IN: ()
	IN: ([])
	OUT: point 0, 0

	IN: (string)
	OUT: Point.namedPoints[string] || Point.parse string

	IN: (s:number)
	IN: ([s:number])
	OUT: new Point s, s

	IN: (x:number, y:number)
	IN: ([x:number, y:number])
	OUT: new Point x, y

	IN: ({x:number, y:number})
	OUT: new Point x || 0, y || 0

	IN: ({aspectRatio: number, area: number})
	  aspectRatio: number representing: width / height
	  area: number representing the square-area desired
	OUT:
	  a point, p, with:
	    p.area == o.area
	    p.aspectRatio == o.aspectRatio
	 */

	module.exports = Point = (function(superClass) {
	  var bottomLeft, centerCenter, centerLeft, k, namedPoints, point, point0, point1, pointWithAspectRatioAndArea, ref, topCenter, topRight, v;

	  extend(Point, superClass);

	  function Point() {
	    return Point.__super__.constructor.apply(this, arguments);
	  }

	  Point.defineAtomicClass({
	    fieldNames: "x y"
	  });

	  Point.isPoint = function(v) {
	    return v instanceof Point;
	  };

	  pointWithAspectRatioAndArea = function(arg) {
	    var area, aspectRatio, sqrtArea;
	    aspectRatio = arg.aspectRatio, area = arg.area;
	    sqrtArea = Math.sqrt(area / aspectRatio);
	    return point(sqrtArea * aspectRatio, sqrtArea);
	  };

	  Point.point = point = function(a, b) {
	    var p, x, y;
	    if (a instanceof Point) {
	      return a;
	    }
	    if (isString(a) && (p = namedPoints[a])) {
	      return p;
	    }
	    if ((a != null ? a.aspectRatio : void 0) && a.area >= 0) {
	      return pointWithAspectRatioAndArea(a);
	    }
	    x = a || 0;
	    y = b != null ? b : a;
	    if (point0.eq(x, y)) {
	      return point0;
	    }
	    if (point1.eq(x, y)) {
	      return point1;
	    }
	    return new Point(a, b);
	  };

	  Point.parse = function(string, existing) {
	    if (existing) {
	      throw new Error("existing feature is no longer supported");
	    }
	    return new Point(string);
	  };

	  Point.prototype._init = function(x, y) {
	    x || (x = 0);
	    if (y == null) {
	      y = x;
	    }
	    this.x = x - 0;
	    return this.y = y - 0;
	  };

	  Point.prototype._initFromObject = function(o) {
	    this.x = o.x || 0;
	    return this.y = o.y || 0;
	  };

	  Point.getter({
	    top: function() {
	      return 0;
	    },
	    left: function() {
	      return 0;
	    },
	    right: function() {
	      return this.x;
	    },
	    bottom: function() {
	      return this.y;
	    },
	    centerX: function() {
	      return this.x * .5;
	    },
	    centerY: function() {
	      return this.y * .5;
	    },
	    tl: function() {
	      return point0;
	    },
	    tc: function() {
	      return this.mul(0.5, 0);
	    },
	    tr: function() {
	      return this.mul(1, 0);
	    },
	    lc: function() {
	      return this.mul(0, 0.5);
	    },
	    cc: function() {
	      return this.mul(0.5, 0.5);
	    },
	    rc: function() {
	      return this.mul(1, 0.5);
	    },
	    bl: function() {
	      return this.mul(0, 1);
	    },
	    bc: function() {
	      return this.mul(0.5, 1);
	    },
	    br: function() {
	      return this;
	    },
	    ccNeg: function() {
	      return this.mul(-0.5);
	    },
	    topLeft: function() {
	      return point0;
	    },
	    topCenter: function() {
	      return this.mul(0.5, 0);
	    },
	    topRight: function() {
	      return this.mul(1, 0);
	    },
	    centerLeft: function() {
	      return this.mul(0, 0.5);
	    },
	    centerCenter: function() {
	      return this.mul(0.5, 0.5);
	    },
	    centerRight: function() {
	      return this.mul(1, 0.5);
	    },
	    bottomLeft: function() {
	      return this.mul(0, 1);
	    },
	    bottomCenter: function() {
	      return this.mul(0.5, 1);
	    },
	    bottomRight: function() {
	      return this;
	    },
	    w: function() {
	      return this.x;
	    },
	    width: function() {
	      return this.x;
	    },
	    h: function() {
	      return this.y;
	    },
	    height: function() {
	      return this.y;
	    },
	    neg: function() {
	      return new Point(-this.x, -this.y);
	    },
	    inv: function() {
	      return new Point(1.0 / this.x, 1.0 / this.y);
	    },
	    vector: function() {
	      return [this.x, this.y];
	    },
	    magnitudeSquared: function() {
	      return this.x * this.x + this.y * this.y;
	    },
	    magnitude: function() {
	      return sqrt(this.x * this.x + this.y * this.y);
	    },
	    aspectRatio: function() {
	      return this.x / this.y;
	    },
	    absoluteAspectRatio: function() {
	      return abs(this.x / this.y);
	    },
	    swapped: function() {
	      return point(this.y, this.x);
	    },
	    rounded: function() {
	      return this.round();
	    },
	    floored: function() {
	      return this.floor();
	    },
	    ceiled: function() {
	      return this.ceil();
	    },
	    area: function() {
	      return this.x * this.y;
	    },
	    sum: function() {
	      return this.x + this.y;
	    },
	    size: function() {
	      return this;
	    },
	    location: function() {
	      return point0;
	    },
	    abs: function() {
	      return this["with"](abs(this.x), abs(this.y));
	    },
	    unitVector: function() {
	      var m;
	      m = 1 / this.magnitude;
	      return new Point(this.x * m, this.y * m);
	    },
	    perpendicularVector: function() {
	      return new Point(this.y, -this.x);
	    },
	    unitPerpendicularVector: function() {
	      var m;
	      m = 1 / this.magnitude;
	      return new Point(this.y * m, -this.x * m);
	    },
	    angle: function() {
	      if (this.x === 0) {
	        return PI * (this.y > 0 ? .5 : 1.5);
	      } else {
	        if (this.x > 0) {
	          return atan(this.y / this.x);
	        } else {
	          return atan(this.y / this.x) + PI;
	        }
	      }
	    },
	    isInteger: function() {
	      return floatEq(this.x, this.x | 0) && floatEq(this.y, this.y | 0);
	    }
	  });

	  Point.prototype.distance = function(p2) {
	    return sqrt(this.distanceSquared(p2));
	  };

	  Point.prototype.distanceSquared = function(p2) {
	    var x, y;
	    x = this.x - p2.x;
	    y = this.y - p2.y;
	    return x * x + y * y;
	  };

	  Point.prototype.withArea = function(newArea) {
	    var area;
	    area = this.area;
	    if (!(area > 0 && newArea >= 0)) {
	      throw new Error("area must be > 0");
	    }
	    return this.mul(Math.sqrt(newArea / area));
	  };

	  Point.prototype.vectorLength = 2;

	  Point.prototype.toIndex = function(lineStride) {
	    return ~~this.y * lineStride + ~~this.x;
	  };

	  Point.prototype.contains = function(p) {
	    return p.x >= 0 && p.y >= 0 && p.x < this.x & p.y < this.y;
	  };

	  Point.prototype.nearestInsidePoint = function(p) {
	    return this["with"](bound(0, p.x, this.x), bound(0, p.y, this.y));
	  };

	  Point.prototype.appendToVector = function(vector) {
	    var l;
	    l = vector.length;
	    vector[l + 1] = this.y;
	    return vector[l] = this.x;
	  };

	  Point.prototype.dot = function(p) {
	    return this.x * p.x + this.y * p.y;
	  };

	  Point.prototype.cross = function(p) {
	    return this.x * p.y - this.y * p.x;
	  };

	  Point.prototype.floor = function() {
	    return this["with"](floor(this.x), floor(this.y));
	  };

	  Point.prototype.ceil = function() {
	    return this["with"](ceil(this.x), ceil(this.y));
	  };

	  Point.prototype.union = function(b) {
	    if (b instanceof Point) {
	      return this.max(b);
	    } else {
	      return b.union(this);
	    }
	  };

	  Point.prototype.intersection = function(b) {
	    if (b instanceof Point) {
	      return this.min(b);
	    } else {
	      return b.intersection(this);
	    }
	  };

	  Point.prototype.min = function(b) {
	    if (b == null) {
	      b = null;
	    }
	    if (b) {
	      return this["with"](min(this.x, b.x), min(this.y, b.y));
	    } else {
	      return min(this.x, this.y);
	    }
	  };

	  Point.prototype.max = function(b) {
	    if (b == null) {
	      b = null;
	    }
	    if (b) {
	      return this["with"](max(this.x, b.x), max(this.y, b.y));
	    } else {
	      return max(this.x, this.y);
	    }
	  };

	  Point.prototype.average = function(b) {
	    if (b == null) {
	      b = null;
	    }
	    if (b) {
	      return this["with"]((this.x + b.x) / 2, (this.y + b.y) / 2);
	    } else {
	      return (this.x + this.y) / 2;
	    }
	  };

	  Point.prototype.bound = function(a, b) {
	    return this["with"](bound(a.x, this.x, b.x), bound(a.y, this.y, b.y));
	  };

	  Point.prototype.round = function(m) {
	    if (m == null) {
	      m = 1;
	    }
	    return this["with"](round(this.x / m) * m, round(this.y / m) * m);
	  };

	  Point.prototype.roundOut = function() {
	    return this.ceil();
	  };


	  /*
	  OUT:
	    out.aspectRatio == @aspectRatio
	    out <= into
	    out.x == into.x or out.y == into.y
	  proposed rename: scaledJustLte
	   */

	  Point.prototype.fitInto = function(into) {
	    var xr, yr;
	    xr = into.x / this.x;
	    yr = into.y / this.y;
	    return this.mul(min(xr, yr));
	  };


	  /*
	  OUT:
	    out.aspectRatio == @aspectRatio
	    out >= into
	    out.x == into.x or out.y == into.y
	  
	  KEYWORD: I used to call this 'zoom'
	  proposed rename: scaledJustGte
	   */

	  Point.prototype.fill = function(into) {
	    var xr, yr;
	    xr = into.x / this.x;
	    yr = into.y / this.y;
	    return this.mul(max(xr, yr));
	  };


	  /*
	  OUT:
	    out.aspectRatio == @aspectRatio
	    out.area == p.area
	   */

	  Point.prototype.withSameAreaAs = function(p) {
	    return this.mul(Math.sqrt(p.area / this.area));
	  };

	  point0 = Object.freeze(new Point(0));

	  point1 = Object.freeze(new Point(1));

	  topRight = Object.freeze(new Point(1, 0));

	  topCenter = Object.freeze(new Point(0.5, 0));

	  centerLeft = Object.freeze(new Point(0, 0.5));

	  centerCenter = Object.freeze(new Point(0.5));

	  bottomLeft = Object.freeze(new Point(0, 1));

	  Point.namedPoints = namedPoints = {
	    point0: point0,
	    point1: point1,
	    topLeft: point0,
	    topCenter: topCenter,
	    topRight: topRight,
	    centerLeft: centerLeft,
	    centerCenter: centerCenter,
	    centerRight: Object.freeze(new Point(1, 0.5)),
	    bottomLeft: bottomLeft,
	    bottomCenter: Object.freeze(new Point(0.5, 1)),
	    bottomRight: point1,
	    pointNearInfinity: Object.freeze(new Point(nearInfinity)),
	    left: point0,
	    center: topCenter,
	    right: topRight,
	    top: point0,
	    bottom: bottomLeft
	  };

	  ref = Point.namedPoints;
	  for (k in ref) {
	    v = ref[k];
	    Point[k] = v;
	  }

	  return Point;

	})(AtomicBase);


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, AtomicBase, Foundation, Point, Rectangle, bound, ceil, floatEq, floor, isArray, isFunction, isNumber, isString, log, max, min, point, round, stringToNumberArray,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(127);

	AtomicBase = __webpack_require__(131);

	Point = __webpack_require__(132);

	max = Foundation.max, min = Foundation.min, bound = Foundation.bound, round = Foundation.round, floatEq = Foundation.floatEq, floor = Foundation.floor, ceil = Foundation.ceil, round = Foundation.round, log = Foundation.log, isNumber = Foundation.isNumber, isArray = Foundation.isArray, isString = Foundation.isString, isFunction = Foundation.isFunction, stringToNumberArray = Foundation.stringToNumberArray;

	point = Point.point;

	module.exports = Rectangle = (function(superClass) {
	  var rect;

	  extend(Rectangle, superClass);

	  function Rectangle() {
	    return Rectangle.__super__.constructor.apply(this, arguments);
	  }

	  Rectangle.defineAtomicClass({
	    fieldNames: "x y w h",
	    constructorFunctionName: "rect"
	  });

	  Rectangle.rect = rect = function(a, b, c, d) {
	    if (a instanceof Rectangle) {
	      return a;
	    }
	    return new Rectangle(a, b, c, d);
	  };

	  Rectangle.prototype._init = function(a, b, c, d) {
	    this.x = this.y = this.w = this.h = 0;
	    if (d != null) {
	      this.x = a - 0;
	      this.y = b - 0;
	      this.w = c - 0;
	      return this.h = d - 0;
	    } else if (b != null) {
	      if (b instanceof Point) {
	        this.x = a.x;
	        this.y = a.y;
	        this.w = b.w;
	        return this.h = b.h;
	      } else {
	        this.w = a - 0;
	        return this.h = b - 0;
	      }
	    } else if (a instanceof Point) {
	      this.w = a.w;
	      return this.h = a.h;
	    } else if (a != null) {
	      return this.w = this.h = a - 0;
	    }
	  };

	  Rectangle.getter({
	    clone: function() {
	      return new Rectangle(this.x, this.y, this.w, this.h);
	    },
	    location: function() {
	      return new Point(this.x, this.y);
	    },
	    locationMatrix: function() {
	      return Atomic.Matrix.translateXY(this.x, this.y);
	    },
	    size: function() {
	      return new Point(this.w, this.h);
	    },
	    width: function() {
	      return this.w;
	    },
	    height: function() {
	      return this.h;
	    },
	    rounded: function() {
	      return this["with"](round(this.x), round(this.y), round(this.w), round(this.h));
	    },
	    tl: function() {
	      return new Point(this.x, this.y);
	    },
	    tc: function() {
	      return new Point(this.hCenter, this.y);
	    },
	    tr: function() {
	      return new Point(this.right, this.y);
	    },
	    lc: function() {
	      return new Point(this.x, this.vCenter);
	    },
	    cc: function() {
	      return new Point(this.hCenter, this.vCenter);
	    },
	    rc: function() {
	      return new Point(this.right, this.vCenter);
	    },
	    bl: function() {
	      return new Point(this.x, this.bottom);
	    },
	    bc: function() {
	      return new Point(this.hCenter, this.bottom);
	    },
	    br: function() {
	      return new Point(this.right, this.bottom);
	    },
	    topLeft: function() {
	      return new Point(this.x, this.y);
	    },
	    topCenter: function() {
	      return new Point(this.hCenter, this.y);
	    },
	    topRight: function() {
	      return new Point(this.right, this.y);
	    },
	    centerLeft: function() {
	      return new Point(this.x, this.vCenter);
	    },
	    centerCenter: function() {
	      return new Point(this.hCenter, this.vCenter);
	    },
	    centerRight: function() {
	      return new Point(this.right, this.vCenter);
	    },
	    bottomLeft: function() {
	      return new Point(this.x, this.bottom);
	    },
	    bottomCenter: function() {
	      return new Point(this.hCenter, this.bottom);
	    },
	    bottomRight: function() {
	      return new Point(this.right, this.bottom);
	    },
	    locationIsZero: function() {
	      return floatEq(this.x, 0) && floatEq(this.y, 0);
	    },
	    top: function() {
	      return this.y;
	    },
	    left: function() {
	      return this.x;
	    },
	    right: function() {
	      return this.x + this.w;
	    },
	    bottom: function() {
	      return this.y + this.h;
	    },
	    hCenter: function() {
	      return this.x + this.w * .5;
	    },
	    vCenter: function() {
	      return this.y + this.h * .5;
	    },
	    infinite: function() {
	      return this.w === 2e308 || this.h === 2e308;
	    },
	    normalized: function() {
	      var h, w, x, y;
	      w = this.w;
	      h = this.h;
	      if (w >= 0 && h >= 0) {
	        return this;
	      } else {
	        x = this.x;
	        y = this.y;
	        if (w < 0) {
	          x += w;
	          w = -w;
	        }
	        if (h < 0) {
	          y += h;
	          h = -h;
	        }
	        return this["with"](x, y, w, h);
	      }
	    },
	    area: function() {
	      return this.w * this.h;
	    },
	    corners: function() {
	      var bottom, left, right, top;
	      left = this.left;
	      top = this.top;
	      right = this.right;
	      bottom = this.bottom;
	      return [new Point(left, top), new Point(right, top), new Point(right, bottom), new Point(left, bottom)];
	    }
	  });

	  Rectangle.prototype.withXY = function(x, y) {
	    if (floatEq(x, this.x) && floatEq(y, this.y)) {
	      return this;
	    } else {
	      return new Rectangle(x, y, this.w, this.h);
	    }
	  };

	  Rectangle.prototype.withWH = function(w, h) {
	    if (floatEq(w, this.w) && floatEq(h, this.h)) {
	      return this;
	    } else {
	      return new Rectangle(this.x, this.y, w, h);
	    }
	  };

	  Rectangle.prototype.withLocation = function(v) {
	    return this.withXY(v.x, v.y);
	  };

	  Rectangle.prototype.withSize = function(v) {
	    return this.withWH(v.x, v.y);
	  };

	  Rectangle.prototype.movedBy = function(d) {
	    return this.withXY(this.x + d.x, this.y + d.y);
	  };

	  Rectangle.prototype.nearestInsidePoint = function(p) {
	    return new Point(bound(this.left, p.x, this.right), bound(this.top, p.y, this.bottom));
	  };

	  Rectangle.prototype.largestInsideRect = function(ofSize) {
	    var h, scaler, w;
	    scaler = min(this.w / ofSize.w, this.h / ofSize.h);
	    w = ofSize.w * scale;
	    h = ofSize.h * scale;
	    return new Rectangle((this.w - w) / 2, (this.h - h) / 2, w, h);
	  };

	  Rectangle.prototype.overlaps = function(val) {
	    if (val == null) {
	      return false;
	    }
	    if (val instanceof Point) {
	      return this.contains(val);
	    } else if (val instanceof Rectangle) {
	      return val.getRight() > this.getLeft() && val.getBottom() > this.getTop() && val.getLeft() < this.getRight() && val.getTop() < this.getBottom();
	    } else {
	      throw new Error("Invalid arguments for 'overlaps'. Expecting Point or Rectangle. Got: " + val + ".");
	    }
	  };

	  Rectangle.prototype.contains = function(val) {
	    if (val == null) {
	      return false;
	    }
	    if (val instanceof Point) {
	      return val.x >= this.x && val.y >= this.y && val.x < this.right && val.y < this.bottom;
	    } else if (val instanceof Rectangle) {
	      return val.x >= this.x && val.y >= this.y && val.right <= this.right && val.bottom <= this.bottom;
	    } else {
	      throw new Error("Invalid arguments for 'contains'. Expecting Point or Rectangle. Got: " + val + ".");
	    }
	  };

	  Rectangle.prototype.round = function(m) {
	    var h, w, x, y;
	    if (m == null) {
	      m = 1;
	    }
	    x = round(this.x, m);
	    y = round(this.y, m);
	    w = round(this.x + this.w, m) - x;
	    h = round(this.y + this.h, m) - y;
	    return this["with"](x, y, w, h);
	  };

	  Rectangle.prototype.roundOut = function(m, k) {
	    var h, w, x, y;
	    if (m == null) {
	      m = 1;
	    }
	    if (k == null) {
	      k = 0;
	    }
	    x = floor(this.x + k, m);
	    y = floor(this.y + k, m);
	    w = ceil(this.x + this.w - k, m) - x;
	    h = ceil(this.y + this.h - k, m) - y;
	    return this["with"](x, y, w, h);
	  };

	  Rectangle.prototype.roundIn = function(m, k) {
	    var h, w, x, y;
	    if (m == null) {
	      m = 1;
	    }
	    if (k == null) {
	      k = 0;
	    }
	    x = ceil(this.x - k, m);
	    y = ceil(this.y - k, m);
	    w = floor(this.x + this.w + k, m) - x;
	    h = floor(this.y + this.h + k, m) - y;
	    return this["with"](x, y, w, h);
	  };

	  Rectangle.prototype.union = function(b) {
	    var h, w, x, y;
	    if (b == null) {
	      return this;
	    }
	    if (this.getArea() <= 0) {
	      return b;
	    }
	    x = min(this.x, b.left);
	    y = min(this.y, b.top);
	    w = max(this.getRight(), b.getRight()) - x;
	    h = max(this.getBottom(), b.getBottom()) - y;
	    return this["with"](x, y, w, h);
	  };

	  Rectangle.prototype.unionInto = function(into) {
	    var area, h, intoArea, w, x, y;
	    area = this.getArea();
	    intoArea = into.getArea();
	    if (area <= 0 || intoArea === 2e308) {
	      return into;
	    }
	    if (intoArea <= 0 || area === 2e308) {
	      into.x = this.x;
	      into.y = this.y;
	      into.w = this.w;
	      into.h = this.h;
	    } else {
	      x = into.x, y = into.y, w = into.w, h = into.h;
	      into.x = min(x, this.x);
	      into.y = min(y, this.y);
	      into.w = max(x + w, this.x + this.w) - into.x;
	      into.h = max(y + h, this.y + this.h) - into.y;
	    }
	    return into;
	  };

	  Rectangle.prototype.intersectInto = function(into) {
	    var area, h, intoArea, w, x, y;
	    area = this.getArea();
	    intoArea = into.getArea();
	    if (intoArea <= 0 || area === 2e308) {
	      return into;
	    }
	    if (area <= 0 || intoArea === 2e308) {
	      into.x = this.x;
	      into.y = this.y;
	      into.w = this.w;
	      return into.h = this.h;
	    } else {
	      x = into.x, y = into.y, w = into.w, h = into.h;
	      into.x = max(x, this.x);
	      into.y = max(y, this.y);
	      into.w = max(0, min(x + w, this.x + this.w) - into.x);
	      into.h = max(0, min(y + h, this.y + this.h) - into.y);
	      return into;
	    }
	  };

	  Rectangle.prototype.intersection = function(b) {
	    var h, w, x, y;
	    if (b == null) {
	      return this;
	    }
	    if (b.getArea() === 2e308 || b.contains(this)) {
	      return this;
	    }
	    if (this.getArea() === 2e308 || this.contains(b)) {
	      return b;
	    }
	    x = max(this.x, b.left);
	    y = max(this.y, b.top);
	    w = min(this.getRight(), b.getRight()) - x;
	    h = min(this.getBottom(), b.getBottom()) - y;
	    if (w <= 0 || h <= 0) {
	      return Rectangle.nothing;
	    } else {
	      return this["with"](x, y, w, h);
	    }
	  };

	  Rectangle.prototype.grow = function(a, b) {
	    var gx, gy;
	    if (a instanceof Point) {
	      gx = a.x;
	      gy = a.y;
	    } else {
	      gx = a;
	      gy = b != null ? b : a;
	    }
	    return this["with"](this.x - gx, this.y - gy, this.w + 2 * gx, this.h + 2 * gy);
	  };

	  Rectangle.nothing = Object.freeze(new Rectangle(0, 0, 0, 0));

	  Rectangle.everything = Object.freeze(new Rectangle(0, 0, 2e308, 2e308));

	  return Rectangle;

	})(AtomicBase);


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	
	/*

	With the exception of the setter methods, this is a pure-functional class.
	 */

	/*
	Experiment: Instead of storing the matrix as 6 members, use a Float32Array:

	  Bonus: if we order the 6 elements correctly, we can just pass the Float32Array directly to Webgl uniformMatrix3fv
	  Result:
	    FF is about 2x as fast with this implementation, but Chrome is about 10x slower (see below)
	    Sticking with Members implementation for now.

	On my Macbook pro Retina (2.6 GHz Intel Core i7)

	Chrome 29.0.1547.57 (members)
	  Matrix.translate 14,716,649/s
	  matrix().translate 8,052,404/s
	  transform point 3,922,725/s
	  invert 12,733,472/s
	  mul 16,146,097/s

	Chrome 29.0.1547.57 (float32Array)
	  Matrix.translate 926,402/s
	  matrix().translate 463,791/s
	  transform point 3,684,177/s
	  invert 978,248/s
	  mul 992,078/s

	FF 23.0.1 (members)
	  Matrix.translate 1,281,078/s
	  matrix().translate 534,542/s
	  transform point 768,224/s
	  invert 1,374,788/s
	  mul 1,413,206/s

	FF 23.0.1 (float32Array)
	  Matrix.translate 2,126,281/s
	  matrix().translate 1,013,548/s
	  transform point 832,604/s
	  invert 2,524,903/s
	  mul 2,669,331/s

	NOTE! the order of the fields in the float32array for Webgl uniformMatrix3fv should be:
	  @values[0] = @sx
	  @values[1] = @shy
	  @values[2] = @tx
	  @values[3] = @shx
	  @values[4] = @sy
	  @values[5] = @ty
	 */
	var AtomicBase, Foundation, Matrix, Point, Rectangle, compact, float32Eq, inspect, isNumber, log, point, rect, simplifyNum,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	AtomicBase = __webpack_require__(131);

	Point = __webpack_require__(132);

	Rectangle = __webpack_require__(133);

	point = Point.point;

	rect = Rectangle.rect;

	inspect = Foundation.inspect, simplifyNum = Foundation.simplifyNum, float32Eq = Foundation.float32Eq, compact = Foundation.compact, log = Foundation.log, isNumber = Foundation.isNumber;

	module.exports = Matrix = (function(superClass) {
	  var cleanInspect, identityMatrix, intermediatResultMatrix, matrix, transform1D;

	  extend(Matrix, superClass);

	  function Matrix() {
	    return Matrix.__super__.constructor.apply(this, arguments);
	  }

	  Matrix.defineAtomicClass({
	    fieldNames: "sx sy shx shy tx ty"
	  });

	  Matrix.matrix = matrix = function(a, b, c, d, e, f) {
	    if (a instanceof Matrix) {
	      return a;
	    } else if (a === null || a === void 0) {
	      return identityMatrix;
	    } else {
	      return new Matrix(a, b, c, d, e, f);
	    }
	  };

	  Matrix._cleanInspect = cleanInspect = function(pointName, s) {
	    var out, r;
	    out = pointName ? (r = new RegExp("([0-9])" + pointName, "g"), s.replace(r, "$1 * " + pointName).replace(/-1 \* /g, "-").replace(/\ \+ -/g, " - ").replace(/0\./g, ".")) : s.replace(/-1([A-Za-z]+)/g, "-$1").replace(/\ \+ -/g, " - ").replace(/0\./g, ".");
	    return out;
	  };

	  Matrix.translate = function(a, b) {
	    var x, y;
	    if (isNumber(b)) {
	      throw new Error("Matrix.translate no longer accepts two numbers. Use translateXY");
	    }
	    if (isNumber(a)) {
	      x = y = a;
	    } else {
	      x = a.x, y = a.y;
	    }
	    return Matrix.translateXY(x, y);
	  };

	  Matrix.translateXY = function(x, y) {
	    if (x === 0 && y === 0) {
	      return identityMatrix;
	    } else {
	      return new Matrix(1, 1, 0, 0, x, y);
	    }
	  };

	  Matrix.scale = function(a, b) {
	    var x, y;
	    if (isNumber(b)) {
	      throw new Error("Matrix.scale no longer accepts two numbers. Use translateXY");
	    }
	    if (isNumber(a)) {
	      x = y = a;
	    } else {
	      x = a.x, y = a.y;
	    }
	    return Matrix.scaleXY(x, y);
	  };

	  Matrix.scaleXY = function(sx, sy) {
	    if (sx === 1 && sy === 1) {
	      return identityMatrix;
	    } else {
	      return new Matrix(sx, sy, 0, 0, 0, 0);
	    }
	  };

	  Matrix.rotate = function(radians) {
	    var cr, sr;
	    cr = Math.cos(radians);
	    sr = Math.sin(radians);
	    if (cr === 1 && sr === 0) {
	      return identityMatrix;
	    } else {
	      return new Matrix(cr, cr, -sr, sr, 0, 0);
	    }
	  };

	  Matrix.prototype.initDefaults = function() {
	    this.sx = this.sy = 1;
	    this.shy = this.shx = 0;
	    this.tx = this.ty = 0;
	    this._exactScale = this._exactScaler = null;
	    return this;
	  };

	  Matrix.prototype._init = function(a, b, c, d, e, f) {
	    this.initDefaults();
	    if (a == null) {
	      return;
	    }
	    if (a instanceof Point) {
	      return this._initFromPoint(a);
	    } else if (a instanceof Matrix) {
	      return this._initFromMatrix(a);
	    } else {
	      this.sx = a - 0;
	      if (b != null) {
	        this.sy = b - 0;
	      }
	      if (c != null) {
	        this.shx = c - 0;
	      }
	      if (d != null) {
	        this.shy = d - 0;
	      }
	      if (e != null) {
	        this.tx = e - 0;
	      }
	      if (f != null) {
	        return this.ty = f - 0;
	      }
	    }
	  };

	  Matrix.prototype.getScale = function() {
	    return this.getS();
	  };

	  Matrix.getter({
	    t: function() {
	      return point(this.tx, this.ty);
	    },
	    s: function() {
	      return point(this.sx, this.sy);
	    },
	    sh: function() {
	      return point(this.shx, this.shy);
	    },
	    xsv: function() {
	      return point(this.sx, this.shx);
	    },
	    ysv: function() {
	      return point(this.sy, this.shy);
	    },
	    exactScale: function() {
	      return this._exactScale || (this._exactScale = point(this.xsv.magnitude, this.ysv.magnitude));
	    },
	    exactScaler: function() {
	      return this._exactScaler || (this._exactScaler = this.exactScale.average());
	    },
	    inv: function() {
	      return this.invert();
	    },
	    locationX: function() {
	      return this.tx;
	    },
	    locationY: function() {
	      return this.ty;
	    },
	    scaleX: function() {
	      return this.sx;
	    },
	    scaleY: function() {
	      return this.sy;
	    },
	    location: function() {
	      return point(this.tx, this.ty);
	    },
	    withRoundedTranslation: function() {
	      if (this.translationIsIntegral) {
	        return this;
	      } else {
	        return new Matrix(this.sx, this.sy, this.shx, this.shy, Math.round(this.tx), Math.round(this.ty));
	      }
	    },
	    angle: function() {
	      var p1, p2;
	      p1 = this.transform(Point.point0);
	      p2 = this.transform(new Point(0, 1));
	      return (p2.sub(p1)).angle - Math.PI * .5;
	    },
	    float32Array: function() {
	      return this.fillFloat32Array(new Float32Array(9));
	    },
	    isIdentity: function() {
	      return float32Eq(this.sx, 1) && float32Eq(this.sy, 1) && float32Eq(this.shx, 0) && float32Eq(this.shy, 0) && float32Eq(this.tx, 0) && float32Eq(this.ty, 0);
	    },
	    isTranslateOnly: function() {
	      return float32Eq(this.sx, 1) && float32Eq(this.sy, 1) && float32Eq(this.shx, 0) && float32Eq(this.shy, 0);
	    },
	    translationIsIntegral: function() {
	      return float32Eq(this.tx, Math.round(this.tx)) && float32Eq(this.ty, Math.round(this.ty));
	    },
	    isIntegerTranslateOnly: function() {
	      return this.isTranslateOnly && float32Eq(this.tx, this.tx | 0) && float32Eq(this.ty, this.ty | 0);
	    },
	    isTranslateAndScaleOnly: function() {
	      return float32Eq(this.shx, 0) && float32Eq(this.shy, 0);
	    },
	    isTranslateAndPositiveScaleOnly: function() {
	      return this.sx > 0 && this.sy > 0 && float32Eq(this.shx, 0) && float32Eq(this.shy, 0);
	    }
	  });

	  Matrix.prototype.fillFloat32Array = function(a) {
	    a[0] = this.sx;
	    a[1] = this.shx;
	    a[2] = this.tx;
	    a[3] = this.shy;
	    a[4] = this.sy;
	    a[5] = this.ty;
	    return a;
	  };

	  Matrix.prototype.simplify = function() {
	    return new Matrix(simplifyNum(this.sx), simplifyNum(this.sy), simplifyNum(this.shx), simplifyNum(this.shy), simplifyNum(this.tx), simplifyNum(this.ty));
	  };

	  Matrix.prototype.withAngle = function(a) {
	    return this.rotate(a - this.angle);
	  };

	  Matrix.prototype.withScale = function(a, b) {
	    var x, y;
	    if (isNumber(a)) {
	      x = a;
	      y = b != null ? b : x;
	    } else {
	      x = a.x, y = a.y;
	    }
	    return this.scale(x / this.sx, y / this.sy);
	  };

	  Matrix.prototype.withLocation = function(a, b) {
	    var x, y;
	    if (isNumber(a)) {
	      x = a;
	      y = b != null ? b : x;
	    } else {
	      x = a.x, y = a.y;
	    }
	    if (x === this.tx && y === this.ty) {
	      return this;
	    } else {
	      return new Matrix(this.sx, this.sy, this.shx, this.shy, x, y);
	    }
	  };

	  Matrix.prototype.withLocationXY = function(x, y) {
	    if (x === this.tx && y === this.ty) {
	      return this;
	    } else {
	      return new Matrix(this.sx, this.sy, this.shx, this.shy, x, y);
	    }
	  };


	  /*
	  IN:
	    amount: point or number
	    into: t/f
	   */

	  Matrix.prototype.translate = function(amount, into) {
	    var x, y;
	    if (isNumber(amount)) {
	      x = y = amount;
	    } else {
	      x = amount.x, y = amount.y;
	    }
	    if (isNumber(into)) {
	      throw new Error("Illegal second input: number (" + into + "). Use translateXY.");
	    }
	    return this.translateXY(x, y, into);
	  };

	  Matrix.prototype.translateXY = function(x, y, into) {
	    return this._into(into, this.sx, this.sy, this.shx, this.shy, this.tx + x, this.ty + y);
	  };

	  Matrix.prototype.rotate = function(radians, into) {
	    var cr, sr;
	    cr = Math.cos(radians);
	    sr = Math.sin(radians);
	    return this._into(into, this.sx * cr - this.shy * sr, this.shx * sr + this.sy * cr, this.shx * cr - this.sy * sr, this.sx * sr + this.shy * cr, this.tx * cr - this.ty * sr, this.tx * sr + this.ty * cr);
	  };

	  Matrix.prototype.scale = function(a, into) {
	    var x, y;
	    if (isNumber(into)) {
	      throw new Error("Matrix.scale no longer accepts two numbers. Use translateXY");
	    }
	    if (isNumber(a)) {
	      x = y = a;
	    } else {
	      x = a.x, y = a.y;
	    }
	    return this.scaleXY(x, y, into);
	  };

	  Matrix.prototype.scaleXY = function(x, y, into) {
	    return this._into(into, this.sx * x, this.sy * y, this.shx * x, this.shy * y, this.tx * x, this.ty * y);
	  };

	  Matrix.getter({
	    determinantReciprocal: function() {
	      return 1.0 / (this.sx * this.sy - this.shy * this.shx);
	    }
	  });

	  Matrix.prototype.invert = function(into) {
	    var d;
	    d = this.getDeterminantReciprocal();
	    return this._into(into, d * this.sy, d * this.sx, d * -this.shx, d * -this.shy, d * (-this.tx * this.sy + this.ty * this.shx), d * (this.tx * this.shy - this.ty * this.sx));
	  };

	  Matrix.prototype.mul = function(m, into) {
	    if (isNumber(m)) {
	      return this._into(into, this.sx * m, this.sy * m, this.shx * m, this.shy * m, this.tx * m, this.ty * m);
	    } else {
	      return this._into(into, this.sx * m.sx + this.shy * m.shx, this.shx * m.shy + this.sy * m.sy, this.shx * m.sx + this.sy * m.shx, this.sx * m.shy + this.shy * m.sy, this.tx * m.sx + this.ty * m.shx + m.tx, this.tx * m.shy + this.ty * m.sy + m.ty);
	    }
	  };

	  Matrix.prototype.div = function(m, into) {
	    var multipler;
	    multipler = isNumber(m) ? 1 / m : m.invert(intermediatResultMatrix);
	    return this.mul(multipler, into);
	  };

	  Matrix.prototype.inspectX = function(pointName, nullForZeroString) {
	    var pn;
	    pn = pointName;
	    pointName = pointName ? pointName + "." : "";
	    if (!(this.sx || this.shx || this.tx)) {
	      return (!nullForZeroString ? "0" : void 0);
	    }
	    return cleanInspect(pn, compact([this.sx === 1 ? pointName + "x" : this.sx ? "" + this.sx + pointName + "x" : void 0, this.shx === 1 ? pointName + "y" : this.shx ? "" + this.shx + pointName + "y" : void 0, this.tx ? "" + this.tx : void 0]).join(" + "));
	  };

	  Matrix.prototype.inspectY = function(pointName, nullForZeroString) {
	    var pn;
	    pn = pointName;
	    pointName = pointName ? pointName + "." : "";
	    if (!(this.sy || this.shy || this.ty)) {
	      return (!nullForZeroString ? "0" : void 0);
	    }
	    return cleanInspect(pn, compact([this.sy === 1 ? pointName + "y" : this.sy ? "" + this.sy + pointName + "y" : void 0, this.shy === 1 ? pointName + "x" : this.shy ? "" + this.shy + pointName + "x" : void 0, this.ty ? "" + this.ty : void 0]).join(" + "));
	  };

	  Matrix.prototype.inspectBoth = function(pointName) {
	    return "(" + (this.inspectX(pointName)) + ", " + (this.inspectY(pointName)) + ")";
	  };

	  Matrix.transform1D = transform1D = function(x, y, sx, shx, tx) {
	    return x * sx + y * shx + tx;
	  };


	  /*
	  IN: a: Point or any object where .x and .y are numbers
	  IN: a: x (number; required), b: y (number, default: x)
	   */

	  Matrix.prototype.transform = function(a, b) {
	    var x, y;
	    if (isNumber(a)) {
	      x = a;
	      y = b != null ? b : x;
	    } else {
	      x = a.x, y = a.y;
	    }
	    return new Point(transform1D(x, y, this.sx, this.shx, this.tx), transform1D(y, x, this.sy, this.shy, this.ty));
	  };

	  Matrix.prototype.transformX = function(x, y) {
	    return transform1D(x, y, this.sx, this.shx, this.tx);
	  };

	  Matrix.prototype.transformY = function(x, y) {
	    return transform1D(y, x, this.sy, this.shy, this.ty);
	  };

	  Matrix.prototype.inverseTransform = function(a, b) {
	    var d, shx, shy, sx, sy, tx, ty, x, y;
	    if (isNumber(a)) {
	      x = a;
	      y = b != null ? b : x;
	    } else {
	      x = a.x, y = a.y;
	    }
	    d = this.getDeterminantReciprocal();
	    sx = d * this.sy;
	    sy = d * this.sx;
	    shx = d * -this.shx;
	    shy = d * -this.shy;
	    tx = d * (-this.tx * this.sy + this.ty * this.shx);
	    ty = d * (this.tx * this.shy - this.ty * this.sx);
	    return new Point(transform1D(x, y, sx, shx, tx), transform1D(y, x, sy, shy, ty));
	  };

	  Matrix.prototype.transformVector = function(a, b) {
	    var dx, dy;
	    switch ((a != null) && a.constructor) {
	      case false:
	        dx = dy = 0;
	        break;
	      case Point:
	        dx = a.x;
	        dy = a.y;
	        break;
	      default:
	        dx = a;
	        dy = b;
	    }
	    return new Point(dx * this.sx + dy * this.shx, dy * this.sy + dx * this.shy);
	  };

	  Matrix.prototype.transformDifference = function(v1, v2) {
	    var dx, dy;
	    dx = v1.x - v2.x;
	    dy = v1.y - v2.y;
	    return new Point(dx * this.sx + dy * this.shx, dy * this.sy + dx * this.shy);
	  };

	  Matrix.prototype.transformBoundingRect = function(r) {
	    var bottom, h, left, right, top, w, x, x1, x2, x3, x4, y, y1, y2, y3, y4;
	    r = rect(r);
	    if (r.infinite) {
	      return r;
	    }
	    if (this.shx === 0 && this.shy === 0) {
	      x = r.x * this.sx + this.tx;
	      y = r.y * this.sy + this.ty;
	      w = r.w * this.sx;
	      h = r.h * this.sy;
	      if (w < 0) {
	        x += w;
	        w = -w;
	      }
	      if (h < 0) {
	        y += h;
	        h = -h;
	      }
	    } else {
	      top = r.x;
	      left = r.y;
	      right = r.x + r.w;
	      bottom = r.y + r.h;
	      x1 = left * this.sx + top * this.shx + this.tx;
	      y1 = top * this.sy + left * this.shy + this.ty;
	      x2 = right * this.sx + top * this.shx + this.tx;
	      y2 = top * this.sy + right * this.shy + this.ty;
	      x3 = right * this.sx + bottom * this.shx + this.tx;
	      y3 = bottom * this.sy + right * this.shy + this.ty;
	      x4 = left * this.sx + bottom * this.shx + this.tx;
	      y4 = bottom * this.sy + left * this.shy + this.ty;
	      x = Math.min(x1, x2, x3, x4);
	      w = Math.max(x1, x2, x3, x4) - x;
	      y = Math.min(y1, y2, y3, y4);
	      h = Math.max(y1, y2, y3, y4) - y;
	    }
	    return new Rectangle(x, y, w, h);
	  };

	  Matrix.identityMatrix = identityMatrix = new Matrix;

	  Matrix.matrix0 = new Matrix(0, 0, 0, 0, 0, 0);

	  intermediatResultMatrix = new Matrix;

	  Matrix.prototype._initFromMatrix = function(m) {
	    this.sx = m.sx;
	    this.sy = m.sy;
	    this.shx = m.shx;
	    this.shy = m.shy;
	    this.tx = m.tx;
	    this.ty = m.ty;
	    return this;
	  };

	  Matrix.prototype._initFromPoint = function(p) {
	    this.tx = p.x;
	    this.ty = p.y;
	    return this;
	  };

	  return Matrix;

	})(AtomicBase);


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var AtomicBase, Foundation, Perimeter, Point, floatEq, inspect, isPlainObject, isString, log, point,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	AtomicBase = __webpack_require__(131);

	Point = __webpack_require__(132);

	log = Foundation.log, inspect = Foundation.inspect, floatEq = Foundation.floatEq, isPlainObject = Foundation.isPlainObject, isString = Foundation.isString;

	point = Point.point;

	module.exports = Perimeter = (function(superClass) {
	  var k, namedPerimeters, perimeter, perimeter0, ref, v;

	  extend(Perimeter, superClass);

	  function Perimeter() {
	    return Perimeter.__super__.constructor.apply(this, arguments);
	  }

	  Perimeter.defineAtomicClass({
	    fieldNames: "left right top bottom"
	  });

	  Perimeter.perimeter = perimeter = function(a, b, c, d) {
	    var p;
	    if (a instanceof Perimeter) {
	      return a;
	    }
	    if (isString(a) && (p = namedPerimeters[a])) {
	      return p;
	    }
	    if ((b == null) && (floatEq(a, 0)) || !a) {
	      return perimeter0;
	    }
	    return new Perimeter(a, b, c, d);
	  };

	  Perimeter.prototype._initFields = function() {
	    return this.left = this.right = this.top = this.bottom = 0;
	  };

	  Perimeter.prototype._initFromObject = function(obj) {
	    this._initFields();
	    this.left = (obj.left || 0) + (obj.l || 0) + (obj.h || 0) + (obj.horizontal || 0);
	    this.right = (obj.right || 0) + (obj.r || 0) + (obj.h || 0) + (obj.horizontal || 0);
	    this.top = (obj.top || 0) + (obj.t || 0) + (obj.v || 0) + (obj.vertical || 0);
	    return this.bottom = (obj.bottom || 0) + (obj.b || 0) + (obj.v || 0) + (obj.vertical || 0);
	  };

	  Perimeter.prototype._init = function(a, b, c, d) {
	    var argLength;
	    this._initFields();
	    argLength = a != null ? b != null ? c != null ? d != null ? 4 : 3 : 2 : 1 : 0;
	    switch (argLength) {
	      case 0:
	        return this.left = this.right = this.top = this.bottom = 0;
	      case 1:
	        return this.left = this.right = this.top = this.bottom = a;
	      case 2:
	        this.left = this.right = a;
	        return this.top = this.bottom = b;
	      case 4:
	        this.left = a;
	        this.right = b;
	        this.top = c;
	        return this.bottom = d;
	      default:
	        throw new Error("invalid number of arguments: " + (inspect(arguments)));
	    }
	  };

	  Perimeter.getter({
	    width: function() {
	      return this.left + this.right;
	    },
	    height: function() {
	      return this.top + this.bottom;
	    },
	    w: function() {
	      return this.left + this.right;
	    },
	    h: function() {
	      return this.top + this.bottom;
	    }
	  });

	  Perimeter.prototype.subtractedFromSize = function(size) {
	    var h, w;
	    w = this.getWidth();
	    h = this.getHeight();
	    if (floatEq(w, 0) && floatEq(h, 0)) {
	      return size;
	    } else {
	      return point(size.x - w, size.y - h);
	    }
	  };

	  Perimeter.prototype.addedToSize = function(size) {
	    var h, w;
	    w = this.getWidth();
	    h = this.getHeight();
	    if (floatEq(w, 0) && floatEq(h, 0)) {
	      return size;
	    } else {
	      return point(size.x + w, size.y + h);
	    }
	  };


	  /*
	  Named Instances
	   */

	  Perimeter.namedPerimeters = namedPerimeters = {
	    perimeter0: perimeter0 = Object.freeze(new Perimeter(0))
	  };

	  ref = Perimeter.namedPerimeters;
	  for (k in ref) {
	    v = ref[k];
	    Perimeter[k] = v;
	  }

	  return Perimeter;

	})(AtomicBase);


/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-foundation": "git://github.com/imikimi/art-foundation.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.5.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"description": "atomic data-types such as Color, Point, Rectangle and Matrix",
		"license": "ISC",
		"name": "art-atomic",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "0.5.0"
	};

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(138);


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(139).includeInNamespace(__webpack_require__(141)).addModules({
	  BitmapBase: __webpack_require__(143),
	  Bitmap: __webpack_require__(144),
	  GoogleFontLoader: __webpack_require__(148),
	  GradientFillStyle: __webpack_require__(145),
	  OriginalStackBlur: __webpack_require__(150),
	  Paths: __webpack_require__(146),
	  StackBlurOriginal: __webpack_require__(151),
	  StackBlur: __webpack_require__(147)
	});


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Canvas,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(140);

	module.exports = Art.Canvas || Art.addNamespace('Canvas', Canvas = (function(superClass) {
	  extend(Canvas, superClass);

	  function Canvas() {
	    return Canvas.__super__.constructor.apply(this, arguments);
	  }

	  return Canvas;

	})(Neptune.Base));


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var _package;

	module.exports = [
	  {
	    "package": _package = __webpack_require__(142),
	    version: _package.version
	  }
	];


/***/ },
/* 142 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-atomic": "git://github.com/imikimi/art-atomic.git",
			"art-foundation": "git://github.com/imikimi/art-foundation.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.5.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webfontloader": "^1.6.26",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"license": "ISC",
		"name": "art-canvas",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "1.3.4"
	};

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, BaseObject, Binary, BinaryString, BitmapBase, Color, Foundation, Matrix, Point, Rectangle, alphaChannelOffset, floor, inspect, isNumber, isString, log, matrix, nextTick, pixelStep, point, pureMerge, rect, rgbColor, round, toChannelNumberMap,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix, rgbColor = Atomic.rgbColor, Color = Atomic.Color;

	inspect = Foundation.inspect, nextTick = Foundation.nextTick, BaseObject = Foundation.BaseObject, Binary = Foundation.Binary, pureMerge = Foundation.pureMerge, isString = Foundation.isString, isNumber = Foundation.isNumber, log = Foundation.log;

	round = Math.round, floor = Math.floor;

	BinaryString = Binary.BinaryString;

	toChannelNumberMap = {
	  0: 0,
	  1: 1,
	  2: 2,
	  3: 3,
	  r: 0,
	  g: 1,
	  b: 2,
	  a: 3,
	  red: 0,
	  green: 1,
	  blue: 2,
	  alpha: 3
	};

	alphaChannelOffset = 3;

	pixelStep = 4;

	module.exports = BitmapBase = (function(superClass) {
	  var calculateBottom, calculateLeft, calculateRight, calculateTop;

	  extend(BitmapBase, superClass);

	  BitmapBase.bitmapsCreated = 0;

	  BitmapBase.prototype.compositeModeSupported = function(mode) {
	    return this.supportedCompositeModes.indexOf(mode) >= 0;
	  };

	  BitmapBase.pixelSnapDefault = true;

	  BitmapBase.prototype.defaultColor = rgbColor("black");

	  BitmapBase.prototype.defaultColorString = "black";

	  function BitmapBase(a, b) {
	    BitmapBase.__super__.constructor.apply(this, arguments);
	    this._htmlImageElement = null;
	    this._canvas = null;
	    this._clippingArea = null;
	    this._context = null;
	    this._size = null;
	    this._lastTransform = null;
	    this._imageSmoothing = false;
	    this.pixelSnap = BitmapBase.pixelSnapDefault;
	    this._pixelsPerPoint = 1;
	    BitmapBase.bitmapsCreated++;
	    if (b) {
	      a = point(a, b);
	    }
	    if (a instanceof BitmapBase) {
	      this.populateClone(this);
	    } else if (a instanceof HTMLCanvasElement) {
	      this.initFromCanvas(a);
	    } else if (a instanceof HTMLImageElement) {
	      this.initFromImage(a);
	    } else {
	      this.initNewCanvas(point(a, b));
	    }
	  }

	  BitmapBase.getter({
	    inspectedObjects: function() {
	      return this;
	    },
	    canvas: function() {
	      if (!this._canvas) {
	        if (this._htmlImageElement) {
	          this.initNewCanvas(this.size);
	          this.drawBitmap(null, this._htmlImageElement);
	        } else {
	          throw new Error("can't get @canvas");
	        }
	      }
	      return this._canvas;
	    },
	    bitmapClass: function() {
	      return this["class"];
	    },
	    clippingArea: function() {
	      return this._clippingArea || (this._clippingArea = rect(this.getSize()));
	    },
	    aspectRatio: function() {
	      return this.getSize().getAspectRatio();
	    }
	  });

	  BitmapBase.prototype.shouldPixelSnap = function(where) {
	    return this.pixelSnap && ((!where) || (where instanceof Point) || where.isTranslateAndPositiveScaleOnly);
	  };

	  BitmapBase.prototype.pixelSnapWhere = function(where) {
	    if (where instanceof Point) {
	      return where.rounded;
	    } else if (where) {
	      return where.withRoundedTranslation;
	    }
	  };

	  BitmapBase.prototype.pixelSnapRectangle = function(where, r) {
	    var bottom, h, isx, isy, right, sx, sy, tx, ty, w, x, y;
	    right = (x = r.x) + (w = r.w);
	    bottom = (y = r.y) + (h = r.h);
	    isx = isy = sx = sy = 1;
	    tx = ty = 0;
	    if (where instanceof Point) {
	      tx = where.x;
	      ty = where.y;
	    } else if (where) {
	      tx = where.tx;
	      ty = where.ty;
	      sx = where.sx;
	      isx = 1 / sx;
	      sy = where.sy;
	      isy = 1 / sy;
	    }
	    x = (Math.round((x * sx) + tx) - tx) * isx;
	    y = (Math.round((y * sy) + ty) - ty) * isy;
	    w = (Math.round((right * sx) + tx) - tx) * isx - x;
	    h = (Math.round((bottom * sy) + ty) - ty) * isy - y;
	    return rect(x, y, w, h);
	  };

	  BitmapBase.prototype.pixelSnapAndTransformRectangle = function(where, r) {
	    var bottom, left, right, top;
	    if (!r) {
	      console.error("no r");
	    }
	    left = r.left, right = r.right, top = r.top, bottom = r.bottom;
	    if (where instanceof Point) {
	      left += where.x;
	      right += where.x;
	      top += where.y;
	      bottom += where.y;
	    } else if (where) {
	      left = where.transformX(left, top);
	      top = where.transformY(left, top);
	      right = where.transformX(right, bottom);
	      bottom = where.transformY(right, bottom);
	    }
	    left = Math.round(left);
	    top = Math.round(top);
	    right = Math.round(right);
	    bottom = Math.round(bottom);
	    return rect(left, top, right - left, bottom - top);
	  };

	  BitmapBase.prototype.clone = function() {
	    var b;
	    b = this.newBitmap(this.size);
	    b.drawBitmap(null, this);
	    return b;
	  };

	  BitmapBase.prototype.crop = function(area) {
	    area || (area = this.getAutoCropRectangle());
	    area = rect(area).intersection(rect(this.size));
	    return this.newBitmap(area.size).drawBitmap(Matrix.translateXY(-area.x, -area.y), this);
	  };

	  BitmapBase.prototype.initFromCanvas = function(canvas) {
	    this._canvas = canvas;
	    this._size = point(this._canvas.width, this._canvas.height);
	    return this.initContext();
	  };

	  BitmapBase.prototype.initFromImage = function(image) {
	    this._size = point(image.width, image.height);
	    this.initNewCanvas(this.size);
	    return this.drawBitmap(point(), image);
	  };

	  BitmapBase.prototype.initNewCanvas = function(size) {
	    if (this._context) {
	      return;
	    }
	    if (!size.gt(point())) {
	      throw new Error("invalid size=" + size + " for Art.Canvas.Bitmap");
	    }
	    this._size = size.floor();
	    this._canvas = document.createElement('canvas');
	    this._canvas.width = this.size.x;
	    this._canvas.height = this.size.y;
	    return this.initContext();
	  };

	  BitmapBase.prototype.populateClone = function(result) {
	    result.initNewCanvas(this.size);
	    result.drawBitmap(null, this);
	    return result._pixelsPerPoint = this._pixelsPerPoint;
	  };

	  BitmapBase.getter({
	    pixelsPerPoint: function() {
	      return this._pixelsPerPoint;
	    },
	    pointsPerPixel: function() {
	      return 1 / this._pixelsPerPoint;
	    },
	    pointSize: function() {
	      return this.size.div(this.pixelsPerPoint);
	    },
	    byteSize: function() {
	      return this.size.area * this.getBytesPerPixel();
	    },
	    bytesPerPixel: function() {
	      return 4;
	    }
	  });

	  BitmapBase.setter({
	    pixelsPerPoint: function(v) {
	      return this._pixelsPerPoint = v;
	    },
	    pointsPerPixel: function(v) {
	      return this._pixelsPerPoint = 1 / v;
	    }
	  });

	  BitmapBase.property({
	    size: point(100, 100)
	  });

	  BitmapBase.property({
	    imageSmoothing: false
	  });

	  BitmapBase.prototype.toMemoryBitmap = function() {
	    return this;
	  };

	  BitmapBase.prototype.toMemoryDrawableBitmap = function() {
	    return this;
	  };

	  BitmapBase.prototype.getImageData = function(a, b, c, d) {
	    var area;
	    area = a === null || a === void 0 ? rect(this.size) : rect(a, b, c, d);
	    return this.toMemoryBitmap().context.getImageData(area.x, area.y, area.w, area.h);
	  };

	  BitmapBase.prototype.putImageData = function(imageData, location, sourceArea) {
	    if (location == null) {
	      location = point();
	    }
	    if (sourceArea == null) {
	      sourceArea = rect(this.size);
	    }
	    location = location.sub(sourceArea.location);
	    this._context.putImageData(imageData, location.x, location.y, sourceArea.x, sourceArea.y, sourceArea.w, sourceArea.h);
	    return this;
	  };

	  BitmapBase.prototype.getImageDataArray = function(channel) {
	    var data, end, i, j, len, results, results1, v;
	    if (channel == null) {
	      channel = null;
	    }
	    data = this.getImageData().data;
	    if ((channel = toChannelNumberMap[channel]) != null) {
	      i = channel;
	      end = data.length;
	      results = [];
	      while (i < end) {
	        i += 4;
	        results.push(data[i - 4]);
	      }
	      return results;
	    } else {
	      results1 = [];
	      for (j = 0, len = data.length; j < len; j++) {
	        v = data[j];
	        results1.push(v);
	      }
	      return results1;
	    }
	  };

	  BitmapBase.prototype.toPngUri = function() {
	    return nextTick().then((function(_this) {
	      return function() {
	        return _this.toMemoryBitmap().canvas.toDataURL();
	      };
	    })(this));
	  };

	  BitmapBase.prototype.toJpgUri = function(quality) {
	    if (quality == null) {
	      quality = .95;
	    }
	    return nextTick().then((function(_this) {
	      return function() {
	        return _this.toMemoryBitmap().canvas.toDataURL("image/jpeg", quality);
	      };
	    })(this));
	  };

	  BitmapBase.prototype.toPng = function() {
	    return this.toPngUri().then(function(dataURI) {
	      return BinaryString.fromDataUri(dataURI);
	    });
	  };

	  BitmapBase.prototype.toJpg = function(quality) {
	    return this.toJpgUri(quality).then(function(dataURI) {
	      return BinaryString.fromDataUri(dataURI);
	    });
	  };

	  BitmapBase.prototype.toImage = function() {
	    return nextTick().then((function(_this) {
	      return function() {
	        var url;
	        if (_this._htmlImageElement) {
	          return _this._htmlImageElement;
	        } else {
	          url = _this.toMemoryBitmap().canvas.toDataURL();
	          return Binary.EncodedImage.toImage(url).then(function(image) {
	            var h, ref, w;
	            ref = _this.pointSize, w = ref.w, h = ref.h;
	            image.width = w;
	            image.height = h;
	            return image;
	          });
	        }
	      };
	    })(this));
	  };

	  BitmapBase.prototype.hFlipped = function() {
	    var result;
	    result = this.newBitmap(this.size);
	    result.drawBitmap(Matrix.translateXY(-this.size.x / 2, 0).scaleXY(-1, 1).translateXY(this.size.x / 2, 0), this);
	    return result;
	  };

	  BitmapBase.prototype.vFlipped = function() {
	    var result;
	    result = this.newBitmap(this.size);
	    result.drawBitmap(Matrix.translateXY(0, -this.size.y / 2).scaleXY(1, -1).translateXY(0, this.size.y / 2), this);
	    return result;
	  };

	  BitmapBase.prototype.drawBorder = function(where, r, options) {
	    var c, m, p, w;
	    m = matrix(where);
	    r = rect(r);
	    c = options.color || "#777";
	    w = options.width || 1;
	    p = options.padding || 0;
	    r = r.grow(p);
	    this.drawRectangle(m, rect(r.x, r.y, r.w, w), c);
	    this.drawRectangle(m, rect(r.x, r.bottom - w, r.w, w), c);
	    this.drawRectangle(m, rect(r.x, r.y + w, w, r.h - w * 2), c);
	    return this.drawRectangle(m, rect(r.right - w, r.y + w, w, r.h - w * 2), c);
	  };

	  BitmapBase.prototype.drawStretchedBorderBitmap = function(drawMatrix, targetArea, bitmap, sourceCenterArea, options) {
	    var bitmapSize, borderRatio, borderReductionRatio, borderScale, botomCenter, bottomCenter, bottomLeft, bottomRight, centerCenter, centerLeft, centerRight, centertCenter, hide, horizontalBorderHeight, horizontalBorderWidth, m, show, sourceBottomHeight, sourceBottomScale, sourceCenterAreaBottom, sourceCenterAreaHeight, sourceCenterAreaLeft, sourceCenterAreaRight, sourceCenterAreaTop, sourceCenterAreaWidth, sourceCenterHeightScale, sourceCenterWidthScale, sourceLeftScale, sourceLeftWidth, sourceRightScale, sourceRightWidth, sourceTopHeight, sourceTopScale, targetAreaBottom, targetAreaHeight, targetAreaLeft, targetAreaRight, targetAreaTop, targetAreaWidth, targetBottomHeight, targetCenterAreaBottom, targetCenterAreaHeight, targetCenterAreaLeft, targetCenterAreaRight, targetCenterAreaTop, targetCenterAreaWidth, targetLeftWidth, targetRightWidth, targetTopHeight, topCenter, topLeft, topRight, totalBorderHeight, totalBorderWidth;
	    if (options == null) {
	      options = {};
	    }
	    hide = options.hide, show = options.show;
	    bitmapSize = bitmap.size;
	    borderScale = options.borderScale;
	    if (!isNumber(borderScale)) {
	      borderScale = 1;
	    }
	    sourceCenterAreaLeft = sourceCenterArea.left;
	    sourceCenterAreaTop = sourceCenterArea.top;
	    sourceCenterAreaRight = sourceCenterArea.right;
	    sourceCenterAreaBottom = sourceCenterArea.bottom;
	    sourceCenterAreaWidth = sourceCenterAreaRight - sourceCenterAreaLeft;
	    sourceCenterAreaHeight = sourceCenterAreaBottom - sourceCenterAreaTop;
	    targetAreaLeft = round(drawMatrix.transformX(targetArea.left, 0));
	    targetAreaTop = round(drawMatrix.transformY(0, targetArea.top));
	    targetAreaRight = round(drawMatrix.transformX(targetArea.right, 0));
	    targetAreaBottom = round(drawMatrix.transformY(0, targetArea.bottom));
	    targetAreaWidth = targetAreaRight - targetAreaLeft;
	    targetAreaHeight = targetAreaBottom - targetAreaTop;
	    sourceLeftWidth = sourceCenterAreaLeft;
	    sourceTopHeight = sourceCenterAreaTop;
	    sourceRightWidth = bitmapSize.w - sourceCenterAreaRight;
	    sourceBottomHeight = bitmapSize.h - sourceCenterAreaBottom;
	    targetCenterAreaLeft = round(drawMatrix.transformX(targetArea.left + sourceLeftWidth * borderScale, 0));
	    targetCenterAreaTop = round(drawMatrix.transformY(0, targetArea.top + sourceTopHeight * borderScale));
	    targetCenterAreaRight = round(drawMatrix.transformX(targetArea.right - sourceRightWidth * borderScale, 0));
	    targetCenterAreaBottom = round(drawMatrix.transformY(0, targetArea.bottom - sourceBottomHeight * borderScale));
	    targetCenterAreaWidth = targetCenterAreaRight - targetCenterAreaLeft;
	    targetCenterAreaHeight = targetCenterAreaBottom - targetCenterAreaTop;
	    if (targetCenterAreaWidth < 0) {
	      horizontalBorderWidth = targetAreaWidth - targetCenterAreaWidth;
	      borderReductionRatio = targetAreaWidth / horizontalBorderWidth;
	      borderRatio = sourceLeftWidth / (totalBorderWidth = sourceLeftWidth + sourceRightWidth);
	      sourceLeftWidth = round(sourceLeftWidth * borderReductionRatio);
	      sourceRightWidth = round(sourceRightWidth * borderReductionRatio);
	      sourceCenterAreaRight = bitmap.size.x - sourceRightWidth;
	      targetCenterAreaLeft = targetCenterAreaRight = targetAreaLeft + round(targetAreaWidth * borderRatio);
	      targetCenterAreaWidth = 0;
	    }
	    if (targetCenterAreaHeight < 0) {
	      horizontalBorderHeight = targetAreaHeight - targetCenterAreaHeight;
	      borderReductionRatio = targetAreaHeight / horizontalBorderHeight;
	      borderRatio = sourceTopHeight / (totalBorderHeight = sourceTopHeight + sourceBottomHeight);
	      sourceTopHeight = round(sourceTopHeight * borderReductionRatio);
	      sourceBottomHeight = round(sourceBottomHeight * borderReductionRatio);
	      sourceCenterAreaBottom = bitmap.size.x - sourceBottomHeight;
	      targetCenterAreaTop = targetCenterAreaBottom = targetAreaTop + round(targetAreaHeight * borderRatio);
	      targetCenterAreaHeight = 0;
	    }
	    targetLeftWidth = targetCenterAreaLeft - targetAreaLeft;
	    targetTopHeight = targetCenterAreaTop - targetAreaTop;
	    targetRightWidth = targetAreaRight - targetCenterAreaRight;
	    targetBottomHeight = targetAreaBottom - targetCenterAreaBottom;
	    sourceLeftScale = targetLeftWidth / sourceLeftWidth;
	    sourceTopScale = targetTopHeight / sourceTopHeight;
	    sourceRightScale = targetRightWidth / sourceRightWidth;
	    sourceBottomScale = targetBottomHeight / sourceBottomHeight;
	    sourceCenterWidthScale = targetCenterAreaWidth / sourceCenterAreaWidth;
	    sourceCenterHeightScale = targetCenterAreaHeight / sourceCenterAreaHeight;
	    if (show) {
	      topLeft = !show.topLeft;
	      topRight = !show.topRight;
	      topCenter = !show.topCenter;
	      centerLeft = !show.centerLeft;
	      centerRight = !show.centerRight;
	      centerCenter = !show.centerCenter;
	      bottomLeft = !show.bottomLeft;
	      bottomRight = !show.bottomRight;
	      bottomCenter = !show.bottomCenter;
	    }
	    if (hide) {
	      topLeft = hide.topLeft, topCenter = hide.topCenter, topRight = hide.topRight, centerLeft = hide.centerLeft, centerCenter = hide.centerCenter, centerRight = hide.centerRight, bottomLeft = hide.bottomLeft, botomCenter = hide.botomCenter, bottomRight = hide.bottomRight;
	      if (hide.top) {
	        topLeft = topCenter = topRight = true;
	      }
	      if (hide.bottom) {
	        bottomLeft = bottomCenter = bottomRight = true;
	      }
	      if (hide.left) {
	        topLeft = centerLeft = bottomLeft = true;
	      }
	      if (hide.left) {
	        topRight = centerRight = bottomRight = true;
	      }
	      if (hide.centerRow) {
	        centerLeft = centerCenter = centerRight = true;
	      }
	      if (hide.centerColumn) {
	        topCenter = centertCenter = bottomRight = true;
	      }
	    }
	    if (!topLeft) {
	      m = Matrix.scaleXY(sourceLeftScale, sourceTopScale).translateXY(targetAreaLeft, targetAreaTop);
	      options.sourceArea = rect(0, 0, sourceLeftWidth, sourceTopHeight);
	      this.drawBitmap(m, bitmap, options);
	    }
	    if (!topRight) {
	      m = Matrix.scaleXY(sourceRightScale, sourceTopScale).translateXY(targetCenterAreaRight, targetAreaTop);
	      options.sourceArea = rect(sourceCenterAreaRight, 0, sourceRightWidth, sourceTopHeight);
	      this.drawBitmap(m, bitmap, options);
	    }
	    if (!bottomLeft) {
	      m = Matrix.scaleXY(sourceLeftScale, sourceBottomScale).translateXY(targetAreaLeft, targetCenterAreaBottom);
	      options.sourceArea = rect(0, sourceCenterAreaBottom, sourceLeftWidth, sourceBottomHeight);
	      this.drawBitmap(m, bitmap, options);
	    }
	    if (!bottomRight) {
	      m = Matrix.scaleXY(sourceRightScale, sourceBottomScale).translateXY(targetCenterAreaRight, targetCenterAreaBottom);
	      options.sourceArea = rect(sourceCenterAreaRight, sourceCenterAreaBottom, sourceRightWidth, sourceBottomHeight);
	      this.drawBitmap(m, bitmap, options);
	    }
	    if (targetCenterAreaHeight > 0) {
	      if (!centerLeft) {
	        m = Matrix.scaleXY(sourceLeftScale, sourceCenterHeightScale).translateXY(targetAreaLeft, targetCenterAreaTop);
	        options.sourceArea = rect(0, sourceTopHeight, sourceLeftWidth, sourceCenterAreaHeight);
	        this.drawBitmap(m, bitmap, options);
	      }
	      if (!(centerCenter || targetCenterAreaWidth <= 0)) {
	        m = Matrix.scaleXY(sourceCenterWidthScale, sourceCenterHeightScale).translateXY(targetCenterAreaLeft, targetCenterAreaTop);
	        options.sourceArea = rect(sourceCenterAreaLeft, sourceCenterAreaTop, sourceCenterAreaWidth, sourceCenterAreaHeight);
	        this.drawBitmap(m, bitmap, options);
	      }
	      if (!centerRight) {
	        m = Matrix.scaleXY(sourceRightScale, sourceCenterHeightScale).translateXY(targetCenterAreaRight, targetCenterAreaTop);
	        options.sourceArea = rect(sourceCenterAreaRight, sourceTopHeight, sourceRightWidth, sourceCenterAreaHeight);
	        this.drawBitmap(m, bitmap, options);
	      }
	    }
	    if (sourceCenterAreaWidth > 0) {
	      if (!bottomCenter) {
	        m = Matrix.scaleXY(sourceCenterWidthScale, sourceBottomScale).translateXY(targetCenterAreaLeft, targetCenterAreaBottom);
	        options.sourceArea = rect(sourceLeftWidth, sourceCenterAreaBottom, sourceCenterAreaWidth, sourceBottomHeight);
	        this.drawBitmap(m, bitmap, options);
	      }
	      if (!topCenter) {
	        m = Matrix.scaleXY(sourceCenterWidthScale, sourceTopScale).translateXY(targetCenterAreaLeft, targetAreaTop);
	        options.sourceArea = rect(sourceCenterAreaLeft, 0, sourceCenterAreaWidth, sourceTopHeight);
	        return this.drawBitmap(m, bitmap, options);
	      }
	    }
	  };

	  calculateTop = function(data, size, threshold) {
	    var lineStep, pos;
	    lineStep = size.x * pixelStep;
	    pos = alphaChannelOffset;
	    while (pos < data.length && data[pos] <= threshold) {
	      pos += pixelStep;
	    }
	    return floor(pos / lineStep);
	  };

	  calculateBottom = function(data, size, threshold, top) {
	    var lineStep, pos, stopPos;
	    lineStep = size.x * pixelStep;
	    pos = data.length + alphaChannelOffset - pixelStep;
	    stopPos = top * lineStep;
	    while (pos > stopPos && data[pos] <= threshold) {
	      pos -= pixelStep;
	    }
	    return floor(pos / lineStep);
	  };

	  calculateLeft = function(data, size, threshold, top, bottom) {
	    var bottomOffset, length, lineStep, pos, posX, stop, topOffset;
	    lineStep = size.x * pixelStep;
	    length = data.length;
	    topOffset = top * lineStep;
	    bottomOffset = bottom * lineStep;
	    posX = alphaChannelOffset;
	    while (posX < lineStep) {
	      pos = posX + topOffset;
	      stop = posX + bottomOffset;
	      while (pos < stop) {
	        if (data[pos] > threshold) {
	          return floor(posX / pixelStep);
	        }
	        pos += lineStep;
	      }
	      posX += pixelStep;
	    }
	  };

	  calculateRight = function(data, size, threshold, top, bottom, left) {
	    var bottomOffset, length, lineStep, outterStop, pos, posX, stop, topOffset;
	    lineStep = size.x * pixelStep;
	    length = data.length;
	    topOffset = top * lineStep;
	    bottomOffset = bottom * lineStep;
	    posX = lineStep - pixelStep + alphaChannelOffset;
	    outterStop = left * pixelStep;
	    while (posX > outterStop) {
	      pos = posX + topOffset;
	      stop = posX + bottomOffset;
	      while (pos < stop) {
	        if (data[pos] > threshold) {
	          return floor(posX / pixelStep);
	        }
	        pos += lineStep;
	      }
	      posX -= pixelStep;
	    }
	  };

	  BitmapBase.prototype.getAutoCropRectangle = function(threshold) {
	    var bottom, context, data, left, ref, right, size, top;
	    if (threshold == null) {
	      threshold = 0;
	    }
	    ref = this, size = ref.size, context = ref.context;
	    data = context.getImageData(0, 0, size.x, size.y).data;
	    top = calculateTop(data, size, threshold);
	    if (top === size.y) {
	      return rect();
	    }
	    bottom = calculateBottom(data, size, threshold, top);
	    left = calculateLeft(data, size, threshold, top, bottom);
	    right = calculateRight(data, size, threshold, top, bottom, left);
	    return rect(left, top, right - left + 1, bottom - top + 1);
	  };

	  return BitmapBase;

	})(BaseObject);


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, Binary, Bitmap, BitmapBase, Color, EncodedImage, Foundation, GradientFillStyle, IdentityMatrix, Matrix, Paths, Point, Promise, Rectangle, StackBlur, canvasBlenders, currentSecond, emptyOptions, eq, floatEq0, inspect, isFunction, isNumber, isPlainObject, log, matrix, max, min, point, point0, rect, rgbColor, round,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Atomic = __webpack_require__(125);

	Foundation = __webpack_require__(19);

	GradientFillStyle = __webpack_require__(145);

	BitmapBase = __webpack_require__(143);

	Paths = __webpack_require__(146);

	StackBlur = __webpack_require__(147);

	inspect = Foundation.inspect, log = Foundation.log, min = Foundation.min, max = Foundation.max, Binary = Foundation.Binary, isFunction = Foundation.isFunction, isPlainObject = Foundation.isPlainObject, eq = Foundation.eq, currentSecond = Foundation.currentSecond, round = Foundation.round, isNumber = Foundation.isNumber, floatEq0 = Foundation.floatEq0, Promise = Foundation.Promise, isPlainObject = Foundation.isPlainObject;

	EncodedImage = Binary.EncodedImage;

	point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix, rgbColor = Atomic.rgbColor, Color = Atomic.Color, IdentityMatrix = Atomic.IdentityMatrix, point0 = Atomic.point0;

	emptyOptions = {};

	canvasBlenders = {
	  add: "lighter",
	  normal: "source-over",
	  target_alphamask: "source-in",
	  alphamask: "destination-in",
	  destover: "destination-over",
	  sourcein: "source-atop",
	  inverse_alphamask: "destination-out",
	  alphaMask: "destination-in",
	  targetAlphaMask: "source-in",
	  inverseAlphaMask: "destination-out",
	  destOver: "destination-over",
	  sourceIn: "source-atop",
	  replace: "copy"
	};

	module.exports = Bitmap = (function(superClass) {
	  var k, v;

	  extend(Bitmap, superClass);

	  function Bitmap() {
	    return Bitmap.__super__.constructor.apply(this, arguments);
	  }

	  Bitmap.supportedCompositeModes = (function() {
	    var results;
	    results = [];
	    for (k in canvasBlenders) {
	      v = canvasBlenders[k];
	      results.push(k);
	    }
	    return results;
	  })();

	  Bitmap.getter({
	    supportedCompositeModes: function() {
	      return Bitmap.supportedCompositeModes;
	    }
	  });

	  Bitmap.artToCanvasCompositeModeMap = canvasBlenders;

	  Bitmap.prototype.initContext = function() {
	    var ref;
	    return this._context = (ref = this._canvas) != null ? ref.getContext("2d") : void 0;
	  };

	  Bitmap.getter({
	    context: function() {
	      if (!this._context && this._htmlImageElement) {
	        this.initNewCanvas(this.size);
	        this.drawBitmap(point(), this._htmlImageElement);
	        this._htmlImageElement = null;
	      }
	      return this._context;
	    },
	    context2D: function() {
	      return this.getContext();
	    },
	    htmlImageElement: function() {
	      return this._htmlImageElement;
	    },
	    htmlElement: function() {
	      return this._htmlImageElement || this._canvas;
	    }
	  });

	  Bitmap.get = function(url, options) {
	    return EncodedImage.get(url, options).then(function(image) {
	      var _, bitmap, match, resolution;
	      bitmap = new Bitmap(image);
	      if (match = url.match(/@([2-9])x\.[a-zA-Z]+$/)) {
	        _ = match[0], resolution = match[1];
	        bitmap.pixelsPerPoint = resolution | 0;
	      }
	      return bitmap;
	    });
	  };


	  /*
	  Uses the browser's file-request dialog to have the user select a local image file.
	  
	  OUT:
	    promise.then ({bitmap, file}) ->
	       * bitmap is a Canvas.Bitmap
	       * file is a javascript File object
	   */

	  Bitmap.requestImage = function() {
	    return Foundation.Browser.File.request({
	      accept: "image/*"
	    }).then((function(_this) {
	      return function(arg) {
	        var file;
	        file = arg[0];
	        return EncodedImage.toImage(file).then(function(image) {
	          return {
	            bitmap: new Bitmap(image),
	            file: file
	          };
	        });
	      };
	    })(this));
	  };

	  Bitmap.prototype.initFromImage = function(image) {
	    this._size = point(image.width, image.height);
	    return this._htmlImageElement = image;
	  };

	  Bitmap.setter({
	    imageSmoothing: function(bool) {
	      return this._context.imageSmoothingEnabled = this._context.mozImageSmoothingEnabled = this._context.webkitImageSmoothingEnabled = this._context.msImageSmoothingEnabled = this._imageSmoothing = !!bool;
	    }
	  });

	  Bitmap.bitmapClass = Bitmap;

	  Bitmap.newBitmap = function(size) {
	    return new Bitmap.bitmapClass(size);
	  };

	  Bitmap.prototype.newBitmap = function(size) {
	    return new this.bitmapClass(size || this.size).tap((function(_this) {
	      return function(b) {
	        return b.pixelsPerPoint = _this.pixelsPerPoint;
	      };
	    })(this));
	  };

	  Bitmap.prototype.setClippingArea = function(area, drawMatrix) {
	    this._setTransform(drawMatrix);
	    if (isFunction(area)) {
	      this._context.beginPath();
	      area(this._context);
	      return this._context.clip();
	    } else {
	      area = this.pixelSnapRectangle(drawMatrix, area);
	      this._clippingArea = area.intersection(this._clippingArea);
	      this._context.beginPath();
	      this._context.rect(area.x, area.y, area.w, area.h);
	      return this._context.clip();
	    }
	  };

	  Bitmap.prototype.clippedTo = function(area, f, drawMatrix) {
	    var previousClippingArea;
	    this._context.save();
	    previousClippingArea = this._clippingArea;
	    try {
	      this.setClippingArea(area, drawMatrix);
	      return f();
	    } finally {
	      this._context.restore();
	      this._clippingArea = previousClippingArea;
	    }
	  };

	  Bitmap.prototype.clear = function(a, b, c, d) {
	    var clr;
	    clr = a != null ? rgbColor(a, b, c, d) : rgbColor(0, 0, 0, 0);
	    this._clearTransform();
	    if (clr.a !== 1.0) {
	      this._context.clearRect(0, 0, this.size.x, this.size.y);
	    }
	    if (!clr.eq(rgbColor(0, 0, 0, 0))) {
	      this._context.globalCompositeOperation = "source-over";
	      this._setFillStyle(clr);
	      this._context.fillRect(0, 0, this.size.x, this.size.y);
	    }
	    return this;
	  };

	  Bitmap.prototype.strokeRectangle = function(where, rectangle, options) {
	    var grow, lineWidth, lineWidthMod2, r;
	    if (options == null) {
	      options = emptyOptions;
	    }
	    r = rect(rectangle);
	    if (this.shouldPixelSnap(where)) {
	      lineWidth = options.lineWidth || 1;
	      r = this.pixelSnapRectangle(where, r);
	      lineWidthMod2 = lineWidth % 2;
	      grow = lineWidthMod2 < 1 ? -lineWidthMod2 / 2 : lineWidthMod2 / 2 - 1;
	      if (!floatEq0(grow)) {
	        r = r.grow(grow);
	      }
	    }
	    if (options.radius) {
	      this.strokeShape(where, options, (function(_this) {
	        return function() {
	          return Paths.roundedRectangle(_this._context, r, min(options.radius, r.w / 2, r.h / 2));
	        };
	      })(this));
	    } else {
	      if (this._setupDraw(where, options, true)) {
	        this._context.strokeRect(r.x, r.y, r.w, r.h);
	        this._cleanupDraw(options);
	      }
	    }
	    return this;
	  };

	  Bitmap.prototype.strokeShape = function(where, options, pathFunction) {
	    if (this._setupDraw(where, options, true)) {
	      this._context.beginPath();
	      pathFunction(this._context);
	      this._context.stroke();
	      this._cleanupDraw(options);
	    }
	    return this;
	  };

	  Bitmap.prototype.drawBorder = function(where, rectangle, options) {
	    var a, a1, g, p, w;
	    if (this._setupDraw(where, options, true)) {
	      p = options.padding || 0;
	      w = options.width || 1;
	      a1 = rect(rectangle);
	      g = p - w / 2;
	      a = a1.grow(g);
	      this._context.beginPath();
	      Paths.rectangle(this._context, a);
	      this._context.stroke();
	      this._cleanupDraw(options);
	    }
	    return this;
	  };

	  Bitmap.prototype.drawLine = function(where, fromPoint, toPoint, options) {
	    if (options == null) {
	      options = emptyOptions;
	    }
	    if (this._setupDraw(where, options, true)) {
	      this._context.beginPath();
	      Paths.line(this._context, fromPoint, toPoint);
	      this._context.stroke();
	      this._cleanupDraw(options);
	    }
	    return this;
	  };

	  Bitmap.prototype.drawRectangle = function(where, rectangle, options) {
	    var _context, fillRule, r, radius;
	    if (options == null) {
	      options = emptyOptions;
	    }
	    r = rect(rectangle);
	    radius = options.radius, fillRule = options.fillRule;
	    if (this.shouldPixelSnap(where)) {
	      r = this.pixelSnapRectangle(where, r);
	    }
	    _context = this._context;
	    if (this._setupDraw(where, options)) {
	      if (radius > 0 || isPlainObject(radius)) {
	        _context.beginPath();
	        Paths.roundedRectangle(_context, r, radius);
	        _context.fill(fillRule || "nonzero");
	      } else {
	        _context.fillRect(r.x, r.y, r.w, r.h);
	      }
	      this._cleanupDraw(options);
	    }
	    return this;
	  };

	  Bitmap.prototype.fillShape = function(where, options, pathFunction) {
	    var _context;
	    _context = this._context;
	    if (this._setupDraw(where, options)) {
	      _context.beginPath();
	      pathFunction(_context);
	      _context.fill(options.fillRule || "nonzero");
	      this._cleanupDraw(options);
	    }
	    return this;
	  };

	  Bitmap.prototype.drawBitmap = function(where, bitmap, options) {
	    var aboutToDrawTime, drawed, endTime, h, inputBitmap, inputBitmapSize, origSourceArea, ref, ref1, sh, sourceArea, startTime, sw, sx, sy, w, x, y;
	    if (options == null) {
	      options = emptyOptions;
	    }
	    startTime = currentSecond();
	    sourceArea = options.sourceArea;
	    inputBitmap = bitmap;
	    if (bitmap.toMemoryDrawableBitmap) {
	      bitmap = bitmap.toMemoryDrawableBitmap();
	    }
	    bitmap = bitmap._canvas || bitmap._htmlImageElement || bitmap;
	    inputBitmapSize = inputBitmap.size || point(inputBitmap.width, inputBitmap.height);
	    drawed = "";
	    if (this.shouldPixelSnap(where)) {
	      ref = this.pixelSnapAndTransformRectangle(where, (sourceArea != null ? sourceArea.size : void 0) || inputBitmapSize), x = ref.x, y = ref.y, w = ref.w, h = ref.h;
	      if (sourceArea) {
	        sx = round(sourceArea.x);
	        sy = round(sourceArea.y);
	        sw = round(sourceArea.w);
	        sh = round(sourceArea.h);
	      } else {
	        sx = sy = 0;
	        sw = inputBitmapSize.x;
	        sh = inputBitmapSize.y;
	      }
	      if (this._setupDraw(null, options)) {
	        drawed = "pixelSnap - " + (inspect([sx, sy, sw, sh]));
	        aboutToDrawTime = currentSecond();
	        this._context.drawImage(bitmap, sx, sy, sw, sh, x, y, w, h);
	        this._cleanupDraw(options);
	      }
	    } else {
	      if (this._setupDraw(where, options)) {
	        aboutToDrawTime = currentSecond();
	        if (origSourceArea = sourceArea) {
	          drawed = "sourceArea";
	          ref1 = sourceArea.intersection(rect(inputBitmap.size)), x = ref1.x, y = ref1.y, w = ref1.w, h = ref1.h;
	          this._context.drawImage(bitmap, x, y, w, h, 0, 0, w, h);
	        } else {
	          drawed = "other";
	          this._context.drawImage(bitmap, 0, 0);
	        }
	        this._cleanupDraw(options);
	      }
	    }
	    endTime = currentSecond();
	    if (endTime - startTime > .1) {
	      log({
	        Canvas_Bitmap_drawBitmap: {
	          slowDraw: ((endTime - startTime) * 1000 | 0) + "ms",
	          time2: ((endTime - aboutToDrawTime) * 1000 | 0) + "ms",
	          where: where,
	          options: options,
	          drawed: drawed,
	          bitmapSize: [bitmap._size, bitmap.width, bitmap.height]
	        }
	      });
	    }
	    return this;
	  };

	  Bitmap.prototype.drawText = function(where, text, options) {
	    if (options == null) {
	      options = emptyOptions;
	    }
	    if (this._setupDraw(where, options)) {
	      this._context.font = (options.size || 16) + "px " + (options.family || 'Arial') + ", Arial";
	      this._context.textAlign = options.align || 'start';
	      this._context.textBaseline = options.baseline || 'alphabetic';
	      this._context.fillText(text, 0, 0);
	      this._cleanupDraw(options);
	    }
	    return this;
	  };

	  Bitmap.prototype.blur = function(radius, toClone) {
	    return (toClone ? this.clone() : this).tap((function(_this) {
	      return function(target) {
	        return StackBlur.blur(_this, radius, target);
	      };
	    })(this));
	  };

	  Bitmap.prototype.blurAlpha = function(radius, options) {
	    if (options == null) {
	      options = emptyOptions;
	    }
	    return (options.clone ? this.clone() : this).tap((function(_this) {
	      return function(target) {
	        var func;
	        func = options.inverted ? "blurInvertedAlpha" : "blurAlpha";
	        return StackBlur[func](_this, radius, target);
	      };
	    })(this));
	  };

	  Bitmap.prototype._clearTransform = function() {
	    this._lastTransform = IdentityMatrix;
	    return this._context.setTransform(1, 0, 0, 1, 0, 0);
	  };

	  Bitmap.prototype._setTransform = function(m) {
	    if (m) {
	      this._lastTransform = m;
	      if (m instanceof Point) {
	        return this._context.setTransform(1, 0, 0, 1, m.x, m.y);
	      } else {
	        return this._context.setTransform(m.sx, m.shy, m.shx, m.sy, m.tx, m.ty);
	      }
	    } else {
	      return this._clearTransform();
	    }
	  };

	  Bitmap.prototype._setStrokeStyle = function(strokeStyle) {
	    return this._context.strokeStyle = strokeStyle.toCanvasStyle ? strokeStyle.toCanvasStyle(this._context) : strokeStyle.toString();
	  };

	  Bitmap.prototype._setFillStyle = function(fillStyle) {
	    return this._context.fillStyle = fillStyle.toCanvasStyle ? fillStyle.toCanvasStyle(this._context) : fillStyle.toString();
	  };

	  Bitmap.prototype._getFillStyleFromOptions = function(options) {
	    var fromPoint, gradientRadius1, toPoint;
	    if (options.colors) {
	      fromPoint = options.from || point0;
	      gradientRadius1 = options.gradientRadius1 || options.gradientRadius;
	      toPoint = options.to || (gradientRadius1 != null ? fromPoint : this.size);
	      return new GradientFillStyle(fromPoint, toPoint, options.colors, gradientRadius1, options.gradientRadius2);
	    } else {
	      return options.fillStyle || options.color || this.defaultColorString;
	    }
	  };

	  Bitmap.prototype._setStrokeStyleFromOptions = function(options) {
	    var lineCap, lineDash, lineJoin, lineWidth, miterLimit;
	    this._setStrokeStyle(this._getFillStyleFromOptions(options));
	    lineWidth = options.lineWidth, lineCap = options.lineCap, lineJoin = options.lineJoin, miterLimit = options.miterLimit, lineDash = options.lineDash;
	    this._context.setLineDash(lineDash || []);
	    this._context.lineWidth = lineWidth || 1;
	    this._context.lineCap = lineCap || "butt";
	    this._context.lineJoin = lineJoin || "miter";
	    return this._context.miterLimit = miterLimit || 10;
	  };

	  Bitmap.prototype._setFillStyleFromOptions = function(options) {
	    return this._setFillStyle(this._getFillStyleFromOptions(options));
	  };

	  Bitmap.prototype._setupDraw = function(where, options, stroke) {
	    var _context, blur, compositeMode, offset, offsetX, offsetY, opacity, shadow, shadowColor;
	    compositeMode = options.compositeMode, shadow = options.shadow, opacity = options.opacity;
	    stroke || (stroke = options.stroke);
	    if (!isNumber(opacity)) {
	      opacity = 1;
	    }
	    if (opacity < 1 / 256) {
	      return false;
	    }
	    _context = this._context;
	    if (stroke) {
	      this._setStrokeStyleFromOptions(options);
	    } else {
	      this._setFillStyleFromOptions(options);
	    }
	    if (compositeMode && compositeMode !== "normal") {
	      _context.globalCompositeOperation = canvasBlenders[compositeMode] || canvasBlenders.normal;
	    }
	    if (opacity < 1) {
	      _context.globalAlpha = opacity;
	    }
	    if (shadow) {
	      blur = shadow.blur, offsetX = shadow.offsetX, offsetY = shadow.offsetY, offset = shadow.offset;
	      shadowColor = shadow.color;
	      _context.shadowColor = rgbColor(shadowColor || "black");
	      if (blur) {
	        _context.shadowBlur = blur;
	      }
	      offsetX || (offsetX = 0);
	      offsetY || (offsetY = 0);
	      if (where instanceof Matrix) {

	        /*
	        Shadows seem to ignore scale and rotation transformations.
	        
	        It seems someone wanted to enforce consistent shadows while completely breaking
	        the setTransform abstraction. Bah! :)
	        
	        I believe this was a design mistake. It introduces inconsistencies both subtle
	        and large. For example, it makes shadow placement vary across devices depending
	        upon their devicePixelsPerPoint. No other draw command works this way.
	        
	        Consistent shadows should be up to the programmer, not the drawing engine.
	        
	        I believe this hack solves the problem. Shadow SHAPE does obey setTransforms. It
	        is also correctly proporitonal to the shape it is creating a shadow of. Said shape
	        fully obeys setTrasform - including location. Only the vector from the center of
	        the shape to the center of the shadow seems to ignore setTransform.
	         - July 2016, SBD
	         */
	        _context.shadowOffsetX = Matrix.transform1D(offsetX, offsetY, where.sx, where.shx, 0);
	        _context.shadowOffsetY = Matrix.transform1D(offsetY, offsetX, where.sy, where.shy, 0);
	      } else {
	        _context.shadowOffsetX = offsetX;
	        _context.shadowOffsetY = offsetY;
	      }
	    }
	    this._setTransform(where);
	    return true;
	  };

	  Bitmap.prototype._cleanupDraw = function(options) {
	    var _context, compositeMode, opacity, shadow;
	    compositeMode = options.compositeMode, shadow = options.shadow, opacity = options.opacity;
	    if (!isNumber(opacity)) {
	      opacity = 1;
	    }
	    _context = this._context;
	    if (compositeMode && compositeMode !== "normal") {
	      _context.globalCompositeOperation = canvasBlenders.normal;
	    }
	    if (opacity < 1) {
	      _context.globalAlpha = 1;
	    }
	    if (shadow) {
	      _context.shadowColor = "transparent";
	      _context.shadowBlur = 0;
	      _context.shadowOffsetX = 0;
	      return _context.shadowOffsetY = 0;
	    }
	  };

	  return Bitmap;

	})(BitmapBase);


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, Foundation, GradientFillStyle, arrayWith, clone, flatten, floatEq, inspect, isNumber, isPlainArray, isPlainObject, isString, log, min, peek, point, point1, rgbColor, shallowClone,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Atomic = __webpack_require__(125);

	Foundation = __webpack_require__(19);

	point = Atomic.point, rgbColor = Atomic.rgbColor, point1 = Atomic.point1;

	inspect = Foundation.inspect, shallowClone = Foundation.shallowClone, flatten = Foundation.flatten, isPlainObject = Foundation.isPlainObject, log = Foundation.log, isNumber = Foundation.isNumber, isString = Foundation.isString, isPlainArray = Foundation.isPlainArray, clone = Foundation.clone, min = Foundation.min, floatEq = Foundation.floatEq, peek = Foundation.peek, arrayWith = Foundation.arrayWith;

	module.exports = GradientFillStyle = (function(superClass) {
	  extend(GradientFillStyle, superClass);


	  /*
	  from and to are points where the lineary gradient will begin and end.
	  "colors" is a list of the colors for the gradient. There must be at least two colors.
	  In the explicit form, each rgbColor should be formatted as {n:<number>, c:<html rgbColor string>}
	    Ex: {n:.45, c:"#ff0"}
	  Implicitly, you can:
	    provide just a HTML rgbColor string with no "n".
	    N is determined as follows:
	      The first and last rgbColor will be forced to have n=0 and n=1 respectively
	      Any string of omitted Ns will be interpolated between the specified ns.
	  
	  Examples:
	    black to white:
	      new GradientFillStyle point(0,0), point(100,0), {c:"#000"}, {c:"#fff"}
	      OR
	      new GradientFillStyle point(0,0), point(100,0), "#000", "#fff"
	  
	    black to red to white:
	      new GradientFillStyle point(0,0), point(100,0), {c:"#000"}, {n:.5, c:"#f00"}, {c:"#fff"}
	      OR
	      new GradientFillStyle point(0,0), point(100,0), "#000", "#f00", "#fff"
	  
	    red to transparent
	      new GradientFillStyle point(0,0), point(100,0), #f00", "rgba(1,0,0,0)"
	  
	    rainbow:
	      new GradientFillStyle(
	        point(0,0), point(100,0)
	        "#f00"
	        "#ff0"
	        "#0f0"
	        "#0ff"
	        "#00f"
	        "#f0f"
	        "#f00"
	      )
	   */

	  GradientFillStyle.colorsToObjectsAndStringColors = function(colors) {
	    var clr, j, len, results;
	    results = [];
	    for (j = 0, len = colors.length; j < len; j++) {
	      clr = colors[j];
	      if (isPlainObject(clr)) {
	        results.push({
	          n: clr.n,
	          c: String(rgbColor(clr.c))
	        });
	      } else {
	        results.push({
	          c: String(rgbColor(clr))
	        });
	      }
	    }
	    return results;
	  };

	  GradientFillStyle.colorsFromObjects = function(colors) {
	    var c, clr, j, k, len, n, ret;
	    ret = [];
	    for (j = 0, len = colors.length; j < len; j++) {
	      clr = colors[j];
	      if (isPlainObject(clr)) {
	        if (isNumber(clr.r)) {
	          ret.push(rgbColor(clr));
	        } else if (isNumber(clr.n)) {
	          ret.push(clr);
	        } else {
	          for (k in clr) {
	            c = clr[k];
	            n = k - 0;
	            ret.push({
	              n: n,
	              c: c
	            });
	          }
	        }
	      } else {
	        ret.push(clr);
	      }
	    }
	    return ret;
	  };

	  GradientFillStyle.interpolateColorPositionRange = function(outColors, colors, start, end, firstN, lastN) {
	    var i, j, nDelta, ref, ref1, results, steps;
	    steps = end - start + 1;
	    nDelta = (lastN - firstN) / steps;
	    results = [];
	    for (i = j = ref = start, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
	      results.push(outColors.push({
	        c: colors[i].c,
	        n: (i - start + 1) * nDelta
	      }));
	    }
	    return results;
	  };

	  GradientFillStyle.needToInterpolateColors = function(colors) {
	    var clr, j, len, ret;
	    ret = false;
	    for (j = 0, len = colors.length; j < len; j++) {
	      clr = colors[j];
	      if (!(clr.n == null)) {
	        continue;
	      }
	      ret = true;
	      break;
	    }
	    return ret;
	  };

	  GradientFillStyle.interpolateColorPositions = function(colors) {
	    var clr, firstColor, i, interpolateCount, j, lastColor, len, n, outColors, startN;
	    if (!GradientFillStyle.needToInterpolateColors(colors)) {
	      return colors;
	    }
	    firstColor = colors[0], lastColor = colors[colors.length - 1];
	    if (firstColor.n == null) {
	      firstColor = {
	        c: firstColor.c,
	        n: 0
	      };
	    }
	    if (lastColor.n == null) {
	      lastColor = {
	        c: lastColor.c,
	        n: 1
	      };
	    }
	    outColors = [firstColor];
	    startN = firstColor.n;
	    interpolateCount = 0;
	    for (i = j = 0, len = colors.length; j < len; i = ++j) {
	      clr = colors[i];
	      if (!(i > 0)) {
	        continue;
	      }
	      if (i === colors.length - 1) {
	        clr = lastColor;
	      }
	      n = clr.n;
	      if (n != null) {
	        if (interpolateCount > 0) {
	          GradientFillStyle.interpolateColorPositionRange(outColors, colors, i - interpolateCount, i, startN, n);
	          interpolateCount = 0;
	        }
	        startN = n;
	      } else {
	        interpolateCount++;
	      }
	    }
	    outColors.push(lastColor);
	    return outColors;
	  };

	  GradientFillStyle.sortColorsByN = function(colors) {
	    return colors.sort(function(a, b) {
	      return a.n - b.n;
	    });
	  };

	  GradientFillStyle.normalizeColors = function(colors) {
	    colors = this.colorsFromObjects(colors);
	    colors = this.colorsToObjectsAndStringColors(colors);
	    colors = this.interpolateColorPositions(colors);
	    colors = this.sortColorsByN(colors);
	    return colors;
	  };

	  function GradientFillStyle(from, to, colors, radius11, radius21) {
	    this.from = from;
	    this.to = to;
	    this.radius1 = radius11;
	    this.radius2 = radius21;
	    this.setColors(this.inputColors = colors);
	  }

	  GradientFillStyle.prototype.inspect2 = function() {
	    return "gradient(from:" + this.from + ", to:" + this.to + ", colors:" + (inspect(this.inputColors)) + ")";
	  };

	  GradientFillStyle.clone = function() {
	    return new GradientFillStyle(this.from, this.to, shallowClone(this.colors), this.radius1, this.radius2);
	  };

	  GradientFillStyle.getter({
	    colors: function() {
	      return this._colors;
	    },
	    premultipliedColorPositions: function() {
	      var a, j, len, ref, results;
	      ref = this._colors;
	      results = [];
	      for (j = 0, len = ref.length; j < len; j++) {
	        a = ref[j];
	        results.push({
	          n: a.n,
	          c: rgbColor(a.c).premultiplied
	        });
	      }
	      return results;
	    }
	  });

	  GradientFillStyle.setter({
	    colors: function(colors) {
	      var k, v;
	      return this._colors = isPlainArray(colors) ? GradientFillStyle.normalizeColors(colors) : isPlainObject(colors) ? (colors = (function() {
	        var results;
	        results = [];
	        for (k in colors) {
	          v = colors[k];
	          results.push({
	            n: k * 1,
	            c: isString(v) ? v : String(rgbColor(v))
	          });
	        }
	        return results;
	      })(), colors = GradientFillStyle.sortColorsByN(colors), GradientFillStyle.interpolateColorPositions(colors)) : [
	        {
	          n: 0,
	          c: rgbColor("black"),
	          n: 1,
	          c: rgbColor("white")
	        }
	      ];
	    }
	  });

	  GradientFillStyle.prototype.getColorAt = function(atN) {
	    var c, i, j, lastC, lastN, len, n, range, ref, ref1;
	    lastN = null;
	    lastC = null;
	    ref = this.colors;
	    for (i = j = 0, len = ref.length; j < len; i = ++j) {
	      ref1 = ref[i], c = ref1.c, n = ref1.n;
	      if (atN <= n) {
	        if (lastC) {
	          range = n - lastN;
	          return rgbColor(lastC).interpolate(c, (atN - lastN) / range);
	        } else {
	          return c;
	        }
	      }
	      lastC = c;
	      lastN = n;
	    }
	    return null;
	  };

	  GradientFillStyle.prototype.toCanvasStyle = function(context) {
	    var clr, e, gradient, j, len, radius1, radius2, ref, ref1;
	    if (context.context) {
	      context = context.context;
	    }
	    gradient = this.radius1 != null ? (this.radius2 != null ? (ref = this, radius1 = ref.radius1, radius2 = ref.radius2, ref) : (radius1 = 0, radius2 = this.radius1), context.createRadialGradient(this.from.x, this.from.y, radius1, this.to.x, this.to.y, radius2)) : context.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
	    ref1 = this._colors;
	    for (j = 0, len = ref1.length; j < len; j++) {
	      clr = ref1[j];
	      try {
	        gradient.addColorStop(clr.n, clr.c.toString());
	      } catch (error) {
	        e = error;
	        gradient.addColorStop(clr.n, "black");
	      }
	    }
	    return gradient;
	  };

	  return GradientFillStyle;

	})(Foundation.BaseObject);


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, Paths, bound, float32Eq0, floatEq, isNumber, isPlainObject, log, max, min;

	Foundation = __webpack_require__(19);

	log = Foundation.log, floatEq = Foundation.floatEq, min = Foundation.min, max = Foundation.max, isNumber = Foundation.isNumber, isPlainObject = Foundation.isPlainObject, float32Eq0 = Foundation.float32Eq0, bound = Foundation.bound;

	module.exports = Paths = (function() {
	  var rectangle, roundedRectangle;

	  function Paths() {}

	  Paths.rectangle = rectangle = function(context, r) {
	    var bottom, left, right, top;
	    left = r.left, right = r.right, top = r.top, bottom = r.bottom;
	    context.moveTo(left, top);
	    context.lineTo(right, top);
	    context.lineTo(right, bottom);
	    context.lineTo(left, bottom);
	    return context.closePath();
	  };

	  Paths.line = function(context, fromPoint, toPoint) {
	    context.moveTo(fromPoint.x, fromPoint.y);
	    return context.lineTo(toPoint.x, toPoint.y);
	  };

	  Paths.roundedRectangle = roundedRectangle = function(context, r, radius) {
	    var bl, bottom, br, h, hCenter, halfW, left, maxRadius, right, tl, top, tr, vCenter, w;
	    if (!radius) {
	      return rectangle(context, r);
	    }
	    if (isPlainObject(radius)) {
	      tl = radius.tl, tr = radius.tr, bl = radius.bl, br = radius.br;
	    } else {
	      tl = tr = bl = br = radius;
	    }
	    if (float32Eq0(tl) && float32Eq0(tr) && float32Eq0(bl) && float32Eq0(br)) {
	      return rectangle(context, r);
	    }
	    w = r.w, h = r.h;
	    w = max(0, w);
	    h = max(0, h);
	    if (floatEq(w, h) && isNumber(radius) && radius >= (halfW = w / 2)) {
	      hCenter = r.hCenter, vCenter = r.vCenter;
	      context.arc(hCenter, vCenter, halfW, 0, Math.PI * 2, true);
	      return;
	    }
	    maxRadius = min(w / 2, h / 2);
	    bl = bound(0, bl, maxRadius);
	    br = bound(0, br, maxRadius);
	    tl = bound(0, tl, maxRadius);
	    tr = bound(0, tr, maxRadius);
	    left = r.left, right = r.right, top = r.top, bottom = r.bottom;
	    context.moveTo(left, top + tl);
	    context.arcTo(left, top, left + tl, top, tl);
	    context.lineTo(right - tr, top);
	    context.arcTo(right, top, right, top + tr, tr);
	    context.lineTo(right, bottom - br);
	    context.arcTo(right, bottom, right - br, bottom, br);
	    context.lineTo(left + bl, bottom);
	    context.arcTo(left, bottom, left, bottom - bl, bl);
	    return context.closePath();
	  };

	  Paths.curriedRoundedRectangle = function(r, radius) {
	    return function(context) {
	      return roundedRectangle(context, r, radius);
	    };
	  };

	  return Paths;

	})();


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
	/*
	SBD TODO

	Bluring transparencies has errors. Repro:
	  clear background to: color(1,0,0,.5)
	  drawRectangle color(0,1,0,1) over a sub-area of the bitmap
	  blur

	The problem (I think) is transparent colors have equal weight as non-transparent colors.

	...

	I need to test bluring on the edge of the bitmap. I'm not convinced it works right.

	...

	Possible speedup and simplification:

	One solution which may be faster overall is to reserve one line of pixels in memory plus
	the blur radius amount of pixels on each side. Those pixel colors should be repetitions of the edge colors.
	Then we can blur over that range with reduced tests in our inner loop.
	It looks like "slice" allows us to quickly get a subsection of an ArrayBuffer. That will work for all lines
	except the first and last one(s). Just slice and then overwrite the first and end colors with the edge-colors.

	UInt8Array .subarray and .set should make moving the pixles to and from pretty fast. The only slow part will
	be filling the edge pixels in.
	 */

	/*

	StackBlur - a fast almost Gaussian Blur For Canvas

	Version:  0.5
	Author:   Mario Klingemann
	Contact:  mario@quasimondo.com
	Website:  http://www.quasimondo.com/StackBlurForCanvas
	Twitter:  @quasimondo

	In case you find this class useful - especially in commercial projects -
	I am not totally unhappy for a small donation to my PayPal account
	mario@quasimondo.de

	Or support me on flattr:
	https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

	Copyright (c) 2010 Mario Klingemann

	Permission is hereby granted, free of charge, to any person
	obtaining a copy of this software and associated documentation
	files (the "Software"), to deal in the Software without
	restriction, including without limitation the rights to use,
	copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following
	conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
	 */
	var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(139), __webpack_require__(125), __webpack_require__(19), __webpack_require__(143)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Canvas, Atomic, Foundation) {
	  var BlurStack, color, inspect, matrix, nextTick, point, rect;
	  point = Atomic.point, matrix = Atomic.matrix, rect = Atomic.rect, color = Atomic.color;
	  inspect = Foundation.Inspect.inspect;
	  nextTick = Foundation.nextTick;
	  BlurStack = (function() {
	    function BlurStack() {
	      this.r = this.g = this.b = this.a = 0;
	      this.next = null;
	    }

	    return BlurStack;

	  })();
	  return Canvas.StackBlur = (function(superClass) {
	    extend(StackBlur, superClass);

	    function StackBlur() {
	      return StackBlur.__super__.constructor.apply(this, arguments);
	    }

	    StackBlur.blur = function(bitmap, radius) {
	      return (new Canvas.StackBlur).blur(bitmap, radius);
	    };

	    StackBlur.blurRGB = function(bitmap, radius) {
	      return (new Canvas.StackBlur).blurRGB(bitmap, radius);
	    };

	    StackBlur.blurAlpha = function(bitmap, radius) {
	      return (new Canvas.StackBlur).blurAlpha(bitmap, radius);
	    };

	    StackBlur.blurInvertedAlpha = function(bitmap, radius) {
	      return (new Canvas.StackBlur).blurInvertedAlpha(bitmap, radius);
	    };

	    StackBlur.prototype.blur = function(bitmap, radius, targetBitmap) {
	      var imageData, pixels;
	      targetBitmap || (targetBitmap = bitmap);
	      imageData = bitmap.getImageData();
	      pixels = imageData.data;
	      radius = radius + .5 | 0;
	      if (radius > 0) {
	        this.stackBlurCanvasRGBA(pixels, bitmap.size.w, bitmap.size.h, radius);
	      }
	      return targetBitmap.putImageData(imageData);
	    };

	    StackBlur.prototype.blurRGB = function(bitmap, radius, targetBitmap) {
	      var imageData, pixels;
	      targetBitmap || (targetBitmap = bitmap);
	      imageData = bitmap.getImageData();
	      pixels = imageData.data;
	      radius = radius + .5 | 0;
	      if (radius > 0) {
	        this.stackBlurCanvasRGB(pixels, bitmap.size.w, bitmap.size.h, radius);
	      }
	      return targetBitmap.putImageData(imageData);
	    };

	    StackBlur.prototype.blurAlpha = function(bitmap, radius, targetBitmap) {
	      var imageData, pixels;
	      targetBitmap || (targetBitmap = bitmap);
	      imageData = bitmap.getImageData();
	      pixels = imageData.data;
	      radius = radius + .5 | 0;
	      if (radius > 0) {
	        this.stackBlurCanvasAlpha(pixels, bitmap.size.w, bitmap.size.h, radius);
	      }
	      return targetBitmap.putImageData(imageData);
	    };

	    StackBlur.prototype.blurInvertedAlpha = function(bitmap, radius, targetBitmap) {
	      var imageData, pixels;
	      targetBitmap || (targetBitmap = bitmap);
	      imageData = bitmap.getImageData();
	      pixels = imageData.data;
	      radius = radius + .5 | 0;
	      this.invertAlpha(pixels, bitmap.size.area);
	      if (radius > 0) {
	        this.stackBlurCanvasAlpha(pixels, bitmap.size.w, bitmap.size.h, radius);
	      }
	      return targetBitmap.putImageData(imageData);
	    };

	    StackBlur.prototype.invertAlpha = function(pixels, numPixels) {
	      var end, end8, i, results;
	      i = 0;
	      end = numPixels * 4 - 4;
	      end8 = end - (end % 8);
	      while (i <= end) {
	        pixels[i + 3] = 255 - pixels[i + 3];
	        i += 4;
	        pixels[i + 3] = 255 - pixels[i + 3];
	        i += 4;
	        pixels[i + 3] = 255 - pixels[i + 3];
	        i += 4;
	        pixels[i + 3] = 255 - pixels[i + 3];
	        i += 4;
	        pixels[i + 3] = 255 - pixels[i + 3];
	        i += 4;
	        pixels[i + 3] = 255 - pixels[i + 3];
	        i += 4;
	        pixels[i + 3] = 255 - pixels[i + 3];
	        i += 4;
	        pixels[i + 3] = 255 - pixels[i + 3];
	        i += 4;
	      }
	      results = [];
	      while (i <= end) {
	        pixels[i + 3] = 255 - pixels[i + 3];
	        results.push(i += 4);
	      }
	      return results;
	    };

	    StackBlur.prototype.createStack = function(radius) {
	      var i, j, ref, stack;
	      this.stackStart = new BlurStack();
	      stack = this.stackStart;
	      for (i = j = 1, ref = 2 * radius; j <= ref; i = j += 1) {
	        stack = stack.next = new BlurStack();
	        if (i === radius + 1) {
	          this.stackEnd = stack;
	        }
	      }
	      return stack.next = this.stackStart;
	    };

	    StackBlur.prototype.rgbaPass = function(radius, pixels, outterStep, outterEnd, innerStep, innerEndDelta) {
	      var a_in_sum, a_out_sum, a_sum, b_in_sum, b_out_sum, b_sum, firstPixelSumWeight, g_in_sum, g_out_sum, g_sum, i, innerEnd, innerPos, innerRadiusEnd, j, oneOverStackWeight, outterPos, pa, pb, pg, pr, r_in_sum, r_out_sum, r_sum, radiusPlus1, rbs, readPos, readPosOffset, ref, results, stackEnd, stackIn, stackOut, stackStart, stackWeight, weight;
	      radiusPlus1 = radius + 1;
	      stackWeight = radiusPlus1 * radiusPlus1;
	      oneOverStackWeight = 1 / stackWeight;
	      firstPixelSumWeight = (stackWeight + radiusPlus1) / 2;
	      stackStart = this.stackStart;
	      stackEnd = this.stackEnd;
	      outterPos = 0;
	      results = [];
	      while (outterPos <= outterEnd) {
	        r_in_sum = g_in_sum = b_in_sum = a_in_sum = 0;
	        pr = pixels[outterPos];
	        pg = pixels[outterPos + 1];
	        pb = pixels[outterPos + 2];
	        pa = pixels[outterPos + 3];
	        if (pa < 255) {
	          weight = pa / 255;
	          pr *= weight;
	          pg *= weight;
	          pb *= weight;
	        }
	        r_out_sum = radiusPlus1 * pr;
	        g_out_sum = radiusPlus1 * pg;
	        b_out_sum = radiusPlus1 * pb;
	        a_out_sum = radiusPlus1 * pa;
	        r_sum = firstPixelSumWeight * pr;
	        g_sum = firstPixelSumWeight * pg;
	        b_sum = firstPixelSumWeight * pb;
	        a_sum = firstPixelSumWeight * pa;
	        stackIn = stackStart;
	        for (i = j = 0, ref = radius; j <= ref; i = j += 1) {
	          stackIn.r = pr;
	          stackIn.g = pg;
	          stackIn.b = pb;
	          stackIn.a = pa;
	          stackIn = stackIn.next;
	        }
	        innerEnd = outterPos + innerEndDelta;
	        rbs = radius;
	        innerRadiusEnd = outterPos + radius * innerStep;
	        innerPos = outterPos + innerStep;
	        while (innerPos <= innerRadiusEnd) {
	          readPos = innerPos;
	          if (innerPos > innerEnd) {
	            readPos = innerEnd;
	          }
	          pr = pixels[readPos];
	          pg = pixels[readPos + 1];
	          pb = pixels[readPos + 2];
	          pa = pixels[readPos + 3];
	          if (pa < 255) {
	            weight = pa / 255;
	            pr *= weight;
	            pg *= weight;
	            pb *= weight;
	          }
	          r_in_sum += stackIn.r = pr;
	          g_in_sum += stackIn.g = pg;
	          b_in_sum += stackIn.b = pb;
	          a_in_sum += stackIn.a = pa;
	          r_sum += pr * rbs;
	          g_sum += pg * rbs;
	          b_sum += pb * rbs;
	          a_sum += pa * rbs;
	          rbs--;
	          stackIn = stackIn.next;
	          innerPos += innerStep;
	        }
	        stackOut = stackEnd;
	        readPosOffset = radiusPlus1 * innerStep;
	        innerPos = outterPos;
	        while (innerPos <= innerEnd) {
	          pixels[innerPos + 3] = pa = a_sum * oneOverStackWeight;
	          if (pa !== 0) {
	            pa = oneOverStackWeight * 255 / pa;
	            pixels[innerPos] = r_sum * pa;
	            pixels[innerPos + 1] = g_sum * pa;
	            pixels[innerPos + 2] = b_sum * pa;
	          } else {
	            pixels[innerPos] = pixels[innerPos + 1] = pixels[innerPos + 2] = 0;
	          }
	          r_sum -= r_out_sum;
	          g_sum -= g_out_sum;
	          b_sum -= b_out_sum;
	          a_sum -= a_out_sum;
	          r_out_sum -= stackIn.r;
	          g_out_sum -= stackIn.g;
	          b_out_sum -= stackIn.b;
	          a_out_sum -= stackIn.a;
	          readPos = innerPos + readPosOffset;
	          if (readPos > innerEnd) {
	            readPos = innerEnd;
	          }
	          pr = pixels[readPos];
	          pg = pixels[readPos + 1];
	          pb = pixels[readPos + 2];
	          pa = pixels[readPos + 3];
	          if (pa < 255) {
	            weight = pa / 255;
	            pr *= weight;
	            pg *= weight;
	            pb *= weight;
	          }
	          r_in_sum += stackIn.r = pr;
	          g_in_sum += stackIn.g = pg;
	          b_in_sum += stackIn.b = pb;
	          a_in_sum += stackIn.a = pa;
	          r_sum += r_in_sum;
	          g_sum += g_in_sum;
	          b_sum += b_in_sum;
	          a_sum += a_in_sum;
	          r_out_sum += pr = stackOut.r;
	          g_out_sum += pg = stackOut.g;
	          b_out_sum += pb = stackOut.b;
	          a_out_sum += pa = stackOut.a;
	          r_in_sum -= pr;
	          g_in_sum -= pg;
	          b_in_sum -= pb;
	          a_in_sum -= pa;
	          stackIn = stackIn.next;
	          stackOut = stackOut.next;
	          innerPos += innerStep;
	        }
	        results.push(outterPos += outterStep);
	      }
	      return results;
	    };

	    StackBlur.prototype.rgbPass = function(radius, pixels, outterStep, outterEnd, innerStep, innerEndDelta) {
	      var b_in_sum, b_out_sum, b_sum, firstPixelSumWeight, g_in_sum, g_out_sum, g_sum, i, innerEnd, innerPos, innerRadiusEnd, j, oneOverStackWeight, outterPos, pb, pg, pr, r_in_sum, r_out_sum, r_sum, radiusPlus1, rbs, readPos, readPosOffset, ref, results, stackEnd, stackIn, stackOut, stackStart, stackWeight;
	      radiusPlus1 = radius + 1;
	      stackWeight = radiusPlus1 * radiusPlus1;
	      oneOverStackWeight = 1 / stackWeight;
	      firstPixelSumWeight = (stackWeight + radiusPlus1) / 2;
	      stackStart = this.stackStart;
	      stackEnd = this.stackEnd;
	      outterPos = 0;
	      results = [];
	      while (outterPos <= outterEnd) {
	        r_in_sum = g_in_sum = b_in_sum = 0;
	        pr = pixels[outterPos];
	        pg = pixels[outterPos + 1];
	        pb = pixels[outterPos + 2];
	        r_out_sum = radiusPlus1 * pr;
	        g_out_sum = radiusPlus1 * pg;
	        b_out_sum = radiusPlus1 * pb;
	        r_sum = firstPixelSumWeight * pr;
	        g_sum = firstPixelSumWeight * pg;
	        b_sum = firstPixelSumWeight * pb;
	        stackIn = stackStart;
	        for (i = j = 0, ref = radius; j <= ref; i = j += 1) {
	          stackIn.r = pr;
	          stackIn.g = pg;
	          stackIn.b = pb;
	          stackIn = stackIn.next;
	        }
	        innerEnd = outterPos + innerEndDelta;
	        rbs = radius;
	        innerRadiusEnd = outterPos + radius * innerStep;
	        innerPos = outterPos + innerStep;
	        while (innerPos <= innerRadiusEnd) {
	          readPos = innerPos;
	          if (innerPos > innerEnd) {
	            readPos = innerEnd;
	          }
	          pr = pixels[readPos];
	          pg = pixels[readPos + 1];
	          pb = pixels[readPos + 2];
	          r_in_sum += stackIn.r = pr;
	          g_in_sum += stackIn.g = pg;
	          b_in_sum += stackIn.b = pb;
	          r_sum += pr * rbs;
	          g_sum += pg * rbs;
	          b_sum += pb * rbs;
	          rbs--;
	          stackIn = stackIn.next;
	          innerPos += innerStep;
	        }
	        stackOut = stackEnd;
	        readPosOffset = radiusPlus1 * innerStep;
	        innerPos = outterPos;
	        while (innerPos <= innerEnd) {
	          pixels[innerPos] = r_sum * oneOverStackWeight;
	          pixels[innerPos + 1] = g_sum * oneOverStackWeight;
	          pixels[innerPos + 2] = b_sum * oneOverStackWeight;
	          r_sum -= r_out_sum;
	          g_sum -= g_out_sum;
	          b_sum -= b_out_sum;
	          r_out_sum -= stackIn.r;
	          g_out_sum -= stackIn.g;
	          b_out_sum -= stackIn.b;
	          readPos = innerPos + readPosOffset;
	          if (readPos > innerEnd) {
	            readPos = innerEnd;
	          }
	          pr = pixels[readPos];
	          pg = pixels[readPos + 1];
	          pb = pixels[readPos + 2];
	          r_in_sum += stackIn.r = pr;
	          g_in_sum += stackIn.g = pg;
	          b_in_sum += stackIn.b = pb;
	          r_sum += r_in_sum;
	          g_sum += g_in_sum;
	          b_sum += b_in_sum;
	          r_out_sum += pr = stackOut.r;
	          g_out_sum += pg = stackOut.g;
	          b_out_sum += pb = stackOut.b;
	          r_in_sum -= pr;
	          g_in_sum -= pg;
	          b_in_sum -= pb;
	          stackIn = stackIn.next;
	          stackOut = stackOut.next;
	          innerPos += innerStep;
	        }
	        results.push(outterPos += outterStep);
	      }
	      return results;
	    };

	    StackBlur.prototype.alphaPass = function(radius, pixels, outterStep, outterEnd, innerStep, innerEndDelta) {
	      var a_in_sum, a_out_sum, a_sum, firstPixelSumWeight, i, innerEnd, innerPos, innerRadiusEnd, j, oneOverStackWeight, outterPos, pa, radiusPlus1, rbs, readPos, readPosOffset, ref, results, stackEnd, stackIn, stackOut, stackStart, stackWeight;
	      radiusPlus1 = radius + 1;
	      stackWeight = radiusPlus1 * radiusPlus1;
	      oneOverStackWeight = 1 / stackWeight;
	      firstPixelSumWeight = (stackWeight + radiusPlus1) / 2;
	      stackStart = this.stackStart;
	      stackEnd = this.stackEnd;
	      outterPos = 3;
	      outterEnd += 3;
	      results = [];
	      while (outterPos <= outterEnd) {
	        a_in_sum = 0;
	        pa = pixels[outterPos];
	        a_out_sum = radiusPlus1 * pa;
	        a_sum = firstPixelSumWeight * pa;
	        stackIn = stackStart;
	        for (i = j = 0, ref = radius; j <= ref; i = j += 1) {
	          stackIn.a = pa;
	          stackIn = stackIn.next;
	        }
	        innerEnd = outterPos + innerEndDelta;
	        rbs = radius;
	        innerRadiusEnd = outterPos + radius * innerStep;
	        innerPos = outterPos + innerStep;
	        while (innerPos <= innerRadiusEnd) {
	          readPos = innerPos;
	          if (innerPos > innerEnd) {
	            readPos = innerEnd;
	          }
	          pa = pixels[readPos];
	          a_in_sum += stackIn.a = pa;
	          a_sum += pa * rbs;
	          rbs--;
	          stackIn = stackIn.next;
	          innerPos += innerStep;
	        }
	        stackOut = stackEnd;
	        readPosOffset = radiusPlus1 * innerStep;
	        innerPos = outterPos;
	        while (innerPos <= innerEnd) {
	          pixels[innerPos] = a_sum * oneOverStackWeight;
	          a_sum -= a_out_sum;
	          a_out_sum -= stackIn.a;
	          readPos = innerPos + readPosOffset;
	          if (readPos > innerEnd) {
	            readPos = innerEnd;
	          }
	          a_in_sum += stackIn.a = pixels[readPos];
	          a_sum += a_in_sum;
	          a_out_sum += pa = stackOut.a;
	          a_in_sum -= pa;
	          stackIn = stackIn.next;
	          stackOut = stackOut.next;
	          innerPos += innerStep;
	        }
	        results.push(outterPos += outterStep);
	      }
	      return results;
	    };

	    StackBlur.prototype.stackBlurCanvasRGBA = function(pixels, width, height, radius) {
	      if (radius <= 0) {
	        return;
	      }
	      this.createStack(radius);
	      this.rgbaPass(radius, pixels, 4, (width - 1) * 4, width * 4, (height - 1) * width * 4);
	      return this.rgbaPass(radius, pixels, width * 4, (height - 1) * width * 4, 4, (width - 1) * 4);
	    };

	    StackBlur.prototype.stackBlurCanvasAlpha = function(pixels, width, height, radius) {
	      if (radius <= 0) {
	        return;
	      }
	      this.createStack(radius);
	      this.alphaPass(radius, pixels, 4, (width - 1) * 4, width * 4, (height - 1) * width * 4);
	      return this.alphaPass(radius, pixels, width * 4, (height - 1) * width * 4, 4, (width - 1) * 4);
	    };

	    StackBlur.prototype.stackBlurCanvasRGB = function(pixels, width, height, radius) {
	      if (radius <= 0) {
	        return;
	      }
	      this.createStack(radius);
	      this.rgbPass(radius, pixels, 4, (width - 1) * 4, width * 4, (height - 1) * width * 4);
	      return this.rgbPass(radius, pixels, width * 4, (height - 1) * width * 4, 4, (width - 1) * 4);
	    };

	    return StackBlur;

	  })(Foundation.BaseObject);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var BatchLoader, Foundation, GoogleFontLoader, WebFont, inspect, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	WebFont = __webpack_require__(149);

	inspect = Foundation.inspect, log = Foundation.log, BatchLoader = Foundation.BatchLoader;

	module.exports = GoogleFontLoader = (function(superClass) {
	  extend(GoogleFontLoader, superClass);

	  GoogleFontLoader.singletonClass();

	  function GoogleFontLoader(options) {
	    if (options == null) {
	      options = {};
	    }
	    this.defaultWeight = {
	      UnifrakturCook: 700
	    };
	    GoogleFontLoader.__super__.constructor.call(this, (function(_this) {
	      return function(src) {
	        return _this.webFontLoadWithWaiting([src]);
	      };
	    })(this));
	  }

	  GoogleFontLoader.prototype.googleFamilies = function(fontFamilies) {
	    var font, i, len, results, weight;
	    results = [];
	    for (i = 0, len = fontFamilies.length; i < len; i++) {
	      font = fontFamilies[i];
	      weight = this.defaultWeight[font] || "";
	      results.push((font.split(" ").join("+")) + ":" + weight + ":latin,latin-ext");
	    }
	    return results;
	  };

	  GoogleFontLoader.prototype.webFontLoad = function(fontFamilies, done) {
	    return WebFont.load({
	      google: {
	        families: this.googleFamilies(fontFamilies)
	      },
	      fontactive: (function(_this) {
	        return function(font) {
	          return _this.addAsset(font, font);
	        };
	      })(this),
	      fontinactive: (function(_this) {
	        return function(font) {
	          return _this.addAsset(font, "FAILED TO LOAD");
	        };
	      })(this),
	      inactive: done,
	      active: done
	    });
	  };

	  GoogleFontLoader.prototype.webFontLoadWithWaiting = function(fontFamilies) {
	    var font, i, len, wfw;
	    if (window.WebFontConfig) {
	      wfw = window.WebFontWaiting || (window.WebFontWaiting = {});
	      for (i = 0, len = fontFamilies.length; i < len; i++) {
	        font = fontFamilies[i];
	        wfw[font] = true;
	      }
	      return;
	    }
	    return this.webFontLoad(fontFamilies, (function(_this) {
	      return function() {
	        var waitingList;
	        waitingList = window.WebFontWaiting && Object.keys(window.WebFontWaiting);
	        window.WebFontWaiting = null;
	        window.WebFontConfig = null;
	        if (waitingList) {
	          return _this.webFontLoad(waitingList);
	        }
	      };
	    })(this));
	  };

	  return GoogleFontLoader;

	})(BatchLoader);


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* Web Font Loader v1.6.26 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.m=b||a;this.c=this.m.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}
	function w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function y(a,b){for(var c=a.className.split(/\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}
	function z(a){if("string"===typeof a.f)return a.f;var b=a.m.location.protocol;"about:"==b&&(b=a.a.location.protocol);return"https:"==b?"https:":"http:"}function ea(a){return a.m.location.hostname||a.a.location.hostname}
	function A(a,b,c){function d(){k&&e&&f&&(k(g),k=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,k=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}
	function B(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function C(){this.a=0;this.c=null}function D(a){a.a++;return function(){a.a--;E(a)}}function F(a,b){a.c=b;E(a)}function E(a){0==a.a&&a.c&&(a.c(),a.c=null)};function G(a){this.a=a||"-"}G.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\W_]+/g,"").toLowerCase());return b.join(this.a)};function H(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return I(a)+" "+(a.f+"00")+" 300px "+J(a.c)}function J(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");-1!=d.indexOf(" ")||/^\d/.test(d)?b.push("'"+d+"'"):b.push(d)}return b.join(",")}function K(a){return a.a+a.f}function I(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}
	function ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.m.document.documentElement;this.h=b;this.a=new G("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);L(a,"loading")}function M(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}L(a,"inactive")}function L(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,K(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function N(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function O(a){u(a.c,"body",a.a)}function P(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+J(a.c)+";"+("font-style:"+I(a)+";font-weight:"+(a.f+"00")+";")};function Q(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}Q.prototype.start=function(){var a=this.c.m.document,b=this,c=q(),d=new Promise(function(d,e){function k(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(k,25)},function(){e()})}k()}),e=new Promise(function(a,d){setTimeout(d,b.f)});Promise.race([e,d]).then(function(){b.g(b.a)},function(){b.j(b.a)})};function R(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.o=this.j=this.h=this.g=null;this.g=new N(this.c,this.s);this.h=new N(this.c,this.s);this.j=new N(this.c,this.s);this.o=new N(this.c,this.s);a=new H(this.a.c+",serif",K(this.a));a=P(a);this.g.a.style.cssText=a;a=new H(this.a.c+",sans-serif",K(this.a));a=P(a);this.h.a.style.cssText=a;a=new H("serif",K(this.a));a=P(a);this.j.a.style.cssText=a;a=new H("sans-serif",K(this.a));a=
	P(a);this.o.a.style.cssText=a;O(this.g);O(this.h);O(this.j);O(this.o)}var S={D:"serif",C:"sans-serif"},T=null;function U(){if(null===T){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);T=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return T}R.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.o.a.offsetWidth;this.A=q();la(this)};
	function ma(a,b,c){for(var d in S)if(S.hasOwnProperty(d)&&b===a.f[S[d]]&&c===a.f[S[d]])return!0;return!1}function la(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=U()&&ma(a,b,c));d?q()-a.A>=a.w?U()&&ma(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):na(a):V(a,a.v)}function na(a){setTimeout(p(function(){la(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.o.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.o=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,K(a).toString(),"active")],[b.a.c("wf",a.c,K(a).toString(),"loading"),b.a.c("wf",a.c,K(a).toString(),"inactive")]);L(b,"fontactive",a);this.o=!0;oa(this)};
	W.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,K(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,K(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,K(a).toString(),"inactive"));w(b.f,d,e)}L(b,"fontinactive",a);oa(this)};function oa(a){0==--a.f&&a.j&&(a.o?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),L(a,"active")):M(a.a))};function pa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}pa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;qa(this,new ha(this.c,a),a)};
	function ra(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,k=d||null||{};if(0===c.length&&f)M(b.a);else{b.f+=c.length;f&&(b.j=f);var h,m=[];for(h=0;h<c.length;h++){var l=c[h],n=k[l.c],r=b.a,x=l;r.g&&w(r.f,[r.a.c("wf",x.c,K(x).toString(),"loading")]);L(r,"fontloading",x);r=null;null===X&&(X=window.FontFace?(x=/Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent))?42<parseInt(x[1],10):!0:!1);X?r=new Q(p(b.g,b),p(b.h,b),b.c,l,b.s,n):r=new R(p(b.g,b),p(b.h,b),b.c,l,b.s,a,
	n);m.push(r)}for(h=0;h<m.length;h++)m[h].start()}},0)}function qa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){ra(a,f,b,d,c)})};function sa(a,b){this.c=a;this.a=b}function ta(a,b,c){var d=z(a.c);a=(a.a.api||"fast.fonts.net/jsapi").replace(/^.*http(s?):(\/\/)?/,"");return d+"//"+a+"/"+b+".js"+(c?"?v="+c:"")}
	sa.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var m=0;m<c.length;m++){var l=c[m].fontfamily;void 0!=c[m].fontStyle&&void 0!=c[m].fontWeight?(h=c[m].fontStyle+c[m].fontWeight,e.push(new H(l,h))):e.push(new H(l))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.m;B(this.c,ta(c,d,e),function(e){e?a([]):(f["__MonotypeConfiguration__"+d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+
	d}else a([])};function ua(a,b){this.c=a;this.a=b}ua.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new C;b=0;for(c=d.length;b<c;b++)A(this.c,d[b],D(g));var k=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),m=0;m<h.length;m+=1)k.push(new H(d[0],h[m]));else k.push(new H(d[0]));F(g,function(){a(k,f)})};function va(a,b,c){a?this.c=a:this.c=b+wa;this.a=[];this.f=[];this.g=c||""}var wa="//fonts.googleapis.com/css";function xa(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}
	function ya(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function za(a){this.f=a;this.a=[];this.c={}}
	var Aa={latin:"BESbswy","latin-ext":"\u00e7\u00f6\u00fc\u011f\u015f",cyrillic:"\u0439\u044f\u0416",greek:"\u03b1\u03b2\u03a3",khmer:"\u1780\u1781\u1782",Hanuman:"\u1780\u1781\u1782"},Ba={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ca={i:"i",italic:"i",n:"n",normal:"n"},
	Da=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
	function Ea(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\+/g," "),f=["n4"];if(2<=d.length){var g;var k=d[1];g=[];if(k)for(var k=k.split(","),h=k.length,m=0;m<h;m++){var l;l=k[m];if(l.match(/^[\w-]+$/)){var n=Da.exec(l.toLowerCase());if(null==n)l="";else{l=n[2];l=null==l||""==l?"n":Ca[l];n=n[1];if(null==n||""==n)n="4";else var r=Ba[n],n=r?r:isNaN(n)?"4":n.substr(0,1);l=[l,n].join("")}}else l="";l&&g.push(l)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):
	g,0<d.length&&(d=Aa[d[0]])&&(a.c[e]=d))}a.c[e]||(d=Aa[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new H(e,f[d]))}};function Fa(a,b){this.c=a;this.a=b}var Ga={Arimo:!0,Cousine:!0,Tinos:!0};Fa.prototype.load=function(a){var b=new C,c=this.c,d=new va(this.a.api,z(c),this.a.text),e=this.a.families;xa(d,e);var f=new za(e);Ea(f);A(c,ya(d),D(b));F(b,function(){a(f.a,f.c,Ga)})};function Ha(a,b){this.c=a;this.a=b}Ha.prototype.load=function(a){var b=this.a.id,c=this.c.m;b?B(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],k=b[f+1],h=0;h<k.length;h++)e.push(new H(g,k[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(m){}a(e)}},2E3):a([])};function Ia(a,b){this.c=a;this.f=b;this.a=[]}Ia.prototype.load=function(a){var b=this.f.id,c=this.c.m,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,k=c.fonts.length;g<k;++g){var h=c.fonts[g];d.a.push(new H(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},B(this.c,z(this.c)+(this.f.api||"//f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new pa(window);Y.a.c.custom=function(a,b){return new ua(b,a)};Y.a.c.fontdeck=function(a,b){return new Ia(b,a)};Y.a.c.monotype=function(a,b){return new sa(b,a)};Y.a.c.typekit=function(a,b){return new Ha(b,a)};Y.a.c.google=function(a,b){return new Fa(b,a)};var Z={load:p(Y.load,Y)}; true?!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return Z}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*

	StackBlur - a fast almost Gaussian Blur For Canvas

	Version:  0.5
	Author:   Mario Klingemann
	Contact:  mario@quasimondo.com
	Website:  http://www.quasimondo.com/StackBlurForCanvas
	Twitter:  @quasimondo

	In case you find this class useful - especially in commercial projects -
	I am not totally unhappy for a small donation to my PayPal account
	mario@quasimondo.de

	Or support me on flattr:
	https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

	Copyright (c) 2010 Mario Klingemann

	Permission is hereby granted, free of charge, to any person
	obtaining a copy of this software and associated documentation
	files (the "Software"), to deal in the Software without
	restriction, including without limitation the rights to use,
	copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following
	conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
	*/
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {


	  var mul_table = [
	          512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
	          454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
	          482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
	          437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
	          497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
	          320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
	          446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
	          329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
	          505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
	          399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
	          324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
	          268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
	          451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
	          385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
	          332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
	          289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];


	  var shg_table = [
	         9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17,
	      17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
	      19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
	      20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
	      21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
	      21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22,
	      22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
	      22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
	      23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	      23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	      23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
	      23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	      24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

	  function stackBlurImage( imageID, canvasID, radius, blurAlphaChannel )
	  {

	    var img = document.getElementById( imageID );
	    var w = img.naturalWidth;
	      var h = img.naturalHeight;

	    var canvas = document.getElementById( canvasID );

	      canvas.style.width  = w + "px";
	      canvas.style.height = h + "px";
	      canvas.width = w;
	      canvas.height = h;

	      var context = canvas.getContext("2d");
	      context.clearRect( 0, 0, w, h );
	      context.drawImage( img, 0, 0 );

	    if ( isNaN(radius) || radius < 1 ) return;

	    if ( blurAlphaChannel )
	      stackBlurCanvasRGBA( canvasID, 0, 0, w, h, radius );
	    else
	      stackBlurCanvasRGB( canvasID, 0, 0, w, h, radius );
	  }


	  function stackBlurCanvasRGBA( imageData, top_x, top_y, width, height, radius )
	  {
	    // if ( isNaN(radius) || radius < 1 ) return;
	    // radius |= 0;

	    // var canvas  = document.getElementById( id );
	    // var context = canvas.getContext("2d");
	    // var imageData;

	    // try {
	    //   try {
	    //   imageData = context.getImageData( top_x, top_y, width, height );
	    //   } catch(e) {

	    //   // NOTE: this part is supposedly only needed if you want to work with local files
	    //   // so it might be okay to remove the whole try/catch block and just use
	    //   // imageData = context.getImageData( top_x, top_y, width, height );
	    //   try {
	    //     netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
	    //     imageData = context.getImageData( top_x, top_y, width, height );
	    //   } catch(e) {
	    //     alert("Cannot access local image");
	    //     throw new Error("unable to access local image data: " + e);
	    //     return;
	    //   }
	    //   }
	    // } catch(e) {
	    //   alert("Cannot access image");
	    //   throw new Error("unable to access image data: " + e);
	    // }

	    var pixels = imageData.data;

	    var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum,
	    r_out_sum, g_out_sum, b_out_sum, a_out_sum,
	    r_in_sum, g_in_sum, b_in_sum, a_in_sum,
	    pr, pg, pb, pa, rbs;

	    var div = radius + radius + 1;
	    var w4 = width << 2;
	    var widthMinus1  = width - 1;
	    var heightMinus1 = height - 1;
	    var radiusPlus1  = radius + 1;
	    var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;

	    var stackStart = new BlurStack();
	    var stack = stackStart;
	    for ( i = 1; i < div; i++ )
	    {
	      stack = stack.next = new BlurStack();
	      if ( i == radiusPlus1 ) var stackEnd = stack;
	    }
	    stack.next = stackStart;
	    var stackIn = null;
	    var stackOut = null;

	    yw = yi = 0;

	    var mul_sum = mul_table[radius];
	    var shg_sum = shg_table[radius];

	    for ( y = 0; y < height; y++ )
	    {
	      r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

	      r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
	      g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
	      b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
	      a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );

	      r_sum += sumFactor * pr;
	      g_sum += sumFactor * pg;
	      b_sum += sumFactor * pb;
	      a_sum += sumFactor * pa;

	      stack = stackStart;

	      for( i = 0; i < radiusPlus1; i++ )
	      {
	        stack.r = pr;
	        stack.g = pg;
	        stack.b = pb;
	        stack.a = pa;
	        stack = stack.next;
	      }

	      for( i = 1; i < radiusPlus1; i++ )
	      {
	        p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
	        r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
	        g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
	        b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
	        a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;

	        r_in_sum += pr;
	        g_in_sum += pg;
	        b_in_sum += pb;
	        a_in_sum += pa;

	        stack = stack.next;
	      }


	      stackIn = stackStart;
	      stackOut = stackEnd;
	      for ( x = 0; x < width; x++ )
	      {
	        pixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;
	        if ( pa != 0 )
	        {
	          pa = 255 / pa;
	          pixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;
	          pixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;
	          pixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;
	        } else {
	          pixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;
	        }

	        r_sum -= r_out_sum;
	        g_sum -= g_out_sum;
	        b_sum -= b_out_sum;
	        a_sum -= a_out_sum;

	        r_out_sum -= stackIn.r;
	        g_out_sum -= stackIn.g;
	        b_out_sum -= stackIn.b;
	        a_out_sum -= stackIn.a;

	        p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;

	        r_in_sum += ( stackIn.r = pixels[p]);
	        g_in_sum += ( stackIn.g = pixels[p+1]);
	        b_in_sum += ( stackIn.b = pixels[p+2]);
	        a_in_sum += ( stackIn.a = pixels[p+3]);

	        r_sum += r_in_sum;
	        g_sum += g_in_sum;
	        b_sum += b_in_sum;
	        a_sum += a_in_sum;

	        stackIn = stackIn.next;

	        r_out_sum += ( pr = stackOut.r );
	        g_out_sum += ( pg = stackOut.g );
	        b_out_sum += ( pb = stackOut.b );
	        a_out_sum += ( pa = stackOut.a );

	        r_in_sum -= pr;
	        g_in_sum -= pg;
	        b_in_sum -= pb;
	        a_in_sum -= pa;

	        stackOut = stackOut.next;

	        yi += 4;
	      }
	      yw += width;
	    }


	    for ( x = 0; x < width; x++ )
	    {
	      g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

	      yi = x << 2;
	      r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
	      g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
	      b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
	      a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);

	      r_sum += sumFactor * pr;
	      g_sum += sumFactor * pg;
	      b_sum += sumFactor * pb;
	      a_sum += sumFactor * pa;

	      stack = stackStart;

	      for( i = 0; i < radiusPlus1; i++ )
	      {
	        stack.r = pr;
	        stack.g = pg;
	        stack.b = pb;
	        stack.a = pa;
	        stack = stack.next;
	      }

	      yp = width;

	      for( i = 1; i <= radius; i++ )
	      {
	        yi = ( yp + x ) << 2;

	        r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
	        g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
	        b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
	        a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;

	        r_in_sum += pr;
	        g_in_sum += pg;
	        b_in_sum += pb;
	        a_in_sum += pa;

	        stack = stack.next;

	        if( i < heightMinus1 )
	        {
	          yp += width;
	        }
	      }

	      yi = x;
	      stackIn = stackStart;
	      stackOut = stackEnd;
	      for ( y = 0; y < height; y++ )
	      {
	        p = yi << 2;
	        pixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;
	        if ( pa > 0 )
	        {
	          pa = 255 / pa;
	          pixels[p]   = ((r_sum * mul_sum) >> shg_sum ) * pa;
	          pixels[p+1] = ((g_sum * mul_sum) >> shg_sum ) * pa;
	          pixels[p+2] = ((b_sum * mul_sum) >> shg_sum ) * pa;
	        } else {
	          pixels[p] = pixels[p+1] = pixels[p+2] = 0;
	        }

	        r_sum -= r_out_sum;
	        g_sum -= g_out_sum;
	        b_sum -= b_out_sum;
	        a_sum -= a_out_sum;

	        r_out_sum -= stackIn.r;
	        g_out_sum -= stackIn.g;
	        b_out_sum -= stackIn.b;
	        a_out_sum -= stackIn.a;

	        p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;

	        r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
	        g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
	        b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
	        a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));

	        stackIn = stackIn.next;

	        r_out_sum += ( pr = stackOut.r );
	        g_out_sum += ( pg = stackOut.g );
	        b_out_sum += ( pb = stackOut.b );
	        a_out_sum += ( pa = stackOut.a );

	        r_in_sum -= pr;
	        g_in_sum -= pg;
	        b_in_sum -= pb;
	        a_in_sum -= pa;

	        stackOut = stackOut.next;

	        yi += width;
	      }
	    }

	    // context.putImageData( imageData, top_x, top_y );

	  }


	  function stackBlurCanvasRGB( imageData, top_x, top_y, width, height, radius )
	  {
	    // if ( isNaN(radius) || radius < 1 ) return;
	    // radius |= 0;

	    // var canvas  = document.getElementById( id );
	    // var context = canvas.getContext("2d");
	    // var imageData;

	    // try {
	    //   try {
	    //   imageData = context.getImageData( top_x, top_y, width, height );
	    //   } catch(e) {

	    //   // NOTE: this part is supposedly only needed if you want to work with local files
	    //   // so it might be okay to remove the whole try/catch block and just use
	    //   // imageData = context.getImageData( top_x, top_y, width, height );
	    //   try {
	    //     netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
	    //     imageData = context.getImageData( top_x, top_y, width, height );
	    //   } catch(e) {
	    //     alert("Cannot access local image");
	    //     throw new Error("unable to access local image data: " + e);
	    //     return;
	    //   }
	    //   }
	    // } catch(e) {
	    //   alert("Cannot access image");
	    //   throw new Error("unable to access image data: " + e);
	    // }

	    var pixels = imageData.data;

	    var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum,
	    r_out_sum, g_out_sum, b_out_sum,
	    r_in_sum, g_in_sum, b_in_sum,
	    pr, pg, pb, rbs;

	    var div = radius + radius + 1;
	    var w4 = width << 2;
	    var widthMinus1  = width - 1;
	    var heightMinus1 = height - 1;
	    var radiusPlus1  = radius + 1;
	    var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;

	    var stackStart = new BlurStack();
	    var stack = stackStart;
	    for ( i = 1; i < div; i++ )
	    {
	      stack = stack.next = new BlurStack();
	      if ( i == radiusPlus1 ) var stackEnd = stack;
	    }
	    stack.next = stackStart;
	    var stackIn = null;
	    var stackOut = null;

	    yw = yi = 0;

	    var mul_sum = mul_table[radius];
	    var shg_sum = shg_table[radius];

	    for ( y = 0; y < height; y++ )
	    {
	      r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;

	      r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
	      g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
	      b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );

	      r_sum += sumFactor * pr;
	      g_sum += sumFactor * pg;
	      b_sum += sumFactor * pb;

	      stack = stackStart;

	      for( i = 0; i < radiusPlus1; i++ )
	      {
	        stack.r = pr;
	        stack.g = pg;
	        stack.b = pb;
	        stack = stack.next;
	      }

	      for( i = 1; i < radiusPlus1; i++ )
	      {
	        p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
	        r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
	        g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
	        b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;

	        r_in_sum += pr;
	        g_in_sum += pg;
	        b_in_sum += pb;

	        stack = stack.next;
	      }


	      stackIn = stackStart;
	      stackOut = stackEnd;
	      for ( x = 0; x < width; x++ )
	      {
	        pixels[yi]   = (r_sum * mul_sum) >> shg_sum;
	        pixels[yi+1] = (g_sum * mul_sum) >> shg_sum;
	        pixels[yi+2] = (b_sum * mul_sum) >> shg_sum;

	        r_sum -= r_out_sum;
	        g_sum -= g_out_sum;
	        b_sum -= b_out_sum;

	        r_out_sum -= stackIn.r;
	        g_out_sum -= stackIn.g;
	        b_out_sum -= stackIn.b;

	        p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;

	        r_in_sum += ( stackIn.r = pixels[p]);
	        g_in_sum += ( stackIn.g = pixels[p+1]);
	        b_in_sum += ( stackIn.b = pixels[p+2]);

	        r_sum += r_in_sum;
	        g_sum += g_in_sum;
	        b_sum += b_in_sum;

	        stackIn = stackIn.next;

	        r_out_sum += ( pr = stackOut.r );
	        g_out_sum += ( pg = stackOut.g );
	        b_out_sum += ( pb = stackOut.b );

	        r_in_sum -= pr;
	        g_in_sum -= pg;
	        b_in_sum -= pb;

	        stackOut = stackOut.next;

	        yi += 4;
	      }
	      yw += width;
	    }


	    for ( x = 0; x < width; x++ )
	    {
	      g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;

	      yi = x << 2;
	      r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
	      g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
	      b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);

	      r_sum += sumFactor * pr;
	      g_sum += sumFactor * pg;
	      b_sum += sumFactor * pb;

	      stack = stackStart;

	      for( i = 0; i < radiusPlus1; i++ )
	      {
	        stack.r = pr;
	        stack.g = pg;
	        stack.b = pb;
	        stack = stack.next;
	      }

	      yp = width;

	      for( i = 1; i <= radius; i++ )
	      {
	        yi = ( yp + x ) << 2;

	        r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
	        g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
	        b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;

	        r_in_sum += pr;
	        g_in_sum += pg;
	        b_in_sum += pb;

	        stack = stack.next;

	        if( i < heightMinus1 )
	        {
	          yp += width;
	        }
	      }

	      yi = x;
	      stackIn = stackStart;
	      stackOut = stackEnd;
	      for ( y = 0; y < height; y++ )
	      {
	        p = yi << 2;
	        pixels[p]   = (r_sum * mul_sum) >> shg_sum;
	        pixels[p+1] = (g_sum * mul_sum) >> shg_sum;
	        pixels[p+2] = (b_sum * mul_sum) >> shg_sum;

	        r_sum -= r_out_sum;
	        g_sum -= g_out_sum;
	        b_sum -= b_out_sum;

	        r_out_sum -= stackIn.r;
	        g_out_sum -= stackIn.g;
	        b_out_sum -= stackIn.b;

	        p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;

	        r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
	        g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
	        b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));

	        stackIn = stackIn.next;

	        r_out_sum += ( pr = stackOut.r );
	        g_out_sum += ( pg = stackOut.g );
	        b_out_sum += ( pb = stackOut.b );

	        r_in_sum -= pr;
	        g_in_sum -= pg;
	        b_in_sum -= pb;

	        stackOut = stackOut.next;

	        yi += width;
	      }
	    }

	    // context.putImageData( imageData, top_x, top_y );

	  }

	  function BlurStack()
	  {
	    this.r = 0;
	    this.g = 0;
	    this.b = 0;
	    this.a = 0;
	    this.next = null;
	  }
	  return {stackBlurCanvasRGBA:stackBlurCanvasRGBA, stackBlurCanvasRGB:stackBlurCanvasRGB};
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
	/*

	StackBlurOriginal - a fast almost Gaussian Blur For Canvas

	Version:  0.5
	Author:   Mario Klingemann
	Contact:  mario@quasimondo.com
	Website:  http://www.quasimondo.com/StackBlurForCanvas
	Twitter:  @quasimondo

	In case you find this class useful - especially in commercial projects -
	I am not totally unhappy for a small donation to my PayPal account
	mario@quasimondo.de

	Or support me on flattr:
	https://flattr.com/thing/72791/StackBlurOriginal-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

	Copyright (c) 2010 Mario Klingemann

	Permission is hereby granted, free of charge, to any person
	obtaining a copy of this software and associated documentation
	files (the "Software"), to deal in the Software without
	restriction, including without limitation the rights to use,
	copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following
	conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
	 */
	var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(125), __webpack_require__(139), __webpack_require__(150), __webpack_require__(143)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Foundation, Atomic, Canvas, OrigStackBlur) {
	  var BlurStack, color, inspect, matrix, mulTable, nextTick, point, rect, shgTable;
	  point = Atomic.point, matrix = Atomic.matrix, rect = Atomic.rect, color = Atomic.color;
	  inspect = Foundation.Inspect.inspect;
	  nextTick = Foundation.nextTick;
	  mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
	  shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
	  BlurStack = (function() {
	    function BlurStack() {
	      this.r = this.g = this.b = this.a = 0;
	      this.next = null;
	    }

	    return BlurStack;

	  })();
	  return Canvas.StackBlurOriginal = (function(superClass) {
	    extend(StackBlurOriginal, superClass);

	    function StackBlurOriginal() {
	      return StackBlurOriginal.__super__.constructor.apply(this, arguments);
	    }

	    StackBlurOriginal.blur = function(bitmap, radius) {
	      return (new Canvas.StackBlurOriginal).blur(bitmap, radius);
	    };

	    StackBlurOriginal.blurRGB = function(bitmap, radius) {
	      return (new Canvas.StackBlurOriginal).blurRGB(bitmap, radius);
	    };

	    StackBlurOriginal.prototype.blur = function(bitmap, radius) {
	      var imageData, pixels;
	      imageData = bitmap.getImageData();
	      pixels = imageData.data;
	      OrigStackBlur.stackBlurCanvasRGBA(imageData, 0, 0, bitmap.size.w, bitmap.size.h, radius);
	      return bitmap.putImageData(imageData);
	    };

	    StackBlurOriginal.prototype.blurRGB = function(bitmap, radius) {
	      var imageData, pixels;
	      imageData = bitmap.getImageData();
	      pixels = imageData.data;
	      OrigStackBlur.stackBlurCanvasRGB(imageData, 0, 0, bitmap.size.w, bitmap.size.h, radius);
	      return bitmap.putImageData(imageData);
	    };

	    StackBlurOriginal.prototype.stackBlurCanvasRGBA = function(pixels, top_x, top_y, width, height, radius) {
	      var a_in_sum, a_out_sum, a_sum, b_in_sum, b_out_sum, b_sum, div, g_in_sum, g_out_sum, g_sum, heightMinus1, i, j, k, l, m, mul_sum, n, o, p, pa, pb, pg, pr, q, r, r_in_sum, r_out_sum, r_sum, radiusPlus1, rbs, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, results, s, shg_sum, stack, stackEnd, stackIn, stackOut, stackStart, sumFactor, w4, widthMinus1, x, y, yi, yp, yw;
	      div = radius + radius + 1;
	      w4 = width << 2;
	      widthMinus1 = width - 1;
	      heightMinus1 = height - 1;
	      radiusPlus1 = radius + 1;
	      sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
	      stackStart = new BlurStack();
	      stack = stackStart;
	      for (i = j = 1, ref = div - 1; j <= ref; i = j += 1) {
	        stack = stack.next = new BlurStack();
	        if (i === radiusPlus1) {
	          stackEnd = stack;
	        }
	      }
	      stack.next = stackStart;
	      yw = yi = 0;
	      mul_sum = mulTable[radius];
	      shg_sum = shgTable[radius];
	      for (y = k = 0, ref1 = heightMinus1; k <= ref1; y = k += 1) {
	        r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
	        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
	        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
	        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
	        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
	        r_sum += sumFactor * pr;
	        g_sum += sumFactor * pg;
	        b_sum += sumFactor * pb;
	        a_sum += sumFactor * pa;
	        stack = stackStart;
	        for (i = l = 0, ref2 = radius; l <= ref2; i = l += 1) {
	          stack.r = pr;
	          stack.g = pg;
	          stack.b = pb;
	          stack.a = pa;
	          stack = stack.next;
	        }
	        for (i = m = 1, ref3 = radius; m <= ref3; i = m += 1) {
	          p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
	          r_sum += (stack.r = (pr = pixels[p])) * (rbs = radiusPlus1 - i);
	          g_sum += (stack.g = (pg = pixels[p + 1])) * rbs;
	          b_sum += (stack.b = (pb = pixels[p + 2])) * rbs;
	          a_sum += (stack.a = (pa = pixels[p + 3])) * rbs;
	          r_in_sum += pr;
	          g_in_sum += pg;
	          b_in_sum += pb;
	          a_in_sum += pa;
	          stack = stack.next;
	        }
	        stackIn = stackStart;
	        stackOut = stackEnd;
	        for (x = n = 0, ref4 = widthMinus1; n <= ref4; x = n += 1) {
	          pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
	          if (pa !== 0) {
	            pa = 255 / pa;
	            pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
	            pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
	            pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
	          } else {
	            pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
	          }
	          r_sum -= r_out_sum;
	          g_sum -= g_out_sum;
	          b_sum -= b_out_sum;
	          a_sum -= a_out_sum;
	          r_out_sum -= stackIn.r;
	          g_out_sum -= stackIn.g;
	          b_out_sum -= stackIn.b;
	          a_out_sum -= stackIn.a;
	          p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;
	          r_in_sum += (stackIn.r = pixels[p]);
	          g_in_sum += (stackIn.g = pixels[p + 1]);
	          b_in_sum += (stackIn.b = pixels[p + 2]);
	          a_in_sum += (stackIn.a = pixels[p + 3]);
	          r_sum += r_in_sum;
	          g_sum += g_in_sum;
	          b_sum += b_in_sum;
	          a_sum += a_in_sum;
	          stackIn = stackIn.next;
	          r_out_sum += (pr = stackOut.r);
	          g_out_sum += (pg = stackOut.g);
	          b_out_sum += (pb = stackOut.b);
	          a_out_sum += (pa = stackOut.a);
	          r_in_sum -= pr;
	          g_in_sum -= pg;
	          b_in_sum -= pb;
	          a_in_sum -= pa;
	          stackOut = stackOut.next;
	          yi += 4;
	        }
	        yw += width;
	      }
	      results = [];
	      for (x = o = 0, ref5 = widthMinus1; o <= ref5; x = o += 1) {
	        g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
	        yi = x << 2;
	        r_out_sum = radiusPlus1 * (pr = pixels[yi]);
	        g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
	        b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
	        a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
	        r_sum += sumFactor * pr;
	        g_sum += sumFactor * pg;
	        b_sum += sumFactor * pb;
	        a_sum += sumFactor * pa;
	        stack = stackStart;
	        for (i = q = 0, ref6 = radius; q <= ref6; i = q += 1) {
	          stack.r = pr;
	          stack.g = pg;
	          stack.b = pb;
	          stack.a = pa;
	          stack = stack.next;
	        }
	        yp = width;
	        for (i = r = 1, ref7 = radius; r <= ref7; i = r += 1) {
	          yi = (yp + x) << 2;
	          r_sum += (stack.r = (pr = pixels[yi])) * (rbs = radiusPlus1 - i);
	          g_sum += (stack.g = (pg = pixels[yi + 1])) * rbs;
	          b_sum += (stack.b = (pb = pixels[yi + 2])) * rbs;
	          a_sum += (stack.a = (pa = pixels[yi + 3])) * rbs;
	          r_in_sum += pr;
	          g_in_sum += pg;
	          b_in_sum += pb;
	          a_in_sum += pa;
	          stack = stack.next;
	          if (i < heightMinus1) {
	            yp += width;
	          }
	        }
	        yi = x;
	        stackIn = stackStart;
	        stackOut = stackEnd;
	        for (y = s = 0, ref8 = heightMinus1; s <= ref8; y = s += 1) {
	          p = yi << 2;
	          pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
	          if (pa > 0) {
	            pa = 255 / pa;
	            pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
	            pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
	            pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
	          } else {
	            pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
	          }
	          r_sum -= r_out_sum;
	          g_sum -= g_out_sum;
	          b_sum -= b_out_sum;
	          a_sum -= a_out_sum;
	          r_out_sum -= stackIn.r;
	          g_out_sum -= stackIn.g;
	          b_out_sum -= stackIn.b;
	          a_out_sum -= stackIn.a;
	          p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width)) << 2;
	          r_sum += (r_in_sum += (stackIn.r = pixels[p]));
	          g_sum += (g_in_sum += (stackIn.g = pixels[p + 1]));
	          b_sum += (b_in_sum += (stackIn.b = pixels[p + 2]));
	          a_sum += (a_in_sum += (stackIn.a = pixels[p + 3]));
	          stackIn = stackIn.next;
	          r_out_sum += (pr = stackOut.r);
	          g_out_sum += (pg = stackOut.g);
	          b_out_sum += (pb = stackOut.b);
	          a_out_sum += (pa = stackOut.a);
	          r_in_sum -= pr;
	          g_in_sum -= pg;
	          b_in_sum -= pb;
	          a_in_sum -= pa;
	          stackOut = stackOut.next;
	          yi += width;
	        }
	        results.push(1);
	      }
	      return results;
	    };

	    return StackBlurOriginal;

	  })(Foundation.BaseObject);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(153);


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(154).includeInNamespace(__webpack_require__(156)).addModules({
	  FullScreenApp: __webpack_require__(250)
	});

	__webpack_require__(205);

	__webpack_require__(157);

	__webpack_require__(266);

	__webpack_require__(212);

	__webpack_require__(163);

	__webpack_require__(269);

	__webpack_require__(245);

	__webpack_require__(187);


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Engine,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(155);

	module.exports = Art.Engine || Art.addNamespace('Engine', Engine = (function(superClass) {
	  extend(Engine, superClass);

	  function Engine() {
	    return Engine.__super__.constructor.apply(this, arguments);
	  }

	  return Engine;

	})(Neptune.Base));


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	var _package;

	module.exports = [
	  __webpack_require__(157), __webpack_require__(212), __webpack_require__(205), __webpack_require__(245), {
	    "package": _package = __webpack_require__(249),
	    version: _package.version
	  }
	];


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(158).includeInNamespace(__webpack_require__(159)).addModules({
	  CanvasElement: __webpack_require__(161),
	  DrawCacheManager: __webpack_require__(203),
	  DrawEpoch: __webpack_require__(202),
	  ElementBase: __webpack_require__(192),
	  ElementFactory: __webpack_require__(160),
	  Element: __webpack_require__(184),
	  EngineStat: __webpack_require__(210),
	  EpochedObject: __webpack_require__(200),
	  EventedEpochedObject: __webpack_require__(193),
	  GlobalEpochCycle: __webpack_require__(201),
	  IdleEpoch: __webpack_require__(204),
	  StateEpoch: __webpack_require__(194)
	});

	__webpack_require__(211);


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var Core, Engine,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Engine = __webpack_require__(154);

	module.exports = Engine.Core || Engine.addNamespace('Core', Core = (function(superClass) {
	  extend(Core, superClass);

	  function Core() {
	    return Core.__super__.constructor.apply(this, arguments);
	  }

	  return Core;

	})(Neptune.Base));


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  newElement: (__webpack_require__(160)).newElement
	};


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, ElementFactory, Foundation, inspect, timeout,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	BaseObject = Foundation.BaseObject, timeout = Foundation.timeout, inspect = Foundation.inspect;

	module.exports = ElementFactory = (function(superClass) {
	  extend(ElementFactory, superClass);

	  ElementFactory.singletonClass();

	  ElementFactory.newElement = function(elementClassName, props, children) {
	    return ElementFactory.singleton.newElement(elementClassName, props, children);
	  };

	  function ElementFactory() {
	    ElementFactory.__super__.constructor.apply(this, arguments);
	    this._elementClassesByName = {};
	  }

	  ElementFactory.prototype.register = function(klass) {
	    var name;
	    name = klass.name;
	    if (this._elementClassesByName[name]) {
	      return timeout(100, (function(_this) {
	        return function() {
	          return console.warn("ElementFactory: element with class-name " + name + " already exists. ClassPaths: Existing: " + _this._elementClassesByName[name].namespacePath + ", Adding: " + klass.namespacePath);
	        };
	      })(this));
	    } else {
	      return this._elementClassesByName[name] = klass;
	    }
	  };

	  ElementFactory.prototype.classForElement = function(elementClassName) {
	    return this._elementClassesByName[elementClassName];
	  };

	  ElementFactory.prototype.newElement = function(elementClassName, props, children) {
	    var klass;
	    klass = this._elementClassesByName[elementClassName];
	    if (!klass) {
	      throw new Error("ElementFactor: class not found for " + (inspect(elementClassName)) + " (props: " + (inspect(props)) + ")");
	    }
	    return new this._elementClassesByName[elementClassName](props, children);
	  };

	  return ElementFactory;

	})(BaseObject);


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var ArtEngineEvents, Atomic, Browser, Canvas, CanvasElement, DrawEpoch, Element, EngineStat, Foundation, GlobalEpochCycle, HtmlCanvas, KeyEvent, Matrix, Point, PointerEvent, PointerEventManager, Rectangle, createWithPostCreate, currentSecond, domElementOffset, drawEpoch, durationString, first, getDevicePixelRatio, globalEpochCycle, inspect, isMobileBrowser, isPlainObject, log, matrix, merge, nextTick, objectDiff, point, rect, ref, select, timeStampToPerformanceSecond, timeout, wordsArray,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	__webpack_require__(162);

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Canvas = __webpack_require__(137);

	ArtEngineEvents = __webpack_require__(163);

	Element = __webpack_require__(184);

	GlobalEpochCycle = __webpack_require__(201);

	DrawEpoch = __webpack_require__(202);

	EngineStat = __webpack_require__(210);

	log = Foundation.log, inspect = Foundation.inspect, nextTick = Foundation.nextTick, currentSecond = Foundation.currentSecond, timeout = Foundation.timeout, durationString = Foundation.durationString, timeStampToPerformanceSecond = Foundation.timeStampToPerformanceSecond, first = Foundation.first, Browser = Foundation.Browser, createWithPostCreate = Foundation.createWithPostCreate, wordsArray = Foundation.wordsArray, select = Foundation.select, merge = Foundation.merge, objectDiff = Foundation.objectDiff, isPlainObject = Foundation.isPlainObject;

	isMobileBrowser = Browser.isMobileBrowser;

	HtmlCanvas = Browser.DomElementFactories.Canvas;

	point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix;

	ref = Browser.Dom, getDevicePixelRatio = ref.getDevicePixelRatio, domElementOffset = ref.domElementOffset;

	PointerEventManager = ArtEngineEvents.PointerEventManager, PointerEvent = ArtEngineEvents.PointerEvent, KeyEvent = ArtEngineEvents.KeyEvent;

	globalEpochCycle = GlobalEpochCycle.globalEpochCycle;

	drawEpoch = DrawEpoch.drawEpoch;

	module.exports = createWithPostCreate(CanvasElement = (function(superClass) {
	  extend(CanvasElement, superClass);

	  CanvasElement.classGetter({
	    devicePixelsPerPoint: function() {
	      return getDevicePixelRatio();
	    }
	  });

	  CanvasElement.prototype._updateRegistryFromPendingState = function() {
	    return null;
	  };


	  /*
	  IN:
	    options:
	      for 'real' mode, set one of the following
	      for 'test' mode, leave all blank and there will be no HTMLCanvasElement
	        canvas:             HTMLCanvasElement instance
	        canvasId:           canvas = document.getElementById canvasId
	        parentHtmlElement:  parentHtmlElement.appendChild HtmlCanvas(...)
	  
	      parentHtmlElement is the preferred option:
	        A new HtmlCanvas is generated, and
	        it's styles are setup for the best results.
	   */

	  function CanvasElement(options) {
	    if (options == null) {
	      options = {};
	    }
	    CanvasElement.__super__.constructor.apply(this, arguments);
	    this.canvasElement = this;
	    this._focusedElement = null;
	    this._wasFocusedElement = null;
	    this._devicePixelsPerPoint = 1;
	    this._domEventListeners = [];
	    this._drawEpochPreprocessing = [];
	    this._drawEpochQueued = false;
	    if (!options.disableRetina) {
	      this.retinaSupport = true;
	    }
	    this._attach(this._getOrCreateCanvasElement(options));
	    this.engineStat = new EngineStat;
	    this.pointerEventManager = new PointerEventManager({
	      canvasElement: this
	    });
	    self.canvasElement || (self.canvasElement = this);
	  }

	  CanvasElement.prototype._getOrCreateCanvasElement = function(arg) {
	    var canvas, canvasId, noHtmlCanvasElement, parentHtmlElement;
	    canvas = arg.canvas, canvasId = arg.canvasId, parentHtmlElement = arg.parentHtmlElement, noHtmlCanvasElement = arg.noHtmlCanvasElement;
	    if (!noHtmlCanvasElement) {
	      return canvas || document.getElementById(canvasId) || this._createCanvasElement(parentHtmlElement);
	    }
	  };

	  CanvasElement.prototype._createCanvasElement = function(parentHtmlElement) {
	    parentHtmlElement || (parentHtmlElement = document.getElementById("artDomConsoleArea") || document.body);
	    return parentHtmlElement.appendChild(this._createdHtmlCanvasElement = HtmlCanvas({
	      style: merge(this.pendingStyle, {
	        position: "absolute",
	        outline: "none",
	        top: "0",
	        left: "0"
	      }),
	      id: "artCanvas"
	    }));
	  };

	  CanvasElement.concreteProperty({
	    style: {
	      "default": {},
	      validate: function(v) {
	        return isPlainObject(v);
	      },
	      postSetter: function(newValue, oldValue, rawNewValue) {
	        var remove, update;
	        update = (function(_this) {
	          return function(key, newValue) {
	            return _this._canvas.style[key] = newValue;
	          };
	        })(this);
	        remove = (function(_this) {
	          return function(key) {
	            return _this._canvas.style[key] = null;
	          };
	        })(this);
	        return this._canvas && objectDiff(newValue, oldValue, update, remove, update);
	      }
	    }
	  });

	  CanvasElement.virtualProperty({
	    parentSizeForChildren: function(pending) {
	      return this.getParentSize(pending);
	    },
	    parentSize: function(pending) {
	      var ref1, ref2;
	      if (this._canvas) {
	        return point(((ref1 = this._canvas.parentElement) != null ? ref1.clientWidth : void 0) || 100, ((ref2 = this._canvas.parentElement) != null ? ref2.clientHeight : void 0) || 100);
	      } else {
	        return point(100);
	      }
	    }
	  });

	  CanvasElement.prototype._domListener = function(target, type, listener) {
	    target.addEventListener(type, listener);
	    return this._domEventListeners.push({
	      target: target,
	      type: type,
	      listener: listener
	    });
	  };

	  CanvasElement.prototype.detach = function() {
	    var ref1;
	    globalEpochCycle.detachCanvasElement(this);
	    if (this._createdHtmlCanvasElement) {
	      log("CanvasElement#detach: removing createdHtmlCanvasElement...");
	      if ((ref1 = this._createdHtmlCanvasElement.parentElement) != null) {
	        ref1.removeChild(this._createdHtmlCanvasElement);
	      }
	      this._createdHtmlCanvasElement = null;
	      this._canvas = null;
	      log("CanvasElement#detach: removed createdHtmlCanvasElement.");
	    }
	    this._unregister();
	    return this._detachDomEventListeners();
	  };

	  CanvasElement.prototype._detachDomEventListeners = function() {
	    var i, len, listener, ref1;
	    if (!this._eventListenersAttached) {
	      return;
	    }
	    this._eventListenersAttached = false;
	    this._detachResizeListener();
	    ref1 = this._domEventListeners;
	    for (i = 0, len = ref1.length; i < len; i++) {
	      listener = ref1[i];
	      listener.target.removeEventListener(listener.type, listener.listener);
	    }
	    return this._domEventListeners = [];
	  };

	  CanvasElement.prototype.isFocused = function(el) {
	    return (!this._canvas || (document.hasFocus() && document.activeElement === this._canvas)) && this.pointerEventManager.isFocused(el);
	  };

	  CanvasElement.prototype._blur = function() {
	    return this._focusedElement = null;
	  };

	  CanvasElement.prototype.focusCanvas = function() {
	    var ref1;
	    return (ref1 = this._canvas) != null ? ref1.focus() : void 0;
	  };

	  CanvasElement.prototype.blur = function() {
	    var ref1;
	    if ((ref1 = this._canvas) != null) {
	      ref1.blur();
	    }
	    return this._blur();
	  };

	  CanvasElement.prototype.focusElement = function(el) {
	    if (!(el && el !== this._focusedElement)) {
	      return;
	    }
	    this._focusedElement = this._wasFocusedElement = el;
	    return this.pointerEventManager.focus(null, el);
	  };

	  CanvasElement.prototype._restoreFocus = function() {
	    return (this._wasFocusedElement || this)._focus();
	  };

	  CanvasElement.prototype.enableFileDrop = function() {
	    if (!window.FileReader) {
	      this.log(this.className + "#enableFileDrop failed - browser not supported");
	      return false;
	    }
	    this._domListener(window, 'dragover', (function(_this) {
	      return function(e) {
	        return _this.routeFileDropEvent(e, 'dragOver');
	      };
	    })(this));
	    this._domListener(window, 'dragenter', (function(_this) {
	      return function(e) {
	        return _this.routeFileDropEvent(e, 'dragEnter');
	      };
	    })(this));
	    this._domListener(window, 'dragleave', (function(_this) {
	      return function(e) {
	        return _this.routeFileDropEvent(e, 'dragLeave');
	      };
	    })(this));
	    this._domListener(window, 'drop', (function(_this) {
	      return function(e) {
	        return _this.routeFileDropEvent(e, 'drop');
	      };
	    })(this));
	    this.log(this.className + "#enableFileDrop enabled");
	    return true;
	  };

	  CanvasElement.prototype.routeFileDropEvent = function(e, type) {
	    if (e.dataTransfer.types[0] !== "Files") {
	      return true;
	    }
	    e.preventDefault();
	    this.pointerEventManager.fileDropEvent(type, {
	      locations: [this._domEventLocation(e)],
	      files: e.dataTransfer.files
	    });
	    return false;
	  };

	  CanvasElement.prototype._needsRedrawing = function(descendant) {
	    CanvasElement.__super__._needsRedrawing.apply(this, arguments);
	    return this.queueDrawEpoch();
	  };

	  CanvasElement.prototype._releaseAllCacheBitmaps = function() {};

	  CanvasElement.prototype.queueDrawEpoch = function() {
	    if (!this._drawEpochQueued) {
	      this._drawEpochQueued = true;
	      return drawEpoch.queueItem((function(_this) {
	        return function() {
	          return _this.processEpoch();
	        };
	      })(this));
	    }
	  };

	  CanvasElement.prototype.queueDrawEpochPreprocessor = function(f) {
	    this._drawEpochPreprocessing.push(f);
	    return this.queueDrawEpoch();
	  };

	  CanvasElement.prototype.processEpoch = function() {
	    var f, i, len, pp;
	    this._drawEpochQueued = false;
	    if (this._drawEpochPreprocessing.length > 0) {
	      pp = this._drawEpochPreprocessing;
	      this._drawEpochPreprocessing = [];
	      for (i = 0, len = pp.length; i < len; i++) {
	        f = pp[i];
	        f();
	      }
	    }
	    return this.draw();
	  };

	  CanvasElement.setter({
	    cssCursor: function(cursor) {
	      var ref1;
	      if (cursor !== this._cssCursor) {
	        if ((ref1 = this._canvas) != null) {
	          ref1.style.cursor = cursor;
	        }
	        return this._cssCursor = cursor;
	      }
	    }
	  });

	  CanvasElement.getter({
	    htmlCanvasElement: function() {
	      return this._canvas;
	    },
	    numActivePointers: function() {
	      return this.pointerEventManager.getNumActivePointers();
	    },
	    cacheable: function() {
	      return false;
	    },
	    canvasElement: function() {
	      return this;
	    },
	    cssCursor: function() {
	      return this._cssCursor;
	    },
	    windowScrollOffset: function() {
	      return point(window.scrollX, window.scrollY);
	    },
	    canvasInnerSize: function() {
	      return point(this._fullPageWidth ? window.innerWidth : this._canvas.clientWidth, this._fullPageHeight ? window.innerHeight : this._canvas.clientHeight);
	    }
	  });

	  CanvasElement.prototype._attach = function(canvas) {
	    globalEpochCycle.attachCanvasElement(this);
	    this.onNextReady((function(_this) {
	      return function() {
	        return _this._register();
	      };
	    })(this));
	    this._canvas = canvas;
	    this._retinaSetup();
	    if (canvas) {
	      this._updateCanvasGeometry();
	      return this._attachDomEventListeners();
	    }
	  };

	  CanvasElement.prototype._retinaSetup = function() {
	    return this._devicePixelsPerPoint = this.retinaSupport ? getDevicePixelRatio() : 1;
	  };

	  CanvasElement.prototype._sizeChanged = function(newSize, oldSize) {
	    CanvasElement.__super__._sizeChanged.apply(this, arguments);
	    this._pointSize = newSize;
	    this._canvas.style.width = newSize.x + "px";
	    this._canvas.style.height = newSize.y + "px";
	    this._pixelSize = this._pointSize.mul(this._devicePixelsPerPoint);
	    this._canvas.setAttribute("width", this._pixelSize.x);
	    this._canvas.setAttribute("height", this._pixelSize.y);
	    this._updateCanvasToDocumentMatricies();
	    this._bitmapFactory = this.canvasBitmap = new Canvas.Bitmap(this._canvas);
	    return this.queueDrawEpoch();
	  };

	  CanvasElement.prototype._setElementToParentMatrixFromLayoutXY = function(x, y) {
	    var e2p, ref1, ref2;
	    if (this._locationLayoutDisabled) {
	      return;
	    }
	    e2p = this._getElementToParentMatrixForXY(true, x, y, 1);
	    if ((ref1 = this._canvas) != null) {
	      ref1.style.left = e2p.locationX + "px";
	    }
	    if ((ref2 = this._canvas) != null) {
	      ref2.style.top = e2p.locationY + "px";
	    }
	    e2p = (this._getElementToParentMatrixForXY(true, x, y)).withLocation(0);
	    if (!this._pendingState._elementToParentMatrix.eq(e2p)) {
	      this._pendingState._elementToParentMatrix = e2p;
	      return this._elementChanged();
	    }
	  };

	  CanvasElement.prototype._updateCanvasGeometry = function() {
	    this._updateCanvasToDocumentMatricies();
	    this._layoutPropertyChanged();
	    return this._elementChanged();
	  };

	  CanvasElement.prototype._updateCanvasToDocumentMatricies = function() {
	    var documentOffset, left, ref1, top;
	    ref1 = domElementOffset(this._canvas), left = ref1.left, top = ref1.top;
	    documentOffset = point(left, top);
	    if (!documentOffset.eq(this._canvasDocumentOffset)) {
	      this._canvasDocumentOffset = documentOffset;
	      this._elementToDocumentMatrix = Matrix.scale(1 / this._devicePixelsPerPoint).translateXY(left, top);
	      this._documentToElementMatrix = Matrix.translateXY(-left, -top).scale(this._devicePixelsPerPoint);
	      this._parentToElementMatrix = null;
	      this.scale = this._devicePixelsPerPoint;
	      return this.queueEvent("documentMatriciesChanged");
	    }
	  };

	  CanvasElement.prototype._domEventLocation = function(domEvent) {
	    var windowScrollOffset, x, y;
	    windowScrollOffset = this.getWindowScrollOffset();
	    x = (domEvent.clientX + windowScrollOffset.x - this._canvasDocumentOffset.x) * this._devicePixelsPerPoint;
	    y = (domEvent.clientY + windowScrollOffset.y - this._canvasDocumentOffset.y) * this._devicePixelsPerPoint;
	    return new Point(x, y);
	  };

	  CanvasElement.prototype._detachResizeListener = function() {
	    return this._canvas.parentElement && removeResizeListener(this._canvas.parentElement, this._resizeListener);
	  };

	  CanvasElement.prototype._attachResizeListener = function() {
	    this._domListener(window, "resize", (function(_this) {
	      return function(domEvent) {
	        return _this._updateCanvasToDocumentMatricies();
	      };
	    })(this));
	    return this._canvas.parentElement && addResizeListener(this._canvas.parentElement, this._resizeListener = (function(_this) {
	      return function() {
	        _this._updateCanvasGeometry();
	        return globalEpochCycle.processEpoch();
	      };
	    })(this));
	  };

	  CanvasElement.prototype._attachBlurFocusListeners = function() {
	    this._domListener(this._canvas, "blur", (function(_this) {
	      return function(domEvent) {
	        return _this._blur();
	      };
	    })(this));
	    return this._domListener(this._canvas, "focus", (function(_this) {
	      return function(domEvent) {
	        return _this._restoreFocus();
	      };
	    })(this));
	  };

	  CanvasElement.prototype._attachPointerMoveListeners = function() {
	    this._domListener(this._canvas, "mousemove", (function(_this) {
	      return function(domEvent) {
	        if (_this.numActivePointers === 0) {
	          return _this.mouseMove(_this._domEventLocation(domEvent, timeStampToPerformanceSecond(domEvent.timeStamp)));
	        }
	      };
	    })(this));
	    return this._domListener(window, "mousemove", (function(_this) {
	      return function(domEvent) {
	        if (_this.numActivePointers > 0) {
	          return _this.mouseMove(_this._domEventLocation(domEvent), timeStampToPerformanceSecond(domEvent.timeStamp));
	        }
	      };
	    })(this));
	  };

	  CanvasElement.getter({
	    numActivePointers: function() {
	      return this.pointerEventManager.numActivePointers;
	    },
	    activePointers: function() {
	      return this.pointerEventManager.activePointers;
	    }
	  });

	  CanvasElement.prototype.mouseDown = function(location, timeStampInPerformanceSeconds) {
	    this.pointerEventManager.mouseMove(location, timeStampInPerformanceSeconds);
	    return this.pointerEventManager.mouseDown(location, timeStampInPerformanceSeconds);
	  };

	  CanvasElement.prototype.mouseMove = function(location, timeStampInPerformanceSeconds) {
	    return this.pointerEventManager.mouseMove(location, timeStampInPerformanceSeconds);
	  };

	  CanvasElement.prototype.mouseUp = function(location, timeStampInPerformanceSeconds) {
	    this.pointerEventManager.mouseMove(location, timeStampInPerformanceSeconds);
	    return this.pointerEventManager.mouseUp(timeStampInPerformanceSeconds);
	  };

	  CanvasElement.prototype.mouseWheel = function(location, timeStampInPerformanceSeconds, props) {
	    return this.pointerEventManager.mouseWheel(location, timeStampInPerformanceSeconds, props);
	  };

	  CanvasElement.prototype.touchDown = function(id, location, timeStampInPerformanceSeconds) {
	    return this.pointerEventManager.pointerDown(id, location, timeStampInPerformanceSeconds);
	  };

	  CanvasElement.prototype.touchMove = function(id, location, timeStampInPerformanceSeconds) {
	    return this.pointerEventManager.pointerMove(id, location, timeStampInPerformanceSeconds);
	  };

	  CanvasElement.prototype.touchUp = function(id, location, timeStampInPerformanceSeconds) {
	    this.pointerEventManager.pointerMove(id, location, timeStampInPerformanceSeconds);
	    return this.pointerEventManager.pointerUp(id, timeStampInPerformanceSeconds);
	  };

	  CanvasElement.prototype.touchCancel = function(id, timeStampInPerformanceSeconds) {
	    return this.pointerEventManager.pointerCancel(id, timeStampInPerformanceSeconds);
	  };

	  CanvasElement.prototype._focus = function() {
	    this._canvas.focus();
	    return this.focusElement(this._focusedElement = this._wasFocusedElement);
	  };

	  CanvasElement.prototype.capturePointerEvents = function(element) {
	    return this.pointerEventManager.capturePointerEvents(element);
	  };

	  CanvasElement.prototype.pointerEventsCapturedBy = function(element) {
	    return this.pointerEventManager.pointerEventsCapturedBy(element);
	  };

	  CanvasElement.prototype._attachPointerButtonListeners = function() {
	    this._domListener(this._canvas, "mouseover", (function(_this) {
	      return function(domEvent) {
	        return _this._updateCanvasToDocumentMatricies();
	      };
	    })(this));
	    this._domListener(this._canvas, "mousedown", (function(_this) {
	      return function(domEvent) {
	        _this._updateCanvasToDocumentMatricies();
	        _this._restoreFocus();
	        if (domEvent.button === 0) {
	          domEvent.preventDefault();
	          return _this.mouseDown(_this._domEventLocation(domEvent), timeStampToPerformanceSecond(domEvent.timeStamp));
	        }
	      };
	    })(this));
	    return this._domListener(window, "mouseup", (function(_this) {
	      return function(domEvent) {
	        if (domEvent.button === 0 && _this.activePointers["mousePointer"]) {
	          domEvent.preventDefault();
	          return _this.mouseUp(_this._domEventLocation(domEvent), timeStampToPerformanceSecond(domEvent.timeStamp));
	        }
	      };
	    })(this));
	  };

	  CanvasElement.prototype._attachPointerWheelListeners = function() {
	    return this._domListener(this._canvas, "wheel", (function(_this) {
	      return function(domEvent) {
	        domEvent.preventDefault();
	        return _this.mouseWheel(_this._domEventLocation(domEvent), timeStampToPerformanceSecond(domEvent.timeStamp), merge({
	          deltaMode: (function() {
	            switch (domEvent.deltaMode) {
	              case 0:
	                return "pixel";
	              case 1:
	                return "line";
	              case 2:
	                return "page";
	            }
	          })()
	        }, select(domEvent, "deltaX", "deltaY", "deltaZ")));
	      };
	    })(this));
	  };

	  CanvasElement.prototype._attachPointerTouchListeners = function() {
	    this._domListener(this._canvas, "touchstart", (function(_this) {
	      return function(e) {
	        var changedTouch, i, len, ref1, results;
	        _this._updateCanvasToDocumentMatricies();
	        e.preventDefault();
	        _this._restoreFocus();
	        ref1 = e.changedTouches;
	        results = [];
	        for (i = 0, len = ref1.length; i < len; i++) {
	          changedTouch = ref1[i];
	          results.push(_this.touchDown(changedTouch.identifier, _this._domEventLocation(changedTouch), timeStampToPerformanceSecond(e.timeStamp)));
	        }
	        return results;
	      };
	    })(this));
	    this._domListener(this._canvas, "touchmove", (function(_this) {
	      return function(e) {
	        var changedTouch, i, len, ref1, results;
	        e.preventDefault();
	        ref1 = e.changedTouches;
	        results = [];
	        for (i = 0, len = ref1.length; i < len; i++) {
	          changedTouch = ref1[i];
	          results.push(_this.pointerEventManager.pointerMove(changedTouch.identifier, _this._domEventLocation(changedTouch), timeStampToPerformanceSecond(e.timeStamp)));
	        }
	        return results;
	      };
	    })(this));
	    this._domListener(this._canvas, "touchend", (function(_this) {
	      return function(e) {
	        var changedTouch, i, len, ref1, results;
	        e.preventDefault();
	        ref1 = e.changedTouches;
	        results = [];
	        for (i = 0, len = ref1.length; i < len; i++) {
	          changedTouch = ref1[i];
	          results.push(_this.touchUp(changedTouch.identifier, _this._domEventLocation(changedTouch), timeStampToPerformanceSecond(e.timeStamp)));
	        }
	        return results;
	      };
	    })(this));
	    return this._domListener(this._canvas, "touchcancel", (function(_this) {
	      return function(e) {
	        var changedTouch, i, len, ref1, results;
	        e.preventDefault();
	        ref1 = e.changedTouches;
	        results = [];
	        for (i = 0, len = ref1.length; i < len; i++) {
	          changedTouch = ref1[i];
	          results.push(_this.touchCancel(changedTouch.identifier, timeStampToPerformanceSecond(e.timeStamp)));
	        }
	        return results;
	      };
	    })(this));
	  };

	  CanvasElement.prototype.queueKeyEvents = function(type, keyboardEvent) {
	    return this.pointerEventManager.queueKeyEvents(type, keyboardEvent);
	  };

	  CanvasElement.prototype.keyDownEvent = function(keyboardEvent) {
	    this.queueKeyEvents("keyDown", keyboardEvent);
	    return this.queueKeyEvents("keyPress", keyboardEvent);
	  };

	  CanvasElement.prototype.keyUpEvent = function(keyboardEvent) {
	    return this.queueKeyEvents("keyUp", keyboardEvent);
	  };

	  CanvasElement.prototype._attachKeypressListeners = function() {
	    this._domListener(this._canvas, "keydown", (function(_this) {
	      return function(keyboardEvent) {
	        _this.keyDownEvent(keyboardEvent);
	        if (keyboardEvent.key === "Backspace") {
	          return keyboardEvent.preventDefault();
	        }
	      };
	    })(this));
	    return this._domListener(this._canvas, "keyup", (function(_this) {
	      return function(keyboardEvent) {
	        return _this.keyUpEvent(keyboardEvent);
	      };
	    })(this));
	  };

	  CanvasElement.prototype._enableHtmlFocusOnCanvas = function() {
	    if (!isMobileBrowser()) {
	      this._canvas.tabIndex = "-1";
	      return this._canvas.contentEditable = true;
	    }
	  };

	  CanvasElement.prototype._attachDomEventListeners = function() {
	    if (this._eventListenersAttached) {
	      return;
	    }
	    this._eventListenersAttached = true;
	    this._enableHtmlFocusOnCanvas();
	    this._attachBlurFocusListeners();
	    this._attachPointerMoveListeners();
	    this._attachPointerTouchListeners();
	    this._attachPointerButtonListeners();
	    this._attachPointerWheelListeners();
	    this._attachResizeListener();
	    return this._attachKeypressListeners();
	  };

	  CanvasElement.prototype.draw = function() {
	    var frameEndTime, frameStartTime;
	    Element.resetStats();
	    frameStartTime = currentSecond();
	    this.firstFrameTime || (this.firstFrameTime = frameStartTime);
	    if (this.lastFrameTime) {
	      this.engineStat.add("fps", 1 / (frameStartTime - this.lastFrameTime));
	      this.engineStat.add("frameTimeMS", (frameStartTime - this.lastFrameTime) * 1000);
	    }
	    this.lastFrameTime = frameStartTime;
	    if (this.canvasBitmap) {
	      CanvasElement.__super__.draw.call(this, this.canvasBitmap, this.elementToParentMatrix);
	    }
	    frameEndTime = currentSecond();
	    return this.engineStat.add("drawTimeMS", (frameEndTime - frameStartTime) * 1000 | 0);
	  };

	  CanvasElement.prototype._showDrawStats = function() {
	    var numSamples;
	    numSamples = this.engineStat.length("drawTimeMS");
	    return timeout(1000, (function(_this) {
	      return function() {
	        var totalDrawDuration;
	        if (numSamples === _this.engineStat.length("drawTimeMS")) {
	          totalDrawDuration = frameEndTime - _this.firstFrameTime;
	          _this.engineStat.log();
	          _this.engineStat.reset();
	          _this.log({
	            cache: {
	              count: Element._activeCacheCount,
	              size: (Element._activeCacheByteSize / (1024 * 1024)).toFixed(1) + "mb"
	            }
	          });
	          _this.firstFrameTime = null;
	          _this.frameCount = 0;
	          return _this.lastFrameTime = null;
	        }
	      };
	    })(this));
	  };

	  return CanvasElement;

	})(Element));


/***/ },
/* 162 */
/***/ function(module, exports) {

	/**
	* Detect Element Resize
	*
	* https://github.com/sdecima/javascript-detect-element-resize
	* Sebastian Decima
	*
	* version: 0.5.3
	**/

	(function () {
		var attachEvent = document.attachEvent,
			stylesCreated = false;
		
		if (!attachEvent) {
			var requestFrame = (function(){
				var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame ||
									function(fn){ return window.setTimeout(fn, 20); };
				return function(fn){ return raf(fn); };
			})();
			
			var cancelFrame = (function(){
				var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame ||
									   window.clearTimeout;
			  return function(id){ return cancel(id); };
			})();

			function resetTriggers(element){
				var triggers = element.__resizeTriggers__,
					expand = triggers.firstElementChild,
					contract = triggers.lastElementChild,
					expandChild = expand.firstElementChild;
				contract.scrollLeft = contract.scrollWidth;
				contract.scrollTop = contract.scrollHeight;
				expandChild.style.width = expand.offsetWidth + 1 + 'px';
				expandChild.style.height = expand.offsetHeight + 1 + 'px';
				expand.scrollLeft = expand.scrollWidth;
				expand.scrollTop = expand.scrollHeight;
			};

			function checkTriggers(element){
				return element.offsetWidth != element.__resizeLast__.width ||
							 element.offsetHeight != element.__resizeLast__.height;
			}
			
			function scrollListener(e){
				var element = this;
				resetTriggers(this);
				if (this.__resizeRAF__) cancelFrame(this.__resizeRAF__);
				this.__resizeRAF__ = requestFrame(function(){
					if (checkTriggers(element)) {
						element.__resizeLast__.width = element.offsetWidth;
						element.__resizeLast__.height = element.offsetHeight;
						element.__resizeListeners__.forEach(function(fn){
							fn.call(element, e);
						});
					}
				});
			};
			
			/* Detect CSS Animations support to detect element display/re-attach */
			var animation = false,
				animationstring = 'animation',
				keyframeprefix = '',
				animationstartevent = 'animationstart',
				domPrefixes = 'Webkit Moz O ms'.split(' '),
				startEvents = 'webkitAnimationStart animationstart oAnimationStart MSAnimationStart'.split(' '),
				pfx  = '';
			{
				var elm = document.createElement('fakeelement');
				if( elm.style.animationName !== undefined ) { animation = true; }    
				
				if( animation === false ) {
					for( var i = 0; i < domPrefixes.length; i++ ) {
						if( elm.style[ domPrefixes[i] + 'AnimationName' ] !== undefined ) {
							pfx = domPrefixes[ i ];
							animationstring = pfx + 'Animation';
							keyframeprefix = '-' + pfx.toLowerCase() + '-';
							animationstartevent = startEvents[ i ];
							animation = true;
							break;
						}
					}
				}
			}
			
			var animationName = 'resizeanim';
			var animationKeyframes = '@' + keyframeprefix + 'keyframes ' + animationName + ' { from { opacity: 0; } to { opacity: 0; } } ';
			var animationStyle = keyframeprefix + 'animation: 1ms ' + animationName + '; ';
		}
		
		function createStyles() {
			if (!stylesCreated) {
				//opacity:0 works around a chrome bug https://code.google.com/p/chromium/issues/detail?id=286360
				var css = (animationKeyframes ? animationKeyframes : '') +
						'.resize-triggers { ' + (animationStyle ? animationStyle : '') + 'visibility: hidden; opacity: 0; } ' +
						'.resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }',
					head = document.head || document.getElementsByTagName('head')[0],
					style = document.createElement('style');
				
				style.type = 'text/css';
				if (style.styleSheet) {
					style.styleSheet.cssText = css;
				} else {
					style.appendChild(document.createTextNode(css));
				}

				head.appendChild(style);
				stylesCreated = true;
			}
		}
		
		window.addResizeListener = function(element, fn){
			if (attachEvent) element.attachEvent('onresize', fn);
			else {
				if (!element.__resizeTriggers__) {
					if (getComputedStyle(element).position == 'static') element.style.position = 'relative';
					createStyles();
					element.__resizeLast__ = {};
					element.__resizeListeners__ = [];
					(element.__resizeTriggers__ = document.createElement('div')).className = 'resize-triggers';
					element.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div>' +
																							'<div class="contract-trigger"></div>';
					element.appendChild(element.__resizeTriggers__);
					resetTriggers(element);
					element.addEventListener('scroll', scrollListener, true);
					
					/* Listen for a css animation to detect element display/re-attach */
					animationstartevent && element.__resizeTriggers__.addEventListener(animationstartevent, function(e) {
						if(e.animationName == animationName)
							resetTriggers(element);
					});
				}
				element.__resizeListeners__.push(fn);
			}
		};
		
		window.removeResizeListener = function(element, fn){
			if (attachEvent) element.detachEvent('onresize', fn);
			else {
				element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);
				if (!element.__resizeListeners__.length) {
						element.removeEventListener('scroll', scrollListener);
						element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
				}
			}
		}
	})();

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(164).addModules({
	  GestureRecognizer: __webpack_require__(165),
	  KeyEvent: __webpack_require__(167),
	  PointerEventManager: __webpack_require__(182),
	  PointerEvent: __webpack_require__(183),
	  Pointer: __webpack_require__(166)
	});


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var Engine, Events,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Engine = __webpack_require__(154);

	module.exports = Engine.Events || Engine.addNamespace('Events', Events = (function(superClass) {
	  extend(Events, superClass);

	  function Events() {
	    return Events.__super__.constructor.apply(this, arguments);
	  }

	  return Events;

	})(Neptune.Base));


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(125), __webpack_require__(166)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Foundation, Atomic, Pointer) {
	  var BaseObject, GestureRecognizer, abs, clone, first, inspect, isFunction, isPlainObject, matrix, objectWithout, peek, point, pointerDeadZone, pointerDeadZoneSquared, rect, select;
	  inspect = Foundation.inspect, clone = Foundation.clone, peek = Foundation.peek, first = Foundation.first, BaseObject = Foundation.BaseObject, isPlainObject = Foundation.isPlainObject, clone = Foundation.clone, abs = Foundation.abs, isFunction = Foundation.isFunction, select = Foundation.select, objectWithout = Foundation.objectWithout;
	  point = Atomic.point, rect = Atomic.rect, matrix = Atomic.matrix;
	  pointerDeadZone = Pointer.pointerDeadZone;
	  pointerDeadZoneSquared = pointerDeadZone * pointerDeadZone;
	  return GestureRecognizer = (function(superClass) {
	    var pointerHandlers;

	    extend(GestureRecognizer, superClass);

	    GestureRecognizer.createGestureRecognizer = function(o) {
	      var gr;
	      gr = new GestureRecognizer(o);
	      return gr.getPointerHandlers();
	    };

	    pointerHandlers = ["pointerDown", "pointerUp", "pointerMove", "pointerCancel"];

	    function GestureRecognizer(gestureRecognizers) {
	      this._nonGestureHandlers = select(gestureRecognizers, pointerHandlers);
	      this._gestureRecognizers = objectWithout(gestureRecognizers, pointerHandlers);
	      this._activeGesture = null;
	      this._lastActiveGesture = null;
	      this._startEvent = null;
	      GestureRecognizer.__super__.constructor.apply(this, arguments);
	      this.setupDefaultRecognizers();
	      this._startEvent = null;
	    }

	    GestureRecognizer.prototype.setupDefaultRecognizers = function() {
	      var k, ref, results, v;
	      ref = this._gestureRecognizers;
	      results = [];
	      for (k in ref) {
	        v = ref[k];
	        switch (k) {
	          case "horizontal":
	            results.push(v.recognize || (v.recognize = function(e) {
	              var d;
	              d = e.delta;
	              return abs(d.y) < abs(d.x);
	            }));
	            break;
	          case "vertical":
	            results.push(v.recognize || (v.recognize = function(e) {
	              var d;
	              d = e.delta;
	              return abs(d.y) > abs(d.x);
	            }));
	            break;
	          default:
	            if (!isFunction(v.recognize)) {
	              throw new Error("'recognize' function required for recognizer '" + k + "'");
	            } else {
	              results.push(void 0);
	            }
	        }
	      }
	      return results;
	    };

	    GestureRecognizer.getter({
	      pointerHandlers: function() {
	        return {
	          pointerDown: (function(_this) {
	            return function(e) {
	              var base, ref;
	              if (typeof (base = _this._nonGestureHandlers).pointerDown === "function") {
	                base.pointerDown(e);
	              }
	              _this._startEvent = e.newEvent ? e.newEvent() : clone(e);
	              if ((ref = _this._lastActiveGesture) != null ? typeof ref.resume === "function" ? ref.resume(e) : void 0 : void 0) {
	                return _this._resumeGesture(e);
	              }
	            };
	          })(this),
	          pointerMove: (function(_this) {
	            return function(e) {
	              var ag, base, base1;
	              if (ag = _this._activeGesture) {
	                return typeof ag.move === "function" ? ag.move(e) : void 0;
	              } else {
	                if (_this._startEvent && !e.pointer.stayedWithinDeadzone) {
	                  _this._startGesture(e);
	                  return typeof (base = _this._nonGestureHandlers).pointerCancel === "function" ? base.pointerCancel(e) : void 0;
	                } else {
	                  return typeof (base1 = _this._nonGestureHandlers).pointerMove === "function" ? base1.pointerMove(e) : void 0;
	                }
	              }
	            };
	          })(this),
	          pointerUp: (function(_this) {
	            return function(e) {
	              var base, base1;
	              if (_this._activeGesture) {
	                if (typeof (base = _this._activeGesture).end === "function") {
	                  base.end(e);
	                }
	                return _this._activeGesture = null;
	              } else {
	                return typeof (base1 = _this._nonGestureHandlers).pointerUp === "function" ? base1.pointerUp(e) : void 0;
	              }
	            };
	          })(this),
	          pointerCancel: (function(_this) {
	            return function(e) {
	              var base, base1;
	              if (_this._activeGesture) {
	                if (typeof (base = _this._activeGesture).cancel === "function") {
	                  base.cancel(e);
	                }
	                _this._activeGesture = null;
	              } else {
	                if (typeof (base1 = _this._nonGestureHandlers).pointerCancel === "function") {
	                  base1.pointerCancel(e);
	                }
	              }
	              return _this._startEvent = null;
	            };
	          })(this)
	        };
	      }
	    });

	    GestureRecognizer.prototype._resumeGesture = function(e) {
	      var base, ref;
	      if ((ref = e.target) != null) {
	        if (typeof ref.capturePointerEvents === "function") {
	          ref.capturePointerEvents();
	        }
	      }
	      this._activeGesture = this._lastActiveGesture;
	      return typeof (base = this._activeGesture).begin === "function" ? base.begin(this._startEvent) : void 0;
	    };

	    GestureRecognizer.prototype._startGesture = function(e) {
	      var base, base1, k, ref, ref1, v;
	      ref = this._gestureRecognizers;
	      for (k in ref) {
	        v = ref[k];
	        if (v.recognize(e)) {
	          this._lastActiveGesture = this._activeGesture = v;
	          break;
	        }
	      }
	      if (this._activeGesture) {
	        if ((ref1 = e.target) != null) {
	          if (typeof ref1.capturePointerEvents === "function") {
	            ref1.capturePointerEvents();
	          }
	        }
	        if (typeof (base = this._activeGesture).begin === "function") {
	          base.begin(this._startEvent);
	        }
	        return typeof (base1 = this._activeGesture).move === "function" ? base1.move(e) : void 0;
	      } else {
	        return this._startEvent = null;
	      }
	    };

	    return GestureRecognizer;

	  })(BaseObject);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(125)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Foundation, Atomic) {
	  var BaseObject, Pointer, clone, first, inspect, matrix, peek, point, rect;
	  inspect = Foundation.inspect, clone = Foundation.clone, peek = Foundation.peek, first = Foundation.first, BaseObject = Foundation.BaseObject;
	  point = Atomic.point, rect = Atomic.rect, matrix = Atomic.matrix;
	  return Pointer = (function(superClass) {
	    var emptyObject, pointerDeadZone, pointerDeadZoneSquared;

	    extend(Pointer, superClass);

	    Pointer.pointerDeadZone = pointerDeadZone = 10;

	    Pointer.pointerDeadZoneSquared = pointerDeadZoneSquared = pointerDeadZone * pointerDeadZone;

	    function Pointer(id, location, lastLocation, firstLocation, stayedWithinDeadzone) {
	      if (stayedWithinDeadzone == null) {
	        stayedWithinDeadzone = true;
	      }
	      this.id = id;
	      this.location = location;
	      this.lastLocation = lastLocation || location;
	      this.firstLocation = firstLocation || location;
	      this.stayedWithinDeadzone = stayedWithinDeadzone;
	    }

	    emptyObject = {};

	    Pointer.prototype.newPointer = function(options) {
	      if (options == null) {
	        options = emptyObject;
	      }
	      return new Pointer(options.id || this.id, options.location || this.location, options.lastLocation || this.lastLocation, options.firstLocation || this.firstLocation, options.stayedWithinDeadzone || this.stayedWithinDeadzone);
	    };

	    Pointer.prototype.moved = function(newLocation) {
	      var stayedWithinDeadzone;
	      stayedWithinDeadzone = this.stayedWithinDeadzone && newLocation.distanceSquared(this.firstLocation) <= pointerDeadZoneSquared;
	      return new Pointer(this.id, newLocation, this.location, this.firstLocation, stayedWithinDeadzone);
	    };

	    Pointer.prototype.locationIn = function(element) {
	      if (element) {
	        return element.absToElementMatrix.transform(this.location);
	      } else {
	        return this.location;
	      }
	    };

	    Pointer.prototype.lastLocationIn = function(element) {
	      if (element) {
	        return element.absToElementMatrix.transform(this.lastLocation);
	      } else {
	        return this.lastLocation;
	      }
	    };

	    Pointer.prototype.firstLocationIn = function(element) {
	      if (element) {
	        return element.absToElementMatrix.transform(this.firstLocation);
	      } else {
	        return this.firstLocation;
	      }
	    };

	    Pointer.prototype.deltaIn = function(element) {
	      if (element) {
	        return element.absToElementMatrix.transformDifference(this.location, this.lastLocation);
	      } else {
	        return this.location.sub(this.lastLocation);
	      }
	    };

	    Pointer.prototype.totalDeltaIn = function(element) {
	      if (element) {
	        return element.absToElementMatrix.transformDifference(this.location, this.firstLocation);
	      } else {
	        return this.location.sub(this.firstLocation);
	      }
	    };

	    return Pointer;

	  })(BaseObject);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var Events, Foundation, KeyEvent, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Events = __webpack_require__(168);


	/*
	KeyboardEvent Polyfill

	We are using the upcoming (as-of-2016) "DOM Keyboard Level 3 Events".
	Info:
	  https://w3c.github.io/uievents/#interface-KeyboardEvent
	  https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent

	This polyfill helps the "key" value of KeyboardEvents be populated consistently across browsers.

	Current browser support: http://caniuse.com/#search=keyboardevent.key
	Alternative polyfill: https://github.com/termi/DOM-Keyboard-Event-Level-3-polyfill
	  (not using because it hasn't been touchedin 3 years and is complex)
	 */

	__webpack_require__(181).polyfill();

	log = Foundation.log;

	module.exports = KeyEvent = (function(superClass) {
	  extend(KeyEvent, superClass);

	  function KeyEvent(type, _keyboardEvent) {
	    this._keyboardEvent = _keyboardEvent;
	    KeyEvent.__super__.constructor.call(this, type, {
	      key: this._keyboardEvent.key,
	      altKey: this._keyboardEvent.altKey,
	      ctrlKey: this._keyboardEvent.ctrlKey,
	      shiftKey: this._keyboardEvent.shiftKey,
	      metaKey: this._keyboardEvent.metaKey
	    });
	  }

	  return KeyEvent;

	})(Events.Event);


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(169);


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(170).includeInNamespace(__webpack_require__(172)).addModules({
	  Event: __webpack_require__(174),
	  EventedBaseMixin: __webpack_require__(175),
	  EventedMixin: __webpack_require__(177),
	  EventedObject: __webpack_require__(179),
	  EventedObjectBase: __webpack_require__(180),
	  EventEpoch: __webpack_require__(176),
	  EventManager: __webpack_require__(178)
	});


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Events,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(171);

	module.exports = Art.Events || Art.addNamespace('Events', Events = (function(superClass) {
	  extend(Events, superClass);

	  function Events() {
	    return Events.__super__.constructor.apply(this, arguments);
	  }

	  return Events;

	})(Neptune.Base));


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var _package;

	module.exports = [
	  {
	    "package": _package = __webpack_require__(173),
	    version: _package.version
	  }
	];


/***/ },
/* 173 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-foundation": "git://github.com/imikimi/art-foundation.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.4.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"license": "ISC",
		"name": "art-events",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "1.1.1"
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Event, Foundation, currentSecond, emptyProps,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	currentSecond = Foundation.currentSecond, BaseObject = Foundation.BaseObject;

	emptyProps = {};

	module.exports = Event = (function(superClass) {
	  extend(Event, superClass);

	  function Event(type, props, timeStamp) {
	    this.type = type;
	    this.props = props != null ? props : emptyProps;
	    this.timeStamp = timeStamp != null ? timeStamp : currentSecond();
	  }

	  return Event;

	})(BaseObject);


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Event, EventEpoch, Foundation, defineModule, eventEpoch, inspect, isFunction, isPlainObject, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	EventEpoch = __webpack_require__(176);

	Event = __webpack_require__(174);

	defineModule = Foundation.defineModule, isFunction = Foundation.isFunction, log = Foundation.log, isPlainObject = Foundation.isPlainObject, inspect = Foundation.inspect;

	eventEpoch = EventEpoch.eventEpoch;


	/*
	to be used as a mixin via BaseObject's @include method

	If this class is included directly, you must also implement the methods
	  listed in "TO IMPLEMENT" below.
	 */

	defineModule(module, function() {
	  return function(superClass) {
	    var EventedBaseMixin;
	    return EventedBaseMixin = (function(superClass1) {
	      var typeFromEventOrType;

	      extend(EventedBaseMixin, superClass1);

	      function EventedBaseMixin() {
	        return EventedBaseMixin.__super__.constructor.apply(this, arguments);
	      }

	      EventedBaseMixin.typeFromEventOrType = typeFromEventOrType = function(eventOrType) {
	        return eventOrType && (eventOrType.type || eventOrType);
	      };


	      /*
	      Purpose:
	        handle event immediately
	        do some preprocessing on the event
	      
	      Inputs: see #event()'s inputs
	      
	      Output: true if the event was actually handled
	      
	      IMPORTANT: This should only be called during an eventEpoch.
	        This means:
	          Usually, just don't call this directly. Use @queueEvent.
	          If you need to call this directly, only do it from within an event handler.
	        Examples reasons to call directly:
	          - to do custom event routing
	          - send a new event triggered from the first
	       */

	      EventedBaseMixin.prototype.handleEvent = function(eventOrType, eventPropertiesOrCreator) {
	        var e, event, eventType;
	        eventType = typeFromEventOrType(eventOrType);
	        if (!(eventType && this._hasEventHandler(eventType))) {
	          return false;
	        }
	        event = eventOrType instanceof Event ? eventOrType : isFunction(eventPropertiesOrCreator) ? isPlainObject(e = eventPropertiesOrCreator()) ? new Event(eventType, e) : e : new Event(eventType, eventPropertiesOrCreator);
	        if (!event) {
	          return false;
	        }
	        event.target = this;
	        try {
	          this._sendToEventHandler(event);
	        } catch (error1) {
	          e = error1;
	          this._handleErrorInHandler(event, "unknown", e);
	        }
	        event.target = null;
	        return true;
	      };


	      /*
	      Inputs:
	        eventOrType can be:
	         * an instanceof Event or
	         * a string representing the "type" of the event
	            (a new Event will be created)
	      
	        eventPropertiesOrCreator can be:
	         * null: only if eventOrType is an instanceof Event
	         * Object: properties passed into: new Event eventOrType, eventPropertiesOrCreator
	         * Function: returns null (indicating a noop) or a new instanceof Event
	      
	      Output:
	        true:   The event was queued.
	        false:  There is no handler for the event. The event was ignored (discarded).
	       */

	      EventedBaseMixin.prototype.queueEvent = function(eventOrType, eventPropertiesOrCreator) {
	        var eventType;
	        eventType = typeFromEventOrType(eventOrType);
	        if (eventType && this._hasEventHandler(eventType)) {
	          eventEpoch.queue((function(_this) {
	            return function() {
	              return _this.handleEvent(eventOrType, eventPropertiesOrCreator);
	            };
	          })(this));
	          return true;
	        } else {
	          return false;
	        }
	      };


	      /*
	      inputs: eventType is a string
	      outputs: true if there is a handler for the specified type
	       */

	      EventedBaseMixin.prototype._hasEventHandler = function(eventType) {
	        throw new Error("must implement");
	      };


	      /*
	      inputs: an Event object with event.target set to @
	      output: ignored
	      
	      - Called exclusively from handleEvent. Don't call manually.
	      - This is where the event handler is actually called.
	      - Only called during an eventEpoch.
	      - Only called if @_hasEventHandler returned true for event.type
	       */

	      EventedBaseMixin.prototype._sendToEventHandler = function(event) {
	        throw new Error("must implement");
	      };

	      EventedBaseMixin.prototype._handleErrorInHandler = function(event, handler, error) {
	        console.log("EventedObjectBase: exception in handler. Error:", error);
	        console.log("Event: " + (inspect(event, 1)));
	        console.log("Handler:", handler);
	        console.log("Stack:", error.stack);
	        return Foundation.throwErrorOutOfStack(error);
	      };

	      return EventedBaseMixin;

	    })(superClass);
	  };
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Epoch, EventEpoch, Foundation, defineModule, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	defineModule = Foundation.defineModule, log = Foundation.log, Epoch = Foundation.Epoch;

	defineModule(module, EventEpoch = (function(superClass) {
	  extend(EventEpoch, superClass);

	  function EventEpoch() {
	    return EventEpoch.__super__.constructor.apply(this, arguments);
	  }

	  EventEpoch.singletonClass();

	  EventEpoch.prototype.queue = function(event) {
	    return this.queueItem(event);
	  };

	  EventEpoch.prototype.logEvent = function(name, id) {};

	  return EventEpoch;

	})(Epoch));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Event, EventEpoch, EventManager, EventedBaseMixin, Foundation, defineModule, eventEpoch, isFunction, isPlainObject, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	EventManager = __webpack_require__(178);

	EventEpoch = __webpack_require__(176);

	Event = __webpack_require__(174);

	EventedBaseMixin = __webpack_require__(175);

	defineModule = Foundation.defineModule, isFunction = Foundation.isFunction, log = Foundation.log, isPlainObject = Foundation.isPlainObject;

	eventEpoch = EventEpoch.eventEpoch;

	defineModule(module, function() {
	  return function(superClass) {
	    var EventedMixin;
	    return EventedMixin = (function(superClass1) {
	      extend(EventedMixin, superClass1);

	      function EventedMixin() {
	        return EventedMixin.__super__.constructor.apply(this, arguments);
	      }


	      /*
	      optional: call from your constructor to make your object more efficient
	      Explanation: Most optimized javascript engines like objects that declare all their fields
	        in the same order every time. In practice, this means do it in the constructor w/o conditionals.
	       */

	      EventedMixin.prototype.initEventHandling = function() {
	        return this.eventManager = null;
	      };

	      EventedMixin.prototype._sendToEventHandler = function(event) {
	        return this.eventManager.handleEvent(event);
	      };

	      EventedMixin.prototype._hasEventHandler = function(eventType) {
	        var ref;
	        return (ref = this.eventManager) != null ? ref.hasHandler(eventType) : void 0;
	      };

	      EventedMixin.prototype.clearEventHandlers = function() {
	        return this.eventManager = null;
	      };

	      EventedMixin.prototype.removeListeners = function(handlerMap) {
	        var ref;
	        return (ref = this.eventManager) != null ? ref.removeListeners(handlerMap) : void 0;
	      };

	      EventedMixin.prototype.preprocessEventHandlers = function(handlerMap) {
	        return handlerMap;
	      };

	      EventedMixin.prototype.on = function(handlerMap) {
	        (this.eventManager || (this.eventManager = new EventManager(this))).on(handlerMap);
	        return this.preprocessEventHandlers(handlerMap);
	      };

	      EventedMixin.prototype.onNext = function(handlerMap) {
	        return (this.eventManager || (this.eventManager = new EventManager(this))).onNext(handlerMap);
	      };

	      return EventedMixin;

	    })(EventedBaseMixin(superClass));
	  };
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {
	/*

	TODO:
	  handlEvent alternate signature:
	    (type, functionReturningEventElement) ->

	  The function would only be invoked if there are actually event handlers for the specified type.
	 */
	var Event, EventManager, Foundation, arrayWith, clone, defineModule, inspect, isFunction, nextTick, rawErrorLog,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Event = __webpack_require__(174);

	defineModule = Foundation.defineModule, nextTick = Foundation.nextTick, isFunction = Foundation.isFunction, inspect = Foundation.inspect, clone = Foundation.clone, arrayWith = Foundation.arrayWith;

	rawErrorLog = Foundation.Log.rawErrorLog;

	defineModule(module, EventManager = (function(superClass) {
	  extend(EventManager, superClass);

	  function EventManager(parent) {
	    this.parent = parent;
	    this.eventHandlers = {};
	  }

	  EventManager.prototype.hasHandler = function(type) {
	    var handlers;
	    return !!((handlers = this.eventHandlers[type]) && handlers.length > 0);
	  };

	  EventManager.prototype.on = function(handlerMap) {
	    var action, results, type;
	    results = [];
	    for (type in handlerMap) {
	      action = handlerMap[type];
	      if (!(action)) {
	        continue;
	      }
	      if (!isFunction(action)) {
	        throw new Error("EventManager: action is not a function for " + (inspect(type)) + " event handler. (action: " + (inspect(action)) + ", parent: " + (inspect(this.parent)) + ")");
	      }
	      results.push(this.eventHandlers[type] = arrayWith(this.eventHandlers[type], {
	        action: action,
	        oneTime: false
	      }));
	    }
	    return results;
	  };

	  EventManager.prototype.removeListeners = function(handlerMap) {
	    var action, beforeCount, count, handler, handlers, type;
	    count = 0;
	    for (type in handlerMap) {
	      action = handlerMap[type];
	      if (!(handlers = this.eventHandlers[type])) {
	        continue;
	      }
	      beforeCount = handlers.length;
	      this.eventHandlers[type] = (function() {
	        var i, len, results;
	        results = [];
	        for (i = 0, len = handlers.length; i < len; i++) {
	          handler = handlers[i];
	          if (handler.action !== action) {
	            results.push(handler);
	          }
	        }
	        return results;
	      })();
	      count = beforeCount - this.eventHandlers[type].length;
	    }
	    return count;
	  };

	  EventManager.prototype.onNext = function(handlerMap) {
	    var action, base, results, type;
	    results = [];
	    for (type in handlerMap) {
	      action = handlerMap[type];
	      if ((base = this.eventHandlers)[type] == null) {
	        base[type] = [];
	      }
	      results.push(this.eventHandlers[type].push({
	        action: action,
	        oneTime: true
	      }));
	    }
	    return results;
	  };

	  EventManager.prototype.countOneTimeHandlersFor = function(eventType) {
	    var count, handler, handlers, i, len;
	    count = 0;
	    if (handlers = this.eventHandlers[eventType]) {
	      for (i = 0, len = handlers.length; i < len; i++) {
	        handler = handlers[i];
	        if (handler.oneTime) {
	          count++;
	        }
	      }
	    }
	    return count;
	  };

	  EventManager.prototype.handleEvent = function(event) {
	    if (typeof event === "string") {
	      event = new Event(event);
	    }
	    return this.sendToHandlers(event.type, event);
	  };

	  EventManager.prototype.handleEvents = function(events) {
	    var event, i, len, results;
	    results = [];
	    for (i = 0, len = events.length; i < len; i++) {
	      event = events[i];
	      results.push(this.handleEvent(event));
	    }
	    return results;
	  };

	  EventManager.prototype.sendToHandlers = function(eventType, event) {
	    var action, error, firedOneTimeHandler, handler, handlers, i, len;
	    handlers = this.eventHandlers[eventType];
	    if (!(handlers && handlers.length > 0)) {
	      return;
	    }
	    firedOneTimeHandler = false;
	    for (i = 0, len = handlers.length; i < len; i++) {
	      handler = handlers[i];
	      try {
	        if (handler.oneTime) {
	          handler.remove = firedOneTimeHandler = true;
	        }
	        action = handler.action;
	        action(event);
	      } catch (error1) {
	        error = error1;
	        this.handleErrorInHandler(handler, event, error);
	      }
	    }
	    if (firedOneTimeHandler) {
	      return this.eventHandlers[event.type] = (function() {
	        var j, len1, ref, results;
	        ref = this.eventHandlers[eventType];
	        results = [];
	        for (j = 0, len1 = ref.length; j < len1; j++) {
	          handler = ref[j];
	          if (!handler.remove) {
	            results.push(handler);
	          }
	        }
	        return results;
	      }).call(this);
	    }
	  };

	  EventManager.prototype.handleErrorInHandler = function(handler, event, error) {
	    if (event.type === "eventException") {
	      rawErrorLog("exception in eventException handler.\nEvent:" + (inspect(event, 1)) + ".\n\nError:\n" + error.stack);
	      return Foundation.throwErrorOutOfStack(error);
	    } else if (this.eventHandlers["eventException"]) {
	      return this.handleEvent(new Event("eventException", {
	        event: clone(event),
	        exception: error,
	        handler: handler
	      }));
	    } else {
	      rawErrorLog("exception in handler AND no eventException handler. Error:");
	      rawErrorLog(error);
	      rawErrorLog("Event: " + (inspect(event, 1)));
	      rawErrorLog("Stack:\n" + error.stack);
	      return Foundation.throwErrorOutOfStack(error);
	    }
	  };

	  return EventManager;

	})(Foundation.BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Event, EventEpoch, EventManager, EventedObject, EventedObjectBase, Foundation, defineModule, eventEpoch, isFunction, isPlainObject, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	EventManager = __webpack_require__(178);

	EventEpoch = __webpack_require__(176);

	Event = __webpack_require__(174);

	EventedObjectBase = __webpack_require__(180);

	defineModule = Foundation.defineModule, isFunction = Foundation.isFunction, log = Foundation.log, isPlainObject = Foundation.isPlainObject;

	eventEpoch = EventEpoch.eventEpoch;

	defineModule(module, EventedObject = (function(superClass) {
	  extend(EventedObject, superClass);

	  function EventedObject() {
	    return EventedObject.__super__.constructor.apply(this, arguments);
	  }


	  /*
	  optional: call from your constructor to make your object more efficient
	  Explanation: Most optimized javascript engines like objects that declare all their fields
	    in the same order every time. In practice, this means do it in the constructor w/o conditionals.
	   */

	  EventedObject.prototype.initEventHandling = function() {
	    return this.eventManager = null;
	  };

	  EventedObject.prototype._sendToEventHandler = function(event) {
	    return this.eventManager.handleEvent(event);
	  };

	  EventedObject.prototype._hasEventHandler = function(eventType) {
	    var ref;
	    return (ref = this.eventManager) != null ? ref.hasHandler(eventType) : void 0;
	  };

	  EventedObject.prototype.clearEventHandlers = function() {
	    return this.eventManager = null;
	  };

	  EventedObject.prototype.removeListeners = function(handlerMap) {
	    var ref;
	    return (ref = this.eventManager) != null ? ref.removeListeners(handlerMap) : void 0;
	  };

	  EventedObject.prototype.preprocessEventHandlers = function(handlerMap) {
	    return handlerMap;
	  };

	  EventedObject.prototype.on = function(handlerMap) {
	    (this.eventManager || (this.eventManager = new EventManager(this))).on(handlerMap);
	    return this.preprocessEventHandlers(handlerMap);
	  };

	  EventedObject.prototype.onNext = function(handlerMap) {
	    return (this.eventManager || (this.eventManager = new EventManager(this))).onNext(handlerMap);
	  };

	  return EventedObject;

	})(EventedObjectBase));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Event, EventEpoch, EventedObjectBase, Foundation, defineModule, eventEpoch, inspect, isFunction, isPlainObject, log;

	Foundation = __webpack_require__(19);

	EventEpoch = __webpack_require__(176);

	Event = __webpack_require__(174);

	defineModule = Foundation.defineModule, isFunction = Foundation.isFunction, log = Foundation.log, isPlainObject = Foundation.isPlainObject, inspect = Foundation.inspect;

	eventEpoch = EventEpoch.eventEpoch;


	/*
	to be used as a mixin via BaseObject's @include method

	If this class is included directly, you must also implement the methods
	  listed in "TO IMPLEMENT" below.
	 */

	defineModule(module, EventedObjectBase = (function() {
	  var typeFromEventOrType;

	  function EventedObjectBase() {}

	  EventedObjectBase.typeFromEventOrType = typeFromEventOrType = function(eventOrType) {
	    return eventOrType && (eventOrType.type || eventOrType);
	  };


	  /*
	  Purpose:
	    handle event immediately
	    do some preprocessing on the event
	  
	  Inputs: see #event()'s inputs
	  
	  Output: true if the event was actually handled
	  
	  IMPORTANT: This should only be called during an eventEpoch.
	    This means:
	      Usually, just don't call this directly. Use @queueEvent.
	      If you need to call this directly, only do it from within an event handler.
	    Examples reasons to call directly:
	      - to do custom event routing
	      - send a new event triggered from the first
	   */

	  EventedObjectBase.prototype.handleEvent = function(eventOrType, eventPropertiesOrCreator) {
	    var e, event, eventType;
	    eventType = typeFromEventOrType(eventOrType);
	    if (!(eventType && this._hasEventHandler(eventType))) {
	      return false;
	    }
	    event = eventOrType instanceof Event ? eventOrType : isFunction(eventPropertiesOrCreator) ? isPlainObject(e = eventPropertiesOrCreator()) ? new Event(eventType, e) : e : new Event(eventType, eventPropertiesOrCreator);
	    if (!event) {
	      return false;
	    }
	    event.target = this;
	    try {
	      this._sendToEventHandler(event);
	    } catch (error1) {
	      e = error1;
	      this._handleErrorInHandler(event, "unknown", e);
	    }
	    event.target = null;
	    return true;
	  };


	  /*
	  Inputs:
	    eventOrType can be:
	     * an instanceof Event or
	     * a string representing the "type" of the event
	        (a new Event will be created)
	  
	    eventPropertiesOrCreator can be:
	     * null: only if eventOrType is an instanceof Event
	     * Object: properties passed into: new Event eventOrType, eventPropertiesOrCreator
	     * Function: returns null (indicating a noop) or a new instanceof Event
	  
	  Output:
	    true:   The event was queued.
	    false:  There is no handler for the event. The event was ignored (discarded).
	   */

	  EventedObjectBase.prototype.queueEvent = function(eventOrType, eventPropertiesOrCreator) {
	    var eventType;
	    eventType = typeFromEventOrType(eventOrType);
	    if (eventType && this._hasEventHandler(eventType)) {
	      eventEpoch.queue((function(_this) {
	        return function() {
	          return _this.handleEvent(eventOrType, eventPropertiesOrCreator);
	        };
	      })(this));
	      return true;
	    } else {
	      return false;
	    }
	  };


	  /*
	  inputs: eventType is a string
	  outputs: true if there is a handler for the specified type
	   */

	  EventedObjectBase.prototype._hasEventHandler = function(eventType) {
	    throw new Error("must implement");
	  };


	  /*
	  inputs: an Event object with event.target set to @
	  output: ignored
	  
	  - Called exclusively from handleEvent. Don't call manually.
	  - This is where the event handler is actually called.
	  - Only called during an eventEpoch.
	  - Only called if @_hasEventHandler returned true for event.type
	   */

	  EventedObjectBase.prototype._sendToEventHandler = function(event) {
	    throw new Error("must implement");
	  };

	  EventedObjectBase.prototype._handleErrorInHandler = function(event, handler, error) {
	    console.log("EventedObjectBase: exception in handler. Error:", error);
	    console.log("Event: " + (inspect(event, 1)));
	    console.log("Handler:", handler);
	    console.log("Stack:", error.stack);
	    return Foundation.throwErrorOutOfStack(error);
	  };

	  return EventedObjectBase;

	})());

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global define, KeyboardEvent, module */

	(function () {

	  var keyboardeventKeyPolyfill = {
	    polyfill: polyfill,
	    keys: {
	      3: 'Cancel',
	      6: 'Help',
	      8: 'Backspace',
	      9: 'Tab',
	      12: 'Clear',
	      13: 'Enter',
	      16: 'Shift',
	      17: 'Control',
	      18: 'Alt',
	      19: 'Pause',
	      20: 'CapsLock',
	      27: 'Escape',
	      28: 'Convert',
	      29: 'NonConvert',
	      30: 'Accept',
	      31: 'ModeChange',
	      32: ' ',
	      33: 'PageUp',
	      34: 'PageDown',
	      35: 'End',
	      36: 'Home',
	      37: 'ArrowLeft',
	      38: 'ArrowUp',
	      39: 'ArrowRight',
	      40: 'ArrowDown',
	      41: 'Select',
	      42: 'Print',
	      43: 'Execute',
	      44: 'PrintScreen',
	      45: 'Insert',
	      46: 'Delete',
	      48: ['0', ')'],
	      49: ['1', '!'],
	      50: ['2', '@'],
	      51: ['3', '#'],
	      52: ['4', '$'],
	      53: ['5', '%'],
	      54: ['6', '^'],
	      55: ['7', '&'],
	      56: ['8', '*'],
	      57: ['9', '('],
	      91: 'OS',
	      93: 'ContextMenu',
	      144: 'NumLock',
	      145: 'ScrollLock',
	      181: 'VolumeMute',
	      182: 'VolumeDown',
	      183: 'VolumeUp',
	      186: [';', ':'],
	      187: ['=', '+'],
	      188: [',', '<'],
	      189: ['-', '_'],
	      190: ['.', '>'],
	      191: ['/', '?'],
	      192: ['`', '~'],
	      219: ['[', '{'],
	      220: ['\\', '|'],
	      221: [']', '}'],
	      222: ["'", '"'],
	      224: 'Meta',
	      225: 'AltGraph',
	      246: 'Attn',
	      247: 'CrSel',
	      248: 'ExSel',
	      249: 'EraseEof',
	      250: 'Play',
	      251: 'ZoomOut'
	    }
	  };

	  // Function keys (F1-24).
	  var i;
	  for (i = 1; i < 25; i++) {
	    keyboardeventKeyPolyfill.keys[111 + i] = 'F' + i;
	  }

	  // Printable ASCII characters.
	  var letter = '';
	  for (i = 65; i < 91; i++) {
	    letter = String.fromCharCode(i);
	    keyboardeventKeyPolyfill.keys[i] = [letter.toLowerCase(), letter.toUpperCase()];
	  }

	  function polyfill () {
	    if (!('KeyboardEvent' in window) ||
	        'key' in KeyboardEvent.prototype) {
	      return false;
	    }

	    // Polyfill `key` on `KeyboardEvent`.
	    var proto = {
	      get: function (x) {
	        var key = keyboardeventKeyPolyfill.keys[this.which || this.keyCode];

	        if (Array.isArray(key)) {
	          key = key[+this.shiftKey];
	        }

	        return key;
	      }
	    };
	    Object.defineProperty(KeyboardEvent.prototype, 'key', proto);
	    return proto;
	  }

	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (keyboardeventKeyPolyfill), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
	    module.exports = keyboardeventKeyPolyfill;
	  } else if (window) {
	    window.keyboardeventKeyPolyfill = keyboardeventKeyPolyfill;
	  }

	})();


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	PointerEventManager

	All Event Types:
	  pointerCancel
	  pointerMove
	  pointerUp
	  pointerDown
	  mouseMove
	  mouseIn
	  mouseOut
	  focus
	  blur

	  pointerClick
	  pointerUpInside
	  pointerUpOutside
	  pointerIn
	  pointerOut

	Keyboard events are routed through the PointerEventManager.
	  Keyboard Event types:
	    keyDown
	    keyUp
	    keyPress

	  see KeyEvent for details on the event

	TODO:
	  Rename these events:

	    mouseMove => cursorMove
	    mouseIn   => cursorMoveIn
	    mouseOut  => cursorMoveOut

	DESIGN NOTES
	Purpose:
	  Support Touch and Mouse events.
	  Support a common set of events for the subset of Touch and Mouse semantics that overlap:
	    single-touch / single-mouse-button-down

	  Synthesize events:
	    pointerClick
	      triggered if active-locations went from 0 to non-0 and back to 0 without moving outside the pointerDeadZone
	    pointerUpInside / pointerUpOutside
	      just before the pointerUp event is sent:
	        if pointer is "pointInside" for the target element
	          send pointerUpInside
	        else
	          send pointerUpOutside
	    pointerIn / pointerOut
	      pointer's "pointInside" changed from false>>true for the target element
	        send pointerMovedIn
	      else
	        send pointerMovedOut

	Differences between Touch events and Mouse events
	  Touch Events
	    can have 0 or more "active" locations. Does not have "inactive" locations.
	    locations can be added or removed. A removed location is not "re-added", only "new" locations are added.
	  Mouse Events
	    can have 1 active or 1 "inactive" location
	    the "active" location has state:
	      what mouse buttons are down

	EVENT ORDER
	  Parents get events before children.
	  If a parent captures a pointer during an event, children will NOT see the event.

	TODO
	  updateMousePath should be called anytime Elements are added, removed or any other change that might effect the mousePath

	HOW IT WORKS
	  pointerDown, pointerUp and pointerMove events all happen when a pointer is being ACTIVE:
	    touchs are always "active"
	    mouse is "active" if one or more buttons are down (currently only left button is supported)

	  multi-touch:
	    Each active touch sends its own events. Ex:
	      these sequence of real-world events:
	        index-finger-touch-start
	        middle-finger-touch-start
	        hand-moves-and-so-do-both-fingers
	        remove-all-fingers
	      results in an event sequence like this:
	        touch_down id: 7
	        touch_down id: 3
	        touch_move id: 7
	        touch_move id: 3
	        touch_up   id: 7
	        touch_down id: 3

	      NOTE: the ids are abitrary, but consistent across events for a touch sequence
	      NOTE: Because of this, if you listen to "pointerMove" without inspecting the pointer's id,
	        you might get more move events than you are expecting.

	  mouseMove is sent every time the mouse moves regardless of button status
	    NOTE: mouseMove is never sent on a touch device.

	GUARANTEES
	  All pointer movement will send mouseMove events!
	    This isn't true with the raw DOM events. Mouse-Pointer up/down and touchEnd can all show locations different from the last move event.
	    This means:
	      On desktop, if you are tracking "null" move events (inactive pointer), then you'll be up-to-date with the pointer-location when a click happens.
	      On either desktop or touch devices, if you are tracking move events, the pointer's location won't have changed between the last mouseMove event and the pointerUp event.
	 */
	var Atomic, EventEpoch, Events, Foundation, KeyEvent, Pointer, PointerEvent, PointerEventManager, arrayWithoutValue, clone, eq, eventEpoch, first, inspect, isObject, log, matrix, max, min, peek, point, rect, shallowClone, stableSort,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Atomic = __webpack_require__(125);

	Foundation = __webpack_require__(19);

	Events = __webpack_require__(168);

	Pointer = __webpack_require__(166);

	PointerEvent = __webpack_require__(183);

	KeyEvent = __webpack_require__(167);

	EventEpoch = Events.EventEpoch;

	eventEpoch = EventEpoch.eventEpoch;

	point = Atomic.point, rect = Atomic.rect, matrix = Atomic.matrix;

	inspect = Foundation.inspect, clone = Foundation.clone, shallowClone = Foundation.shallowClone, peek = Foundation.peek, first = Foundation.first, min = Foundation.min, max = Foundation.max, eq = Foundation.eq, arrayWithoutValue = Foundation.arrayWithoutValue, stableSort = Foundation.stableSort, log = Foundation.log, isObject = Foundation.isObject;

	module.exports = PointerEventManager = (function(superClass) {
	  var elementToRootPath, prioritySortElements, rootToElementPath, updatePath;

	  extend(PointerEventManager, superClass);

	  function PointerEventManager(options) {
	    if (options == null) {
	      options = {};
	    }
	    PointerEventManager.__super__.constructor.apply(this, arguments);
	    this.canvasElement = options.canvasElement;
	    this.mouse = new Pointer("mouse", point(-1));
	    this.activePointers = {};
	    this._numActivePointers = 0;
	    this.capturingElement = null;
	    this.currentMousePath = [];
	    this._currentFocusedPath = [this.canvasElement];
	  }

	  PointerEventManager.getter({
	    currentFocusedPath: function() {
	      return this._currentFocusedPath;
	    },
	    numActivePointers: function() {
	      return this._numActivePointers;
	    },
	    hasMouseCursor: function() {
	      return true;
	    },
	    currentMousePathClassNames: function() {
	      var el, j, len, ref, results;
	      ref = this.currentMousePath;
	      results = [];
	      for (j = 0, len = ref.length; j < len; j++) {
	        el = ref[j];
	        results.push(el.classPathName);
	      }
	      return results;
	    }
	  });

	  PointerEventManager.setter({
	    currentFocusedPath: function() {
	      throw new Error("can't set currentFocusedPath directly");
	    }
	  });

	  PointerEventManager.prototype.capturePointerEvents = function(element) {
	    var elementsToCancel, name, pointer, ref;
	    elementsToCancel = arrayWithoutValue(this.currentFocusedPath, element);
	    ref = this.activePointers;
	    for (name in ref) {
	      pointer = ref[name];
	      this.queuePointerEventForElements(elementsToCancel, "pointerCancel", pointer);
	    }
	    return this.capturingElement = element;
	  };

	  PointerEventManager.prototype.pointerEventsCapturedBy = function(element) {
	    return element === this.capturingElement;
	  };

	  PointerEventManager.prototype.pointerElementPath = function(pointer) {
	    var element, newPath, root;
	    root = this.canvasElement;
	    if (!root.pointInside(pointer.location)) {
	      return [];
	    }
	    element = root;
	    newPath = [];
	    while (element) {
	      newPath.push(element);
	      element = element.childUnderPoint(pointer.locationIn(element));
	    }
	    return newPath;
	  };

	  PointerEventManager.prototype.queueEventForElements = function(elements, type, newEventFunction) {
	    var element, j, len, results;
	    results = [];
	    for (j = 0, len = elements.length; j < len; j++) {
	      element = elements[j];
	      results.push(element.queueEvent(type, newEventFunction));
	    }
	    return results;
	  };

	  PointerEventManager.prototype.queuePointerEventForElement = function(element, type, pointer, timeStampInPerformanceSeconds, props) {
	    return element.queueEvent(type, (function(_this) {
	      return function() {
	        if (!_this.capturingElement || type === "pointerCancel" || element === _this.capturingElement) {
	          return new PointerEvent(type, pointer, timeStampInPerformanceSeconds, props);
	        }
	      };
	    })(this));
	  };


	  /*
	  SBD NOTE 2016: This method of sorting priority is global and breaks "parents encapsulate children".
	  Breaking that rule makes Elements/Components less modular. A Component (subranch of the AIM tree) could
	  move within the tree and have its own behavior or the behavior of ancesors change unpredictably.
	  
	  Is there a better way??? We need to better understand the use-cases. Mostly it has to do with gestures.
	  Sometimes we want the child to have a chance to capture a gesture first, if it decides to, and then let
	  the parent have a default gesture if the child declines.
	  
	  Old Idea: allow the parent to invert its own priority. It can set itself to have lower priority than its children.
	    This meets the encapsulation requirement.
	    It does limit us to only putting the parent before all children or after all children for events.
	      Do we need a way to put a parent in the middle of its children event-wise?
	  
	  2016 May Idea: Use a similar system to the one I'm putting in place today for KeyboardEvents:
	    Change pointerEventPriority to be one of:
	      beforeAncestors:
	      beforeDescendents:
	      beforeChildren: (default)
	      afterChildren
	  
	    OR a function which takes: (pointerEventType, pointer) -> and returns one of the above values.
	  
	    If we implement it as a recursive function, it looks like this:
	  
	  
	      add = (index) ->
	  
	      recurse = (startIndexInclusive, endIndexExclusive) ->
	        firstBeforeDescendentsIndex = -1
	        firstBeforeAncestorsIndex = -1
	        lastBeforeAncestorsIndex = -1
	  
	        for i in [startIndexInclusive...endIndexExclusive] by 1
	          priority = elementPriorities[i]
	          switch priority
	            when "beforeDescendents" then firstBeforeDescendentsIndex = i if firstBeforeDescendentsIndex < 0
	            when "beforeAncestors"
	              firstBeforeAncestorsIndex = i if firstBeforeAncestorsIndex < 0
	              lastBeforeAncestorsIndex = i
	  
	        if firstBeforeDescendentsIndex >= 0 && firstBeforeDescendentsIndex < firstBeforeAncestorsIndex
	          recurse startIndexInclusive, firstBeforeDescendentsIndex
	          add firstBeforeDescendentsIndex
	          recurse firstBeforeDescendentsIndex + 1, endIndexExclusive
	  
	        else if lastBeforeAncestorsIndex >= 0
	          add lastBeforeAncestorsIndex
	          recurse lastBeforeAncestorsIndex + 1, endIndexExclusive
	          recurse startIndexInclusive, lastBeforeAncestorsIndex
	  
	        else # none in range are beforeAncestors or beforeDescendents
	          addLast = null
	          for i in [startIndexInclusive...endIndexExclusive] by 1
	            if elementPriorities[i] "afterChildren"
	              if addLast
	                addLast.push i
	              else
	                addLast = [i]
	            else
	              add i
	  
	          add i for i in addLast by -1 if addLast
	   */

	  PointerEventManager.prioritySortElements = prioritySortElements = function(elements) {
	    return stableSort(elements, function(a, b) {
	      return b._pointerEventPriority - a._pointerEventPriority;
	    });
	  };

	  PointerEventManager.sortElementsBaseOnRelationshipPriority = function(elementPriorities) {
	    var add, orderList, recurse;
	    orderList = [];
	    add = function(index) {
	      return orderList.push(index);
	    };
	    recurse = function(startIndexInclusive, endIndexExclusive) {
	      var addLast, firstBeforeAncestorsIndex, firstBeforeDescendentsIndex, i, j, k, l, priority, ref, ref1, ref2, ref3, ref4, ref5, results;
	      if (endIndexExclusive <= startIndexInclusive) {
	        return;
	      }
	      if (startIndexInclusive + 1 === endIndexExclusive) {
	        return add(startIndexInclusive);
	      }
	      firstBeforeDescendentsIndex = endIndexExclusive;
	      firstBeforeAncestorsIndex = endIndexExclusive;
	      for (i = j = ref = endIndexExclusive - 1, ref1 = startIndexInclusive; j >= ref1; i = j += -1) {
	        priority = elementPriorities[i];
	        switch (priority) {
	          case "beforeDescendents":
	            firstBeforeDescendentsIndex = i;
	            break;
	          case "beforeAncestors":
	            if (i > startIndexInclusive) {
	              firstBeforeAncestorsIndex = i;
	            }
	        }
	      }
	      if (firstBeforeDescendentsIndex <= firstBeforeAncestorsIndex) {
	        addLast = false;
	        for (i = k = ref2 = startIndexInclusive, ref3 = firstBeforeDescendentsIndex; k < ref3; i = k += 1) {
	          if (elementPriorities[i] === "afterChildren") {
	            addLast = true;
	          } else {
	            add(i);
	          }
	        }
	        if (firstBeforeDescendentsIndex < endIndexExclusive) {
	          add(firstBeforeDescendentsIndex);
	        }
	        recurse(firstBeforeDescendentsIndex + 1, endIndexExclusive);
	        if (addLast) {
	          results = [];
	          for (i = l = ref4 = firstBeforeDescendentsIndex - 1, ref5 = startIndexInclusive; l >= ref5; i = l += -1) {
	            if (elementPriorities[i] === "afterChildren") {
	              results.push(add(i));
	            } else {
	              results.push(void 0);
	            }
	          }
	          return results;
	        }
	      } else if (firstBeforeAncestorsIndex < endIndexExclusive) {
	        recurse(firstBeforeAncestorsIndex, endIndexExclusive);
	        return recurse(startIndexInclusive, firstBeforeAncestorsIndex);
	      }
	    };
	    recurse(0, elementPriorities.length);
	    return orderList;
	  };

	  PointerEventManager.prototype.queuePointerEventForElements = function(elements, type, pointer, timeStampInPerformanceSeconds, props) {
	    var element, j, len, results;
	    elements = prioritySortElements(elements.slice());
	    results = [];
	    for (j = 0, len = elements.length; j < len; j++) {
	      element = elements[j];
	      results.push(this.queuePointerEventForElement(element, type, pointer, timeStampInPerformanceSeconds, props));
	    }
	    return results;
	  };

	  PointerEventManager.prototype.queuePointerEvents = function(type, pointer, timeStampInPerformanceSeconds) {
	    return this.forEachReceivingElement((function(_this) {
	      return function(e) {
	        return _this.queuePointerEventForElement(e, type, pointer, timeStampInPerformanceSeconds);
	      };
	    })(this));
	  };

	  PointerEventManager.prototype.forEachReceivingElement = function(f) {
	    var e, j, len, ref, results;
	    if (e = this.capturingElement) {
	      return f(e);
	    } else {
	      ref = prioritySortElements(this.currentFocusedPath);
	      results = [];
	      for (j = 0, len = ref.length; j < len; j++) {
	        e = ref[j];
	        results.push(f(e));
	      }
	      return results;
	    }
	  };

	  PointerEventManager.prototype.queueMouseEvents = function(type, pointer, timeStampInPerformanceSeconds, props) {
	    return this.queuePointerEventForElements(this.currentMousePath, type, pointer, timeStampInPerformanceSeconds, props);
	  };


	  /*
	  queueKeyEvents
	  
	  NOTE: @currentFocusedPath is sorted ancestors first.
	  
	  All elements in @currentFocusedPath potentially can receive the event.
	  
	  To generate the exact elementsToSendEventTo list, we need to call
	  @willConsumeKeyboardEvent() on all elements in @currentFocusedPath.
	  
	  Basic:
	    Send the event to each element in @currentFocusedPath in order until one returns "beforeDescendents"
	  Unless:
	    If any return "beforeAncestors", only send the event to the very last one that returns "beforeAncestors"
	   */

	  PointerEventManager.prototype.queueKeyEvents = function(artEngineEventType, keyboardEvent) {
	    var allowBrowserDefault, element, elements, elementsToSendEventTo, i, j, k, lastBeforeParent, len, len1, newEventFunction, order, results, willConsumeEvent;
	    elementsToSendEventTo = elements = this.updateFocusedPath();
	    lastBeforeParent = null;
	    for (i = j = 0, len = elements.length; j < len; i = ++j) {
	      element = elements[i];
	      if (order = willConsumeEvent = element.getWillConsumeKeyboardEvent()(artEngineEventType, keyboardEvent)) {
	        if (isObject(willConsumeEvent)) {
	          order = willConsumeEvent.order, allowBrowserDefault = willConsumeEvent.allowBrowserDefault;
	        }
	        if (!allowBrowserDefault) {
	          keyboardEvent.preventDefault();
	        }
	        switch (order) {
	          case "beforeAncestors":
	            lastBeforeParent = element;
	            break;
	          case "beforeDescendents":
	            if (!lastBeforeParent) {
	              elementsToSendEventTo = elements.slice(0, i + 1);
	              break;
	            }
	        }
	      }
	    }
	    newEventFunction = function() {
	      return new KeyEvent(artEngineEventType, keyboardEvent);
	    };
	    if (lastBeforeParent) {
	      return lastBeforeParent.queueEvent(artEngineEventType, newEventFunction);
	    } else {
	      results = [];
	      for (k = 0, len1 = elementsToSendEventTo.length; k < len1; k++) {
	        element = elementsToSendEventTo[k];
	        results.push(element.queueEvent(artEngineEventType, newEventFunction));
	      }
	      return results;
	    }
	  };

	  PointerEventManager.elementToRootPath = elementToRootPath = function(element) {
	    var path;
	    path = [];
	    while (element) {
	      path.push(element);
	      element = element.parent;
	    }
	    return path;
	  };

	  PointerEventManager.rootToElementPath = rootToElementPath = function(element) {
	    return elementToRootPath(element).reverse();
	  };

	  PointerEventManager.updatePath = updatePath = function(oldPath, newPath, removedElementsAction, addedElementsAction, onAnyChange) {
	    var i, j, maxLen, minLen, ref;
	    minLen = min(oldPath.length, newPath.length);
	    maxLen = max(oldPath.length, newPath.length);
	    for (i = j = 0, ref = minLen; j < ref; i = j += 1) {
	      if (oldPath[i] !== newPath[i]) {
	        removedElementsAction(oldPath.slice(i));
	        addedElementsAction(newPath.slice(i));
	        if (onAnyChange) {
	          onAnyChange(newPath);
	        }
	        return newPath;
	      }
	    }
	    if (minLen === maxLen) {
	      return oldPath;
	    }
	    if (minLen < oldPath.length) {
	      removedElementsAction(oldPath.slice(minLen));
	    }
	    if (minLen < newPath.length) {
	      addedElementsAction(newPath.slice(minLen));
	    }
	    if (onAnyChange && minLen !== maxLen) {
	      onAnyChange(newPath);
	    }
	    return newPath;
	  };

	  PointerEventManager.prototype.updateCursor = function(path) {
	    var c, cursor, el, j, len;
	    cursor = "default";
	    for (j = 0, len = path.length; j < len; j++) {
	      el = path[j];
	      if (c = el.cursor) {
	        cursor = c;
	      }
	    }
	    return this.canvasElement.cssCursor = cursor;
	  };

	  PointerEventManager.prototype.queueOutEvents = function(pointer, elements) {
	    return this.queuePointerEventForElements(elements, "mouseOut", pointer);
	  };

	  PointerEventManager.prototype.queueInEvents = function(pointer, elements) {
	    return this.queuePointerEventForElements(elements, "mouseIn", pointer);
	  };

	  PointerEventManager.prototype.queueBlurEvents = function(pointer, elements) {
	    return this.queuePointerEventForElements(elements, "blur", pointer);
	  };

	  PointerEventManager.prototype.queueFocusEvents = function(pointer, elements) {
	    return this.queuePointerEventForElements(elements, "focus", pointer);
	  };

	  PointerEventManager.prototype.isFocused = function(element) {
	    return this.currentFocusedPath.indexOf(element) >= 0;
	  };

	  PointerEventManager.getter({
	    validatedFocusPath: function() {
	      var element, i, lastElement, path;
	      lastElement = this.canvasElement.parent;
	      path = (function() {
	        var j, len, ref, results;
	        ref = this.currentFocusedPath;
	        results = [];
	        for (i = j = 0, len = ref.length; j < len; i = ++j) {
	          element = ref[i];
	          if (!(element.canvasElement === this.canvasElement && element.parent === lastElement)) {
	            break;
	          }
	          results.push(lastElement = element);
	        }
	        return results;
	      }).call(this);
	      if (path[0] !== this.canvasElement) {
	        return [this.canvasElement];
	      }
	      return path;
	    }
	  });

	  PointerEventManager.prototype.updateFocusedPath = function(pointer, element) {
	    var el, newPath;
	    pointer || (pointer = this.activePointers[0]);
	    newPath = rootToElementPath(element || peek(this.currentFocusedPath));
	    if (newPath[0] !== this.canvasElement) {
	      newPath = this.validatedFocusPath;
	    }
	    this._currentFocusedPath = updatePath(this.currentFocusedPath, newPath, (function(_this) {
	      return function(oldElements) {
	        return _this.queueBlurEvents(pointer, oldElements);
	      };
	    })(this), (function(_this) {
	      return function(newElements) {
	        return _this.queueFocusEvents(pointer, newElements);
	      };
	    })(this));
	    if (this.currentFocusedPath[0] !== this.canvasElement) {
	      log((function() {
	        var j, len, ref, results;
	        ref = this.currentFocusedPath;
	        results = [];
	        for (j = 0, len = ref.length; j < len; j++) {
	          el = ref[j];
	          results.push(el.inspectedName);
	        }
	        return results;
	      }).call(this));
	      throw new Error("root element should be canvas (internal error - it should be impossible for this to happen)");
	    }
	    return this.currentFocusedPath;
	  };

	  PointerEventManager.prototype.focus = function(pointer, element) {
	    return this.updateFocusedPath(pointer, element);
	  };

	  PointerEventManager.prototype.updateMousePath = function() {
	    var pointer;
	    pointer = this.mouse;
	    if (!(this._numActivePointers === 0 && this.getHasMouseCursor())) {
	      return;
	    }
	    return this.currentMousePath = updatePath(this.currentMousePath, this.pointerElementPath(pointer), (function(_this) {
	      return function(oldElements) {
	        return _this.queueOutEvents(pointer, oldElements);
	      };
	    })(this), (function(_this) {
	      return function(newElements) {
	        return _this.queueInEvents(pointer, newElements);
	      };
	    })(this), (function(_this) {
	      return function(newPath) {
	        return _this.updateCursor(newPath);
	      };
	    })(this));
	  };

	  PointerEventManager.prototype.pointerDown = function(id, location, timeStampInPerformanceSeconds) {
	    var pointer;
	    eventEpoch.logEvent("pointerDown", id);
	    if (this.activePointers[id]) {
	      console.error("pointerDown(id:" + (inspect(id)) + ", location:" + (inspect(location)) + "): already have an active pointer for that id");
	    } else {
	      this._numActivePointers++;
	    }
	    pointer = this.activePointers[id] = new Pointer(id, location);
	    if (this._numActivePointers === 1) {
	      this.focus(pointer, peek(this.pointerElementPath(pointer)));
	    }
	    return this.queuePointerEvents("pointerDown", pointer, timeStampInPerformanceSeconds);
	  };

	  PointerEventManager.prototype.queuePointerUpInAndOutsideEvents = function(pointer, timeStampInPerformanceSeconds) {
	    return this.forEachReceivingElement((function(_this) {
	      return function(element) {
	        var locationInParentSpace, type;
	        locationInParentSpace = pointer.locationIn(element.parent);
	        type = element.pointInside(locationInParentSpace) ? "pointerUpInside" : "pointerUpOutside";
	        return _this.queuePointerEventForElement(element, type, pointer, timeStampInPerformanceSeconds);
	      };
	    })(this));
	  };

	  PointerEventManager.prototype.queuePointerMoveInAndOutEvents = function(pointer, timeStampInPerformanceSeconds) {
	    var isInsideParent, wasInsideParent;
	    isInsideParent = true;
	    wasInsideParent = true;
	    return this.forEachReceivingElement((function(_this) {
	      return function(element) {
	        var isInside, lastLocationInParentSpace, locationInParentSpace, type, wasInside;
	        lastLocationInParentSpace = pointer.lastLocationIn(element.parent);
	        locationInParentSpace = pointer.locationIn(element.parent);
	        wasInside = wasInsideParent && element.pointInside(lastLocationInParentSpace);
	        isInside = isInsideParent && element.pointInside(locationInParentSpace);
	        if (isInside !== wasInside) {
	          type = isInside ? "pointerIn" : "pointerOut";
	          _this.queuePointerEventForElement(element, type, pointer, timeStampInPerformanceSeconds);
	        }
	        isInsideParent = isInside;
	        return wasInsideParent = wasInside;
	      };
	    })(this));
	  };

	  PointerEventManager.prototype.pointerUp = function(id, timeStampInPerformanceSeconds) {
	    var pointer;
	    eventEpoch.logEvent("pointerUp", id);
	    if (!(pointer = this.activePointers[id])) {
	      return console.error("pointerUp(" + id + "): no active pointer for that id");
	    }
	    this._numActivePointers--;
	    delete this.activePointers[id];
	    this.queuePointerUpInAndOutsideEvents(pointer, timeStampInPerformanceSeconds);
	    this.queuePointerEvents("pointerUp", pointer, timeStampInPerformanceSeconds);
	    if (pointer.stayedWithinDeadzone) {
	      this.queuePointerEvents("pointerClick", pointer, timeStampInPerformanceSeconds);
	      eventEpoch.flushEpochNow();
	    }
	    if (this.capturingElement && this._numActivePointers === 0) {
	      return this.capturingElement = null;
	    }
	  };

	  PointerEventManager.prototype.mouseWheel = function(location, timeStampInPerformanceSeconds, props) {
	    return this.queueMouseEvents("mouseWheel", this.mouse, timeStampInPerformanceSeconds, props);
	  };

	  PointerEventManager.prototype.pointerCancel = function(id, timeStampInPerformanceSeconds) {
	    var pointer;
	    eventEpoch.logEvent("pointerCancel", id);
	    if (!(pointer = this.activePointers[id])) {
	      return console.error("pointerCancel(" + id + "): no active pointer for that id");
	    }
	    this._numActivePointers--;
	    delete this.activePointers[id];
	    this.queuePointerEvents("pointerCancel", pointer, timeStampInPerformanceSeconds);
	    if (this.capturingElement && this._numActivePointers === 0) {
	      return this.capturingElement = null;
	    }
	  };

	  PointerEventManager.prototype.pointerMove = function(id, location, timeStampInPerformanceSeconds) {
	    var pointer;
	    eventEpoch.logEvent("pointerMove", id);
	    if (!(pointer = this.activePointers[id])) {
	      return console.error("pointerMove(" + id + ", " + location + "): no active pointer for that id");
	    }
	    if (!!pointer.location.eq(location)) {
	      return;
	    }
	    this.activePointers[id] = pointer = pointer.moved(location);
	    this.queuePointerMoveInAndOutEvents(pointer, timeStampInPerformanceSeconds);
	    return this.queuePointerEvents("pointerMove", pointer, timeStampInPerformanceSeconds);
	  };

	  PointerEventManager.prototype.mouseDown = function(location, timeStampInPerformanceSeconds) {
	    return this.pointerDown("mousePointer", location, timeStampInPerformanceSeconds);
	  };

	  PointerEventManager.prototype.mouseUp = function(timeStampInPerformanceSeconds) {
	    this.pointerUp("mousePointer", timeStampInPerformanceSeconds);
	    return this.updateMousePath();
	  };

	  PointerEventManager.prototype.mouseMove = function(location, timeStampInPerformanceSeconds) {
	    if (!!this.mouse.location.eq(location)) {
	      return;
	    }
	    this.mouse = this.mouse.moved(location);
	    this.updateMousePath();
	    if (this._numActivePointers > 0) {
	      this.pointerMove("mousePointer", location, timeStampInPerformanceSeconds);
	    }
	    return this.queueMouseEvents("mouseMove", this.mouse);
	  };

	  return PointerEventManager;

	})(Foundation.BaseObject);


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(125), __webpack_require__(19), __webpack_require__(168)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Atomic, Foundation, Events) {
	  var PointerEvent, arrayize, clone, first, inspect, matrix, merge, peek, point, rect, transformedArray;
	  point = Atomic.point, rect = Atomic.rect, matrix = Atomic.matrix;
	  inspect = Foundation.inspect, clone = Foundation.clone, peek = Foundation.peek, first = Foundation.first, merge = Foundation.merge;
	  arrayize = function(single, array, defaultArray) {
	    if (single) {
	      return [single];
	    } else {
	      return array || defaultArray || [];
	    }
	  };
	  transformedArray = function(arrayOfPoints, matrix) {
	    var i, len, p, results;
	    results = [];
	    for (i = 0, len = arrayOfPoints.length; i < len; i++) {
	      p = arrayOfPoints[i];
	      results.push(matrix.transform(p));
	    }
	    return results;
	  };
	  return PointerEvent = (function(superClass) {
	    var emptyObject;

	    extend(PointerEvent, superClass);

	    function PointerEvent(type, pointer, time, props) {
	      PointerEvent.__super__.constructor.call(this, type, props, time);
	      this.pointer = pointer;
	    }

	    emptyObject = {};

	    PointerEvent.prototype.newEvent = function(options) {
	      var e;
	      if (options == null) {
	        options = emptyObject;
	      }
	      e = new PointerEvent(options.type || this.type, options.pointer || this.pointer, options.time || this.time);
	      e.timeStamp = this.timeStamp;
	      e.target = options.target || this.target;
	      return e;
	    };

	    PointerEvent.getter({
	      location: function() {
	        return this.pointer.locationIn(this.target);
	      },
	      firstLocation: function() {
	        return this.pointer.firstLocationIn(this.target);
	      },
	      lastLocation: function() {
	        return this.pointer.lastLocationIn(this.target);
	      },
	      absLocation: function() {
	        return this.pointer.location;
	      },
	      absFirstLocation: function() {
	        return this.pointer.firstLocation;
	      },
	      absLastLocation: function() {
	        return this.pointer.lastLocation;
	      },
	      parentLocation: function() {
	        return this.pointer.locationIn(this.target.parent);
	      },
	      parentParentLocation: function() {
	        return this.pointer.locationIn(this.target.parent.parent);
	      },
	      parentFirstLocation: function() {
	        return this.pointer.firstLocationIn(this.target.parent);
	      },
	      parentParentFirstLocation: function() {
	        return this.pointer.firstLocationIn(this.target.parent.parent);
	      },
	      parentLastLocation: function() {
	        return this.pointer.lastLocationIn(this.target.parent);
	      },
	      parentParentLastLocation: function() {
	        return this.pointer.lastLocationIn(this.target.parent.parent);
	      },
	      absDelta: function() {
	        return this.pointer.location.sub(this.pointer.lastLocation);
	      },
	      delta: function() {
	        return this.location.sub(this.lastLocation);
	      },
	      parentDelta: function() {
	        return this.pointer.deltaIn(this.target.parent);
	      },
	      parentParentDelta: function() {
	        return this.pointer.deltaIn(this.target.parent.parent);
	      },
	      absTotalDelta: function() {
	        return this.pointer.location.sub(this.pointer.firstLocation);
	      },
	      totalDelta: function() {
	        return this.location.sub(this.firstLocation);
	      },
	      totalParentDelta: function() {
	        return this.pointer.totalDeltaIn(this.target.parent);
	      },
	      totalParentParentDelta: function() {
	        return this.pointer.totalDeltaIn(this.target.parent.parent);
	      }
	    });

	    PointerEvent.prototype.toElementMatrix = function(element) {
	      return this.target.getElementToElementMatrix(element);
	    };

	    PointerEvent.prototype.locationIn = function(element) {
	      return this.pointer.locationIn(element);
	    };

	    PointerEvent.prototype.lastLocationIn = function(element) {
	      return this.pointer.lastLocationIn(element);
	    };

	    PointerEvent.prototype.firstLocationIn = function(element) {
	      return this.pointer.firstLocationIn(element);
	    };

	    return PointerEvent;

	  })(Events.Event);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	var Animator, Atomic, Canvas, DrawCacheManager, DrawEpoch, Element, ElementBase, Foundation, GlobalEpochCycle, Join, Layout, Map, Matrix, Point, PointLayout, PointLayoutBase, Promise, Rectangle, StateEpoch, Unique, arrayWithoutValue, cacheAggressively, clone, compact, compactFlatten, createWithPostCreate, currentSecond, defaultSize, drawCacheManager, drawEpoch, floatEq, floatEq0, floor, globalEpochCycle, identityMatrix, insert, inspect, inspectLean, inspectedObjectLiteral, isFunction, isInfiniteResult, isNumber, isPlainArray, isPlainObject, isPoint, isString, keepIfRubyTrue, log, matrix, max, merge, mergeInto, min, minimumOrderedOverlappingMerge, modulo, nonStatePropertyKeyTest, perimeter, perimeter0, plainObjectsDeepEq, point, point0, point1, present, rect, remove, repeat, rubyTrue, shallowEq, stateEpoch, stats, time, truncateLayoutCoordinate, zeroedStats,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	Atomic = __webpack_require__(125);

	Foundation = __webpack_require__(19);

	Canvas = __webpack_require__(137);

	Animator = __webpack_require__(185);

	Layout = __webpack_require__(187);

	ElementBase = __webpack_require__(192);

	StateEpoch = __webpack_require__(194);

	DrawEpoch = __webpack_require__(202);

	GlobalEpochCycle = __webpack_require__(201);

	DrawCacheManager = __webpack_require__(203);

	isInfiniteResult = __webpack_require__(198).isInfiniteResult;

	point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, Matrix = Atomic.Matrix, matrix = Atomic.matrix, identityMatrix = Atomic.identityMatrix, point0 = Atomic.point0, point1 = Atomic.point1, perimeter0 = Atomic.perimeter0, isPoint = Atomic.isPoint, perimeter = Atomic.perimeter;

	floor = Math.floor;

	globalEpochCycle = GlobalEpochCycle.globalEpochCycle;

	drawCacheManager = DrawCacheManager.drawCacheManager;

	PointLayout = Layout.PointLayout, PointLayoutBase = Layout.PointLayoutBase;

	truncateLayoutCoordinate = function(v) {
	  return floor(v + 1 / 256);
	};

	inspect = Foundation.inspect, inspectLean = Foundation.inspectLean, clone = Foundation.clone, time = Foundation.time, Map = Foundation.Map, plainObjectsDeepEq = Foundation.plainObjectsDeepEq, shallowEq = Foundation.shallowEq, Unique = Foundation.Unique, compact = Foundation.compact, compactFlatten = Foundation.compactFlatten, keepIfRubyTrue = Foundation.keepIfRubyTrue, log = Foundation.log, insert = Foundation.insert, remove = Foundation.remove, merge = Foundation.merge, max = Foundation.max, min = Foundation.min, arrayWithoutValue = Foundation.arrayWithoutValue, minimumOrderedOverlappingMerge = Foundation.minimumOrderedOverlappingMerge, isPlainObject = Foundation.isPlainObject, isPlainArray = Foundation.isPlainArray, isNumber = Foundation.isNumber, isString = Foundation.isString, isFunction = Foundation.isFunction, mergeInto = Foundation.mergeInto, floatEq = Foundation.floatEq, floatEq0 = Foundation.floatEq0, Join = Foundation.Join, rubyTrue = Foundation.rubyTrue, createWithPostCreate = Foundation.createWithPostCreate, currentSecond = Foundation.currentSecond, repeat = Foundation.repeat, present = Foundation.present, Promise = Foundation.Promise, modulo = Foundation.modulo, inspectedObjectLiteral = Foundation.inspectedObjectLiteral;

	cacheAggressively = false;

	stats = clone(zeroedStats = {
	  stagingBitmapsCreated: 0,
	  elementsDrawn: 0
	});

	defaultSize = point(100);

	stateEpoch = StateEpoch.stateEpoch;

	drawEpoch = DrawEpoch.drawEpoch;

	nonStatePropertyKeyTest = ElementBase.nonStatePropertyKeyTest;

	module.exports = createWithPostCreate(Element = (function(superClass) {
	  var childrenWithout, defaultLocationLayout, defaultSizeLayout, drawCachingEnabled, initialChildren;

	  extend(Element, superClass);

	  Element.drawCachingEnabled = drawCachingEnabled = true;

	  Element.registerWithElementFactory = function() {
	    return true;
	  };

	  Element.stats = stats;

	  Element.resetStats = function() {
	    return mergeInto(stats, zeroedStats);
	  };

	  Element.created = 0;

	  Element.createdByType = {};

	  Element.resetCreated = function() {
	    Element.created = 0;
	    return Element.createdByType = {};
	  };

	  function Element(options, children) {
	    var childrenArray, i, j, ref;
	    Element.created++;
	    Element.__super__.constructor.call(this, options);
	    this._propertiesInitialized = false;
	    if (arguments.length === 2 && children && children.constructor === Array) {
	      if (children.length > 0) {
	        this.setChildren(children);
	      }
	    } else if (arguments.length > 1) {
	      childrenArray = new Array(arguments.length - 1);
	      for (i = j = 1, ref = arguments.length; j < ref; i = j += 1) {
	        childrenArray[i - 1] = arguments[i];
	      }
	      this.setChildren(childrenArray);
	    }
	    this._propertiesInitialized = true;
	  }

	  Element.prototype._initFields = function() {
	    Element.__super__._initFields.apply(this, arguments);
	    this._initDrawCache();
	    this._initTemporaryFields();
	    this._initComputedFields();
	    this._activeAnimator = null;
	    this._toVoidAnimationStatus = false;
	    return this._locationLayoutDisabled = false;
	  };

	  Element.prototype._initTemporaryFields = function() {
	    this._currentDrawTarget = null;
	    this._currentToTargetMatrix = null;
	    this._lastParentSize = null;
	    return this._bitmapFactory = null;
	  };

	  Element.prototype._initComputedFields = function() {
	    this._elementSpaceDrawArea = null;
	    this._rootElement = this;
	    this._elementToAbsMatrix = null;
	    this._absToElementMatrix = null;
	    return this._parentToElementMatrix = null;
	  };

	  Element.layoutProperty = function(map) {
	    var options, prop, results1;
	    results1 = [];
	    for (prop in map) {
	      options = map[prop];
	      options.layoutProperty = true;
	      results1.push(this._defineElementProperty(prop, options));
	    }
	    return results1;
	  };

	  Element.drawProperty = function(map) {
	    var options, prop, results1;
	    results1 = [];
	    for (prop in map) {
	      options = map[prop];
	      options.drawProperty = true;
	      results1.push(this._defineElementProperty(prop, options));
	    }
	    return results1;
	  };

	  Element.drawLayoutProperty = function(map) {
	    var options, prop, results1;
	    results1 = [];
	    for (prop in map) {
	      options = map[prop];
	      options.layoutProperty = true;
	      options.drawProperty = true;
	      results1.push(this._defineElementProperty(prop, options));
	    }
	    return results1;
	  };

	  Element.drawAreaProperty = function(map) {
	    var options, prop, results1;
	    results1 = [];
	    for (prop in map) {
	      options = map[prop];
	      options.drawAreaProperty = true;
	      options.drawProperty = true;
	      results1.push(this._defineElementProperty(prop, options));
	    }
	    return results1;
	  };

	  Element.prototype._layoutPropertyChanged = function() {
	    return this._elementChanged(true);
	  };

	  Element.prototype._drawPropertyChanged = function() {
	    return this._elementChanged(false, true, false);
	  };

	  Element.prototype._drawAreaPropertyChanged = function() {
	    return this._elementChanged(false, true, true);
	  };

	  Element.getter({
	    absToElementMatrix: function() {
	      return this._absToElementMatrix || (this._absToElementMatrix = this._parent ? this._parent.getAbsToElementMatrix().mul(this.getParentToElementMatrix()) : this.getParentToElementMatrix());
	    },
	    parentToElementMatrix: function() {
	      return this._parentToElementMatrix || (this._parentToElementMatrix = this._elementToParentMatrix.inv);
	    },
	    elementToDocumentMatrix: function() {
	      return this.getElementToAbsMatrix().mul(this.getCanvasElement()._elementToDocumentMatrix);
	    },
	    documentToElementMatrix: function() {
	      return this.getCanvasElement()._documentToElementMatrix.mul(this.getAbsToElementMatrix());
	    },
	    parentSpaceDrawArea: function() {
	      return this._elementToParentMatrix.transformBoundingRect(this.getElementSpaceDrawArea());
	    },
	    elementSpaceDrawArea: function() {
	      return this._elementSpaceDrawArea || (this._elementSpaceDrawArea = this._computeElementSpaceDrawArea());
	    },
	    drawArea: function() {
	      return this.elementSpaceDrawArea;
	    },
	    absOpacity: function() {
	      var opacity, parent;
	      opacity = this.getVisible() ? this.getOpacity() : 0;
	      if (parent = this.getParent()) {
	        opacity *= parent.getAbsOpacity();
	      }
	      return opacity;
	    },
	    isChanging: function() {
	      return this.__stateChangeQueued;
	    },
	    rootElement: function() {
	      return this._rootElement || (this._rootElement = this._parent ? this._parent.getRootElement() : this);
	    },
	    bitmapFactory: function() {
	      var ref;
	      return this._bitmapFactory || ((ref = this.getCanvasElement()) != null ? ref.bitmapFactory : void 0) || Canvas.Bitmap;
	    },
	    devicePixelsPerPoint: function() {
	      return this.getRootElement()._devicePixelsPerPoint || 1;
	    },
	    canvasElement: function() {
	      var re;
	      re = this.getRootElement();
	      if (re !== this) {
	        return re.getCanvasElement();
	      } else {
	        return null;
	      }
	    }
	  });

	  Element.prototype.transformToParentSpace = function(p) {
	    return this._elementToParentMatrix.transform(p);
	  };

	  Element.prototype.transformFromParentSpace = function(p) {
	    return this._elementToParentMatrix.inverseTransform(p);
	  };

	  Element.prototype._clearRootElement = function() {
	    var child, j, len, oldRootElement, ref, results1;
	    if (oldRootElement = this._rootElement) {
	      this._rootElement = null;
	      this.queueEvent("rootElementChanged", (function(_this) {
	        return function() {
	          return {
	            oldRootElement: oldRootElement,
	            rootElement: _this.getRootElement()
	          };
	        };
	      })(this));
	      ref = this._children;
	      results1 = [];
	      for (j = 0, len = ref.length; j < len; j++) {
	        child = ref[j];
	        results1.push(child._clearRootElement());
	      }
	      return results1;
	    }
	  };

	  Element.prototype.preprocessEventHandlers = function(handlerMap) {
	    var k, v;
	    for (k in handlerMap) {
	      v = handlerMap[k];
	      if (k === "rootElementChanged") {
	        this.getRootElement();
	      }
	    }
	    return handlerMap;
	  };

	  Element.setter({
	    absToElementMatrix: function(aToE) {
	      return this.setElementToAbsMatrix(aToE.invert());
	    },
	    parentToElementMatrix: function(pToE) {
	      return this.setElementToParentMatrix(pToE.invert());
	    }
	  });

	  defaultSizeLayout = new PointLayout({
	    ps: 1
	  });

	  defaultLocationLayout = new PointLayout(0);

	  Element.layoutProperty({
	    size: {
	      "default": {
	        ps: 1
	      },
	      preprocess: function(v) {
	        if (v instanceof PointLayoutBase) {
	          return v;
	        } else {
	          return new PointLayout(v, defaultSizeLayout);
	        }
	      }
	    },

	    /*
	    TODO: Update StateEpochLayout to use: childrenSizePreprocessor
	    
	    How do we want to handle currentPadding?
	      - is it always set; gut: yes
	      - should childrenSizePreprocessor be responsible for including padding?
	      - should we check before calling childrenSizePreprocessor? If it is length 4,
	        then padding is added after?
	    
	      - I kinda want to NOT include currentPadding, at least not most the time.
	        99% of the time it is going to be the exact same calulation:
	    
	        if currentPadding
	          right += currentPadding.getWidth()
	          bottom += currentPadding.getHeight()
	    
	        which, if applied after, would look like this:
	    
	          childrenSizePreprocessor(...).add currentPadding.getWidth(), currentPadding.getHeight()
	           * note, this only creates a second point if there is non-zero padding.
	    
	    childrenSizePreprocessor:
	      default: (left, top, right, bottom) -> point right, bottom
	      validate: (v) -> isFunction v
	     */
	    location: {
	      "default": 0,
	      preprocess: function(v) {
	        if (v instanceof PointLayoutBase) {
	          return v;
	        } else {
	          return new PointLayout(v, defaultLocationLayout);
	        }
	      },
	      postSetter: function() {
	        return this._locationLayoutDisabled = false;
	      }
	    },
	    scale: {
	      "default": 1,
	      preprocess: function(s) {
	        if (isFunction(s)) {
	          return s;
	        } else {
	          return point(s);
	        }
	      },
	      postSetter: function() {
	        return this._locationLayoutDisabled = false;
	      }
	    },
	    angle: {
	      "default": 0,
	      postSetter: function() {
	        return this._locationLayoutDisabled = false;
	      }
	    },
	    childrenLayout: {
	      "default": null,
	      validate: function(v) {
	        return v === null || v === "flow" || v === "column" || v === "row";
	      }
	    },
	    childrenGrid: {
	      "default": null,
	      validate: function(v) {
	        return v === null || isString(v) && v.match(/^[ a-zA-Z]+$/);
	      }
	    },
	    childrenAlignment: {
	      "default": point0,
	      preprocess: function(v) {
	        return point(v);
	      }
	    },
	    axis: {
	      "default": point0,
	      preprocess: function(v) {
	        return point(v);
	      }
	    },
	    inFlow: {
	      "default": true,
	      preprocess: function(v) {
	        return !!v;
	      }
	    },
	    layoutWeight: {
	      "default": 1,
	      validate: function(v) {
	        return isNumber(v);
	      }
	    },
	    padding: {
	      "default": 0,
	      preprocess: function(v) {
	        if (isFunction(v)) {
	          return v;
	        } else if (v === false || v === void 0 || v === null) {
	          return null;
	        } else {
	          return perimeter(v);
	        }
	      }
	    },
	    margin: {
	      "default": 0,
	      preprocess: function(v) {
	        if (isFunction(v)) {
	          return v;
	        } else if (v === false || v === void 0 || v === null) {
	          return null;
	        } else {
	          return perimeter(v);
	        }
	      }
	    }
	  });

	  Element.concreteProperty({
	    currentSize: {
	      "default": defaultSize,
	      setter: function(_new, _old) {
	        return _old;
	      }
	    },
	    currentPadding: {
	      "default": perimeter0,
	      setter: function(_new, _old) {
	        return _old;
	      }
	    },
	    currentMargin: {
	      "default": perimeter0,
	      setter: function(_new, _old) {
	        return _old;
	      }
	    }
	  });

	  Element.virtualProperty({
	    currentLocationX: function(pending) {
	      var a, p, s, state;
	      state = this.getState(pending);
	      s = state._currentSize;
	      a = state._axis;
	      p = state._currentPadding;
	      return state._elementToParentMatrix.transformX(s.x * a.x - p.left, s.y * a.y - p.top);
	    },
	    currentLocationY: function(pending) {
	      var a, p, s, state;
	      state = this.getState(pending);
	      s = state._currentSize;
	      a = state._axis;
	      p = state._currentPadding;
	      return state._elementToParentMatrix.transformY(s.x * a.x - p.left, s.y * a.y - p.top);
	    },
	    currentLocation: function(pending, elementToParentMatrix) {
	      var a, p, s, state;
	      state = this.getState(pending);
	      s = state._currentSize;
	      a = state._axis;
	      p = state._currentPadding;
	      elementToParentMatrix || (elementToParentMatrix = state._elementToParentMatrix);
	      return elementToParentMatrix.transform(s.x * a.x - p.left, s.y * a.y - p.top);
	    },
	    currentAngle: function(pending) {
	      var state;
	      state = this.getState(pending);
	      return state._elementToParentMatrix.angle;
	    },
	    currentScale: function(pending) {
	      var state;
	      state = this.getState(pending);
	      return state._elementToParentMatrix.getExactScale();
	    },
	    layout: {
	      getter: function() {
	        throw new Error("get layout is depricated");
	      },
	      setter: function() {
	        throw new Error("set layout is depricated");
	      }
	    },
	    elementToAbsMatrix: {
	      getter: function(pending) {
	        var state;
	        state = this.getState(pending);
	        return state._elementToAbsMatrix || (state._elementToAbsMatrix = state._parent ? state._elementToParentMatrix.mul(state._parent.getElementToAbsMatrix()) : state._elementToParentMatrix);
	      },
	      setter: function(eToA) {
	        return this.setElementToParentMatrix(this._parent ? eToA.mul(this._parent.getAbsToElementMatrix()) : eToA);
	      }
	    }
	  });

	  Element.getter({
	    currentElementToParentMatrix: function(pending, withLocation, withScale) {
	      if (withLocation || withScale) {
	        withLocation || (withLocation = this.getCurrentLocation(pending));
	        return this._getElementToParentMatrixForXY(pending, withLocation.x, withLocation.y, withScale);
	      } else {
	        return this.getState(pending)._elementToParentMatrix;
	      }
	    }
	  });

	  Element.concreteProperty({
	    cursor: {
	      "default": null,
	      validate: function(v) {
	        return v === null || typeof v === "string";
	      }
	    },
	    elementToParentMatrix: {
	      "default": Matrix.identityMatrix,
	      preprocess: function(v) {
	        return matrix(v);
	      },
	      setter: function(v) {
	        this._locationLayoutDisabled = true;
	        return matrix(v);
	      }
	    },
	    parent: {
	      "default": null,
	      setter: function(p) {
	        if (p) {
	          p.addChild(this);
	        } else {
	          this.removeFromParent();
	        }
	        return p;
	      }
	    },
	    children: {
	      "default": initialChildren = [],
	      setter: function(newChildren, oldChildren) {
	        var child, childrenHaveRemovedAnimations, firstTimeSettingChildren, j, keepOldChildren, len, len1, len2, len3, n, oldParent, q, r;
	        this.__drawPropertiesChanged = true;
	        newChildren = compactFlatten(newChildren, keepIfRubyTrue);
	        firstTimeSettingChildren = oldChildren === initialChildren;
	        for (j = 0, len = oldChildren.length; j < len; j++) {
	          child = oldChildren[j];
	          if (!(child.getPendingHasToVoidAnimators())) {
	            continue;
	          }
	          childrenHaveRemovedAnimations = true;
	          break;
	        }
	        if (childrenHaveRemovedAnimations) {
	          keepOldChildren = [];
	          for (n = 0, len1 = oldChildren.length; n < len1; n++) {
	            child = oldChildren[n];
	            if (child._toVoidAnimationStatus === "done") {
	              child._toVoidAnimationStatus = false;
	            } else if (indexOf.call(newChildren, child) >= 0) {
	              keepOldChildren.push(child);
	            } else if (child.getPendingHasToVoidAnimators()) {
	              child._activateToVoidAnimators();
	              keepOldChildren.push(child);
	            }
	          }
	          newChildren = minimumOrderedOverlappingMerge(keepOldChildren, newChildren);
	        }
	        for (q = 0, len2 = oldChildren.length; q < len2; q++) {
	          child = oldChildren[q];
	          if (indexOf.call(newChildren, child) < 0) {
	            child._setParentOnly(null);
	          }
	        }
	        for (r = 0, len3 = newChildren.length; r < len3; r++) {
	          child = newChildren[r];
	          if (!((oldParent = child.getPendingParent()) !== this)) {
	            continue;
	          }
	          if (oldParent != null) {
	            oldParent._setChildrenOnly(oldParent.pendingChildrenWithout(child));
	          }
	          child._setParentOnly(this);
	        }
	        return newChildren;
	      }
	    }
	  });


	  /*
	  Apply f to each child
	  return: this
	  
	  SBD NOTE: 2015-11-5 We should start using this for all child iteration.
	    It will allow us to implement Spans in the future.
	  
	     * basic span sketch:
	    for child in @_children
	      if isSpan child
	        child.eachChild f
	      else
	        f child
	  
	     * span sketch with span-properties:
	    class ElementBase
	      eachChild: (f, spanProps) ->
	        for child in @_children
	          if isSpan child
	            child.eachChild f, spanProps
	          else
	            f child, spanProps
	  
	    class Span extends ElementBase
	      eachChild: (f, spanProps) ->
	        if @props
	          spanProps = if spanProps
	            merge spanProps, @props
	          else
	            @props
	        super f, spanProps
	   */

	  Element.prototype.eachChild = function(f) {
	    var child, j, len, ref;
	    ref = this._children;
	    for (j = 0, len = ref.length; j < len; j++) {
	      child = ref[j];
	      f(child);
	    }
	    return this;
	  };

	  Element.prototype._toVoidAnimationDone = function() {
	    var animator, prop, ref;
	    ref = this.animators;
	    for (prop in ref) {
	      animator = ref[prop];
	      if ((animator.toVoid != null) && (animator.active != null)) {
	        return;
	      }
	    }
	    this._toVoidAnimationStatus = "done";
	    return this.removeFromParent();
	  };

	  Element.prototype._activateToVoidAnimators = function() {
	    var animator, prop, ref, results1;
	    if (!(!this._toVoidAnimationStatus && this.getPendingHasToVoidAnimators())) {
	      return;
	    }
	    this._toVoidAnimationStatus = "active";
	    ref = this.getPendingAnimators();
	    results1 = [];
	    for (prop in ref) {
	      animator = ref[prop];
	      results1.push(animator.startToVoidAnimation(this).then((function(_this) {
	        return function() {
	          return _this._toVoidAnimationDone();
	        };
	      })(this)));
	    }
	    return results1;
	  };

	  Element.getter({
	    area: function() {
	      throw new Error("depricated - use logicalArea");
	    },
	    logicalArea: function() {
	      var p, size;
	      p = this.getCurrentPadding();
	      size = this._currentSize;
	      return new Rectangle(-p.left, -p.top, size.x, size.y);
	    },
	    paddedWidth: function() {
	      return this._currentSize.x - this.getCurrentPadding().getWidth();
	    },
	    paddedHeight: function() {
	      return this._currentSize.y - this.getCurrentPadding().getHeight();
	    },
	    paddedSize: function() {
	      var p, size;
	      p = this.getCurrentPadding();
	      size = this._currentSize;
	      return point(size.x - p.getWidth(), size.y - p.getHeight());
	    },
	    paddedArea: function() {
	      var p, size;
	      p = this.getCurrentPadding();
	      size = this._currentSize;
	      return new Rectangle(0, 0, size.x - p.getWidth(), size.y - p.getHeight());
	    }
	  });

	  Element.drawAreaProperty({
	    clip: {
	      "default": false,
	      preprocess: function(v) {
	        return !!v;
	      }
	    }
	  });

	  Element.drawLayoutProperty({
	    visible: {
	      "default": true,
	      preprocess: function(v) {
	        return !!v;
	      }
	    }
	  });

	  Element.concreteProperty({
	    opacity: {
	      "default": 1,
	      validate: function(v) {
	        return typeof v === "number";
	      }
	    },
	    compositeMode: {
	      "default": "normal",
	      validate: function(v) {
	        return typeof v === "string";
	      }
	    },
	    pointerEventPriority: {
	      "default": 0,
	      preprocess: function(v) {
	        return v | 0;
	      }
	    },
	    userProps: {
	      "default": null,
	      validate: function(v) {
	        return (v == null) || isPlainObject(v);
	      }
	    },
	    receivePointerEvents: {
	      "default": "inLogicalArea",
	      validate: function(v) {
	        return v === "never" || v === "inLogicalArea" || v === "inPaddedArea" || v === "passToChildren";
	      }
	    }
	  });

	  Element.concreteProperty({
	    cacheDraw: {
	      "default": false,
	      validate: function(v) {
	        return v === false || v === true || v === "locked" || v === "always" || v === "auto";
	      },
	      preprocess: function(v) {
	        if (v === true) {
	          return "auto";
	        } else {
	          return v;
	        }
	      },
	      description: "'auto', true: this element will be cached if it is rendered multiple times and isn't changing 'always': this element will always be cached 'locked': it will be cached once and no matter what changes, the old drawCache will be used for drawing. NOTE: If the element's internal draw properties change, _drawCacheBitmapInvalid is set to true, but the old drawCache is still used. NOTE: If it was 'locked' and then cacheDraw is changed to not 'locked' and not false, and _drawCacheBitmapInvalid is true, the cache will be regenerated."
	    }
	  });

	  Element.virtualProperty({
	    invisible: {
	      getter: function(pending) {
	        return this.getState(pending)._visible;
	      },
	      setter: function(v) {
	        return this.setVisible(!v);
	      }
	    },
	    hasToVoidAnimators: {
	      getter: function(pending) {
	        var animator, animators, prop;
	        if (animators = this.getState(pending)._animators) {
	          for (prop in animators) {
	            animator = animators[prop];
	            if (animator.hasToVoidAnimation) {
	              return true;
	            }
	          }
	        }
	        return false;
	      }
	    },
	    isMask: {
	      getter: function(pending) {
	        return this.getState(pending)._compositeMode === "alphaMask";
	      },
	      setter: function(v) {
	        return this.setCompositeMode(v ? "alphaMask" : "normal");
	      }
	    },
	    opacityPercent: function(pending) {
	      var state;
	      state = this.getState(pending);
	      return state._opacity * 100 | 0;
	    },
	    hasMask: function(pending) {
	      var child, j, len, ref, state;
	      state = this.getState(pending);
	      ref = state._children;
	      for (j = 0, len = ref.length; j < len; j++) {
	        child = ref[j];
	        if (child.isMask) {
	          return true;
	        }
	      }
	      return false;
	    },
	    firstMask: function(pending) {
	      var child, j, len, ref, state;
	      state = this.getState(pending);
	      ref = state._children;
	      for (j = 0, len = ref.length; j < len; j++) {
	        child = ref[j];
	        if (child.isMask) {
	          return child;
	        }
	      }
	    },
	    sizeAffectsLocation: function(pending) {
	      var state;
	      state = this.getState(pending);
	      return state._axis.x !== 0 || state._axis.y !== 0;
	    },
	    absoluteAxis: function(pending) {
	      var state;
	      state = this.getState(pending);
	      return state._currentSize.mul(state._axis);
	    },
	    sizeForChildren: function(pending) {
	      var _currentPadding, _currentSize, ref;
	      ref = this.getState(pending), _currentPadding = ref._currentPadding, _currentSize = ref._currentSize;
	      return _currentPadding.subtractedFromSize(_currentSize);
	    },
	    parentSize: function() {
	      throw new Error("parentSize depricated");
	    },
	    parentSizeForChildren: function(pending) {
	      var ref;
	      return ((ref = this.getState(pending)._parent) != null ? ref.getSizeForChildren(pending) : void 0) || defaultSize;
	    },
	    nextSibling: {
	      getter: function(pending) {
	        var parent;
	        parent = this.getState(pending)._parent;
	        return [parent, (parent != null ? parent.getChildren(pending)[parent.getChildIndex(this, pending) + 1] : void 0) || null];
	      },
	      setter: function(siblingOrPair) {
	        return this.placeRelativeToSibling(siblingOrPair, 0);
	      }
	    },
	    prevSibling: {
	      getter: function(pending) {
	        var parent;
	        parent = this.getState(pending)._parent;
	        return [parent, (parent != null ? parent.getChildren(pending)[parent.getChildIndex(this, pending) - 1] : void 0) || null];
	      },
	      setter: function(siblingOrPair) {
	        return this.placeRelativeToSibling(siblingOrPair, 1);
	      }
	    },
	    maxXInParentSpace: function(pending) {
	      var _currentPadding, _currentSize, _elementToParentMatrix, bottom, left, padding, ref, right, top;
	      ref = this.getState(pending), _currentPadding = ref._currentPadding, _currentSize = ref._currentSize, _elementToParentMatrix = ref._elementToParentMatrix;
	      padding = _currentPadding;
	      left = -padding.left;
	      top = -padding.top;
	      right = _currentSize.x + left;
	      bottom = _currentSize.y + top;
	      return max((_elementToParentMatrix.transformX(left, top), _elementToParentMatrix.transformX(left, bottom), _elementToParentMatrix.transformX(right, top), _elementToParentMatrix.transformX(right, bottom)));
	    },
	    maxYInParentSpace: function(pending) {
	      var _currentPadding, _currentSize, _elementToParentMatrix, bottom, left, padding, ref, right, top;
	      ref = this.getState(pending), _currentPadding = ref._currentPadding, _currentSize = ref._currentSize, _elementToParentMatrix = ref._elementToParentMatrix;
	      padding = _currentPadding;
	      left = -padding.left;
	      top = -padding.top;
	      right = _currentSize.x + left;
	      bottom = _currentSize.y + top;
	      return max((_elementToParentMatrix.transformY(left, top), _elementToParentMatrix.transformY(left, bottom), _elementToParentMatrix.transformY(right, top), _elementToParentMatrix.transformY(right, bottom)));
	    },
	    widthInParentSpace: function(pending) {
	      var a, b, bottom, c, d, left, padding, right, state, top;
	      state = this.getState(pending);
	      padding = state._currentPadding;
	      left = -padding.left;
	      top = -padding.top;
	      right = state._currentSize.x + left;
	      bottom = state._currentSize.y + top;
	      a = state._elementToParentMatrix.transformX(left, top);
	      b = state._elementToParentMatrix.transformX(left, bottom);
	      c = state._elementToParentMatrix.transformX(right, top);
	      d = state._elementToParentMatrix.transformX(right, bottom);
	      return max(a, b, c, d) - min(a, b, c, d);
	    },
	    heightInParentSpace: function(pending) {
	      var a, b, bottom, c, d, left, padding, right, state, top;
	      state = this.getState(pending);
	      padding = state._currentPadding;
	      left = -padding.left;
	      top = -padding.top;
	      right = state._currentSize.x + left;
	      bottom = state._currentSize.y + top;
	      a = state._elementToParentMatrix.transformY(left, top);
	      b = state._elementToParentMatrix.transformY(left, bottom);
	      c = state._elementToParentMatrix.transformY(right, top);
	      d = state._elementToParentMatrix.transformY(right, bottom);
	      return max(a, b, c, d) - min(a, b, c, d);
	    },
	    layoutLocationParentCircular: function(pending) {
	      var ref, state;
	      state = this.getState(pending);
	      return !!state._location.layoutIsCircular((ref = state._parent) != null ? ref.getState(pending)._size : void 0);
	    },
	    layoutSizeParentCircular: function(pending) {
	      var ref, state;
	      state = this.getState(pending);
	      return !!state._size.layoutIsCircular((ref = state._parent) != null ? ref.getState(pending)._size : void 0);
	    },
	    layoutMovesChildren: function(pending) {
	      return !!(this.getState(pending))._childrenLayout;
	    },
	    animate: {
	      "default": null,
	      getter: function(pending) {
	        return this._activeAnimator;
	      },
	      setter: function(options) {
	        if (this._toVoidAnimationStatus) {
	          return;
	        }
	        this.finishAnimations();
	        return stateEpoch.onNextReady((function(_this) {
	          return function() {
	            if (options) {
	              return new Animator(_this, options);
	            }
	          };
	        })(this));
	      }
	    },
	    preFilteredBaseDrawArea: function(pending) {
	      var _currentPadding, _currentSize, h, ref, w, x, y;
	      ref = this.getState(pending), _currentPadding = ref._currentPadding, _currentSize = ref._currentSize;
	      x = _currentSize.x, y = _currentSize.y;
	      w = _currentPadding.w, h = _currentPadding.h;
	      return rect(0, 0, x - w, y - h);
	    },
	    baseDrawArea: function(pending) {
	      return this.getPreFilteredBaseDrawArea(pending);
	    }
	  });

	  Element.getter({
	    allChildrenAreUpLayout: function() {
	      return false;
	    }
	  });


	  /*
	  INFO
	   */

	  Element.getter({
	    coreProps: function() {
	      var j, len, prop, properties, ret;
	      properties = [this._axis && !this.axis.eq(point()) ? "axis" : void 0, !this.location.eq(point0) ? "location" : void 0, this._currentSize ? "size" : void 0, !floatEq0(this.angle) ? "angle" : void 0, !this.scale.eq(point(1, 1)) ? "scale" : void 0, this._compositeMode && this._compositeMode !== "normal" ? "compositeMode" : void 0, (this._opacity != null) && this._opacity < 1 ? "opacity" : void 0, this._invisible ? "invisible" : void 0, this._layout ? "layout" : void 0];
	      ret = {};
	      for (j = 0, len = properties.length; j < len; j++) {
	        prop = properties[j];
	        if (prop) {
	          ret[prop] = this[prop];
	        }
	      }
	      return ret;
	    },
	    requiresParentStagingBitmap: function() {
	      switch (this._compositeMode) {
	        case "alphaMask":
	        case "targetAlphaMask":
	        case "destOver":
	        case "sourceIn":
	        case "inverseAlphaMask":
	          return true;
	        case "add":
	        case "normal":
	          return false;
	        default:
	          throw new Error("unknown compositeMode: " + this._compositeMode);
	      }
	    },
	    firstChildRequiringParentStagingBitmap: function() {
	      var child, j, len, ref;
	      ref = this._children;
	      for (j = 0, len = ref.length; j < len; j++) {
	        child = ref[j];
	        if (child.getRequiresParentStagingBitmap()) {
	          return child;
	        }
	      }
	    },
	    childRequiresParentStagingBitmap: function() {
	      return !!this.getFirstChildRequiringParentStagingBitmap();
	    }
	  });

	  Element.prototype.inspectParentStructure = function(elementPath) {
	    if (elementPath == null) {
	      elementPath = this.elementPath;
	    }
	    if (elementPath.length === 1) {
	      return [elementPath[0].inspectedName, elementPath[0].coreProps];
	    } else {
	      return [elementPath[0].inspectedName, elementPath[0].coreProps, this.inspectParentStructure(elementPath.slice(1))];
	    }
	  };

	  Element.prototype.inspectChildrenStructure = function() {
	    var child;
	    return [this.inspectedName, this.coreProps].concat((function() {
	      var j, len, ref, results1;
	      ref = this._children;
	      results1 = [];
	      for (j = 0, len = ref.length; j < len; j++) {
	        child = ref[j];
	        results1.push(child.inspectChildrenStructure());
	      }
	      return results1;
	    }).call(this));
	  };

	  Element.prototype.inspectRender = function(toBitmapOptions, callback) {
	    var childArea;
	    childArea = toBitmapOptions.area || "parentLogicalArea";
	    return this.onNextReady((function(_this) {
	      return function() {
	        var child, fn, i, j, joiner, len, ref;
	        joiner = new Join;
	        joiner["do"](function(done) {
	          return _this.toBitmap(merge(toBitmapOptions, {
	            area: "logicalArea"
	          }), function(bitmap) {
	            var outPut;
	            outPut = {};
	            outPut[_this.inspectedName] = [_this.inspectedName, bitmap];
	            return done(outPut);
	          });
	        });
	        ref = _this.children;
	        fn = function(child, i) {
	          return joiner["do"](function(done) {
	            return child.toBitmap(merge(toBitmapOptions, {
	              area: childArea
	            }), function(bitmap) {
	              var ret;
	              ret = {};
	              ret["child" + i] = [child.inspectedName, bitmap];
	              return done(ret);
	            });
	          });
	        };
	        for (i = j = 0, len = ref.length; j < len; i = ++j) {
	          child = ref[i];
	          fn(child, i);
	        }
	        return joiner.join(function(results) {
	          return callback(merge(results));
	        });
	      };
	    })(this));
	  };

	  Element.prototype.logInspectRender = function(toBitmapOptions) {
	    if (toBitmapOptions == null) {
	      toBitmapOptions = {};
	    }
	    toBitmapOptions.pixelsPerPoint || (toBitmapOptions.pixelsPerPoint = this.devicePixelsPerPoint);
	    return this.inspectRender(toBitmapOptions, (function(_this) {
	      return function(results) {
	        return _this.log(results);
	      };
	    })(this));
	  };

	  Element.prototype.abortAnimations = function() {
	    if (this._activeAnimator) {
	      return this._activeAnimator.abort();
	    }
	  };

	  Element.prototype.finishAnimations = function() {
	    if (this._activeAnimator) {
	      return this._activeAnimator.finish();
	    }
	  };

	  Element.prototype.startChildAddedAnimation = function(child) {
	    var animation;
	    if (animation = child.getPendingAddedAnimation() || (this._propertiesInitialized && this.getPendingChildAddedAnimation())) {
	      return child.animate = animation;
	    }
	  };

	  Element.prototype._useStagingBitmap = function() {
	    return (this.getHasChildren() || this.getIsMask()) && (this._compositeMode !== "normal" || this._opacity < 1 || this.getChildRequiresParentStagingBitmap());
	  };

	  Element.prototype._drawChildren = function(target, elementToTargetMatrix, usingStagingBitmap) {
	    var child, j, len, ref;
	    ref = this.children;
	    for (j = 0, len = ref.length; j < len; j++) {
	      child = ref[j];
	      if (child.visible) {
	        child.draw(target, child.getElementToTargetMatrix(elementToTargetMatrix));
	      }
	    }
	    return this.children;
	  };

	  Element.prototype._renderStagingBitmap = function(targetSpaceDrawArea, elementToTargetMatrix, stagingBitmap) {
	    targetSpaceDrawArea = targetSpaceDrawArea.roundOut();
	    if (!targetSpaceDrawArea.getLocationIsZero()) {
	      elementToTargetMatrix = elementToTargetMatrix.translateXY(-targetSpaceDrawArea.x, -targetSpaceDrawArea.y);
	    }
	    stats.stagingBitmapsCreated++;
	    stagingBitmap || (stagingBitmap = this.bitmapFactory.newBitmap(targetSpaceDrawArea.size));
	    this._currentDrawTarget = stagingBitmap;
	    this._currentToTargetMatrix = elementToTargetMatrix;
	    if (this.getHasCustomClipping()) {
	      this._clipDraw(null, stagingBitmap, elementToTargetMatrix);
	    } else {
	      this._drawChildren(stagingBitmap, elementToTargetMatrix, true);
	    }
	    return stagingBitmap;
	  };

	  Element.prototype._accountForOverdraw = function(proposedTargetSpaceDrawArea, elementToTargetMatrix) {
	    var child, j, len, ref;
	    ref = this.children;
	    for (j = 0, len = ref.length; j < len; j++) {
	      child = ref[j];
	      if (child.overDraw) {
	        proposedTargetSpaceDrawArea = child.overDraw(proposedTargetSpaceDrawArea, elementToTargetMatrix);
	      }
	    }
	    return proposedTargetSpaceDrawArea;
	  };

	  Element.prototype._drawWithStagingBitmap = function(targetSpaceDrawArea, target, elementToTargetMatrix) {
	    var stagingBitmap;
	    targetSpaceDrawArea = this._accountForOverdraw(targetSpaceDrawArea, elementToTargetMatrix);
	    stagingBitmap = this._renderStagingBitmap(targetSpaceDrawArea, elementToTargetMatrix);
	    return target.drawBitmap(targetSpaceDrawArea.locationMatrix, stagingBitmap, {
	      compositeMode: this._compositeMode,
	      opacity: this.opacity
	    });
	  };

	  Element.prototype._clippedDrawWithStagingBitmapInElementSpace = function(target, elementToTargetMatrix) {
	    var m, s, stagingBitmap;
	    s = elementToTargetMatrix.getExactScale();
	    stagingBitmap = this._renderStagingBitmap(rect(0, 0, this._currentSize.x * s.x, this._currentSize.y * s.y), m = Matrix.scale(s));
	    return target.drawBitmap(m.inv.mul(elementToTargetMatrix), stagingBitmap, {
	      compositeMode: this._compositeMode,
	      opacity: this.opacity
	    });
	  };

	  Element.prototype._fullDraw = function(targetSpaceDrawArea, target, elementToTargetMatrix) {
	    if (this._clip) {
	      return this._clipDraw(targetSpaceDrawArea, target, elementToTargetMatrix);
	    } else if (this._useStagingBitmap()) {
	      return this._drawWithStagingBitmap(targetSpaceDrawArea, target, elementToTargetMatrix);
	    } else {
	      return this._drawChildren(target, elementToTargetMatrix);
	    }
	  };

	  Element.prototype._clipDraw = function(clipArea, target, elementToTargetMatrix) {
	    if (!elementToTargetMatrix.getIsTranslateAndScaleOnly() || this._useStagingBitmap()) {
	      return this._clippedDrawWithStagingBitmapInElementSpace(target, elementToTargetMatrix);
	    } else {
	      return target.clippedTo(clipArea, (function(_this) {
	        return function() {
	          return _this._drawChildren(target, elementToTargetMatrix);
	        };
	      })(this));
	    }
	  };

	  Element.getter({
	    hasCustomClipping: function() {
	      return false;
	    }
	  });

	  Element.prototype.draw = function(target, elementToTargetMatrix) {
	    var targetSpaceDrawArea;
	    stats.elementsDrawn++;
	    try {
	      if (this.opacity < 1 / 256) {
	        return;
	      }
	      this._currentDrawTarget = target;
	      this._currentToTargetMatrix = elementToTargetMatrix;
	      targetSpaceDrawArea = this.drawAreaIn(elementToTargetMatrix).intersection(target.getClippingArea());
	      if (targetSpaceDrawArea.area > 0) {
	        return this._cachedFullDraw(targetSpaceDrawArea, target, elementToTargetMatrix);
	      }
	    } finally {
	      this._currentDrawTarget = this._currentToTargetMatrix = null;
	    }
	  };

	  Element.prototype.preCache = function() {
	    var child, j, len, ref, sum;
	    sum = 0;
	    if (this.getCacheDraw()) {
	      if (this._drawCacheBitmap) {

	      } else {
	        this._generateDrawCache();
	        sum++;
	      }
	    } else {
	      ref = this.getChildren();
	      for (j = 0, len = ref.length; j < len; j++) {
	        child = ref[j];
	        sum += child.preCache();
	      }
	    }
	    return sum;
	  };

	  Element.prototype.whenCached = function(callback) {
	    return this.getCanvasElement().queueDrawEpochPreprocessor((function(_this) {
	      return function() {
	        _this.preCache();
	        return drawEpoch.onNextReady(callback);
	      };
	    })(this));
	  };

	  Element.prototype._initDrawCache = function() {
	    this._drawCacheBitmap = null;
	    this._drawCacheBitmapInvalid = false;
	    this._elementDrawChangedThisFrame = true;
	    this._drawCacheToElementMatrix = null;
	    this._uncachableDrawCount = 0;
	    return this._cachableDrawCount = 0;
	  };

	  Element.prototype._drawPropertiesChanged = function() {
	    if (this._drawCacheBitmap) {
	      this._clearDrawCache();
	    }
	    return this._elementDrawChangedThisFrame = true;
	  };

	  Element.prototype._elementToParentMatrixChanged = function(oldElementToParentMatrix) {};

	  Element.prototype._needsRedrawing = function(descendant) {
	    var ref;
	    if (descendant == null) {
	      descendant = this;
	    }
	    if (this._drawCacheBitmap) {
	      this._clearDrawCache();
	    }
	    this._elementDrawChangedThisFrame = true;
	    if (this.getPendingVisible() && this.getPendingOpacity() > 1 / 512) {
	      return (ref = this.getPendingParent()) != null ? ref._needsRedrawing(descendant) : void 0;
	    }
	  };


	  /*
	  
	  When clearing drawCaching for this branch of the AIM, we stop recursing
	  down a sub-branch when we hit an existing drawCache. When a drawCache is
	  created, all its children's drawCaches are removed. Therefor when a
	  drawCache exists, all children are drawCache free.
	   */

	  Element.prototype.__clearDrawCacheCallbackFromDrawCacheManager = function() {
	    return this._drawCacheBitmap = null;
	  };

	  Element.prototype._clearDrawCache = function(force) {
	    if (this._cacheDraw === "locked") {
	      this._drawCacheBitmapInvalid = true;
	      return;
	    }
	    if (this._drawCacheBitmap) {
	      drawCacheManager.doneWithCacheBitmap(this);
	    }
	    return null;
	  };

	  Element.prototype._releaseAllCacheBitmaps = function() {
	    var child, count, j, len, ref;
	    count = 0;
	    if (this._drawCacheBitmap) {
	      drawCacheManager.doneWithCacheBitmap(this);
	      count++;
	    }
	    ref = this._children;
	    for (j = 0, len = ref.length; j < len; j++) {
	      child = ref[j];
	      count += child._releaseAllCacheBitmaps();
	    }
	    return count;
	  };

	  Element._drawCachingEnabled = drawCachingEnabled;

	  Element.prototype._generateDrawCache = function() {
	    var _drawCachingEnabled, cacheDrawArea, drawArea, pixelsPerPoint;
	    drawArea = this.getElementSpaceDrawArea().roundOut();
	    if (drawArea.getArea() <= 0) {
	      return;
	    }
	    pixelsPerPoint = this.getDevicePixelsPerPoint();
	    cacheDrawArea = drawArea.mul(pixelsPerPoint);
	    if (cacheDrawArea.size.area > 2048 * 768 * 2) {
	      return;
	    }
	    this._clearDrawCache();
	    this._drawCacheToElementMatrix = Matrix.translateXY(-drawArea.x, -drawArea.y).scale(pixelsPerPoint).inv;
	    if (!cacheAggressively) {
	      _drawCachingEnabled = Element._drawCachingEnabled;
	      Element._drawCachingEnabled = false;
	    }
	    globalEpochCycle.logEvent("generateDrawCache", "same-id");
	    this._drawCacheBitmap = this._renderStagingBitmap(cacheDrawArea, Matrix.scale(pixelsPerPoint), drawCacheManager.allocateCacheBitmap(this, cacheDrawArea.size));
	    this._drawCacheBitmapInvalid = false;
	    if (!cacheAggressively) {
	      return Element._drawCachingEnabled = _drawCachingEnabled;
	    }
	  };


	  /*
	  TODO:
	  
	    Support for "pixel-exact-caching":
	  
	      If @_useStagingBitmap() is true, we should cache even if _cacheDraw is false.
	  
	      NOTE: cached bitmaps are automatically released and recycled as needed, so over-caching
	        is only a question of overhead. In the case where we are going to generate
	        a staging bitmap ANYWAY, there IS no overhead - just keep the results around in case
	        we need it next time.
	  
	      HOWEVER, this is currently a problem because _generateDrawCache always generates
	      a cache bitmap at a fixed scale - the devicePixelsPerPoint.
	  
	      This can be very wrong. Example: With the Flashy Text-renderer in the Kimi-editor the rendered
	      resolution becomes rediculously low - 1/10th the desired resolution or so.
	  
	      So, we need the option to always cache in such a way that is pixel-exact with would would
	      have been output without caching. If the the draw-matrix changes in anyway other than whole
	      pixel translations then the cache should be invalidated and redrawn.
	  
	      We still want the current mode, which renders the draw-cache at the element's logical size
	      multipled by the devicePixelsPerPoint. This is faster, and often not a quality concern.
	  
	      Additional options:
	        We may add another option which lets of add a "cache-at" scale factor to force lower or
	        higher resolution caching.
	  
	        In the old C++ Art.Engine we had a global "fast" mode where caches were not invalidated under
	        any draw-matrix changes until fast-mode was turned off, then a final redraw pass was made
	        where pixel-inexact caches were invalidated and redrawn. This allowed good user interactivity
	        followed by maximum quality renders. This was handy for the more general-purpose Kimi-editor,
	        for for the current purpose-built kimi-editor, it isn't needed.
	   */

	  Element.prototype._generateDrawCacheIfNeeded = function() {
	    var _cacheDraw;
	    _cacheDraw = this._cacheDraw;
	    if (_cacheDraw && this._useStagingBitmap() && this._elementDrawChangedThisFrame) {
	      this._elementDrawChangedThisFrame = false;
	      this._generateDrawCache();
	      return true;
	    } else if (!_cacheDraw) {
	      if (this._drawCacheBitmap) {
	        this._clearDrawCache();
	      }
	      return false;
	    } else if (_cacheDraw === 'locked' && this._drawCacheBitmap) {
	      return false;
	    } else if (this._elementDrawChangedThisFrame && _cacheDraw === "auto") {
	      this._uncachableDrawCount++;
	      this._elementDrawChangedThisFrame = false;
	      return false;
	    } else {
	      this._cachableDrawCount++;
	      if ((!this._drawCacheBitmap || this._drawCacheBitmapInvalid) && Element._drawCachingEnabled && this.getCacheable() && (_cacheDraw !== "auto" || this._cachableDrawCount >= this._uncachableDrawCount)) {
	        this._generateDrawCache();
	        return true;
	      }
	    }
	  };

	  Element.prototype._cachedFullDraw = function(targetSpaceDrawArea, target, elementToTargetMatrix) {
	    var drawCacheToTargetMatrix;
	    this._generateDrawCacheIfNeeded();
	    if (this._drawCacheBitmap) {
	      drawCacheManager.useDrawCache(this);
	      drawCacheToTargetMatrix = this._drawCacheToElementMatrix.mul(elementToTargetMatrix);
	      return target.drawBitmap(drawCacheToTargetMatrix, this._drawCacheBitmap, {
	        opacity: this.opacity,
	        compositeMode: this.compositeMode
	      });
	    } else {
	      return this._fullDraw(targetSpaceDrawArea, target, elementToTargetMatrix);
	    }
	  };

	  Element.getter({
	    cacheable: function() {
	      return true;
	    }
	  });


	  /*
	  Creates and returns an bitmap with the current element drawn on it
	  options: [defaults]
	    backgroundColor: [transparent]  #
	    area: DEFAULT: "drawArea"
	      "logicalArea"         means => drawArea: @logicalArea,                  elementToDrawAreaMatrix: identityMatrix
	      "paddedArea"          means => drawArea: @paddedArea,                   elementToDrawAreaMatrix: identityMatrix
	      "drawArea"            means => drawArea: @elementSpaceDrawArea,         elementToDrawAreaMatrix: identityMatrix
	      "parentLogicalArea"   means => drawArea: @parent.logicalArea,           elementToDrawAreaMatrix: @elementToParentMatrix
	      "parentPaddedArea"    means => drawArea: @parent.paddedArea,            elementToDrawAreaMatrix: @elementToParentMatrix
	      "parentDrawArea"      means => drawArea: @parent.elementSpaceDrawArea,  elementToDrawAreaMatrix: @elementToParentMatrix
	      "targetDrawArea"    to be used with custom elementToDrawAreaMatrix - sets drawArea to include @elementSpaceDrawArea in the specificed target-space
	    size: [drawArea.size]     # Bitmap size. Will be multiplied by pixelsPerPoint for the final size.
	    mode: ["fit"], "zoom"     # determines how the requested drawArea is scaled to fit the bitmap size
	      "fit" - scaled so requested area is <= size
	        final size adjusted to have the same aspect ratio as the requested area
	      "zoom" - scaled so reqeusted area is >= size
	        size is not altered
	    pixelsPerPoint: [1]       # Ex: set to "2" for "retina" images [default = 1]
	    elementToDrawAreaMatrix:  # the draw matrix [see area's defaults]
	    drawArea: [see area]      # the area to capture in drawArea-space (overrides area's drawArea)
	    bitmapFactory: [null]     # overrides default bitmapFactory
	  
	  OUT promise.then ({bitmap, elementToBitmapMatrix}) ->
	   */

	  Element.prototype.toBitmap = function(options, callback) {
	    if (options == null) {
	      options = {};
	    }
	    if (callback) {
	      console.error("callback DEPRICATED; toBitmap returns Promise now");
	    }
	    if (options.elementSpaceDrawArea) {
	      throw new Error("elementSpaceDrawArea option depricated");
	    }
	    return new Promise((function(_this) {
	      return function(resolve) {
	        return stateEpoch.onNextReady(function() {
	          var results;
	          resolve(results = _this.toBitmapSync(options));
	          return typeof callback === "function" ? callback(results.bitmap, results.elementToBitmapMatrix) : void 0;
	        });
	      };
	    })(this));
	  };

	  Element.prototype.toBitmapSync = function(options) {
	    var areaOptions, backgroundColor, bitmap, bitmapFactory, drawArea, elementToBitmapMatrix, elementToDrawAreaMatrix, mode, oldBitmapFactory, pixelsPerPoint, ratio, scale, size;
	    if (options == null) {
	      options = {};
	    }
	    if (options.elementToDrawAreaMatrix && !options.area) {
	      options.area = "targetDrawArea";
	    }
	    areaOptions = (function() {
	      switch (options.area || "drawArea") {
	        case "logicalArea":
	          return {
	            drawArea: this.logicalArea,
	            elementToDrawAreaMatrix: identityMatrix
	          };
	        case "paddedArea":
	          return {
	            drawArea: this.paddedArea,
	            elementToDrawAreaMatrix: identityMatrix
	          };
	        case "drawArea":
	          return {
	            drawArea: this.elementSpaceDrawArea,
	            elementToDrawAreaMatrix: identityMatrix
	          };
	        case "parentLogicalArea":
	          return {
	            drawArea: this.parent.logicalArea,
	            elementToDrawAreaMatrix: this.elementToParentMatrix
	          };
	        case "parentPaddedArea":
	          return {
	            drawArea: this.parent.paddedArea,
	            elementToDrawAreaMatrix: this.elementToParentMatrix
	          };
	        case "parentDrawArea":
	          return {
	            drawArea: this.parent.elementSpaceDrawArea,
	            elementToDrawAreaMatrix: this.elementToParentMatrix
	          };
	        case "targetDrawArea":
	          return {
	            drawArea: this.drawAreaIn(options.elementToDrawAreaMatrix || identityMatrix),
	            elementToDrawAreaMatrix: identityMatrix
	          };
	        default:
	          throw new Error("invalid area option: " + options.area);
	      }
	    }).call(this);
	    options = merge(areaOptions, options);
	    drawArea = options.drawArea, elementToDrawAreaMatrix = options.elementToDrawAreaMatrix, size = options.size, mode = options.mode, bitmapFactory = options.bitmapFactory, pixelsPerPoint = options.pixelsPerPoint, backgroundColor = options.backgroundColor;
	    pixelsPerPoint || (pixelsPerPoint = 1);
	    mode || (mode = "fit");
	    size = point(size || drawArea.size).mul(pixelsPerPoint).ceil();
	    ratio = size.div(drawArea.size);
	    if (mode === "zoom") {
	      scale = ratio.max();
	    } else {
	      scale = ratio.min();
	      size = drawArea.size.mul(scale).ceil();
	    }
	    elementToBitmapMatrix = elementToDrawAreaMatrix.mul(Matrix.translate(drawArea.cc.neg).scale(scale).translate(size.cc));
	    oldBitmapFactory = this._bitmapFactory;
	    this._bitmapFactory = bitmapFactory || this.bitmapFactory;
	    bitmap = this.bitmapFactory.newBitmap(size);
	    bitmap.pixelsPerPoint = pixelsPerPoint;
	    if (backgroundColor) {
	      bitmap.clear(backgroundColor);
	    }
	    this.draw(bitmap, elementToBitmapMatrix);
	    this._bitmapFactory = oldBitmapFactory;
	    return {
	      bitmap: bitmap,
	      elementToBitmapMatrix: elementToBitmapMatrix
	    };
	  };

	  Element.prototype.logBitmap = function(options) {
	    if (options == null) {
	      options = {};
	    }
	    options.pixelsPerPoint || (options.pixelsPerPoint = this.devicePixelsPerPoint);
	    return this.toBitmap(options).then((function(_this) {
	      return function(arg) {
	        var bitmap;
	        bitmap = arg.bitmap;
	        return _this.log({
	          size: _this.currentSize,
	          location: _this.currentLocation,
	          size: _this.size,
	          location: _this.location,
	          elementToParentMatrix: _this.elementToParentMatrix,
	          bitmap: bitmap
	        });
	      };
	    })(this));
	  };

	  Element.prototype.fillShape = function(target, elementToTargetMatrix, options) {
	    if (options == null) {
	      options = {};
	    }
	  };

	  Element.prototype.strokeShape = function(target, elementToTargetMatrix, options) {
	    if (options == null) {
	      options = {};
	    }
	  };

	  Element.prototype.compositingChanged = function() {
	    return this.getOpacityChanged() || this.getCompositeModeChanged();
	  };

	  Element.getter({
	    redrawRequired: function() {
	      var _pendingState;
	      _pendingState = this._pendingState;
	      return this.__drawPropertiesChanged || (this._opacity !== _pendingState._opacity) || (this._compositeMode !== _pendingState._compositeMode) || (this._parent !== _pendingState._parent) || (!this._currentSize.eq(_pendingState._currentSize)) || (!this._elementToParentMatrix.eq(_pendingState._elementToParentMatrix));
	    }
	  });

	  Element.prototype._setChildrenOnly = function(c) {
	    this._pendingState._children = c;
	    this._elementChanged();
	    return c;
	  };

	  Element.prototype._setParentOnly = function(p) {
	    this._pendingState._parent = p;
	    this._elementChanged();
	    return p;
	  };

	  Element.prototype._getElementToParentMatrixForXY = function(pending, x, y, withScale, withParentSize) {
	    var _angle, _axis, _currentPadding, _currentSize, _elementToParentMatrix, _parent, _scale, axis, axisXInElementSpace, axisYInElementSpace, currentX, currentY, left, parentSize, ref, size, state, top;
	    ref = state = this.getState(pending), _currentPadding = ref._currentPadding, _currentSize = ref._currentSize, _axis = ref._axis, _scale = ref._scale, _angle = ref._angle, _elementToParentMatrix = ref._elementToParentMatrix;
	    if (withScale != null) {
	      _scale = withScale;
	    }
	    if (isFunction(_scale)) {
	      _parent = state._parent;
	      parentSize = withParentSize || _parent.getState(pending)._currentSize;
	      _scale = _scale(parentSize, _currentSize);
	    }
	    _scale = point(_scale);
	    left = _currentPadding.left, top = _currentPadding.top;
	    size = _currentSize;
	    axis = _axis;
	    axisXInElementSpace = axis.x * size.x - left;
	    axisYInElementSpace = axis.y * size.y - top;
	    if (this._locationLayoutDisabled) {
	      currentX = _elementToParentMatrix.transformX(axisXInElementSpace, axisYInElementSpace);
	      currentY = _elementToParentMatrix.transformY(axisXInElementSpace, axisYInElementSpace);
	      return _elementToParentMatrix.translate(x - currentX, y - currentY);
	    } else {
	      return (new Matrix).translateXY(-axisXInElementSpace, -axisYInElementSpace, true).scale(_scale, true).rotate(_angle, true).translateXY(x, y, true);
	    }
	  };

	  Element.prototype._setElementToParentMatrixFromLayout = function(l, parentSize) {
	    return this._setElementToParentMatrixFromLayoutXY(l.x, l.y, parentSize);
	  };

	  Element.prototype._setElementToParentMatrixFromLayoutXY = function(x, y, parentSize) {
	    var e2p;
	    if (this._locationLayoutDisabled) {
	      return;
	    }
	    e2p = this._getElementToParentMatrixForXY(true, x, y, null, parentSize);
	    if (!this._pendingState._elementToParentMatrix.eq(e2p)) {
	      this._pendingState._elementToParentMatrix = e2p;
	      this._elementChanged();
	    }
	    return this;
	  };

	  Element.prototype._sizeDirectlyEffectsDrawing = function() {
	    var c;
	    return ((c = this.getPendingChildren()) && c.length === 0) || this.getPendingClip();
	  };

	  Element.prototype._setSizeFromLayout = function(s) {
	    var x, y;
	    x = s.x, y = s.y;
	    if (!s.eq(this.getPendingCurrentSize())) {
	      this._pendingState._currentSize = s;
	      if (this._sizeDirectlyEffectsDrawing()) {
	        this.__drawPropertiesChanged = true;
	      }
	      this._elementChanged();
	      return s;
	    }
	  };

	  Element.prototype._setPaddingFromLayout = function(p) {
	    this._pendingState._currentPadding = p;
	    this._elementChanged();
	    return p;
	  };

	  Element.prototype._setMarginFromLayout = function(m) {
	    this._pendingState._currentMargin = m;
	    this._elementChanged();
	    return m;
	  };

	  Element.prototype._setElementToParentMatrixWithoutChangingLocation = function(m) {
	    var ax, axis, ay, o, size, x1, x2, y1, y2;
	    o = this._pendingState;
	    size = o._currentSize;
	    axis = o._axis;
	    ax = size.x * axis.x;
	    ay = size.y * axis.y;
	    x1 = o._elementToParentMatrix.transformX(ax, ay);
	    y1 = o._elementToParentMatrix.transformY(ax, ay);
	    x2 = m.transformX(ax, ay);
	    y2 = m.transformY(ax, ay);
	    return this.setElementToParentMatrix(m.translateXY(x1 - x2, y1 - y2));
	  };

	  Element.prototype.elementToElementMatrix = function(o) {
	    console.error("depricated: elementToElementMatrix - use getElementToElementMatrix");
	    if (o === this) {
	      return matrix();
	    } else {
	      return this.getElementToAbsMatrix().mul(o.getAbsToElementMatrix());
	    }
	  };

	  Element.prototype.elementToTargetMatrix = function(parentToTargetMatrix) {
	    console.error("depricated: elementToTargetMatrix - use getElementToTargetMatrix");
	    return this._elementToParentMatrix.mul(parentToTargetMatrix);
	  };

	  Element.prototype.getElementToElementMatrix = function(o) {
	    if (o === this) {
	      return matrix();
	    } else {
	      return this.getElementToAbsMatrix().mul(o.getAbsToElementMatrix());
	    }
	  };

	  Element.prototype.getElementToTargetMatrix = function(parentToTargetMatrix) {
	    return this._elementToParentMatrix.mul(parentToTargetMatrix);
	  };


	  /*
	  returns:
	    if ancestor is not an actual ancestor to v
	      @elementToAbsMatrix.transform v
	    else
	      ancestor.absToElementMatrix.transform @elementToAbsMatrix.transform v
	  performance:
	    only creates one object, the returned point, no matter how far away the ancestor is.
	   */

	  Element.prototype.transformToAncestorSpace = function(v, ancestor) {
	    var element, x, x1, y, y1;
	    x = v.x, y = v.y;
	    element = this;
	    while (element) {
	      x1 = element._elementToParentMatrix.transformX(x, y);
	      y1 = element._elementToParentMatrix.transformY(x, y);
	      x = x1;
	      y = y1;
	      element = element.parent;
	      if (element === ancestor) {
	        return point(x, y);
	      }
	    }
	    return null;
	  };

	  Element.prototype.transformToAncestorSpaceX = function(v, ancestor) {
	    var element, x, y;
	    if (isPoint(v)) {
	      x = v.x, y = v.y;
	    } else {
	      x = v;
	      y = 0;
	    }
	    element = this;
	    while (element) {
	      x = element._elementToParentMatrix.transformX(x, y);
	      y = element._elementToParentMatrix.transformY(x, y);
	      element = element.parent;
	      if (element === ancestor) {
	        return x;
	      }
	    }
	    return null;
	  };

	  Element.prototype.transformToAncestorSpaceY = function(v, ancestor) {
	    var element, x, y;
	    if (isPoint(v)) {
	      x = v.x, y = v.y;
	    } else {
	      x = 0;
	      y = v;
	    }
	    element = this;
	    while (element) {
	      x = element._elementToParentMatrix.transformX(x, y);
	      y = element._elementToParentMatrix.transformY(x, y);
	      element = element.parent;
	      if (element === ancestor) {
	        return y;
	      }
	    }
	    return null;
	  };

	  Element.prototype.pointInsideChildren = function(p) {
	    return !!(this._visible && !!this.childUnderPoint(this.getParentToElementMatrix().transform(p)));
	  };

	  Element.prototype.pointInside = function(p) {
	    var h, p2EM, padding, size, w, x, y;
	    return this._visible && !this.getIsMask() && (function() {
	      switch (this._receivePointerEvents) {
	        case "never":
	          return false;
	        case "passToChildren":
	          return this.pointInsideChildren(p);
	        case "inPaddedArea":
	          p2EM = this.getParentToElementMatrix();
	          size = this._currentSize;
	          padding = this._currentPadding;
	          x = p2EM.transformX(p.x, p.y);
	          y = p2EM.transformY(p.x, p.y);
	          w = size.x - padding.getWidth();
	          h = size.y - padding.getHeight();
	          return x >= 0 && y >= 0 && x < w && y < h;
	        case "inLogicalArea":
	          p2EM = this.getParentToElementMatrix();
	          size = this._currentSize;
	          padding = this._currentPadding;
	          x = p2EM.transformX(p.x, p.y);
	          y = p2EM.transformY(p.x, p.y);
	          x += padding.left;
	          y += padding.top;
	          w = size.x;
	          h = size.y;
	          return x >= 0 && y >= 0 && x < w && y < h;
	      }
	    }).call(this);
	  };

	  Element.prototype.childUnderPoint = function(pointInElementSpace) {
	    var child, j, ref;
	    ref = this._children;
	    for (j = ref.length - 1; j >= 0; j += -1) {
	      child = ref[j];
	      if (child.pointInside(pointInElementSpace)) {
	        return child;
	      }
	    }
	    return false;
	  };

	  Element.prototype.drawAreaIn = function(elementToTargetMatrix) {
	    return elementToTargetMatrix.transformBoundingRect(this.getElementSpaceDrawArea());
	  };

	  Element.prototype._computeElementSpaceDrawArea = function(upToChild) {
	    var child, children, elementSpaceChildDrawArea, elementSpaceDrawArea, j, len;
	    if ((children = this.getPendingChildren()).length > 0 && !this.getPendingClip()) {
	      elementSpaceDrawArea = rect();
	      for (j = 0, len = children.length; j < len; j++) {
	        child = children[j];
	        if (child === upToChild) {
	          break;
	        }
	        elementSpaceChildDrawArea = child.getParentSpaceDrawArea();
	        switch (child.compositeMode) {
	          case "alphaMask":
	            elementSpaceChildDrawArea.intersectInto(elementSpaceDrawArea);
	            break;
	          case "sourceIn":
	          case "targetAlphaMask":
	          case "inverseAlphaMask":
	            null;
	            break;
	          case "normal":
	          case "add":
	          case "replace":
	          case "destOver":
	            elementSpaceChildDrawArea.unionInto(elementSpaceDrawArea);
	            break;
	          default:
	            throw new Error("unknown compositeMode:" + child.compositeMode);
	        }
	      }
	      return elementSpaceDrawArea;
	    } else {

	      /*
	      TODO: should we find out if we even actually need "pending"?
	      
	      Someday parent layout will have the option to be relative to children's draw area.
	      Probably also the case that children could be relative to parent's draw area.
	      
	      USE-CASE: Imikimi's Font effects - fills need to, say, cover all of an outline
	        which requires them to cover the outline's drawarea
	       */
	      return this.getPendingBaseDrawArea();
	    }
	  };

	  Element.prototype._drawAreaChanged = function() {
	    var p;
	    if (this._elementSpaceDrawArea) {
	      this._elementSpaceDrawArea = null;
	      if (p = this.getPendingParent()) {
	        return p._childsDrawAreaChanged();
	      }
	    }
	  };

	  Element.prototype._childsDrawAreaChanged = function() {
	    if (!this.getPendingClip()) {
	      return this._drawAreaChanged();
	    }
	  };

	  Element.prototype.getChildIndex = function(child, pending) {
	    return this.getChildren(pending).indexOf(child);
	  };

	  Element.prototype.find = function(pattern, arg, matches) {
	    var child, findAll, functionResult, j, len, matchAgainst, matchFound, ref, ref1, usedFunction, verbose;
	    ref = arg != null ? arg : {}, findAll = ref.findAll, verbose = ref.verbose;
	    if (matches == null) {
	      matches = [];
	    }
	    matchFound = (usedFunction = isFunction(pattern)) ? !!(functionResult = pattern(this)) : (matchAgainst = "" + this.pathStringWithNames + (this.key ? ":" + this.key : "") + ":" + this.objectId, matchAgainst.match(pattern));
	    if (matchFound) {
	      if (verbose) {
	        this.log(usedFunction ? {
	          found: this.inspectedNameWithoutIds,
	          functionResult: functionResult
	        } : {
	          found: this.inspectedNameWithoutIds,
	          pattern: pattern,
	          matched: matchAgainst
	        });
	      }
	      matches.push(this);
	    }
	    if (!matchFound || findAll) {
	      ref1 = this._children;
	      for (j = 0, len = ref1.length; j < len; j++) {
	        child = ref1[j];
	        child.find(pattern, arguments[1], matches);
	      }
	    }
	    return matches;
	  };

	  Element.prototype.findElementsWithKey = function(key) {
	    return this.find(function(e) {
	      return e.key === key;
	    });
	  };

	  Element.prototype.findElementWithKey = function(key) {
	    var first;
	    first = this.findElementsWithKey(key)[0];
	    return first;
	  };

	  Element.getter({
	    elementPath: function() {
	      if (this.parent) {
	        return this.parent.elementPath + " > " + this.classPathNameAndId;
	      } else {
	        return this.classPathNameAndId;
	      }
	    },
	    elementPathWithoutIds: function() {
	      if (this.parent) {
	        return this.parent.elementPath + " > " + this.classPathNameAndId;
	      } else {
	        return this.classPathNameAndId;
	      }
	    },
	    topMostParent: function() {
	      if (this._parent) {
	        return this._parent.topMostParent || this._parent;
	      } else {
	        return null;
	      }
	    },
	    hasChildren: function() {
	      return this._children.length > 0;
	    },
	    reverseChildren: function() {
	      return this._children.slice().reverse();
	    },
	    childrenMap: function() {
	      return (new Map).tap((function(_this) {
	        return function(map) {
	          var child, j, len, ref, results1;
	          ref = _this._children;
	          results1 = [];
	          for (j = 0, len = ref.length; j < len; j++) {
	            child = ref[j];
	            results1.push(map.set(child, true));
	          }
	          return results1;
	        };
	      })(this));
	    },
	    elementPath: function() {
	      var elementPath;
	      if (this.parent) {
	        elementPath = this.parent.elementPath;
	        elementPath.push(this);
	        return elementPath;
	      } else {
	        return [this];
	      }
	    },
	    pathIdString: function() {
	      var p;
	      return ((function() {
	        var j, len, ref, results1;
	        ref = this.elementPath;
	        results1 = [];
	        for (j = 0, len = ref.length; j < len; j++) {
	          p = ref[j];
	          results1.push(p.className + p.objectId);
	        }
	        return results1;
	      }).call(this)).join('/');
	    },
	    pathString: function() {
	      var p;
	      return ((function() {
	        var j, len, ref, results1;
	        ref = this.elementPath;
	        results1 = [];
	        for (j = 0, len = ref.length; j < len; j++) {
	          p = ref[j];
	          results1.push(p.className);
	        }
	        return results1;
	      }).call(this)).join('/');
	    },
	    pathStringWithNames: function() {
	      var p;
	      return ((function() {
	        var j, len, ref, results1;
	        ref = this.elementPath;
	        results1 = [];
	        for (j = 0, len = ref.length; j < len; j++) {
	          p = ref[j];
	          results1.push(p.inspectedNameWithoutIds);
	        }
	        return results1;
	      }).call(this)).join('/');
	    },
	    fullPathString: function() {
	      var p;
	      return ((function() {
	        var j, len, ref, results1;
	        ref = this.elementPath;
	        results1 = [];
	        for (j = 0, len = ref.length; j < len; j++) {
	          p = ref[j];
	          results1.push(p.classPathNameAndId);
	        }
	        return results1;
	      }).call(this)).join('/');
	    },
	    childrenInspectedNames: function() {
	      var c, j, len, ref, results1;
	      ref = this._children;
	      results1 = [];
	      for (j = 0, len = ref.length; j < len; j++) {
	        c = ref[j];
	        results1.push(c.inspectedName);
	      }
	      return results1;
	    },
	    inspectedObjects: function() {
	      var child;
	      return [inspectedObjectLiteral(this.inspectedName), this.minimalProps].concat((function() {
	        var j, len, ref, results1;
	        ref = this.children;
	        results1 = [];
	        for (j = 0, len = ref.length; j < len; j++) {
	          child = ref[j];
	          results1.push(child.inspectedObjects);
	        }
	        return results1;
	      }).call(this));
	    }
	  });

	  childrenWithout = function(children, child) {
	    var index;
	    children = children.slice();
	    if ((index = children.indexOf(child)) >= 0) {
	      remove(children, index, 1);
	    }
	    return children;
	  };

	  Element.prototype.childrenWithout = function(child) {
	    return childrenWithout(this._children, child);
	  };

	  Element.prototype.pendingChildrenWithout = function(child) {
	    return childrenWithout(this.getPendingChildren(), child);
	  };

	  Element.prototype.insertChild = function(child, index) {
	    var children;
	    children = this.pendingChildrenWithout(child);
	    if (index < 0) {
	      index = children.length + 1 + index;
	    }
	    this.setChildren(insert(children, index, child));
	    return child;
	  };

	  Element.prototype.addChild = function(child) {
	    return this.insertChild(child, -1);
	  };

	  Element.prototype.addChildBelow = function(child, belowChild) {
	    var children;
	    if (!(belowChild !== child && indexOf.call(this.getPendingChildren(), belowChild) >= 0)) {
	      return this.insertChild(child, 0);
	    }
	    children = this.pendingChildrenWithout(child);
	    this.setChildren(insert(children, children.indexOf(belowChild), child));
	    return child;
	  };

	  Element.prototype.addChildAbove = function(child, aboveChild) {
	    var children;
	    if (!(aboveChild !== child && indexOf.call(this.getPendingChildren(), aboveChild) >= 0)) {
	      return this.insertChild(child, -1);
	    }
	    children = this.pendingChildrenWithout(child);
	    this.setChildren(insert(children, children.indexOf(aboveChild) + 1, child));
	    return child;
	  };

	  Element.prototype.addBelow = function(sibling) {
	    return sibling.getPendingParent().addChildBelow(this, sibling);
	  };

	  Element.prototype.addAbove = function(sibling) {
	    return sibling.getPendingParent().addChildAbove(this, sibling);
	  };

	  Element.prototype.addChildBelowMask = function(child) {
	    return this.addChildBelow(child, this.getPendingFirstMask());
	  };

	  Element.prototype.placeRelativeToSibling = function(siblingOrPair, offset) {
	    var children, parent, sibling;
	    if (siblingOrPair && siblingOrPair.constructor === Array) {
	      if (siblingOrPair.length !== 2) {
	        throw new Error("If array is provided, it must be formated: [parent, sibling]");
	      }
	      parent = siblingOrPair[0], sibling = siblingOrPair[1];
	      if (sibling && sibling.getPendingParent() !== parent) {
	        throw new Error("Sibling's current parent does not match specified parent. Did the sibling move?");
	      }
	    } else {
	      sibling = siblingOrPair;
	      parent = (sibling != null ? sibling.getPendingParent() : void 0) || this.getPendingParent();
	    }
	    if (!parent) {
	      if (!sibling) {
	        return this.setParent(null);
	      } else {
	        throw new Error("Can't place next to sibling. Sibling is an orphan.");
	      }
	    }
	    children = parent.pendingChildrenWithout(this);
	    return parent.setChildren(insert(children, children.indexOf(sibling) + offset, this));
	  };

	  Element.prototype.removeChild = function(child) {
	    if (!child) {
	      return;
	    }
	    this.setChildren(this.pendingChildrenWithout(child));
	    return child;
	  };

	  Element.prototype.releaseChildren = function() {
	    return this.setChildren([]);
	  };

	  Element.prototype.removeFromParent = function() {
	    var p, ref;
	    if ((ref = (p = this.getPendingParent())) != null) {
	      ref.removeChild(this);
	    }
	    return p;
	  };

	  Element.prototype.moveChildToFront = function(child) {
	    return this.insertChild(child, -1);
	  };

	  Element.prototype.moveChildToBack = function(child) {
	    return this.insertChild(child, 0);
	  };

	  Element.prototype.moveToFront = function() {
	    var ref;
	    return (ref = this.getPendingParent()) != null ? ref.insertChild(this, -1) : void 0;
	  };

	  Element.prototype.moveToBack = function() {
	    var ref;
	    return (ref = this.getPendingParent()) != null ? ref.insertChild(this, 0) : void 0;
	  };

	  Element.prototype.moveBelow = function(sibling) {
	    var ref;
	    return sibling != null ? (ref = sibling.getPendingParent()) != null ? ref.addChildBelow(this, sibling) : void 0 : void 0;
	  };

	  Element.prototype.moveBelowMask = function() {
	    var ref;
	    return (ref = this.getPendingParent()) != null ? ref.addChildBelowMask(this) : void 0;
	  };

	  Element.prototype._sizeChanged = function(newSize, oldSize) {
	    return this.queueEvent("sizeChanged", {
	      oldSize: oldSize,
	      size: newSize
	    });
	  };

	  Element.prototype._applyStateChanges = function() {
	    var oldElementToParentMatrix, releaseCount;
	    if (this.getCurrentSizeChanged()) {
	      this._sizeChanged(this._pendingState._currentSize, this._currentSize);
	    }
	    if (this.getElementToParentMatrixChanged()) {
	      oldElementToParentMatrix = this._elementToParentMatrix;
	    }
	    Element.__super__._applyStateChanges.apply(this, arguments);
	    if (this.__drawAreaChanged) {
	      this._drawAreaChanged();
	    }
	    if (this.__drawPropertiesChanged) {
	      this._drawPropertiesChanged();
	    }
	    if (oldElementToParentMatrix) {
	      this._elementToParentMatrixChanged(oldElementToParentMatrix);
	    }
	    this.__drawAreaChanged = false;
	    this.__redrawRequired = false;
	    this.__drawPropertiesChanged = false;
	    this.__layoutPropertiesChanged = false;
	    if (!this._parent) {
	      return releaseCount = this._releaseAllCacheBitmaps();
	    }
	  };

	  Element.prototype._layoutPropertiesChanged = function() {};

	  Element.prototype._updateDrawArea = function() {};

	  Element.prototype._layoutSize = function(parentSize, childrenSize) {
	    return this.getPendingSize().layout(parentSize, childrenSize);
	  };

	  Element.prototype._layoutSizeForChildren = function(parentSize, childrenSize) {
	    var out, sizeLayout, x, y;
	    sizeLayout = this.getPendingSize();
	    out = sizeLayout.layout(parentSize, childrenSize);
	    if (sizeLayout.getChildrenRelative()) {
	      x = out.x, y = out.y;
	      return out["with"](isInfiniteResult(x) ? parentSize.x : x, isInfiniteResult(y) ? parentSize.y : y);
	    } else {
	      return out;
	    }
	  };

	  Element.prototype._layoutLocation = function(parentSize) {
	    return this.getPendingLocation().layout(parentSize);
	  };

	  Element.prototype._layoutLocationX = function(parentSize) {
	    return this.getPendingLocation().layoutX(parentSize);
	  };

	  Element.prototype._layoutLocationY = function(parentSize) {
	    return this.getPendingLocation().layoutY(parentSize);
	  };

	  Element.prototype._sizeForChildren = function(size) {
	    return this.getPendingCurrentPadding().subtractedFromSize(size);
	  };

	  Element.prototype.depth = function() {
	    if (this.parent) {
	      return this.parent.depth() + 1;
	    } else {
	      return 1;
	    }
	  };

	  Element.getter({
	    focused: function() {
	      var c;
	      return !!((c = this.getCanvasElement()) && c.isFocused(this));
	    }
	  });

	  Element.prototype._focus = function() {
	    var ref;
	    return (ref = this.getCanvasElement()) != null ? ref.focusElement(this) : void 0;
	  };

	  Element.prototype._blur = function() {
	    var ref;
	    if (!this.focused) {
	      return;
	    }
	    return (ref = this.getCanvasElement()) != null ? ref.focusElement(this.parent) : void 0;
	  };

	  Element.prototype.focus = function() {
	    var ref;
	    if ((ref = this.getCanvasElement()) != null) {
	      ref.focusCanvas();
	    }
	    return this._focus();
	  };

	  Element.prototype.blur = function() {
	    return this._blur();
	  };

	  Element.prototype.capturePointerEvents = function() {
	    var ref;
	    return (ref = this.getCanvasElement()) != null ? ref.capturePointerEvents(this) : void 0;
	  };

	  Element.getter({
	    pointerEventsCaptured: function() {
	      var ref;
	      return (ref = this.getCanvasElement()) != null ? ref.pointerEventsCapturedBy(this) : void 0;
	    }
	  });

	  return Element;

	})(ElementBase));


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	Useful ideas about optimizing animations and garbage collection: http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html

	See Foundation.Transaction for most constructor options.

	from-values are either explicitly specified in the constructor, or any other properties defined
	  in the constructor will have their from-values saved during construction.

	The animation is automatically started on construction UNLESS there are no to-values.
	If there are no to-values specified, then you must manually, later, call "start". At that point, all to-values
	are set to the current values.
	 */
	var Animator, BaseObject, Color, EasingFunctions, Event, EventEpoch, EventedMixin, Matrix, Point, Rectangle, Transaction, currentSecond, eventEpoch, inspect, inspectLean, log, matrix, max, min, point, rect, ref, ref1, ref2, rgbColor,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(19), currentSecond = ref.currentSecond, min = ref.min, max = ref.max, Transaction = ref.Transaction, inspect = ref.inspect, inspectLean = ref.inspectLean, log = ref.log, BaseObject = ref.BaseObject;

	ref1 = __webpack_require__(125), rgbColor = ref1.rgbColor, Color = ref1.Color, point = ref1.point, Point = ref1.Point, rect = ref1.rect, Rectangle = ref1.Rectangle, matrix = ref1.matrix, Matrix = ref1.Matrix;

	ref2 = __webpack_require__(168), Event = ref2.Event, EventEpoch = ref2.EventEpoch, EventedMixin = ref2.EventedMixin;

	EasingFunctions = __webpack_require__(186);

	eventEpoch = EventEpoch.eventEpoch;

	module.exports = Animator = (function(superClass) {
	  extend(Animator, superClass);

	  Animator.animate = function(objects, options) {
	    return new Animator(objects, options);
	  };

	  function Animator(objects, options) {
	    if (options == null) {
	      options = {};
	    }
	    Animator.__super__.constructor.apply(this, arguments);
	    this.transaction = new Transaction(objects, options);
	    this.fixedStep = options.fixedStep;
	    if (this.fixedStep && this.fixedStep <= 0) {
	      throw new Error("fixedStep must be > 0");
	    }
	    this.duration = options.duration || 0.25;
	    this.f = options.f;
	    if (!this.f) {
	      this.f = EasingFunctions[this.fName = "easeInQuad"];
	    } else if (typeof this.f === "string") {
	      this.fName = this.f;
	      this.f = EasingFunctions[this.f];
	    } else {
	      this.fName = "custom";
	    }
	    if (options.on) {
	      this.on(options.on);
	    }
	    this.then = options.then;
	    this.start();
	  }

	  Animator.prototype.inspect = function(inspector) {
	    inspector.put(this.classPathName);
	    inspector.put(" duration: " + this.duration + ", function: " + this.fName);
	    if (this.activated) {
	      inspector.put(", activated, frames: " + this.frames + ", pos: " + this.pos);
	    }
	    if (this.aborted) {
	      inspector.put(", aborted");
	    }
	    if (this.deactivated) {
	      inspector.put(", deactivated");
	    }
	    return this.transaction.inspectParts(inspector);
	  };

	  Animator.prototype.abort = function() {
	    if (!this.aborted) {
	      eventEpoch.logEvent("animationAborted", this.getObjectId());
	      this.aborted = true;
	      this.deactivateAnimation();
	      return this.queueEvent("abort");
	    }
	  };

	  Animator.prototype.start = function() {
	    this.transaction.saveFromValues();
	    this.transaction.saveToValues();
	    this.transaction.optimize();
	    this.updateValues(0);
	    this.activateAnimation();
	    this.frames = 0;
	    return eventEpoch.queue((function(_this) {
	      return function() {
	        if (_this.deactivated) {
	          return;
	        }
	        _this.updateValues(0);
	        eventEpoch.logEvent("animation", _this.getObjectId());
	        _this.startTime = currentSecond();
	        _this.queueEvent("start");
	        return eventEpoch.queue(function() {
	          return _this.advance();
	        });
	      };
	    })(this));
	  };

	  Animator.prototype.finish = function() {
	    this.updateValues(1);
	    return this.done();
	  };

	  Animator.getter({
	    pos: function() {
	      if (this.fixedStep) {
	        return this.frames * this.fixedStep;
	      } else {
	        return (this.now - this.startTime) / this.duration;
	      }
	    },
	    objects: function() {
	      return this.transaction.objects;
	    }
	  });

	  Animator.prototype.activateAnimation = function() {
	    var animatedObject, i, len, ref3, results;
	    if (this.activated) {
	      return;
	    }
	    this.activated = true;
	    ref3 = this.objects;
	    results = [];
	    for (i = 0, len = ref3.length; i < len; i++) {
	      animatedObject = ref3[i];
	      if (animatedObject._activeAnimator) {
	        animatedObject._activeAnimator.abort();
	      }
	      results.push(animatedObject._activeAnimator = this);
	    }
	    return results;
	  };

	  Animator.prototype.deactivateAnimation = function() {
	    var animatedObject, i, len, ref3, results;
	    if (this.deactivated) {
	      return;
	    }
	    this.deactivated = true;
	    ref3 = this.objects;
	    results = [];
	    for (i = 0, len = ref3.length; i < len; i++) {
	      animatedObject = ref3[i];
	      if (animatedObject._activeAnimator !== this) {
	        this.log("INTERNAL WARNING - animatedObject._activeAnimator should == @");
	        this.log("  animatedObject: (" + (inspect(animatedObject, 1)));
	        this.log("  animatedObject._activeAnimator: (" + (inspect(animatedObject._activeAnimator, 1)));
	        this.log("  @: (" + (inspect(this, 1)));
	      }
	      results.push(delete animatedObject._activeAnimator);
	    }
	    return results;
	  };

	  Animator.prototype.advance = function() {
	    var pos;
	    if (this.aborted || this.deactivated) {
	      return;
	    }
	    this.frames++;
	    this.now = currentSecond();
	    pos = this.pos;
	    if (pos < 1) {
	      this.updateValues(this.f(pos));
	      return eventEpoch.queue((function(_this) {
	        return function() {
	          return _this.advance();
	        };
	      })(this));
	    } else {
	      this.updateValues(1);
	      return this.done();
	    }
	  };

	  Animator.prototype.done = function() {
	    if (this.aborted) {
	      return;
	    }
	    eventEpoch.logEvent("animation", this.getObjectId());
	    this.deactivateAnimation();
	    this.queueEvent("done");
	    return this.nextAnimation();
	  };

	  Animator.prototype.nextAnimation = function() {
	    var objects;
	    if (!this.then) {
	      return;
	    }
	    objects = this.then.objects || this.then.object || this.objects;
	    return new Animator(objects, this.then);
	  };

	  Animator.prototype.updateValues = function(p) {
	    this.transaction.interpolate(p);
	    return this.queueEvent("update", {
	      p: p
	    });
	  };

	  return Animator;

	})(EventedMixin(BaseObject));


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = ((function(_this) {
	  return function() {
	    var EasingFunctions;
	    return EasingFunctions = (function() {
	      function EasingFunctions() {}

	      EasingFunctions.linear = function(t) {
	        return t;
	      };

	      EasingFunctions.easeOutQuad = function(t) {
	        return t * t;
	      };

	      EasingFunctions.easeInQuad = function(t) {
	        return -t * (t - 2);
	      };

	      EasingFunctions.easeBothQuad = function(t) {
	        if (t < .5) {
	          return EasingFunctions.easeOutQuad(t * 2) * .5;
	        } else {
	          return EasingFunctions.easeInQuad(t * 2 - 1) * .5 + .5;
	        }
	      };

	      EasingFunctions.easeOutCubic = function(t) {
	        return t * t * t;
	      };

	      EasingFunctions.easeInCubic = function(t) {
	        return (t = t - 1) * t * t + 1;
	      };

	      EasingFunctions.easeBothCubic = function(t) {
	        if (t < .5) {
	          return EasingFunctions.easeOutCubic(t * 2) * .5;
	        } else {
	          return EasingFunctions.easeInCubic(t * 2 - 1) * .5 + .5;
	        }
	      };

	      EasingFunctions.easeOutQuart = function(t) {
	        return t * t * t * t;
	      };

	      EasingFunctions.easeInQuart = function(t) {
	        return -((t = t - 1) * t * t * t - 1);
	      };

	      EasingFunctions.easeBothQuart = function(t) {
	        if (t < .5) {
	          return EasingFunctions.easeOutQuart(t * 2) * .5;
	        } else {
	          return EasingFunctions.easeInQuart(t * 2 - 1) * .5 + .5;
	        }
	      };

	      EasingFunctions.easeOutQuint = function(t) {
	        return 1 * t * t * t * t * t;
	      };

	      EasingFunctions.easeInQuint = function(t) {
	        return 1 * ((t = t - 1) * t * t * t * t + 1);
	      };

	      EasingFunctions.easeBothQuint = function(t) {
	        if (t < .5) {
	          return EasingFunctions.easeOutQuint(t * 2) * .5;
	        } else {
	          return EasingFunctions.easeInQuint(t * 2 - 1) * .5 + .5;
	        }
	      };

	      EasingFunctions.easeOutSine = function(t) {
	        return -Math.cos(t * Math.PI / 2) + 1;
	      };

	      EasingFunctions.easeInSine = function(t) {
	        return Math.sin(t * Math.PI / 2);
	      };

	      EasingFunctions.easeBothSine = function(t) {
	        return -.5 * (Math.cos(Math.PI * t) - 1);
	      };

	      EasingFunctions.easeOutExp = function(t) {
	        if (t <= 0) {
	          return 0;
	        } else {
	          return Math.pow(2, 10 * (t - 1));
	        }
	      };

	      EasingFunctions.easeInExp = function(t) {
	        if (t >= 1) {
	          return 1;
	        } else {
	          return -Math.pow(2, -10 * t) + 1;
	        }
	      };

	      EasingFunctions.easeBothExp = function(t) {
	        if (t < .5) {
	          return EasingFunctions.easeOutExp(t * 2) * .5;
	        } else {
	          return EasingFunctions.easeInExp(t * 2 - 1) * .5 + .5;
	        }
	      };

	      EasingFunctions.easeOutCirc = function(t) {
	        return -(Math.sqrt(1 - t * t) - 1);
	      };

	      EasingFunctions.easeInCirc = function(t) {
	        return Math.sqrt(1 - (t -= 1) * t);
	      };

	      EasingFunctions.easeBothCirc = function(t) {
	        if (t < .5) {
	          return EasingFunctions.easeOutCirc(t * 2) * .5;
	        } else {
	          return EasingFunctions.easeInCirc(t * 2 - 1) * .5 + .5;
	        }
	      };

	      EasingFunctions.easeOutElastic = function(t) {
	        var p, s;
	        if (t <= 0) {
	          return 0;
	        }
	        if (t >= 1) {
	          return 1;
	        }
	        p = .3;
	        s = p / 4;
	        t -= 1;
	        return -Math.pow(2, 10 * t) * Math.sin((t - s) * (2 * Math.PI) / p);
	      };

	      EasingFunctions.easeInElastic = function(t) {
	        var p, s;
	        if (t <= 0) {
	          return 0;
	        }
	        if (t >= 1) {
	          return 1;
	        }
	        p = .3;
	        s = p / 4;
	        return Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
	      };

	      EasingFunctions.easeBothElastic = function(t) {
	        if (t < .5) {
	          return EasingFunctions.easeOutElastic(t * 2) * .5;
	        } else {
	          return EasingFunctions.easeInElastic(t * 2 - 1) * .5 + .5;
	        }
	      };

	      EasingFunctions.easeOutBack = function(t, s) {
	        if (s == null) {
	          s = 1.70158;
	        }
	        return t * t * ((s + 1) * t - s);
	      };

	      EasingFunctions.easeInBack = function(t, s) {
	        if (s == null) {
	          s = 1.70158;
	        }
	        return (t = t - 1) * t * ((s + 1) * t + s) + 1;
	      };

	      EasingFunctions.easeBothBack = function(t, s) {
	        if (t < .5) {
	          return EasingFunctions.easeOutBack(t * 2) * .5;
	        } else {
	          return EasingFunctions.easeInBack(t * 2 - 1) * .5 + .5;
	        }
	      };

	      EasingFunctions.easeOutBounce = function(t) {
	        return 1 - EasingFunctions.easeInBounce(1 - t);
	      };

	      EasingFunctions.easeInBounce = function(t) {
	        if (t < 1 / 2.75) {
	          return 7.5625 * t * t;
	        } else if (t < 2 / 2.75) {
	          return 7.5625 * (t -= 1.5 / 2.75) * t + .75;
	        } else if (t < 2.5 / 2.75) {
	          return 7.5625 * (t -= 2.25 / 2.75) * t + .9375;
	        } else {
	          return 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	        }
	      };

	      EasingFunctions.easeBothBounce = function(t) {
	        if (t < .5) {
	          return EasingFunctions.easeOutBounce(t * 2) * .5;
	        } else {
	          return EasingFunctions.easeInBounce(t * 2 - 1) * .5 + .5;
	        }
	      };

	      return EasingFunctions;

	    })();
	  };
	})(this)), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(188).addModules({
	  InterpolatedPointLayout: __webpack_require__(189),
	  PointLayoutBase: __webpack_require__(190),
	  PointLayout: __webpack_require__(191)
	});


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var Engine, Layout,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Engine = __webpack_require__(154);

	module.exports = Engine.Layout || Engine.addNamespace('Layout', Layout = (function(superClass) {
	  extend(Layout, superClass);

	  function Layout() {
	    return Layout.__super__.constructor.apply(this, arguments);
	  }

	  return Layout;

	})(Neptune.Base));


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, InterpolatedPointLayout, PointLayoutBase, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	PointLayoutBase = __webpack_require__(190);

	log = Foundation.log;

	module.exports = InterpolatedPointLayout = (function(superClass) {
	  var interpolate1D;

	  extend(InterpolatedPointLayout, superClass);

	  PointLayoutBase.InterpolatedPointLayout = InterpolatedPointLayout;

	  function InterpolatedPointLayout(layout1, layout2, p) {
	    InterpolatedPointLayout.__super__.constructor.apply(this, arguments);
	    this.layout1 = layout1;
	    this.layout2 = layout2;
	    this.p = p;
	    this._hasXLayout = this.layout1._hasXLayout || !this.layout2._hasXLayout;
	    this._hasYLayout = this.layout1._hasYLayout || !this.layout2._hasYLayout;
	    this._xRelativeToParentW = this.layout1._xRelativeToParentW || this.layout2._xRelativeToParentW;
	    this._xRelativeToParentH = this.layout1._xRelativeToParentH || this.layout2._xRelativeToParentH;
	    this._yRelativeToParentW = this.layout1._yRelativeToParentW || this.layout2._yRelativeToParentW;
	    this._yRelativeToParentH = this.layout1._yRelativeToParentH || this.layout2._yRelativeToParentH;
	    this._xRelativeToChildrenW = this.layout1._xRelativeToChildrenW || this.layout2._xRelativeToChildrenW;
	    this._xRelativeToChildrenH = this.layout1._xRelativeToChildrenH || this.layout2._xRelativeToChildrenH;
	    this._yRelativeToChildrenW = this.layout1._yRelativeToChildrenW || this.layout2._yRelativeToChildrenW;
	    this._yRelativeToChildrenH = this.layout1._yRelativeToChildrenH || this.layout2._yRelativeToChildrenH;
	    this.layoutX = function(ps, cs) {
	      return interpolate1D(p, layout1._hasXLayout, layout2._hasXLayout, layout1.layoutX(ps, cs), layout2.layoutX(ps, cs));
	    };
	    this.layoutY = function(ps, cs) {
	      return interpolate1D(p, layout1._hasYLayout, layout2._hasYLayout, layout1.layoutY(ps, cs), layout2.layoutY(ps, cs));
	    };
	  }

	  InterpolatedPointLayout.prototype.toString = function() {
	    return "InterpolatedPointLayout(from: (" + (this.layout1.toStringLean()) + "), to: (" + (this.layout2.toStringLean()) + "), " + (this.p * 100 | 0) + "%)";
	  };

	  InterpolatedPointLayout.getter({
	    inspectedString: function() {
	      return this.toString();
	    }
	  });

	  InterpolatedPointLayout.prototype.inspect = function() {
	    return this.toString();
	  };

	  InterpolatedPointLayout.interpolate1D = interpolate1D = function(p, hasFrom, hasTo, from, to) {
	    if (hasFrom) {
	      if (hasTo) {
	        return (to - from) * p + from;
	      } else {
	        return from;
	      }
	    } else {
	      return to;
	    }
	  };

	  return InterpolatedPointLayout;

	})(PointLayoutBase);


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, BaseObject, Foundation, Point, PointLayoutBase, inspect, inspectedObjectLiteral, isFunction, isNumber, isPlainObject, log, nearInfinity, nearInfinityResult, point, point0,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Atomic = __webpack_require__(125);

	Foundation = __webpack_require__(19);

	point = Atomic.point, Point = Atomic.Point;

	point0 = Point.point0;

	BaseObject = Foundation.BaseObject, log = Foundation.log, inspect = Foundation.inspect, isFunction = Foundation.isFunction, isNumber = Foundation.isNumber, isPlainObject = Foundation.isPlainObject, nearInfinity = Foundation.nearInfinity, nearInfinityResult = Foundation.nearInfinityResult, inspectedObjectLiteral = Foundation.inspectedObjectLiteral;

	module.exports = PointLayoutBase = (function(superClass) {
	  var isChildrenHRelative, isChildrenWRelative, isParentHRelative, isParentWRelative, nearInfinityPoint, nearInfinityPointX, nearInfinityPointY;

	  extend(PointLayoutBase, superClass);

	  function PointLayoutBase(a, previousLayout) {
	    this._xRelativeToParentW = this._xRelativeToParentH = this._yRelativeToParentW = this._yRelativeToParentH = this._xRelativeToChildrenW = this._xRelativeToChildrenH = this._yRelativeToChildrenW = this._yRelativeToChildrenH = false;
	    this._hasXLayout = this._hasYLayout = false;
	    this.layoutX = this.layoutY = function() {
	      return 0;
	    };
	    this.layout = function(ps, cs) {
	      return point(this.layoutX(ps, cs), this.layoutY(ps, cs));
	    };
	  }

	  PointLayoutBase.prototype.interpolate = function(toLayout, p) {
	    if (p === 0) {
	      return this;
	    } else if (p === 1) {
	      return toLayout;
	    } else {
	      return new PointLayoutBase.InterpolatedPointLayout(this, toLayout, p);
	    }
	  };

	  PointLayoutBase.getter({
	    inspectedString: function() {
	      return this.toString();
	    }
	  });

	  PointLayoutBase.prototype.inspect = function() {
	    return this.toString();
	  };

	  PointLayoutBase.prototype._copyXRelativity = function(sourceLayout) {
	    this._xRelativeToParentW = sourceLayout._xRelativeToParentW;
	    this._xRelativeToParentH = sourceLayout._xRelativeToParentH;
	    this._xRelativeToChildrenW = sourceLayout._xRelativeToChildrenW;
	    return this._xRelativeToChildrenH = sourceLayout._xRelativeToChildrenH;
	  };

	  PointLayoutBase.prototype._copyYRelativity = function(sourceLayout) {
	    this._yRelativeToParentW = sourceLayout._yRelativeToParentW;
	    this._yRelativeToParentH = sourceLayout._yRelativeToParentH;
	    this._yRelativeToChildrenW = sourceLayout._yRelativeToChildrenW;
	    return this._yRelativeToChildrenH = sourceLayout._yRelativeToChildrenH;
	  };

	  PointLayoutBase.getter({
	    inspectedObjects: function() {
	      return inspectedObjectLiteral(this.toString());
	    }
	  });

	  PointLayoutBase.getter("xRelativeToParentW\nxRelativeToParentH\nyRelativeToParentW\nyRelativeToParentH\nxRelativeToChildrenW\nxRelativeToChildrenH\nyRelativeToChildrenW\nyRelativeToChildrenH\nhasXLayout\nhasYLayout");

	  PointLayoutBase.getter({
	    hasFullLayout: function() {
	      return this._hasXLayout && this._hasYLayout;
	    },
	    hasLayout: function() {
	      return this._hasXLayout || this._hasYLayout;
	    },
	    parentRelative: function() {
	      return this._xRelativeToParentH || this._xRelativeToParentW || this._yRelativeToParentH || this._yRelativeToParentW;
	    },
	    childrenRelative: function() {
	      return this._xRelativeToChildrenH || this._xRelativeToChildrenW || this._yRelativeToChildrenH || this._yRelativeToChildrenW;
	    },
	    xParentRelative: function() {
	      return this._xRelativeToParentH || this._xRelativeToParentW;
	    },
	    yParentRelative: function() {
	      return this._yRelativeToParentH || this._yRelativeToParentW;
	    },
	    xChildrenRelative: function() {
	      return this._xRelativeToChildrenH || this._xRelativeToChildrenW;
	    },
	    yChildrenRelative: function() {
	      return this._yRelativeToChildrenH || this._yRelativeToChildrenW;
	    }
	  });

	  PointLayoutBase.prototype.layoutIsCircular = function(parentLayout) {
	    var result, xcx, xcy, xpx, xpy, ycx, ycy, ypx, ypy;
	    if (!parentLayout) {
	      return false;
	    }
	    xpx = this._xRelativeToParentW;
	    xpy = this._xRelativeToParentH;
	    ypx = this._yRelativeToParentW;
	    ypy = this._yRelativeToParentH;
	    xcx = parentLayout.getXRelativeToChildrenW();
	    xcy = parentLayout.getXRelativeToChildrenH();
	    ycx = parentLayout.getYRelativeToChildrenW();
	    ycy = parentLayout.getYRelativeToChildrenH();
	    result = !!((xpx && xcx) || (xpy && ycx) || (ypy && ycy) || (ypx && xcy) || (xpy && ycy && ypx && xcy) || (xpx && xcy && ypy && ycx));
	    return result;
	  };

	  nearInfinityPoint = point(nearInfinity, nearInfinity);

	  nearInfinityPointX = point0.withX(nearInfinity);

	  nearInfinityPointY = point0.withY(nearInfinity);

	  PointLayoutBase.isParentWRelative = isParentWRelative = function(f, baseline, baselinePoint, testPoint) {
	    return f(testPoint, baselinePoint) !== baseline;
	  };

	  PointLayoutBase.isParentHRelative = isParentHRelative = function(f, baseline, baselinePoint, testPoint) {
	    return f(testPoint, baselinePoint) !== baseline;
	  };

	  PointLayoutBase.isChildrenWRelative = isChildrenWRelative = function(f, baseline, baselinePoint, testPoint) {
	    return f(baselinePoint, testPoint) !== baseline;
	  };

	  PointLayoutBase.isChildrenHRelative = isChildrenHRelative = function(f, baseline, baselinePoint, testPoint) {
	    return f(baselinePoint, testPoint) !== baseline;
	  };

	  PointLayoutBase.prototype._detectXRelativity = function(layoutX) {
	    var layoutBaseline, layoutLength, nearInfinityBaseline;
	    if (layoutX == null) {
	      layoutX = this.layoutX;
	    }
	    this._xRelativeToParentW = this._xRelativeToParentH = this._xRelativeToChildrenW = this._xRelativeToChildrenH = false;
	    layoutLength = layoutX.length;
	    layoutBaseline = layoutX(point0, point0);
	    nearInfinityBaseline = layoutX(nearInfinityPoint, nearInfinityPoint);
	    if (layoutLength > 0) {
	      this._xRelativeToParentW = isParentWRelative(layoutX, layoutBaseline, point0, nearInfinityPointX) || isParentWRelative(layoutX, nearInfinityBaseline, nearInfinityPoint, nearInfinityPointY);
	      this._xRelativeToParentH = isParentHRelative(layoutX, layoutBaseline, point0, nearInfinityPointY) || isParentHRelative(layoutX, nearInfinityBaseline, nearInfinityPoint, nearInfinityPointX);
	      if (layoutLength === 1 && !this._xRelativeToParentW && !this._xRelativeToParentH) {
	        console.warn(this + ": horizontal/x/w layout function has 1 input, which suggests it should be parent-relative, but it doesn't appear to be.\n\nResolution: If the input is unused, remove it. Otherwise, alter your function to respond differently for parent-sizes of 0 and children-sizes of near-infinity.\n\nlayoutX: " + layoutX);
	      }
	    }
	    if (layoutLength > 1) {
	      this._xRelativeToChildrenW = isChildrenWRelative(layoutX, layoutBaseline, point0, nearInfinityPointX) || isChildrenWRelative(layoutX, nearInfinityBaseline, nearInfinityPoint, nearInfinityPointY);
	      this._xRelativeToChildrenH = isChildrenHRelative(layoutX, layoutBaseline, point0, nearInfinityPointY) || isChildrenHRelative(layoutX, nearInfinityBaseline, nearInfinityPoint, nearInfinityPointX);
	      if (!(this._xRelativeToChildrenW || this._xRelativeToChildrenH)) {
	        return console.warn(this + ": horizontal/x/w layout function has 2 inputs, which suggests it should be child-relative, but it doesn't appear to be.\n\nResolution: If the second input is unused, remove it. Otherwise, alter your function to respond differently for children-sizes of 0 vs near-infinity when parent-size is 0.\n\nlayoutX: " + layoutX);
	      }
	    }
	  };

	  PointLayoutBase.prototype._detectYRelativity = function(layoutY) {
	    var layoutBaseline, layoutLength, nearInfinityBaseline;
	    if (layoutY == null) {
	      layoutY = this.layoutY;
	    }
	    this._yRelativeToParentW = this._yRelativeToParentH = this._yRelativeToChildrenW = this._yRelativeToChildrenH = false;
	    layoutLength = layoutY.length;
	    layoutBaseline = layoutY(point0, point0);
	    nearInfinityBaseline = layoutY(nearInfinityPoint, nearInfinityPoint);
	    if (layoutLength > 0) {
	      this._yRelativeToParentW = isParentWRelative(layoutY, layoutBaseline, point0, nearInfinityPointX) || isParentWRelative(layoutY, nearInfinityBaseline, nearInfinityPoint, nearInfinityPointY);
	      this._yRelativeToParentH = isParentHRelative(layoutY, layoutBaseline, point0, nearInfinityPointY) || isParentHRelative(layoutY, nearInfinityBaseline, nearInfinityPoint, nearInfinityPointX);
	      if (layoutLength === 1 && !this._yRelativeToParentW && !this._yRelativeToParentH) {
	        console.warn(this + ": vertical/y/h layout function has 1 input, which suggests it should be parent-relative, but it doesn't appear to be. \n\nResolution: If the input is unused, remove it. Otherwise, alter your function to respond differently for parent-sizes of 0 and children-sizes of near-infinity.");
	      }
	    }
	    if (layoutLength > 1) {
	      this._yRelativeToChildrenW = isChildrenWRelative(layoutY, layoutBaseline, point0, nearInfinityPointX) || isChildrenWRelative(layoutY, nearInfinityBaseline, nearInfinityPoint, nearInfinityPointY);
	      this._yRelativeToChildrenH = isChildrenHRelative(layoutY, layoutBaseline, point0, nearInfinityPointY) || isChildrenHRelative(layoutY, nearInfinityBaseline, nearInfinityPoint, nearInfinityPointX);
	      if (!(this._yRelativeToChildrenW || this._yRelativeToChildrenH)) {
	        return console.warn(this + ": vertical/y/h layout function has 2 inputs, which suggests it should be child-relative, but it doesn't appear to be. \n\nResolution: If the second input is unused, remove it. Otherwise, alter your function to respond differently for children-sizes of 0 vs near-infinity when parent-size is 0.");
	      }
	    }
	  };

	  PointLayoutBase.prototype._detectRelativity = function() {
	    this._detectXRelativity();
	    return this._detectYRelativity();
	  };

	  return PointLayoutBase;

	})(BaseObject);


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(125), __webpack_require__(19), __webpack_require__(190)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Atomic, Foundation, PointLayoutBase) {
	  var BaseObject, Components, Point, PointLayout, inspect, inspectLean, isFunction, isNumber, isPlainObject, isString, log, max, min, point, point0;
	  point = Atomic.point, Point = Atomic.Point;
	  point0 = Point.point0;
	  BaseObject = Foundation.BaseObject, log = Foundation.log, inspect = Foundation.inspect, inspectLean = Foundation.inspectLean, isFunction = Foundation.isFunction, isNumber = Foundation.isNumber, isString = Foundation.isString, isPlainObject = Foundation.isPlainObject, min = Foundation.min, max = Foundation.max;
	  Components = (function() {
	    var applyComponentsFunctions, preprocess2dValue, preprocessValue, pts, returnZero, x, xcw, xph, xpw, y, ych, yph, ypw;

	    function Components() {}

	    returnZero = function() {
	      return 0;
	    };

	    Components.setupPointLayout = function(newPointLayout, options, previousLayout) {
	      var applyFunction, k, layoutX, layoutY, maxLayout, v;
	      maxLayout = options.max ? new PointLayout(options.max) : void 0;
	      this._reset();
	      for (k in options) {
	        v = options[k];
	        applyFunction = applyComponentsFunctions[k];
	        if (!applyFunction) {
	          throw new Error("invalid PointLayout component: " + (inspect(k)) + " in " + (inspect(options)));
	        }
	        applyFunction(v, newPointLayout);
	      }
	      newPointLayout.layoutX = newPointLayout._hasXLayout ? (layoutX = this._buildXLayoutFromComponents(maxLayout), this.needToDetectXRelativity ? newPointLayout._detectXRelativity(layoutX) : void 0, layoutX) : (previousLayout != null ? previousLayout._hasXLayout : void 0) ? (newPointLayout._hasXLayout = true, newPointLayout._copyXRelativity(previousLayout), previousLayout.layoutX) : returnZero;
	      return newPointLayout.layoutY = newPointLayout._hasYLayout ? (layoutY = this._buildYLayoutFromComponents(maxLayout), this.needToDetectYRelativity ? newPointLayout._detectYRelativity(layoutY) : void 0, layoutY) : (previousLayout != null ? previousLayout._hasYLayout : void 0) ? (newPointLayout._hasYLayout = true, newPointLayout._copyYRelativity(previousLayout), previousLayout.layoutY) : returnZero;
	    };

	    Components._buildXLayoutFromComponents = function(maxLayout) {
	      var layoutX, ref, x, xcw, xph, xpw;
	      ref = this, x = ref.x, xpw = ref.xpw, xph = ref.xph, xcw = ref.xcw, layoutX = ref.layoutX;
	      layoutX || (layoutX = xcw === 0 ? function(ps) {
	        return x + xpw * ps.x + xph * ps.y;
	      } : function(ps, cs) {
	        return x + xpw * ps.x + xph * ps.y + xcw * cs.x;
	      });
	      if (maxLayout != null ? maxLayout.getHasXLayout() : void 0) {
	        return function(ps, cs) {
	          return min(maxLayout.layoutX(ps), layoutX(ps, cs));
	        };
	      } else {
	        return layoutX;
	      }
	    };

	    Components._buildYLayoutFromComponents = function(maxLayout) {
	      var layoutY, ref, y, ych, yph, ypw;
	      ref = this, y = ref.y, yph = ref.yph, ypw = ref.ypw, ych = ref.ych, layoutY = ref.layoutY;
	      layoutY || (layoutY = ych === 0 ? function(ps) {
	        return y + yph * ps.y + ypw * ps.x;
	      } : function(ps, cs) {
	        return y + yph * ps.y + ypw * ps.x + ych * cs.y;
	      });
	      if (maxLayout != null ? maxLayout.getHasYLayout() : void 0) {
	        return function(ps, cs) {
	          return min(maxLayout.layoutY(ps), layoutY(ps, cs));
	        };
	      } else {
	        return layoutY;
	      }
	    };

	    Components._reset = function() {
	      this.needToDetectXRelativity = false;
	      this.needToDetectYRelativity = false;
	      this.layoutX = null;
	      this.layoutY = null;
	      return this.x = this.xpw = this.xph = this.xcw = this.y = this.yph = this.ypw = this.ych = 0.0;
	    };

	    Components._reset();

	    preprocessValue = function(value, pointLayout) {
	      value || (value = 0);
	      if (!isNumber(value)) {
	        throw new Error("Each PointLayout component must be a number. Not " + (inspect(value)) + " from " + pointLayout);
	      }
	      return value;
	    };

	    preprocess2dValue = function(value, pointLayout) {
	      return point(value);
	    };

	    Components._applyComponentsFunctions = applyComponentsFunctions = {
	      max: function(value, pointLayout) {},
	      pts: pts = function(value, pointLayout) {
	        value = preprocess2dValue(value, pointLayout);
	        pointLayout._hasXLayout = pointLayout._hasYLayout = true;
	        Components.x += value.x;
	        return Components.y += value.y;
	      },
	      x: x = function(value, pointLayout) {
	        pointLayout._hasXLayout = true;
	        if (isFunction(value)) {
	          Components.layoutX = value;
	          return Components.needToDetectXRelativity = true;
	        } else {
	          value = preprocessValue(value, pointLayout);
	          return Components.x += value;
	        }
	      },
	      y: y = function(value, pointLayout) {
	        pointLayout._hasYLayout = true;
	        if (isFunction(value)) {
	          Components.layoutY = value;
	          return Components.needToDetectYRelativity = true;
	        } else {
	          value = preprocessValue(value, pointLayout);
	          return Components.y += value;
	        }
	      },
	      ps: function(value, pointLayout) {
	        value = preprocess2dValue(value, pointLayout);
	        pointLayout._hasXLayout = pointLayout._hasYLayout = pointLayout._xRelativeToParentW = pointLayout._yRelativeToParentH = true;
	        Components.xpw += value.x;
	        return Components.yph += value.y;
	      },
	      xpw: xpw = function(value, pointLayout) {
	        value = preprocessValue(value, pointLayout);
	        pointLayout._hasXLayout = pointLayout._xRelativeToParentW = true;
	        return Components.xpw += value;
	      },
	      yph: yph = function(value, pointLayout) {
	        value = preprocessValue(value, pointLayout);
	        pointLayout._hasYLayout = pointLayout._yRelativeToParentH = true;
	        return Components.yph += value;
	      },
	      xph: xph = function(value, pointLayout) {
	        value = preprocessValue(value, pointLayout);
	        pointLayout._hasXLayout = pointLayout._xRelativeToParentH = true;
	        return Components.xph += value;
	      },
	      ypw: ypw = function(value, pointLayout) {
	        value = preprocessValue(value, pointLayout);
	        pointLayout._hasYLayout = pointLayout._yRelativeToParentW = true;
	        return Components.ypw += value;
	      },
	      cs: function(value, pointLayout) {
	        value = preprocess2dValue(value, pointLayout);
	        pointLayout._hasXLayout = pointLayout._hasYLayout = pointLayout._xRelativeToChildrenW = pointLayout._yRelativeToChildrenH = true;
	        Components.xcw += value.x;
	        return Components.ych += value.y;
	      },
	      xcw: xcw = function(value, pointLayout) {
	        value = preprocessValue(value, pointLayout);
	        pointLayout._hasXLayout = pointLayout._xRelativeToChildrenW = true;
	        return Components.xcw += value;
	      },
	      ych: ych = function(value, pointLayout) {
	        value = preprocessValue(value, pointLayout);
	        pointLayout._hasYLayout = pointLayout._yRelativeToChildrenH = true;
	        return Components.ych += value;
	      },
	      plus: pts,
	      w: x,
	      h: y,
	      ww: xpw,
	      hh: yph,
	      xw: xpw,
	      yh: yph,
	      wh: xph,
	      hw: ypw,
	      xh: xph,
	      yw: ypw,
	      wpw: xpw,
	      hph: yph,
	      wcw: xcw,
	      hch: ych,
	      wph: xph,
	      hpw: ypw,
	      width: x,
	      height: y,
	      width_parentWidth: xpw,
	      height_parentHeight: yph,
	      width_childrenWidth: xcw,
	      height_childrenHeight: ych,
	      x_parentWidth: xpw,
	      y_parentHeight: yph,
	      x_childrenWidth: xcw,
	      y_childrenHeight: ych
	    };

	    return Components;

	  })();
	  return PointLayout = (function(superClass) {
	    extend(PointLayout, superClass);


	    /*
	    constructor inputs: (initializer, previousLayout)
	    
	    constant initializer: anything that isn't a function or an object that is a legal initializer for Points
	    
	      123         # number
	      point 1, 2  # point
	      [1, 2]      # [x, y] array
	      "topLeft"   # named point
	      "1, 2"      # "x, y" string which is parsed
	    
	    function initializer: (ps, cs) -> Point or Number
	    
	      layout is an abitrary function based on ps (parent-size) and cs (children-size) returning a point
	      NOTE: this is the least efficient option UNLESS the function directly returns ps or cs.
	      REASON: otherwise you are creating new points each time the function is called.
	    
	    options object initializer:
	    
	       * contains one or more of the following options
	    
	       * layoutX = x if isFunction x
	      x:         (ps, cs) -> number
	    
	       * layoutX is the sum of:
	      x:         k # -> k
	      xpw:       k # -> k * ps.w
	      xcw:       k # -> k * cs.w
	      plus:      k # -> k
	      ps:        k # -> k * ps.w
	      cs:        k # -> k * cs.w
	    
	       * layoutY = y if isFunction y
	      y:         (ps, cs) -> number
	    
	       * layoutY is the sum of:
	      y:         k # -> k
	      yph:       k # -> k * ps.h
	      ych:       k # -> k * cs.h
	      plus:      k # -> k
	      ps:        k # -> k * ps.h
	      cs:        k # -> k * cs.h
	    
	       * Alaises
	      w:                        x
	      h:                        y
	      wpw:                      xpw
	      hph:                      yph
	      wcw:                      xcw
	      hch:                      ych
	    
	      width:                    x
	      height:                   y
	      width_parentWidth:        xpw
	      height_parentHeight:      yph
	      width_childrenWidth:      xcw
	      height_childrenHeight:    ych
	    
	      x_parentWidth:            xpw
	      y_parentHeight:           yph
	      x_childrenWidth:          xcw
	      y_childrenHeight:         ych
	    
	    constructor option examples:
	    
	      ps:1, plus:100      # @layout = (ps) -> ps.add 100
	      ps:1, cs:1          # @layout = (cs, ps) -> ps.add cs
	      x:100, y:200        # @layout = -> point 100, 200
	      w:100, h:200        # @layout = -> point 100, 200
	      wpw:1, hch:1        # @layout = (ps, cs) -> point ps.x, cs.y
	    
	    NOTE: When providing custom functions, their dependency on parent or children size is auto-detected by:
	      Evaluating f(point0, point0) and comparing it with nearInfinity for each of the 4 input values respectively.
	      If your function varies at all in response to an input value, it should return something different for point0
	      vs nearInfinity.
	     */

	    function PointLayout(initializer, previousLayout) {
	      this.initializer = initializer != null ? initializer : point0;
	      PointLayout.__super__.constructor.apply(this, arguments);
	      if (isFunction(this.initializer)) {
	        this._setupFromFunction(this.initializer);
	      } else if (isPlainObject(this.initializer)) {
	        this._setupFromOptions(this.initializer, previousLayout);
	      } else {
	        this._setupFromPoint(this.initializer);
	      }
	    }

	    PointLayout.prototype.toString = function() {
	      return "PointLayout(" + (this.toStringLean()) + ")";
	    };

	    PointLayout.prototype.toStringLean = function() {
	      if (this.initializer) {
	        if (this.initializer instanceof Point && this.initializer.x === this.initializer.y) {
	          return this.initializer.x;
	        } else {
	          return inspectLean(this.initializer);
	        }
	      } else {
	        return '0';
	      }
	    };

	    PointLayout.getter({
	      inspectedInitializer: function() {
	        if (this.initializer) {
	          return inspect(this.initializer);
	        } else {
	          return '0';
	        }
	      },
	      plainObjects: function() {
	        var v;
	        v = this.initializer || 0;
	        if ((v instanceof Point) && v.x === v.y) {
	          v = v.x;
	        }
	        if (v.getPlainObjects) {
	          v = v.getPlainObjects();
	        }
	        return v;
	      },
	      inspectObjects: function() {
	        if (isPlainObject(this.initializer)) {
	          return {
	            inspect: (function(_this) {
	              return function() {
	                return inspectLean(_this.initializer);
	              };
	            })(this)
	          };
	        } else if (isFunction(this.initializer)) {
	          return {
	            inspect: (function(_this) {
	              return function() {
	                return _this.initializer.toString().replace(/\s+/g, ' ');
	              };
	            })(this)
	          };
	        } else {
	          return this.initializer;
	        }
	      }
	    });

	    PointLayout.prototype._setupFromPoint = function(val) {
	      var p, ref, x, y;
	      this._hasXLayout = this._hasYLayout = true;
	      ref = p = point(val), x = ref.x, y = ref.y;
	      if (isString(val)) {
	        this.layoutX = function(ps) {
	          return ps.x * x;
	        };
	        this.layoutY = function(ps) {
	          return ps.y * y;
	        };
	        this.layout = function(ps) {
	          return ps.mul(p);
	        };
	      } else {
	        this.layoutX = function(ps) {
	          return x;
	        };
	        this.layoutY = function(ps) {
	          return y;
	        };
	        this.layout = function(ps) {
	          return p;
	        };
	      }
	      return this.initializer = p;
	    };

	    PointLayout.prototype._setupFromFunction = function(layoutFunction) {
	      this._hasXLayout = this._hasYLayout = true;
	      if (layoutFunction.length === 1) {
	        if (isNumber(layoutFunction(point0))) {
	          this.layout = function(ps) {
	            return point(layoutFunction(ps));
	          };
	          this.layoutX = layoutFunction;
	          this.layoutY = layoutFunction;
	        } else {
	          this.layout = layoutFunction;
	          this.layoutX = function(ps) {
	            return layoutFunction(ps).x;
	          };
	          this.layoutY = function(ps) {
	            return layoutFunction(ps).y;
	          };
	        }
	      } else {
	        if (isNumber(layoutFunction(point0, point0))) {
	          this.layout = function(ps, cs) {
	            return point(layoutFunction(ps, cs));
	          };
	          this.layoutX = layoutFunction;
	          this.layoutY = layoutFunction;
	        } else {
	          this.layout = layoutFunction;
	          this.layoutX = function(ps, cs) {
	            return layoutFunction(ps, cs).x;
	          };
	          this.layoutY = function(ps, cs) {
	            return layoutFunction(ps, cs).y;
	          };
	        }
	      }
	      return this._detectRelativity();
	    };

	    PointLayout.prototype._setupFromOptions = function(options, previousLayout) {
	      return Components.setupPointLayout(this, options, previousLayout);
	    };

	    return PointLayout;

	  })(PointLayoutBase);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, ElementBase, EventedEpochedObject, Foundation, compact, elementFactory, inspect, inspectLean, isFunction, isObject, log, merge, peek, present,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	Atomic = __webpack_require__(125);

	Foundation = __webpack_require__(19);

	elementFactory = __webpack_require__(160).elementFactory;

	EventedEpochedObject = __webpack_require__(193);

	log = Foundation.log, inspect = Foundation.inspect, merge = Foundation.merge, peek = Foundation.peek, present = Foundation.present, isFunction = Foundation.isFunction, inspectLean = Foundation.inspectLean, compact = Foundation.compact, isObject = Foundation.isObject;


	/*
	ElementBase adds:

	  1. automatic ElementFactory registration
	  2. Element instance registration
	  3. The name and key properties (TODO: reduce to just 'key')
	  4. Inspectors

	ElementBase is the root for Element and eventually Span. All elements in the AIM
	must inherit from ElementBase.

	TODO:
	  5. parent and children relationships should be in ElementBase not Element
	 */

	module.exports = ElementBase = (function(superClass) {
	  var _elementInstanceRegistry, inspectedPropsFirst, inspectedPropsNotToInclude;

	  extend(ElementBase, superClass);

	  function ElementBase() {
	    return ElementBase.__super__.constructor.apply(this, arguments);
	  }

	  ElementBase.registerWithElementFactory = function() {
	    return false;
	  };

	  ElementBase.postCreate = function() {
	    if (this.registerWithElementFactory()) {
	      elementFactory.register(this);
	    }
	    return ElementBase.__super__.constructor.postCreate.apply(this, arguments);
	  };

	  ElementBase.prototype._initFields = function() {
	    ElementBase.__super__._initFields.apply(this, arguments);
	    this.remoteId = null;
	    this.creator = null;
	    this.__depth = 0;
	    return this.__redrawRequired = false;
	  };

	  ElementBase.concreteProperty({
	    key: {
	      "default": null,
	      validate: function(v) {
	        return v === null || isFunction(v.toString);
	      },
	      preprocess: function(v) {
	        if (v === null) {
	          return v;
	        } else {
	          return v.toString();
	        }
	      }
	    }
	  });

	  ElementBase.virtualProperty({
	    name: {
	      getter: function(pending) {
	        return this.getState(pending)._key;
	      },
	      setter: function(v) {
	        return this.setKey(v);
	      }
	    }
	  });

	  ElementBase.concreteProperty({

	    /*
	    willConsumeKeyboardEvent:
	      "beforeDescendents":   (highest priority) no descendend will get keyboard events
	      "beforeAncestors":     (medium priority) no ancestor will get keyboard events UNLESS an ancestor is set to "beforeDescendents"
	      false:              (lowest priority)
	        will only receive keyboard events if, on the currentFocusPath
	          a) there are no elements that return "beforeAncestors" AND
	          b) this element comes before the first element, if any, that returns "beforeDescendents"
	          If all elements return false, all elements will get the event in ancestor > descendent order
	    
	      (artEngineKeyboardEventType, keyboardEvent) -> "beforeDescendents"/"beforeAncestors"/false
	        IN: artEngineKeyboardEventType: "keyUp", "keyDown", or "keyPress"
	        IN: keyboardEvent: HTMLKeyboardEvent
	          NOTE: use keyboardEvent.key for checking the key-type. It has been polyfilled to the latest HTML standards (2016)
	        OUT:
	          "beforeDescendents":
	            keyboardEvent.preventDefault() is called
	            decendents will not get this keyboardEvent
	          "beforeAncestors":
	            keyboardEvent.preventDefault() is called
	            ancestors will not get this keyboardEvent UNLESS they return "beforeDescendents"
	          false: (default)
	            children, if focused, will get this keyboardEvent
	     */
	    willConsumeKeyboardEvent: {
	      "default": function(artEngineKeyboardEventType, keyboardEvent) {
	        return false;
	      },
	      validate: function(v) {
	        return isObject(v) || v === "beforeDescendents" || v === "beforeAncestors" || isFunction(v);
	      },
	      preprocess: function(v) {
	        if (!isFunction(v)) {
	          return function() {
	            return v;
	          };
	        } else {
	          return v;
	        }
	      }
	    }
	  });

	  ElementBase._elementInstanceRegistry = _elementInstanceRegistry = {};

	  ElementBase.getter({
	    isRegistered: function() {
	      return !!_elementInstanceRegistry[this.getInstanceId()];
	    }
	  });

	  ElementBase.getElementByInstanceId = function(instanceId) {
	    return _elementInstanceRegistry[instanceId];
	  };

	  ElementBase.prototype._register = function() {
	    var instanceId;
	    if (_elementInstanceRegistry[instanceId = this.getInstanceId()]) {
	      return;
	    }
	    this._activateContinuousPersistantAnimators();
	    _elementInstanceRegistry[instanceId] = this;
	    this.eachChild((function(_this) {
	      return function(child) {
	        return child._register();
	      };
	    })(this));
	    return this;
	  };

	  ElementBase.prototype._unregister = function() {
	    var instanceId;
	    if (!_elementInstanceRegistry[instanceId = this.getInstanceId()]) {
	      return;
	    }
	    this._deactivatePersistantAnimators();
	    delete _elementInstanceRegistry[instanceId];
	    this.eachChild((function(_this) {
	      return function(child) {
	        return child._unregister();
	      };
	    })(this));
	    this.queueEvent("unregistered");
	    return null;
	  };

	  ElementBase.prototype._updateRegistryFromPendingState = function() {
	    var pendingParent;
	    if (pendingParent = this.getPendingParent()) {
	      if (pendingParent.getIsRegistered()) {
	        return this._register();
	      }
	    } else {
	      return this._unregister();
	    }
	  };

	  ElementBase.getter({
	    instanceId: function() {
	      return this.remoteId || this.getUniqueId();
	    },
	    shortNamespacePath: function() {
	      var name;
	      name = this.namespacePath;
	      return peek(name.split('.'));
	    },
	    inspectedName: function() {
	      return this.shortNamespacePath + ":" + (this.pendingKey || this.instanceId);
	    },
	    inspectedNameWithoutIds: function() {
	      var key;
	      return this.shortNamespacePath + ((key = this.pendingKey) ? ":" + key : "");
	    },
	    inspectedString: function() {
	      return this.inspectedName;
	    }
	  });

	  inspectedPropsNotToInclude = ["children", "name", "on"];

	  inspectedPropsFirst = ["key", "instanceId", "location", "size", "currentLocation", "currentSize"];

	  ElementBase.getter({
	    inspectedPropsMaps: function() {
	      var defaultValue, i, internalName, k, len1, props, ref, ref1, value, virtual;
	      props = {};
	      for (i = 0, len1 = inspectedPropsFirst.length; i < len1; i++) {
	        k = inspectedPropsFirst[i];
	        if (present(value = this[k])) {
	          props[k] = value;
	        }
	      }
	      ref = this.metaProperties;
	      for (k in ref) {
	        ref1 = ref[k], internalName = ref1.internalName, virtual = ref1.virtual, defaultValue = ref1.defaultValue;
	        if (!virtual && indexOf.call(inspectedPropsNotToInclude, k) < 0 && !EpochedObject.propsEq(defaultValue, value = this[internalName])) {
	          props[k] = value;
	        }
	      }
	      return props;
	    },
	    debugStructure: function() {
	      var child, result;
	      result = [this.shortNamespacePath, this.inspectedPropsMaps];
	      if (this.hasChildren) {
	        result = result.concat((function() {
	          var i, len1, ref, results;
	          ref = this.children;
	          results = [];
	          for (i = 0, len1 = ref.length; i < len1; i++) {
	            child = ref[i];
	            results.push(child.debugStructure);
	          }
	          return results;
	        }).call(this));
	      }
	      return result;
	    },
	    plainObjectProps: function() {
	      var k, out, ref, v;
	      ref = out = this.minimalProps;
	      for (k in ref) {
	        v = ref[k];
	        if (v != null ? v.getPlainObjects : void 0) {
	          out[k] = v.getPlainObjects();
	        }
	      }
	      return out;
	    },
	    propsInspectObjects: function() {
	      var fn, k, length, out, ref, v;
	      length = 0;
	      ref = out = this.minimalProps;
	      fn = function(k, v) {
	        return out[k] = (function() {
	          var ref1;
	          switch ((ref1 = v["class"]) != null ? typeof ref1.getName === "function" ? ref1.getName() : void 0 : void 0) {
	            case "Bitmap":
	              return v;
	            default:
	              if (v != null ? v.getInspectObjects : void 0) {
	                return v.getInspectObjects();
	              } else {
	                return {
	                  inspect: function() {
	                    if (v != null ? v.getPlainObjects : void 0) {
	                      v = v.getPlainObjects();
	                    }
	                    return inspectLean(v);
	                  }
	                };
	              }
	          }
	        })();
	      };
	      for (k in ref) {
	        v = ref[k];
	        length++;
	        fn(k, v);
	      }
	      if (length === 0) {
	        return null;
	      } else {
	        return out;
	      }
	    },
	    inspectedProps: function() {
	      return inspectLean(this.getPlainObjectProps());
	    },
	    plainObjects: function() {
	      var child;
	      return [this["class"].getName(), this.plainObjectProps].concat((function() {
	        var i, len1, ref, results;
	        ref = this._children;
	        results = [];
	        for (i = 0, len1 = ref.length; i < len1; i++) {
	          child = ref[i];
	          results.push(child.plainObjects);
	        }
	        return results;
	      }).call(this));
	    },
	    inspectObjects: function() {
	      var child;
	      return compact([
	        {
	          inspect: (function(_this) {
	            return function() {
	              return _this["class"].getName();
	            };
	          })(this)
	        }, this.propsInspectObjects
	      ].concat((function() {
	        var i, len1, ref, results;
	        ref = this._children;
	        results = [];
	        for (i = 0, len1 = ref.length; i < len1; i++) {
	          child = ref[i];
	          results.push(child.inspectObjects);
	        }
	        return results;
	      }).call(this)));
	    },
	    inspectTree: function() {
	      var c;
	      return [
	        this.getInspectedName(), (function() {
	          var i, len1, ref, results;
	          ref = this._children;
	          results = [];
	          for (i = 0, len1 = ref.length; i < len1; i++) {
	            c = ref[i];
	            results.push(c.inspectTree);
	          }
	          return results;
	        }).call(this)
	      ];
	    },
	    inspectedStructure: function() {
	      return inspect(this.plainObjects);
	    }
	  });

	  ElementBase.prototype.inspect = function() {
	    var a, child, inspectedProps, len;
	    inspectedProps = this.inspectedProps;
	    a = this["class"].getName() + " " + inspectedProps;
	    if (0 < (len = this._children.length)) {
	      a += (inspectedProps.length > 0 ? ',' : '') + " children: [" + (((function() {
	        var i, len1, ref, results;
	        ref = this._children;
	        results = [];
	        for (i = 0, len1 = ref.length; i < len1; i++) {
	          child = ref[i];
	          results.push(child["class"].getName());
	        }
	        return results;
	      }).call(this)).join(', ')) + "]";
	    }
	    return a;
	  };

	  return ElementBase;

	})(EventedEpochedObject);


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var EpochedObject, EventedBaseMixin, EventedEpochedObject, Events, Foundation, StateEpoch, blankOptions, isPlainObject, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Events = __webpack_require__(168);

	StateEpoch = __webpack_require__(194);

	EpochedObject = __webpack_require__(200);

	EventedBaseMixin = Events.EventedBaseMixin;

	log = Foundation.log, isPlainObject = Foundation.isPlainObject;

	blankOptions = {};

	module.exports = EventedEpochedObject = (function(superClass) {
	  var defaultEventHandlerPreprocessor, emptyEventHandlers;

	  extend(EventedEpochedObject, superClass);

	  function EventedEpochedObject(options) {
	    if (options == null) {
	      options = blankOptions;
	    }
	    EventedEpochedObject.__super__.constructor.apply(this, arguments);
	    this._initDefaultEventHandlers(options);
	  }

	  EventedEpochedObject.concreteProperty({
	    on: {
	      "default": {},
	      validate: function(v) {
	        return isPlainObject(v);
	      },
	      setter: function(v) {
	        return this.preprocessEventHandlers(v);
	      }
	    }
	  });


	  /*
	  TODO:
	  
	    I'd like to have a "preprocessProps" function rather than one function which is
	    special-cased for event-handlers. I didn't do this with the first pass because
	    Element props can be set one at a time. They aren't set in batch like ArtReact.
	    But, I realized, they are effectively batch-set in the StateEpoch. Can we run
	    preprocessProps at the beginning of the StateEpoch???
	   */

	  EventedEpochedObject.prototype.preprocessEventHandlers = defaultEventHandlerPreprocessor = function(handlerMap) {
	    return handlerMap;
	  };

	  emptyEventHandlers = {};

	  EventedEpochedObject.prototype._initDefaultEventHandlers = function(options) {
	    if (!options.on && this.preprocessEventHandlers !== defaultEventHandlerPreprocessor) {
	      return this.setOn(emptyEventHandlers);
	    }
	  };

	  EventedEpochedObject.prototype._applyStateChanges = function() {
	    if (this.getParentChanged()) {
	      this.queueEvent("parentChanged", {
	        oldParent: this._parent,
	        parent: this._pendingState._parent
	      });
	    }
	    this.queueEvent("ready");
	    return EventedEpochedObject.__super__._applyStateChanges.apply(this, arguments);
	  };


	  /*
	  NOTE: by checking @_pendingState also, we can receive events triggered in the same
	  epoch as the Element's creation - such as "parentChanged." Actual handling
	  will be done later, in the eventEpoch, where _hasEventHandler is double-checked.
	   */

	  EventedEpochedObject.prototype._hasEventHandler = function(eventType) {
	    var _on, ref;
	    return (_on = this._pendingState._on || this._on) && !!(_on[eventType] || ((ref = _on.preprocess) != null ? ref[eventType] : void 0));
	  };


	  /*
	  To respect stateEpochs, events will never be sent to pending event handlers.
	  This would only be a concern if @_on changed between the last stateEpoch and
	  the current eventEpoch.
	   */

	  EventedEpochedObject.prototype._sendToEventHandler = function(event) {
	    var _on, e, handler, preprocessor, processedEvent, ref, type;
	    _on = this._on;
	    if (_on) {
	      type = (processedEvent = event).type;
	      if (preprocessor = (ref = _on.preprocess) != null ? ref[type] : void 0) {
	        try {
	          processedEvent = preprocessor(event);
	        } catch (error) {
	          e = error;
	          processedEvent = null;
	          this._handleErrorInHandler(event, preprocessor, e);
	        }
	      }
	      if (processedEvent && (handler = _on[type])) {
	        try {
	          return handler(processedEvent);
	        } catch (error) {
	          e = error;
	          return this._handleErrorInHandler(processedEvent, handler, e);
	        }
	      }
	    }
	  };

	  return EventedEpochedObject;

	})(EventedBaseMixin(EpochedObject));


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(125), __webpack_require__(195)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Foundation, Atomic, StateEpochLayout) {
	  var Epoch, Point, StateEpoch, childrenDrawChanged, childrenDrawUnchanged, globalCount, inspect, log, longestCommonSubsequence, point, requestAnimationFrame, select;
	  point = Atomic.point, Point = Atomic.Point;
	  log = Foundation.log, requestAnimationFrame = Foundation.requestAnimationFrame, longestCommonSubsequence = Foundation.longestCommonSubsequence, select = Foundation.select, inspect = Foundation.inspect, Epoch = Foundation.Epoch, globalCount = Foundation.globalCount;
	  childrenDrawUnchanged = function(before, after) {
	    return window.lcs = longestCommonSubsequence(before, after);
	  };
	  childrenDrawChanged = function(before, after) {
	    var child, i, len, results;
	    if (before) {
	      results = [];
	      for (i = 0, len = before.length; i < len; i++) {
	        child = before[i];
	        if (indexOf.call(childrenDrawUnchanged(before, after), child) < 0) {
	          results.push(child);
	        }
	      }
	      return results;
	    } else {
	      return after;
	    }
	  };
	  return StateEpoch = (function(superClass) {
	    var epochCount, markChildrenRedrawRequired;

	    extend(StateEpoch, superClass);

	    StateEpoch.singletonClass();

	    StateEpoch._stateEpochLayoutInProgress = false;

	    function StateEpoch() {
	      StateEpoch.__super__.constructor.call(this, {
	        emptyQueueAfterProcessing: true
	      });
	    }

	    StateEpoch.prototype._addChangingElement = function(element) {
	      return this.queueItem(element);
	    };

	    StateEpoch.prototype._isChangingElement = function(element) {
	      return this.isItemQueued(element);
	    };

	    StateEpoch.prototype.computeDepth = function(element) {
	      if (!element) {
	        return 0;
	      }
	      return element.__depth = 1 + this.computeDepth(element.getPendingParent());
	    };

	    StateEpoch.prototype.computeDepths = function(changingElements) {
	      var element, i, len;
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        element = changingElements[i];
	        this.computeDepth(element);
	      }
	      return null;
	    };

	    StateEpoch.prototype.sortChangingElementsDepthsAscending = function(changingElements) {
	      return changingElements.sort(function(a, b) {
	        return a.__depth - b.__depth;
	      });
	    };

	    StateEpoch.prototype.notifyLayoutPropertiesChanged = function(changingElements) {
	      var element, i, len;
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        element = changingElements[i];
	        if (element.__layoutPropertiesChanged) {
	          element._layoutPropertiesChanged();
	        }
	      }
	      return null;
	    };

	    StateEpoch.prototype.getDrawChangedElements = function(changingElements) {
	      var el, i, len, results;
	      results = [];
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        el = changingElements[i];
	        if (el.__redrawRequired) {
	          results.push(el);
	        }
	      }
	      return results;
	    };

	    StateEpoch.prototype.informAncestorsElementNeedsRedrawing = function(el) {
	      el._needsRedrawing();
	      return null;
	    };

	    StateEpoch.prototype.applyStateChanges = function(changingElements) {
	      var el, i, len;
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        el = changingElements[i];
	        el._applyStateChanges();
	      }
	      return null;
	    };

	    markChildrenRedrawRequired = function(element) {
	      var child, i, len, ref;
	      if (element.getChildrenChanged()) {
	        ref = childrenDrawChanged(element.children, element.getPendingChildren());
	        for (i = 0, len = ref.length; i < len; i++) {
	          child = ref[i];
	          child.__redrawRequired = true;
	        }
	      }
	      return null;
	    };

	    StateEpoch.prototype.markRedrawRequired = function(changingElements) {
	      var element, i, len;
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        element = changingElements[i];
	        element.__redrawRequired = element.getRedrawRequired();
	        markChildrenRedrawRequired(element);
	      }
	      return null;
	    };

	    StateEpoch.prototype.markDrawAreaChanged = function(changingElements) {
	      var element, i, len, parent;
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        element = changingElements[i];
	        element.__drawAreaChanged || (element.__drawAreaChanged = element.getChildrenChanged() || (element.getCurrentSizeChanged() && (element.getPendingChildren().length === 0 || element.getPendingClip())));
	        if (element.getElementToParentMatrixChanged()) {
	          if (parent = element.getPendingParent()) {
	            parent.__drawAreaChanged = true;
	            parent._elementChanged();
	          }
	        }
	      }
	      return null;
	    };

	    StateEpoch.prototype.resetAbsMatriciesR = function(element) {
	      var child, i, len, ref;
	      if (element._elementToAbsMatrix === null && element._absToElementMatrix === null) {
	        return;
	      }
	      element._elementToAbsMatrix = element._absToElementMatrix = null;
	      element.queueEvent("absMatriciesChanged");
	      ref = element.getPendingChildren();
	      for (i = 0, len = ref.length; i < len; i++) {
	        child = ref[i];
	        this.resetAbsMatriciesR(child);
	      }
	      return null;
	    };

	    StateEpoch.prototype.resetParentToElementMatricies = function(elements) {
	      var el, i, len;
	      for (i = 0, len = elements.length; i < len; i++) {
	        el = elements[i];
	        if (el) {
	          if (el.getElementToParentMatrixChanged()) {
	            el._parentToElementMatrix = null;
	          }
	        }
	      }
	      return null;
	    };

	    StateEpoch.prototype.getElementToAbsMatrixChangedElementsDepthAscending = function(changingElements) {
	      var el, i, len, results;
	      results = [];
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        el = changingElements[i];
	        if (el.getElementToParentMatrixChanged() || el.getParentChanged()) {
	          results.push(el);
	        }
	      }
	      return results;
	    };

	    StateEpoch.prototype.resetAbsMatricies = function(elements) {
	      var el, i, len;
	      for (i = 0, len = elements.length; i < len; i++) {
	        el = elements[i];
	        this.resetAbsMatriciesR(el);
	      }
	      return null;
	    };

	    StateEpoch.prototype.updateElementParentChangingElements = function(changingElements) {
	      var el, i, len;
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        el = changingElements[i];
	        if (!(el.getParentChanged())) {
	          continue;
	        }
	        el._clearRootElement();
	        el._updateRegistryFromPendingState();
	      }
	      return null;
	    };

	    StateEpoch.prototype.recomputeMousePathAndCursor = function(changingElements) {
	      var el, i, len, ref, rootElement, testedRoots;
	      testedRoots = [];
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        el = changingElements[i];
	        rootElement = el.getRootElement();
	        if (indexOf.call(testedRoots, rootElement) < 0) {
	          testedRoots.push(rootElement);
	          if ((ref = rootElement.pointerEventManager) != null) {
	            ref.updateMousePath();
	          }
	        }
	      }
	      return null;
	    };

	    epochCount = 0;

	    StateEpoch.prototype.inspectChangingElements = function(changingElements) {
	      var c, ce, changing, changingKeys, key, newV, o, oldV;
	      return {
	        epoch: ++epochCount,
	        changingElements: (function() {
	          var i, j, len, len1, results;
	          results = [];
	          for (i = 0, len = changingElements.length; i < len; i++) {
	            ce = changingElements[i];
	            o = {};
	            if ((changingKeys = ce._getChangingStateKeys()).length > 0) {
	              o.changing = changing = {};
	              for (j = 0, len1 = changingKeys.length; j < len1; j++) {
	                key = changingKeys[j];
	                oldV = ce[key];
	                newV = ce._pendingState[key];
	                switch (key) {
	                  case "_parent":
	                    oldV = oldV != null ? oldV.inspectedName : void 0;
	                    newV = newV != null ? newV.inspectedName : void 0;
	                    break;
	                  case "_children":
	                    oldV = (function() {
	                      var k, len2, results1;
	                      results1 = [];
	                      for (k = 0, len2 = oldV.length; k < len2; k++) {
	                        c = oldV[k];
	                        results1.push(c.inspectedName);
	                      }
	                      return results1;
	                    })();
	                    newV = (function() {
	                      var k, len2, results1;
	                      results1 = [];
	                      for (k = 0, len2 = newV.length; k < len2; k++) {
	                        c = newV[k];
	                        results1.push(c.inspectedName);
	                      }
	                      return results1;
	                    })();
	                }
	                changing[key] = {
	                  old: oldV,
	                  "new": newV
	                };
	              }
	            }
	            o.__depth = ce.__depth;
	            if (ce.__drawAreaChanged) {
	              o.drawAreaChanged = true;
	            }
	            if (ce.__redrawRequired) {
	              o.drawPropertiesChanged = true;
	            }
	            results.push([ce.inspect(), o]);
	          }
	          return results;
	        })()
	      };
	    };

	    StateEpoch.prototype.applyAnimators = function(changingElements) {
	      var el, i, len;
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        el = changingElements[i];
	        el._applyAnimators();
	      }
	      return null;
	    };

	    StateEpoch.prototype.processEpochItems = function(changingElements) {
	      var changingElementsLength, drawChangedElements, el, elementToAbsMatrixChangedElementsDepthAscending, i, j, k, len, len1, len2, results;
	      this.applyAnimators(changingElements);
	      this.computeDepths(changingElements);
	      this.notifyLayoutPropertiesChanged(changingElements);
	      StateEpochLayout.markLayoutPropertiesChanged(changingElements);
	      changingElementsLength = changingElements.length;
	      this.sortChangingElementsDepthsAscending(changingElements);
	      StateEpoch._stateEpochLayoutInProgress = true;
	      StateEpochLayout.updateLayouts(changingElements);
	      StateEpoch._stateEpochLayoutInProgress = false;
	      this.markRedrawRequired(changingElements);
	      this.markDrawAreaChanged(changingElements);
	      if (changingElements.length !== changingElementsLength) {
	        this.sortChangingElementsDepthsAscending(changingElements);
	      }
	      elementToAbsMatrixChangedElementsDepthAscending = this.getElementToAbsMatrixChangedElementsDepthAscending(changingElements);
	      drawChangedElements = this.getDrawChangedElements(changingElements);
	      this.resetParentToElementMatricies(elementToAbsMatrixChangedElementsDepthAscending);
	      for (i = 0, len = changingElements.length; i < len; i++) {
	        el = changingElements[i];
	        if (el.getElementToParentMatrixChanged()) {
	          this.informAncestorsElementNeedsRedrawing(el);
	        }
	      }
	      this.updateElementParentChangingElements(changingElements);
	      this.applyStateChanges(changingElements);
	      this.resetAbsMatricies(elementToAbsMatrixChangedElementsDepthAscending);
	      for (j = 0, len1 = changingElements.length; j < len1; j++) {
	        el = changingElements[j];
	        if (el.__drawAreaChanged) {
	          el._drawAreaChanged();
	        }
	      }
	      results = [];
	      for (k = 0, len2 = drawChangedElements.length; k < len2; k++) {
	        el = drawChangedElements[k];
	        results.push(this.informAncestorsElementNeedsRedrawing(el));
	      }
	      return results;
	    };

	    return StateEpoch;

	  })(Epoch);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	var ArtEngineCore, Atomic, BaseObject, Basics, CoreLayout, FlexLayout, Foundation, Point, StateEpochLayout, Unique, abs, deinfinitize, eachRunAsCharCodes, floatEq, getGlobalEpochCycle, inspect, isFunction, isInfiniteResult, isNumber, layoutChildrenFlex, layoutMargin, layoutPadding, log, longestCommonSubsequence, max, nearInfiniteSize, nearInfinity, nearInfinityResult, partition, peek, perimeter, point, point0, select, shallowEq, sizeWithPadding,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	ArtEngineCore = __webpack_require__(158);

	CoreLayout = __webpack_require__(196);

	FlexLayout = __webpack_require__(197);

	Basics = __webpack_require__(198);


	/*
	TODO:

	  I'd like to move away from my isInfiniteResult tests.
	  I'd rather just use circular tests.
	  The problem is if we have a "max" test in layout, infinite results get masked and appear finite.
	  Circular tests are not 100% reliable though!
	    Perhaps we can let you specific relitivity in the PointLayout Props, if needed:
	      w: (ps, cs) -> blah
	      parentRelative: false # blah isn't actually parent relative
	 */

	layoutChildrenFlex = FlexLayout.layoutChildrenFlex;

	nearInfiniteSize = Basics.nearInfiniteSize, nearInfinity = Basics.nearInfinity, nearInfinityResult = Basics.nearInfinityResult, layoutMargin = Basics.layoutMargin, sizeWithPadding = Basics.sizeWithPadding, layoutPadding = Basics.layoutPadding, deinfinitize = Basics.deinfinitize, isInfiniteResult = Basics.isInfiniteResult;

	point = Atomic.point, Point = Atomic.Point, perimeter = Atomic.perimeter;

	BaseObject = Foundation.BaseObject, log = Foundation.log, max = Foundation.max, shallowEq = Foundation.shallowEq, longestCommonSubsequence = Foundation.longestCommonSubsequence, select = Foundation.select, Unique = Foundation.Unique, peek = Foundation.peek, inspect = Foundation.inspect, isFunction = Foundation.isFunction, eachRunAsCharCodes = Foundation.eachRunAsCharCodes, floatEq = Foundation.floatEq, isNumber = Foundation.isNumber;

	point0 = Point.point0;

	abs = Math.abs;

	getGlobalEpochCycle = function() {
	  return ArtEngineCore.GlobalEpochCycle.globalEpochCycle;
	};

	partition = function(src, f) {
	  var intoIfFalse, intoIfTrue, k, len, v;
	  intoIfFalse = [];
	  intoIfTrue = [];
	  for (k = 0, len = src.length; k < len; k++) {
	    v = src[k];
	    if (f(v)) {
	      intoIfTrue.push(v);
	    } else {
	      intoIfFalse.push(v);
	    }
	  }
	  return [intoIfTrue, intoIfFalse];
	};

	module.exports = StateEpochLayout = (function(superClass) {
	  var alignChildren, isSpace, layoutChildrenComputeArea, layoutChildrenComputeMaxSize, layoutChildrenFlow, layoutChildrenFlowLine, layoutChildrenRowGrid, layoutElement, markParentLayoutPropertiesChanged, subLayoutChildrenAndGatherInformation;

	  extend(StateEpochLayout, superClass);

	  function StateEpochLayout() {
	    return StateEpochLayout.__super__.constructor.apply(this, arguments);
	  }

	  StateEpochLayout.markLayoutPropertiesChanged = function(changingElements) {
	    var element, k, len, results;
	    results = [];
	    for (k = 0, len = changingElements.length; k < len; k++) {
	      element = changingElements[k];
	      if ((element.getParentChanged() && element.getPendingParent()) || (element.getChildrenChanged() && element.getPendingLayoutMovesChildren())) {
	        if (!element.__layoutPropertiesChanged) {
	          element.__layoutPropertiesChanged = true;
	          element._elementChanged();
	        }
	      }
	      results.push(markParentLayoutPropertiesChanged(element));
	    }
	    return results;
	  };

	  StateEpochLayout.updateLayouts = function(layoutChangedElements) {
	    var process;
	    process = function() {
	      var element, k, len, results;
	      results = [];
	      for (k = 0, len = layoutChangedElements.length; k < len; k++) {
	        element = layoutChangedElements[k];
	        if (element.__layoutPropertiesChanged) {
	          results.push(layoutElement(element, element.getPendingParentSizeForChildren()));
	        }
	      }
	      return results;
	    };
	    if (getGlobalEpochCycle()) {
	      getGlobalEpochCycle().timePerformance("aimLayout", process);
	    } else {
	      process();
	    }
	    return null;
	  };

	  markParentLayoutPropertiesChanged = function(element) {
	    var results;
	    results = [];
	    while ((element = element.getPendingParent()) && (element.getPendingSize().getChildrenRelative() || element.getPendingLayoutMovesChildren()) && !element.__layoutPropertiesChanged) {
	      element.__layoutPropertiesChanged = true;
	      results.push(element._elementChanged());
	    }
	    return results;
	  };

	  layoutChildrenComputeMaxSize = function(parentSize, children) {
	    var child, childrenHeight, childrenWidth, k, len, size;
	    childrenHeight = 0;
	    childrenWidth = 0;
	    for (k = 0, len = children.length; k < len; k++) {
	      child = children[k];
	      if (!(children)) {
	        continue;
	      }
	      size = layoutElement(child, parentSize);
	      childrenWidth = max(childrenWidth, size.x);
	      childrenHeight = max(childrenHeight, size.y);
	    }
	    return point(childrenWidth, childrenHeight);
	  };

	  layoutChildrenComputeArea = function(currentPadding, parentSize, children, secondPassChildren, secondPassLocation) {
	    var child, childrenHeight, childrenWidth, k, layoutLocationInSecondPass, len, x, xInfinite, y, yInfinite;
	    childrenHeight = 0;
	    childrenWidth = 0;
	    if (!children) {
	      return point0;
	    }
	    for (k = 0, len = children.length; k < len; k++) {
	      child = children[k];
	      if (children) {
	        if (child.getPendingLayoutSizeParentCircular()) {

	          /*
	          If size is circular:
	            - this element is automatically not "inFlow"
	            - this element is not included in child-size calcs
	            - this element is only layed out after the parent-size is final.
	           */
	          secondPassChildren.push(child);
	        } else {

	          /*
	          If location is circular (but size is not):
	            - this element's location is assumed to be point0 for child-size calc purposes
	            - this element's location layout is done in the second pass. (is it?!?)
	           */
	          if (layoutLocationInSecondPass = child.getPendingLayoutLocationParentCircular()) {
	            child._setElementToParentMatrixFromLayout(point0, parentSize);
	            secondPassLocation.push(child);
	          }
	          layoutElement(child, parentSize, layoutLocationInSecondPass);
	          x = child.getPendingMaxXInParentSpace();
	          y = child.getPendingMaxYInParentSpace();
	          xInfinite = isInfiniteResult(x);
	          yInfinite = isInfiniteResult(y);
	          if (xInfinite || yInfinite) {
	            secondPassChildren.push(child);
	          } else if (layoutLocationInSecondPass) {
	            secondPassLocation.push(child);
	          }
	          if (!xInfinite) {
	            childrenWidth = max(childrenWidth, x);
	          }
	          if (!yInfinite) {
	            childrenHeight = max(childrenHeight, y);
	          }
	        }
	      }
	    }
	    return sizeWithPadding(childrenWidth, childrenHeight, currentPadding);
	  };

	  layoutChildrenFlowLine = function(children, rightEdge, state) {
	    var child, childI, childSize, childrenLength, currentMargin, firstChildOnLine, k, lastChildOnLine, lastLineMarginBottom, lastMarginRight, lineFull, lineHeight, m, maxLineMarginBottom, maxLineMarginTop, maxWidth, ref, ref1, ref2, ref3, x, y;
	    y = state.y, firstChildOnLine = state.firstChildOnLine, lastLineMarginBottom = state.lastLineMarginBottom, maxWidth = state.maxWidth;
	    childrenLength = children.length;
	    maxLineMarginBottom = 0;
	    maxLineMarginTop = 0;
	    lineHeight = 0;
	    lastMarginRight = 0;
	    lastChildOnLine = firstChildOnLine;
	    x = 0;
	    for (childI = k = ref = firstChildOnLine, ref1 = childrenLength; k < ref1; childI = k += 1) {
	      lastChildOnLine = childI;
	      child = children[lastChildOnLine];
	      currentMargin = child.getPendingCurrentMargin();
	      childSize = child.getPendingCurrentSize();
	      if (lastChildOnLine !== firstChildOnLine) {
	        x += max(currentMargin.left, lastMarginRight);
	      }
	      x += childSize.x;
	      lastMarginRight = currentMargin.right;
	      lineFull = x >= rightEdge;
	      if (child.getPendingLayoutSizeParentCircular() && child.getPendingSize().getXParentRelative()) {
	        if (lastChildOnLine !== firstChildOnLine) {
	          lastChildOnLine--;
	        }
	        lineFull = true;
	      }
	      if (!lineFull || lastChildOnLine === firstChildOnLine) {
	        maxLineMarginTop = max(currentMargin.top, maxLineMarginTop);
	        maxLineMarginBottom = max(currentMargin.bottom, maxLineMarginBottom);
	        lineHeight = max(lineHeight, childSize.y);
	        if (lineFull) {
	          break;
	        }
	      } else {
	        lastChildOnLine--;
	        break;
	      }
	    }
	    if (lastLineMarginBottom != null) {
	      y += max(lastLineMarginBottom, maxLineMarginTop);
	    }
	    x = 0;
	    lastMarginRight = 0;
	    for (childI = m = ref2 = firstChildOnLine, ref3 = lastChildOnLine; m <= ref3; childI = m += 1) {
	      child = children[childI];
	      currentMargin = child.getPendingCurrentMargin();
	      childSize = child.getPendingCurrentSize();
	      if (childI !== firstChildOnLine) {
	        x += max(currentMargin.left, lastMarginRight);
	      }
	      child._setElementToParentMatrixFromLayout(point(x, y), point(childSize.x, lineHeight));
	      x += childSize.x;
	      lastMarginRight = currentMargin.right;
	    }
	    if (state.flowChildren) {
	      state.firstChildIndexOfEachLine.push(firstChildOnLine);
	      state.lastChildIndexOfEachLine.push(lastChildOnLine);
	      state.widthOfEachLine.push(x);
	    }
	    state.lastLineMarginBottom = maxLineMarginBottom;
	    state.y = y + lineHeight;
	    state.firstChildOnLine = lastChildOnLine + 1;
	    return state.maxWidth = max(maxWidth, x);
	  };

	  subLayoutChildrenAndGatherInformation = function(parentSize, children, secondPassSizeLayoutChildren) {
	    var child, k, len, results;
	    results = [];
	    for (k = 0, len = children.length; k < len; k++) {
	      child = children[k];
	      if (child.getPendingLayoutSizeParentCircular()) {
	        child._setSizeFromLayout(child._layoutSize(point0, point0));
	        results.push(secondPassSizeLayoutChildren.push(child));
	      } else {
	        results.push(layoutElement(child, parentSize, true));
	      }
	    }
	    return results;
	  };

	  layoutChildrenFlow = function(element, currentPadding, firstPassSizeForChildrenUnconstrained, firstPassSizeForChildrenConstrained, children, secondPassSizeLayoutChildren) {
	    var childrenAlignment, childrenLength, halfPixel, rightEdge, state;
	    subLayoutChildrenAndGatherInformation(firstPassSizeForChildrenConstrained, children, secondPassSizeLayoutChildren);
	    halfPixel = .5;
	    rightEdge = firstPassSizeForChildrenUnconstrained.x + halfPixel;
	    state = {
	      y: 0,
	      firstChildOnLine: 0,
	      lastLineMarginBottom: null,
	      maxWidth: 0
	    };
	    childrenAlignment = element.getPendingChildrenAlignment();
	    if (!floatEq(childrenAlignment.x, 0) || !floatEq(childrenAlignment.y, 0)) {
	      state.childrenAlignment = childrenAlignment;
	      state.flowChildren = children;
	      state.firstChildIndexOfEachLine = [];
	      state.lastChildIndexOfEachLine = [];
	      state.widthOfEachLine = [];
	    }
	    childrenLength = children.length;
	    while (state.firstChildOnLine < childrenLength) {
	      layoutChildrenFlowLine(children, rightEdge, state);
	    }
	    state.childrenSize = sizeWithPadding(state.maxWidth, state.y, currentPadding);
	    return state;
	  };

	  isSpace = function(charCode) {
	    return charCode === 32;
	  };

	  layoutChildrenRowGrid = function(isRowLayout, element, gridString, currentPadding, parentSize, children, secondPassSizeLayoutChildren) {
	    var gridCount, gridStep, lowerCaseACode, maxCrossSize, offset;
	    gridCount = gridString.length;
	    lowerCaseACode = 97;
	    gridStep = (isRowLayout ? parentSize.x : parentSize.y) / gridCount;
	    maxCrossSize = offset = 0;
	    eachRunAsCharCodes(gridString.toLowerCase(), function(charCode, count) {
	      var adjustedParentSize, child, gridSize, locationX, locationY;
	      gridSize = count * gridStep;
	      if (child = children[charCode - lowerCaseACode]) {
	        adjustedParentSize = isRowLayout ? parentSize.withX(gridSize) : parentSize.withY(gridSize);
	        layoutElement(child, adjustedParentSize, true);
	        locationX = child._layoutLocationX(adjustedParentSize);
	        locationY = child._layoutLocationY(adjustedParentSize);
	        maxCrossSize = max(maxCrossSize, isRowLayout ? (child._setElementToParentMatrixFromLayoutXY(offset + locationX, locationY, parentSize), child.getPendingCurrentSize().y) : (child._setElementToParentMatrixFromLayoutXY(locationX, offset + locationY, parentSize), child.getPendingCurrentSize().x));
	      }
	      return offset += gridSize;
	    });
	    return {
	      childrenSize: sizeWithPadding(offset, maxCrossSize, currentPadding)
	    };
	  };

	  alignChildren = function(state, parentSize, childrenSize) {
	    var child, childrenAlignment, childrenAlignmentX, childrenAlignmentY, firstChildIndexOfEachLine, firstChildOnLine, firstIndex, flowChildren, i, j, k, l, lastChildIndexOfEachLine, lastIndex, len, offsetX, offsetY, results, width, widthOfEachLine, widthOfEachLineFunction;
	    childrenAlignment = state.childrenAlignment, flowChildren = state.flowChildren, firstChildIndexOfEachLine = state.firstChildIndexOfEachLine, lastChildIndexOfEachLine = state.lastChildIndexOfEachLine, widthOfEachLine = state.widthOfEachLine, widthOfEachLineFunction = state.widthOfEachLineFunction;
	    widthOfEachLineFunction || (widthOfEachLineFunction = function(i) {
	      return widthOfEachLine[i];
	    });
	    childrenAlignmentX = childrenAlignment.x;
	    childrenAlignmentY = childrenAlignment.y;
	    results = [];
	    for (i = k = 0, len = firstChildIndexOfEachLine.length; k < len; i = ++k) {
	      firstIndex = firstChildIndexOfEachLine[i];
	      lastIndex = lastChildIndexOfEachLine[i];
	      width = widthOfEachLineFunction(i);
	      firstChildOnLine = flowChildren[firstIndex];
	      if (firstChildOnLine.getPendingLayoutSizeParentCircular() && firstChildOnLine.getPendingSize().getXParentRelative()) {
	        width = firstChildOnLine.getPendingCurrentSize().x;
	      }
	      offsetX = (parentSize.x - width) * childrenAlignmentX;
	      offsetY = (parentSize.y - childrenSize.y) * childrenAlignmentY;
	      if (!floatEq(offsetX, 0) || !floatEq(offsetY, 0)) {
	        results.push((function() {
	          var m, ref, ref1, results1;
	          results1 = [];
	          for (j = m = ref = firstIndex, ref1 = lastIndex; m <= ref1; j = m += 1) {
	            child = flowChildren[j];
	            l = child.getPendingCurrentLocation();
	            results1.push(child._setElementToParentMatrixFromLayoutXY(l.x + offsetX, l.y + offsetY, parentSize));
	          }
	          return results1;
	        })());
	      } else {
	        results.push(void 0);
	      }
	    }
	    return results;
	  };

	  CoreLayout.layoutElement = layoutElement = function(element, parentSize, skipLocation) {

	    /*
	    TODO - increase effieciency
	    Currently, we will always recurse all the way down any children
	    which are children-size-relative regardless on if they (or one of their
	    decendents) is actually parent-relative.
	    
	    Sometimes this is right (see the children relative middlemen tests).
	    Often, though, the children really are 100% child-size-relative and 100% ignore
	    parent's size.
	    
	    In that case, we shouldn't re-lay them out.
	    
	    Is there any way to be smart about that?
	    
	    Obviously we can let the app dev specify an element is 100% child-size relative in some way.
	      Element ignoreParentSize: true
	    
	    But that's ugly!
	     */
	    var child, childI, childrenFlowState, childrenGrid, childrenLayout, childrenSize, currentMargin, currentPadding, finalLocation, firstPassChildren, firstPassSize, firstPassSizeForChildrenConstrained, firstPassSizeForChildrenUnconstrained, hasCustomLayoutChildrenFirstPass, hasCustomLayoutChildrenSecondPass, k, len, len1, len2, len3, m, n, o, pendingChildren, s, secondPassChildren, secondPassLocationLayoutChildren, secondPassSize, secondPassSizeForChildren, secondPassSizeLayoutChildren, size;
	    if (!(element.__layoutPropertiesChanged || !shallowEq(element._lastParentSize, parentSize))) {
	      return element.getPendingCurrentSize();
	    }
	    element._lastParentSize = parentSize;
	    element.__layoutPropertiesChanged = false;
	    if (!skipLocation) {
	      finalLocation = element._layoutLocation(parentSize);
	    }
	    firstPassSize = element._layoutSize(parentSize, nearInfiniteSize);
	    currentPadding = layoutPadding(element, parentSize);
	    currentMargin = layoutMargin(element, parentSize);
	    firstPassSizeForChildrenUnconstrained = element._sizeForChildren(firstPassSize);
	    firstPassSizeForChildrenConstrained = element._sizeForChildren(element._layoutSizeForChildren(parentSize, nearInfiniteSize));
	    hasCustomLayoutChildrenFirstPass = isFunction(element.customLayoutChildrenFirstPass);
	    hasCustomLayoutChildrenSecondPass = isFunction(element.customLayoutChildrenSecondPass);
	    pendingChildren = element.getPendingChildren();
	    firstPassChildren = secondPassChildren = null;
	    childrenLayout = element.getPendingChildrenLayout();
	    if (childrenLayout || element.getPendingSize().getChildrenRelative()) {
	      firstPassChildren = pendingChildren;
	      for (childI = k = 0, len = pendingChildren.length; k < len; childI = ++k) {
	        child = pendingChildren[childI];
	        if (child.getPendingInFlow()) {
	          if (secondPassChildren) {
	            firstPassChildren.push(child);
	          }
	        } else {
	          if (!secondPassChildren) {
	            firstPassChildren = pendingChildren.slice(0, childI);
	            secondPassChildren = [];
	          }
	          secondPassChildren.push(child);
	        }
	      }
	      secondPassSizeLayoutChildren = [];
	      secondPassLocationLayoutChildren = [];
	      secondPassChildren || (secondPassChildren = []);
	    } else {
	      secondPassChildren = pendingChildren;
	    }
	    if (firstPassChildren || hasCustomLayoutChildrenFirstPass) {
	      childrenSize = (function() {
	        if (hasCustomLayoutChildrenFirstPass) {
	          s = currentPadding.addedToSize(element.customLayoutChildrenFirstPass(firstPassSizeForChildrenUnconstrained));
	          if ((pendingChildren != null ? pendingChildren.length : void 0) > 0) {
	            s = s.max(size = layoutChildrenComputeArea(currentPadding, firstPassSizeForChildrenConstrained, firstPassChildren, secondPassChildren, secondPassLocationLayoutChildren));
	          }
	          return s;
	        } else {
	          childrenGrid = element.getPendingChildrenGrid();
	          switch (childrenLayout) {
	            case "flow":
	              childrenFlowState = layoutChildrenFlow(element, currentPadding, firstPassSizeForChildrenUnconstrained, firstPassSizeForChildrenConstrained, firstPassChildren, secondPassSizeLayoutChildren);
	              return childrenFlowState.childrenSize;
	            case "column":
	              childrenFlowState = childrenGrid ? layoutChildrenRowGrid(false, element, childrenGrid, currentPadding, firstPassSizeForChildrenConstrained, firstPassChildren, secondPassSizeLayoutChildren) : layoutChildrenFlex(false, element, currentPadding, firstPassSizeForChildrenConstrained, firstPassChildren, parentSize);
	              return childrenFlowState.childrenSize;
	            case "row":
	              childrenFlowState = childrenGrid ? layoutChildrenRowGrid(true, element, childrenGrid, currentPadding, firstPassSizeForChildrenConstrained, firstPassChildren, secondPassSizeLayoutChildren) : layoutChildrenFlex(true, element, currentPadding, firstPassSizeForChildrenConstrained, firstPassChildren, parentSize);
	              return childrenFlowState.childrenSize;
	            default:
	              return layoutChildrenComputeArea(currentPadding, firstPassSizeForChildrenConstrained, firstPassChildren, secondPassChildren, secondPassLocationLayoutChildren);
	          }
	        }
	      })();
	      secondPassSize = element._layoutSize(parentSize, childrenSize);
	      secondPassSizeForChildren = element._sizeForChildren(secondPassSize);
	      if (secondPassSizeLayoutChildren) {
	        for (m = 0, len1 = secondPassSizeLayoutChildren.length; m < len1; m++) {
	          child = secondPassSizeLayoutChildren[m];
	          layoutElement(child, secondPassSizeForChildren, true);
	        }
	      }
	      if (secondPassLocationLayoutChildren) {
	        for (n = 0, len2 = secondPassLocationLayoutChildren.length; n < len2; n++) {
	          child = secondPassLocationLayoutChildren[n];
	          child._setElementToParentMatrixFromLayout(child._layoutLocation(secondPassSizeForChildren), parentSize);
	        }
	      }
	    } else {
	      secondPassSize = firstPassSize;
	      secondPassSizeForChildren = firstPassSizeForChildrenConstrained;
	    }
	    if (childrenFlowState != null ? childrenFlowState.childrenAlignment : void 0) {
	      alignChildren(childrenFlowState, secondPassSizeForChildren, childrenSize);
	    } else if (hasCustomLayoutChildrenSecondPass) {
	      element.customLayoutChildrenSecondPass(secondPassSizeForChildren);
	    }
	    if (secondPassChildren) {
	      for (o = 0, len3 = secondPassChildren.length; o < len3; o++) {
	        child = secondPassChildren[o];
	        layoutElement(child, secondPassSizeForChildren);
	      }
	    }
	    element._setSizeFromLayout(deinfinitize(secondPassSize));
	    if (!skipLocation) {
	      element._setElementToParentMatrixFromLayout(deinfinitize(finalLocation), parentSize);
	    }
	    return secondPassSize;
	  };

	  return StateEpochLayout;

	})(BaseObject);


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var Core, EpochLayout,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Core = __webpack_require__(158);

	module.exports = Core.EpochLayout || Core.addNamespace('EpochLayout', EpochLayout = (function(superClass) {
	  extend(EpochLayout, superClass);

	  function EpochLayout() {
	    return EpochLayout.__super__.constructor.apply(this, arguments);
	  }

	  return EpochLayout;

	})(Neptune.Base));


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, BaseObject, Basics, CoreLayout, FlexLayout, Foundation, Point, abs, floatEq, inspect, layoutMargin, log, max, peek, perimeter, point, point0, select, shallowEq, sizeWithPadding,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	CoreLayout = __webpack_require__(196);

	Basics = __webpack_require__(198);

	point = Atomic.point, Point = Atomic.Point, perimeter = Atomic.perimeter;

	BaseObject = Foundation.BaseObject, log = Foundation.log, inspect = Foundation.inspect, shallowEq = Foundation.shallowEq, select = Foundation.select, peek = Foundation.peek, inspect = Foundation.inspect, floatEq = Foundation.floatEq;

	layoutMargin = Basics.layoutMargin, sizeWithPadding = Basics.sizeWithPadding;

	point0 = Point.point0;

	abs = Math.abs, max = Math.max;

	module.exports = FlexLayout = (function(superClass) {
	  extend(FlexLayout, superClass);

	  function FlexLayout() {
	    return FlexLayout.__super__.constructor.apply(this, arguments);
	  }

	  FlexLayout.layoutChildrenFlex = function(isRowLayout, element, currentPadding, elementSizeForChildren, children, parentSize) {

	    /*
	    Flexbox terminology: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes
	    
	    Names for row-layout: (swap x/y, width/height, left/top and right/bottom for column-layout)
	      main-axis:    x
	      cross-axis:   y
	      main-size:    w
	      cross-size    h
	      main-start:   left / 0
	      main-end:     right / parent-width
	      cross-start:  top / 0
	      cross-end:    bottom / parent-height
	     */
	    var addSecondPassChild, adjustedCrossSize, adjustedParentSize, child, childCrossSize, childFlexWeight, childrenAlignment, childrenSize, crossAlignment, crossCoordinate, crossOffset, crossRelativeTestFunction, crossSize, currentSize, effectivePrevMargin, elementCrossSizeForChildren, elementMainAxisIsChildRelative, elementMainSizeForChildren, finalPassMainSizesForChildren, finalPassSizeLayoutChildren, flexParentSize, hasCrossAlignment, hasMainAlignment, heightRemainingChildren, i, j, k, l, lastChildsNextMargin, len, len1, len2, len3, locationX, locationY, m, mainAlignment, mainCoordinate, mainPos, mainSize, mainSizeForChild, margin, maxCrossSize, nextMargin, previousMargin, ratio, relativeSizeIndex, relativeTestFunction, secondPassSizeForChildren, sizeForChild, spaceForFlexChildren, state, toPoint, totalFlexWeight, totalMainSize;
	    if (isRowLayout) {
	      mainCoordinate = "x";
	      crossCoordinate = "y";
	      previousMargin = "left";
	      nextMargin = "right";
	      relativeTestFunction = "getXRelativeToParentW";
	      crossRelativeTestFunction = "getYRelativeToParentH";
	      elementMainAxisIsChildRelative = element.getPendingSize().getXRelativeToChildrenW();
	    } else {
	      mainCoordinate = "y";
	      crossCoordinate = "x";
	      previousMargin = "top";
	      nextMargin = "bottom";
	      relativeTestFunction = "getYRelativeToParentH";
	      crossRelativeTestFunction = "getXRelativeToParentW";
	      elementMainAxisIsChildRelative = element.getPendingSize().getYRelativeToChildrenH();
	    }
	    elementMainSizeForChildren = elementSizeForChildren[mainCoordinate];
	    elementCrossSizeForChildren = elementSizeForChildren[crossCoordinate];
	    heightRemainingChildren = null;
	    maxCrossSize = totalFlexWeight = 0;
	    spaceForFlexChildren = elementSizeForChildren[mainCoordinate];
	    totalMainSize = 0;
	    toPoint = function(mainPos, crossPos, currentPadding) {
	      var x, y;
	      x = y = 0;
	      if (isRowLayout) {
	        x = mainPos;
	        y = crossPos;
	      } else {
	        x = crossPos;
	        y = mainPos;
	      }
	      if (currentPadding) {
	        return sizeWithPadding(x, y, currentPadding);
	      } else {
	        return point(x, y);
	      }
	    };
	    state = {};
	    lastChildsNextMargin = 0;
	    finalPassSizeLayoutChildren = null;
	    finalPassMainSizesForChildren = null;
	    addSecondPassChild = function(child, mainSizeForChild) {
	      if (finalPassSizeLayoutChildren) {
	        finalPassSizeLayoutChildren.push(child);
	        return finalPassMainSizesForChildren.push(mainSizeForChild);
	      } else {
	        finalPassSizeLayoutChildren = [child];
	        return finalPassMainSizesForChildren = [mainSizeForChild];
	      }
	    };
	    for (i = j = 0, len = children.length; j < len; i = ++j) {
	      child = children[i];
	      if (child.getPendingSize()[relativeTestFunction]()) {
	        currentSize = child._layoutSize(elementSizeForChildren, point0);
	        childFlexWeight = child.getPendingLayoutWeight();
	        totalFlexWeight += childFlexWeight;
	      } else {
	        CoreLayout.layoutElement(child, elementSizeForChildren, true);
	        currentSize = child.getPendingCurrentSize();
	        mainSize = currentSize[mainCoordinate];
	        totalMainSize += mainSize;
	        spaceForFlexChildren -= mainSize;
	        if (child.getPendingLayoutSizeParentCircular()) {
	          addSecondPassChild(child, null);
	        } else {
	          crossSize = currentSize[crossCoordinate];
	          maxCrossSize = max(maxCrossSize, crossSize);
	        }
	      }
	      margin = layoutMargin(child, elementSizeForChildren);
	      if (i > 0) {
	        effectivePrevMargin = max(lastChildsNextMargin, margin[previousMargin]);
	        spaceForFlexChildren -= effectivePrevMargin;
	      }
	      lastChildsNextMargin = margin[nextMargin];
	    }
	    relativeSizeIndex = 0;
	    for (i = k = 0, len1 = children.length; k < len1; i = ++k) {
	      child = children[i];
	      if (!(child.getPendingSize()[relativeTestFunction]())) {
	        continue;
	      }
	      childFlexWeight = child.getPendingLayoutWeight();
	      ratio = childFlexWeight / totalFlexWeight;
	      flexParentSize = toPoint(mainSizeForChild = spaceForFlexChildren * ratio, elementCrossSizeForChildren);
	      CoreLayout.layoutElement(child, flexParentSize, true);
	      currentSize = child.getPendingCurrentSize();
	      mainSize = currentSize[mainCoordinate];
	      if (child.getPendingLayoutSizeParentCircular()) {
	        addSecondPassChild(child, mainSizeForChild);
	      } else {
	        crossSize = currentSize[crossCoordinate];
	        maxCrossSize = max(maxCrossSize, crossSize);
	      }
	      totalFlexWeight -= childFlexWeight;
	      spaceForFlexChildren -= mainSize;
	      totalMainSize += mainSize;
	    }
	    childrenSize = toPoint(totalMainSize, maxCrossSize, currentPadding);
	    if (isRowLayout) {
	      elementMainSizeForChildren = element.getPendingSize().layoutX(parentSize, childrenSize) - currentPadding.getWidth();
	      elementCrossSizeForChildren = element.getPendingSize().layoutY(parentSize, childrenSize) - currentPadding.getHeight();
	    } else {
	      elementCrossSizeForChildren = element.getPendingSize().layoutX(parentSize, childrenSize) - currentPadding.getWidth();
	      elementMainSizeForChildren = element.getPendingSize().layoutY(parentSize, childrenSize) - currentPadding.getHeight();
	    }
	    if (finalPassSizeLayoutChildren) {
	      secondPassSizeForChildren = toPoint(elementMainSizeForChildren, elementCrossSizeForChildren);
	      for (i = l = 0, len2 = finalPassSizeLayoutChildren.length; l < len2; i = ++l) {
	        child = finalPassSizeLayoutChildren[i];
	        sizeForChild = (mainSizeForChild = finalPassMainSizesForChildren[i]) ? toPoint(mainSizeForChild, elementCrossSizeForChildren) : secondPassSizeForChildren;
	        CoreLayout.layoutElement(child, sizeForChild, true);
	      }
	    }
	    lastChildsNextMargin = 0;
	    childrenAlignment = element.getPendingChildrenAlignment();
	    crossAlignment = childrenAlignment[crossCoordinate];
	    hasCrossAlignment = !floatEq(0, crossAlignment);
	    mainPos = !elementMainAxisIsChildRelative && (hasMainAlignment = !floatEq(0, mainAlignment)) ? (mainAlignment = childrenAlignment[mainCoordinate], (elementMainSizeForChildren - totalMainSize) * mainAlignment) : 0;
	    for (i = m = 0, len3 = children.length; m < len3; i = ++m) {
	      child = children[i];
	      margin = child.getPendingCurrentMargin();
	      if (i > 0) {
	        effectivePrevMargin = max(lastChildsNextMargin, margin[previousMargin]);
	        mainPos += effectivePrevMargin;
	      }
	      lastChildsNextMargin = margin[nextMargin];
	      currentSize = child.getPendingCurrentSize();
	      mainSize = !elementMainAxisIsChildRelative && i === children.length - 1 ? elementMainSizeForChildren - mainPos : currentSize[mainCoordinate];
	      crossOffset = 0;
	      adjustedCrossSize = elementCrossSizeForChildren;
	      if (hasCrossAlignment) {
	        childCrossSize = currentSize[crossCoordinate];
	        crossOffset = (elementCrossSizeForChildren - childCrossSize) * crossAlignment;
	        adjustedCrossSize = childCrossSize;
	      }
	      adjustedParentSize = toPoint(mainSize, adjustedCrossSize);
	      locationX = child._layoutLocationX(adjustedParentSize);
	      locationY = child._layoutLocationY(adjustedParentSize);
	      if (isRowLayout) {
	        locationX += mainPos;
	        locationY += crossOffset;
	      } else {
	        locationY += mainPos;
	        locationX += crossOffset;
	      }
	      child._setElementToParentMatrixFromLayoutXY(locationX, locationY, adjustedParentSize);
	      mainPos += mainSize;
	    }
	    state.childrenSize = toPoint(mainPos, maxCrossSize, currentPadding);
	    return state;
	  };

	  return FlexLayout;

	})(BaseObject);


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, BaseObject, Basics, Foundation, Point, abs, isFunction, isInfiniteResult, nearInfiniteSize, nearInfinity, nearInfinityResult, perimeter, point, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	point = Atomic.point, Point = Atomic.Point, perimeter = Atomic.perimeter;

	BaseObject = Foundation.BaseObject, isFunction = Foundation.isFunction, abs = Foundation.abs;

	ref = __webpack_require__(199), nearInfiniteSize = ref.nearInfiniteSize, nearInfinity = ref.nearInfinity, nearInfinityResult = ref.nearInfinityResult, isInfiniteResult = ref.isInfiniteResult;

	module.exports = Basics = (function(superClass) {
	  extend(Basics, superClass);

	  function Basics() {
	    return Basics.__super__.constructor.apply(this, arguments);
	  }

	  Basics.nearInfiniteSize = nearInfiniteSize;

	  Basics.nearInfinity = nearInfinity;

	  Basics.nearInfinityResult = nearInfinityResult;

	  Basics.layoutMargin = function(element, parentSize) {
	    var margin;
	    margin = element.getPendingMargin();
	    return element._setMarginFromLayout(perimeter(isFunction(margin) ? margin(parentSize) : margin));
	  };

	  Basics.layoutPadding = function(element, parentSize) {
	    var padding;
	    padding = element.getPendingPadding();
	    return element._setPaddingFromLayout(perimeter(isFunction(padding) ? padding(parentSize) : padding));
	  };

	  Basics.isInfiniteResult = isInfiniteResult;

	  Basics.deinfinitize = function(p) {
	    var x, y;
	    x = p.x, y = p.y;
	    x = isInfiniteResult(x) ? 0 : x;
	    y = isInfiniteResult(y) ? 0 : y;
	    return p["with"](x, y);
	  };

	  Basics.sizeWithPadding = function(width, height, currentPadding) {
	    return point(width + currentPadding.getWidth(), height + currentPadding.getHeight());
	  };

	  return Basics;

	})(BaseObject);


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, BaseObject, Foundation, abs, isFunction, isPlainObject, log, nearInfinitePoint, nearInfinity, nearInfinityResult, point;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	BaseObject = Foundation.BaseObject, isPlainObject = Foundation.isPlainObject, log = Foundation.log, isFunction = Foundation.isFunction, nearInfinity = Foundation.nearInfinity, nearInfinityResult = Foundation.nearInfinityResult, abs = Foundation.abs;

	point = Atomic.point;

	module.exports = {
	  nearInfinity: nearInfinity,
	  nearInfinityResult: nearInfinityResult,
	  nearInfinitePoint: nearInfinitePoint = point(nearInfinity),
	  nearInfiniteSize: nearInfinitePoint,
	  isInfiniteResult: function(x) {
	    return abs(x) >= nearInfinityResult;
	  }
	};


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, EasingPersistantAnimator, EpochedObject, Events, Foundation, GlobalEpochCycle, PeriodicPersistantAnimator, PersistantAnimator, StateEpoch, blankOptions, capitalize, compactFlatten, globalEpochCycle, inspect, isFunction, isNumber, isPlainArray, isPlainObject, isString, log, merge, mergeInto, nextTick, plainObjectsDeepEq, propInternalName, ref, shallowEq, stateEpoch,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	Foundation = __webpack_require__(19);

	Events = __webpack_require__(168);

	StateEpoch = __webpack_require__(194);

	GlobalEpochCycle = __webpack_require__(201);

	ref = __webpack_require__(205), PersistantAnimator = ref.PersistantAnimator, EasingPersistantAnimator = ref.EasingPersistantAnimator, PeriodicPersistantAnimator = ref.PeriodicPersistantAnimator;

	log = Foundation.log, merge = Foundation.merge, mergeInto = Foundation.mergeInto, BaseObject = Foundation.BaseObject, capitalize = Foundation.capitalize, compactFlatten = Foundation.compactFlatten, isNumber = Foundation.isNumber, isFunction = Foundation.isFunction, shallowEq = Foundation.shallowEq, plainObjectsDeepEq = Foundation.plainObjectsDeepEq, isString = Foundation.isString, inspect = Foundation.inspect, isPlainObject = Foundation.isPlainObject, isPlainArray = Foundation.isPlainArray, nextTick = Foundation.nextTick;

	propInternalName = BaseObject.propInternalName;

	blankOptions = {};

	stateEpoch = StateEpoch.stateEpoch;

	globalEpochCycle = GlobalEpochCycle.globalEpochCycle;

	module.exports = EpochedObject = (function(superClass) {
	  var _setPropertiesTempVirtualPropSetterNames, _setPropertiesTempVirtualPropValues, minimalPropsIngore, propsEq, shallowPropsEq;

	  extend(EpochedObject, superClass);

	  EpochedObject.propsEq = propsEq = plainObjectsDeepEq;

	  EpochedObject.shallowPropsEq = shallowPropsEq = shallowEq;


	  /*
	  
	  CONCRETE PROPERTIES
	  -------------------
	  
	  Concrete-properties (non-virtual properties), once declared, take care of many common property tasks.
	  For a property "foo":
	  
	    * @_foo and @_pendingState._foo are initialized on Element-instantiation
	      - They are either intialized to default values (which are validated for consistency) or
	      - Can be initialized by the instantiating code. Ex: new Element foo:123
	    * Defines the following API
	      - element.foo       # getter, returns @_foo
	      - element.getFoo()  # old-school, alternative getter - faster in some browsers (Safari7 is 100x faster, Safary8 is 3x faster. Chrome is same speed.)
	      - element.foo = v   # setter
	      - element.setFoo(v) # old-school, alternative setter
	      - element.pendingFoo / getPendingFoo() # returns @_pendingState.foo
	      - element.fooChanged / getFooChanged() # returns propsEq @foo, @pendingFoo
	    * Elements can override the default values for properties by setting:
	      - prototype.defaultFoo to something other than undefined
	      - Ex:
	        class MyElement extends Element
	          defaultSize: ps:1
	    * Populates @class.metaProperties.foo with things like default values, names, preprocessors, etc...
	      (this code is in flux; see below for current implementation)
	  
	  options:
	    default:  # default value set when the Element is created
	    setter: (preprocessedNewValue, oldValue, rawNewValue, preprocessAndValidate) ->
	      THIS: the Element
	      IN:
	        rawNewValue: the exact, unprocessed, unvalidated value of 'foo' passed by the setYourProp(foo) or @yourProp = foo statement.
	        oldValue: the (custom-setter-processed) value that was last set (i.e. the value in @_pendingState)
	        preprocessAndValidate: your custom preprocessor and validator are merged into a single function you can use
	          as part of your custom setter if desired. A no-op function is provided by default, so this is always a valid function.
	      OUT: It should return the value to set in @_pendingState.
	      SIDE EFFECTS:
	        It should NOT actually set the value in @ or @_pendingState.
	        It is best to use setProperty calls for all side-effects. This maintains the epoch
	        consistency model: mutations only modify pendingState, not current-state.
	  
	      TODO:
	        Verify and implement:
	          Depricate concrete property setters:
	            They are obsolete now that we can have postSetters.
	            "postSetter" plus "preprocess" covers everything, I think.
	  
	      Use when:
	        a) you need to do update other poperties when this one changes AND/OR
	        b) you need to do something different when actually setting the value
	           as opposed to simply preprocessing the value.
	           NOTE: animations use the preprocessor when initializing their to and from values.
	  
	    postSetter: (newValue, oldValue, rawNewValue) ->
	      THIS: the Element
	      IN:
	        newValue: the value after it has passed through the preprocessor and/or setter
	        oldValue: the (custom-setter-processed) value that was last set
	          i.e. the value in @_pendingState before the setter was called
	      OUT: ignored
	      STATE: @_pendingState has been updated with newValue; getPendingPropertyName() will return newValue
	      SIDE EFFECTS:
	        It is best to use setProperty calls for all side-effects. This maintains the epoch
	        consistency model: mutations only modify pendingState, not current-state.
	  
	      Use when:
	        a) You need to update other properties when this one changes. The simplest example is when
	          this property defines default values for other properties that haven't been set yet.
	        b) You need to fire off events when this property changes.
	  
	      This is particularly useful when writing custom Elements which consist of a struture of other
	      elements. Often you'll want to update that structure in response to properties being set.
	  
	    preprocess: (rawValue) -> processedValue
	      IN: raw setter input
	      THIS: not set
	      OUT: normalized value to actually set
	  
	    validate: (rawValue) -> boolean
	      IN: raw value
	      THIS: not set
	      OUT: true or false
	      Return false if the input is invalid which will trigger an exception.
	  
	  In all cases _elementChanged executes every time the property is set
	  .setter takes precidence over .preprocess takes precidence over .validate; you can only have one
	  
	  VIRTUAL PROPERTIES
	  ------------------
	  
	  Virtual properties are specified with the class method: @virtualProperty
	  
	  VPs have the same API from the client's perspective, but they don't have any storage in @ or @_pendingState.
	  Virtual properties are used as alternative "views" into the Element's state. Ex:
	  
	     @currentLocation isn't actually stored as a point. It is derived from @elementToParentMatrix and @axis.
	  
	  As a short-cut, you can supply just a getter function instead of options to define a
	  virtual property. See getter below for details. Here is how to use this shortcut:
	  
	    @virtualProperty
	      foo: (pending) -> ...
	  
	  Virtual property options (when isPlainObject options)
	  
	    getter: (pending) ->
	      REQUIRED
	      THIS: the Element
	      IN:   pending: true/false
	      OUT:  if pending, return the pending value, else the current value
	  
	    setter: (preprocessedNewValue, rawNewValue, preprocessAndValidate) ->
	      OPTIONAL
	        If not provided, this virtual property cannot be set.
	        Attempting to set this virtual property will be IGNORED
	        I.E. attempting to set this property does not trigger errors.
	  
	      THIS: the Element
	      IN:
	        rawNewValue: the value passed in by the client
	        preprocessAndValidate: your custom preprocessor and validator are merged into a single function you can use
	          as part of your custom setter if desired. A no-op function is provided by default, so this is always a valid function.
	      OUT: ignored
	  
	    validate: (v) ->
	    preprocess: (v) ->
	      works the same as the options for concrete-properties
	      except they are only used by:
	        preprocessAndValidate function passed to the setter
	        animations
	  
	  Virtual property getter-function-only (if the 'options' passed in is actually a function)
	  
	    If you pass in a function only when defining a virtual property, you are setting the getter.
	    Thus you can define a virtual property with just a getter.
	  
	  Virtual vs Concrete properties:
	  
	    * Virutal props don't have default values
	    * Virtual props don't create property slots in Element instances or their _pendingState, BUT
	    * Virtual props can have their setters invoked from initializers
	    * preprocessors and validators can be specified
	    * getter - you must specify a custom getter, see getter option above
	    * setter specification/semantics are a little different. See setter option above
	   */


	  /*
	  propertyInitializerList:
	    list of tupples, one per property:
	      [externalName, internalName, preprocessor, defaultValue]
	  
	  metaProperties fields:
	    externalName:
	    internalName:
	    preprocessor:
	    defaultValue:
	    setterName:
	    getterName:
	   */

	  EpochedObject.extendableProperty({
	    propertyInitializerList: [],
	    metaProperties: {}
	  });


	  /*
	  Main method for defining properties. Used by concreteProp, virtualProp and others.
	   */

	  EpochedObject._defineElementProperty = function(externalName, options) {
	    var _getter, _setter, capitalizedExternalName, customPreprocessor, customSetter, customValidator, defaultValue, drawAreaProperty, drawProperty, getter, internalName, layoutProperty, metaProperties, pendingGetter, postSetter, preprocessor, setter;
	    if (options == null) {
	      options = {};
	    }
	    internalName = propInternalName(externalName);
	    customValidator = options.validate;
	    customPreprocessor = options.preprocess;
	    defaultValue = options["default"];
	    preprocessor = customPreprocessor && customValidator ? customPreprocessor.length > 1 || customValidator.length > 1 ? function(v, oldValue) {
	      if (v == null) {
	        v = defaultValue;
	      }
	      if (!customValidator(v, oldValue)) {
	        throw new Error("invalid value for " + externalName + ": " + (inspect(v)));
	      }
	      return customPreprocessor(v, oldValue);
	    } : function(v) {
	      if (v == null) {
	        v = defaultValue;
	      }
	      if (!customValidator(v)) {
	        throw new Error("invalid value for " + externalName + ": " + (inspect(v)));
	      }
	      return customPreprocessor(v);
	    } : customValidator ? customValidator.length > 1 ? function(v, oldValue) {
	      if (v == null) {
	        v = defaultValue;
	      }
	      if (!customValidator(v, oldValue)) {
	        throw new Error("invalid value for " + externalName + ": " + (inspect(v)));
	      }
	      return v;
	    } : function(v) {
	      if (v == null) {
	        v = defaultValue;
	      }
	      if (!customValidator(v)) {
	        throw new Error("invalid value for " + externalName + ": " + (inspect(v)));
	      }
	      return v;
	    } : customPreprocessor || function(v) {
	      if (v == null) {
	        v = defaultValue;
	      }
	      return v;
	    };
	    metaProperties = {
	      internalName: internalName,
	      externalName: externalName,
	      preprocessor: preprocessor,
	      getterName: this._propGetterName(externalName),
	      setterName: this._propSetterName(externalName)
	    };
	    if (options.virtual) {
	      metaProperties.virtual = true;
	      _setter = options.setter || function() {};
	      _getter = options.getter;
	      getter = _getter;
	      pendingGetter = function() {
	        return _getter.call(this, true);
	      };
	      setter = function(rawValue) {
	        return _setter.call(this, preprocessor(rawValue), rawValue, preprocessor);
	      };
	    } else {
	      metaProperties.defaultValue = defaultValue = preprocessor(defaultValue);
	      getter = function(pending) {
	        if (pending) {
	          return this._pendingState[internalName];
	        } else {
	          return this[internalName];
	        }
	      };
	      pendingGetter = function() {
	        return this._pendingState[internalName];
	      };
	      layoutProperty = options.layoutProperty, drawProperty = options.drawProperty, drawAreaProperty = options.drawAreaProperty, postSetter = options.postSetter, setter = options.setter;
	      setter = (customSetter = setter) ? postSetter ? function(rawNewValue) {
	        var newValue, oldValue;
	        oldValue = this._pendingState[internalName];
	        newValue = this._pendingState[internalName] = customSetter.call(this, preprocessor(rawNewValue, oldValue), oldValue, rawNewValue, preprocessor);
	        this._elementChanged(layoutProperty, drawProperty, drawAreaProperty);
	        postSetter.call(this, newValue, oldValue, rawNewValue);
	        return newValue;
	      } : function(rawNewValue) {
	        var newValue, oldValue;
	        oldValue = this._pendingState[internalName];
	        newValue = preprocessor(rawNewValue, oldValue);
	        newValue = this._pendingState[internalName] = customSetter.call(this, preprocessor(rawNewValue, oldValue), oldValue, rawNewValue, preprocessor);
	        this._elementChanged(layoutProperty, drawProperty, drawAreaProperty);
	        return newValue;
	      } : postSetter ? function(rawNewValue) {
	        var newValue, oldValue;
	        oldValue = this._pendingState[internalName];
	        newValue = this._pendingState[internalName] = preprocessor(rawNewValue, oldValue);
	        this._elementChanged(layoutProperty, drawProperty, drawAreaProperty);
	        postSetter.call(this, newValue, oldValue);
	        return newValue;
	      } : preprocessor.length > 1 ? function(rawNewValue) {
	        var newValue, oldValue;
	        oldValue = this._pendingState[internalName];
	        newValue = this._pendingState[internalName] = preprocessor(rawNewValue, oldValue);
	        this._elementChanged(layoutProperty, drawProperty, drawAreaProperty);
	        return newValue;
	      } : function(rawNewValue) {
	        var newValue;
	        newValue = this._pendingState[internalName] = preprocessor(rawNewValue);
	        this._elementChanged(layoutProperty, drawProperty, drawAreaProperty);
	        return newValue;
	      };
	      this.extendPropertyInitializerList().push([internalName, defaultValue, externalName]);
	    }
	    this.extendMetaProperties(externalName, metaProperties);
	    capitalizedExternalName = capitalize(externalName);
	    this._addGetter(this.prototype, externalName, getter);
	    this._addGetter(this.prototype, "pending" + capitalizedExternalName, pendingGetter);
	    this._addGetter(this.prototype, externalName + "Changed", function() {
	      return !shallowPropsEq(getter.call(this), pendingGetter.call(this));
	    });
	    return this._addSetter(this.prototype, externalName, setter);
	  };

	  EpochedObject.concreteProperty = function(map) {
	    var options, prop, results;
	    results = [];
	    for (prop in map) {
	      options = map[prop];
	      results.push(this._defineElementProperty(prop, options));
	    }
	    return results;
	  };


	  /*
	  IN: map from prop names to:
	    a) property options object: see 'Virtual property options' above
	    b) OR getter function f. Equivelent to (propName: getter: f)
	   */

	  EpochedObject.virtualProperty = function(map) {
	    var options, prop, results;
	    results = [];
	    for (prop in map) {
	      options = map[prop];
	      if (isFunction(options)) {
	        options = {
	          getter: options
	        };
	      }
	      options.virtual = true;
	      results.push(this._defineElementProperty(prop, options));
	    }
	    return results;
	  };


	  /*
	  EFFECT: set each property in propertySet if it is a legitimate property; otherwise it is ignored
	   */

	  _setPropertiesTempVirtualPropSetterNames = [];

	  _setPropertiesTempVirtualPropValues = [];


	  /*
	  Sets all properties in propertySet
	  undefined values and properties without setters are skipped
	   */

	  EpochedObject.prototype.setProperties = function(props) {
	    var i, j, metaProperties, mp, prop, ref1, setterName, value, virtualPropCount;
	    metaProperties = this.metaProperties;
	    virtualPropCount = 0;
	    for (prop in props) {
	      value = props[prop];
	      if (value !== void 0 && (mp = metaProperties[prop]) && (setterName = mp.setterName)) {
	        if (mp.virtual) {
	          _setPropertiesTempVirtualPropSetterNames[virtualPropCount] = setterName;
	          _setPropertiesTempVirtualPropValues[virtualPropCount++] = value;
	        } else {
	          this[setterName](value);
	        }
	      }
	    }
	    for (i = j = 0, ref1 = virtualPropCount; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
	      this[_setPropertiesTempVirtualPropSetterNames[i]](_setPropertiesTempVirtualPropValues[i]);
	    }
	    return props;
	  };


	  /*
	  EFFECT: set all properties, use propertySet values if present, otherwise use defaults
	  
	  TODO: this sets @parent and @children, it shouldn't, but they aren't virtual...
	  TODO: if this is used much, it would be faster to have a concreteMetaProperties array so we don't have to test mp.virtual
	    this "concreteMetaProperties" array would not include parent or children
	   */

	  EpochedObject.prototype.replaceProperties = function(propertySet) {
	    var externalName, metaProperties, mp, name, property;
	    metaProperties = this.metaProperties;
	    for (property in metaProperties) {
	      mp = metaProperties[property];
	      if (!(!mp.virtual)) {
	        continue;
	      }
	      externalName = mp.externalName;
	      if (typeof this[name = mp.setterName] === "function") {
	        this[name](propertySet.hasOwnProperty(externalName) ? propertySet[externalName] : mp.defaultValue);
	      }
	    }
	    return propertySet;
	  };

	  EpochedObject.prototype.setProperty = function(property, value) {
	    var mp, name;
	    if (mp = this.metaProperties[property]) {
	      return typeof this[name = mp.setterName] === "function" ? this[name](value) : void 0;
	    }
	  };

	  EpochedObject.prototype.preprocessProperty = function(property, value) {
	    var mp;
	    if (mp = this.metaProperties[property]) {
	      return mp.preprocessor(value);
	    }
	  };


	  /*
	  EFFECT: reset one property to its default
	   */

	  EpochedObject.prototype.resetProperty = function(property) {
	    var mp, name;
	    if (mp = this.metaProperties[property]) {
	      return typeof this[name = mp.setterName] === "function" ? this[name](mp.defaultValue) : void 0;
	    }
	  };

	  EpochedObject.prototype.preprocessProperties = function(propertySet) {
	    var metaProperties, mp, property, value;
	    metaProperties = this.metaProperties;
	    for (property in propertySet) {
	      value = propertySet[property];
	      if (mp = metaProperties[property]) {
	        propertySet[property] = mp.preprocessor(value, this[mp.internalName]);
	      }
	    }
	    return propertySet;
	  };

	  EpochedObject.prototype.getPendingPropertyValues = function(propertyNames) {
	    var j, len, metaProp, property, ret;
	    ret = {};
	    for (j = 0, len = propertyNames.length; j < len; j++) {
	      property = propertyNames[j];
	      if (metaProp = this.metaProperties[property]) {
	        ret[property] = this._pendingState[metaProp.internalName];
	      }
	    }
	    return ret;
	  };

	  EpochedObject.prototype.getPropertyValues = function(propertyNames) {
	    var j, len, metaProp, property, ret;
	    ret = {};
	    for (j = 0, len = propertyNames.length; j < len; j++) {
	      property = propertyNames[j];
	      if (metaProp = this.metaProperties[property]) {
	        ret[property] = this[metaProp.internalName];
	      }
	    }
	    return ret;
	  };

	  EpochedObject.getter({
	    props: function() {
	      var k, ref1, ret, virtual;
	      ret = {};
	      ref1 = this.metaProperties;
	      for (k in ref1) {
	        virtual = ref1[k].virtual;
	        ret[k] = this[k];
	      }
	      return ret;
	    },
	    concreteProps: function() {
	      var internalName, k, ref1, ref2, ret, virtual;
	      ret = {};
	      ref1 = this.metaProperties;
	      for (k in ref1) {
	        ref2 = ref1[k], internalName = ref2.internalName, virtual = ref2.virtual;
	        if (!virtual) {
	          ret[k] = this[internalName];
	        }
	      }
	      return ret;
	    },
	    virtualProps: function() {
	      var k, ref1, ret, virtual;
	      ret = {};
	      ref1 = this.metaProperties;
	      for (k in ref1) {
	        virtual = ref1[k].virtual;
	        if (virtual) {
	          ret[k] = this[k];
	        }
	      }
	      return ret;
	    }
	  });

	  minimalPropsIngore = ["children", "parent"];

	  EpochedObject.getter({
	    minimalProps: function() {
	      var defaultValue, externalName, internalName, k, ref1, ref2, ret, value, virtual;
	      ret = {};
	      ref1 = this.metaProperties;
	      for (k in ref1) {
	        ref2 = ref1[k], externalName = ref2.externalName, internalName = ref2.internalName, virtual = ref2.virtual, defaultValue = ref2.defaultValue;
	        if (!virtual) {
	          if (indexOf.call(minimalPropsIngore, externalName) < 0) {
	            if (!propsEq(defaultValue, value = this[internalName])) {
	              ret[k] = value;
	            }
	          }
	        }
	      }
	      return ret;
	    }
	  });

	  EpochedObject.prototype.onNextReady = function(callback, forceEpoch) {
	    if (forceEpoch == null) {
	      forceEpoch = true;
	    }
	    return stateEpoch.onNextReady(callback, forceEpoch, this);
	  };

	  EpochedObject.onNextReady = function(callback, forceEpoch) {
	    if (forceEpoch == null) {
	      forceEpoch = true;
	    }
	    return stateEpoch.onNextReady(callback, forceEpoch);
	  };

	  EpochedObject.prototype.onNextEpoch = function(callback, forceEpoch) {
	    if (forceEpoch == null) {
	      forceEpoch = true;
	    }
	    return globalEpochCycle.onNextReady(callback, forceEpoch, this);
	  };

	  EpochedObject.onNextEpoch = function(callback, forceEpoch) {
	    if (forceEpoch == null) {
	      forceEpoch = true;
	    }
	    return globalEpochCycle.onNextReady(callback, forceEpoch);
	  };

	  EpochedObject.prototype.onIdle = function(callback) {
	    return stateEpoch.onNextReady(callback);
	  };

	  EpochedObject.prototype.getState = function(pending) {
	    if (pending == null) {
	      pending = false;
	    }
	    if (pending) {
	      return this._pendingState;
	    } else {
	      return this;
	    }
	  };

	  EpochedObject.concreteProperty({
	    animators: {
	      "default": null,
	      preprocess: function(v) {
	        var addProp, addProps, processedAnimators;
	        processedAnimators = null;
	        addProp = (function(_this) {
	          return function(prop, options) {
	            processedAnimators || (processedAnimators = {});
	            return processedAnimators["_" + prop] = options instanceof PersistantAnimator ? options : isFunction(options) ? new PersistantAnimator(prop, {
	              animate: options
	            }) : isNumber(options != null ? options.period : void 0) ? new PeriodicPersistantAnimator(prop, merge(options, {
	              continuous: true
	            })) : (options != null ? options.animate : void 0) ? new PersistantAnimator(prop, options) : new EasingPersistantAnimator(prop, options);
	          };
	        })(this);
	        addProps = function(v) {
	          var el, j, l, len, len1, options, prop, ref1, results, results1, results2;
	          if (!v) {
	            return;
	          }
	          if (isString(v)) {
	            ref1 = v.match(/[a-z]+/gi);
	            results = [];
	            for (j = 0, len = ref1.length; j < len; j++) {
	              prop = ref1[j];
	              results.push(addProp(prop));
	            }
	            return results;
	          } else if (isPlainArray(v)) {
	            results1 = [];
	            for (l = 0, len1 = v.length; l < len1; l++) {
	              el = v[l];
	              results1.push(addProps(el));
	            }
	            return results1;
	          } else {
	            results2 = [];
	            for (prop in v) {
	              options = v[prop];
	              results2.push(addProp(prop, options));
	            }
	            return results2;
	          }
	        };
	        addProps(v);
	        return processedAnimators;
	      }
	    }
	  });

	  function EpochedObject(options) {
	    if (options == null) {
	      options = blankOptions;
	    }
	    EpochedObject.__super__.constructor.apply(this, arguments);
	    this._initFields();
	    this._initProperties(options);
	  }

	  EpochedObject.prototype._initFields = function() {
	    this._pendingState = {};
	    this.__stateEpochCount = 0;
	    this.__stateChangeQueued = false;
	    this.__layoutPropertiesChanged = false;
	    this.__drawAreaChanged = true;
	    return this.__drawPropertiesChanged = true;
	  };

	  EpochedObject._generateSetPropertyDefaults = function() {
	    var defaultName, defaultOverride, externalName, functionString, i, k, metaProperties, preprocessor, propertyInitializerList, v, value;
	    propertyInitializerList = this.getPropertyInitializerList();
	    metaProperties = this.getMetaProperties();
	    functionString = compactFlatten([
	      "(function(options) {", "var _pendingState = this._pendingState;", "var metaProperties = this.metaProperties;", (function() {
	        var j, len, ref1, results;
	        results = [];
	        for (i = j = 0, len = propertyInitializerList.length; j < len; i = ++j) {
	          ref1 = propertyInitializerList[i], k = ref1[0], v = ref1[1], externalName = ref1[2];
	          value = (defaultOverride = this.prototype[defaultName = "default" + capitalize(externalName)]) !== void 0 ? ((preprocessor = metaProperties[externalName].preprocessor) ? this.prototype[defaultName] = preprocessor(defaultOverride) : void 0, "this." + defaultName) : v === null || v === false || v === true || v === void 0 || isNumber(v) ? v : "metaProperties." + externalName + ".defaultValue;";
	          results.push("this." + k + " = _pendingState." + k + " = " + value + ";");
	        }
	        return results;
	      }).call(this), "})"
	    ]).join("\n");
	    return eval(functionString);
	  };

	  EpochedObject.prototype._initProperties = function(options) {
	    var metaProperties;
	    metaProperties = this.metaProperties;
	    if (!this.__proto__.hasOwnProperty("_initPropertiesAuto")) {
	      this.__proto__._initPropertiesAuto = this["class"]._generateSetPropertyDefaults();
	    }
	    this._initPropertiesAuto(options);
	    this.setProperties(options);
	    this._elementChanged(true, true, true);
	    return null;
	  };

	  EpochedObject.prototype._getChangingStateKeys = function() {
	    var k, ref1, results, v;
	    ref1 = this._pendingState;
	    results = [];
	    for (k in ref1) {
	      v = ref1[k];
	      if (!shallowPropsEq(this[k], this._pendingState[k])) {
	        results.push(k);
	      }
	    }
	    return results;
	  };

	  EpochedObject.prototype._logPendingStateChanges = function() {
	    var k, newValues, oldValues, ref1, v;
	    oldValues = {};
	    newValues = {};
	    ref1 = this._pendingState;
	    for (k in ref1) {
	      v = ref1[k];
	      if (!(!(k.match(/^__/)) && !plainObjectsDeepEq(v, this[k]))) {
	        continue;
	      }
	      oldValues[k] = this[k];
	      newValues[k] = v;
	    }
	    return log({
	      "ElementBase pending state changes": {
	        element: this.inspectedName,
	        old: oldValues,
	        "new": newValues
	      }
	    });
	  };

	  EpochedObject.prototype._getIsChangingElement = function() {
	    return stateEpoch._isChangingElement(this);
	  };

	  EpochedObject.prototype._elementChanged = function(layoutPropertyChanged, drawPropertyChanged, drawAreaPropertyChanged) {
	    var _pendingState;
	    _pendingState = this._pendingState;
	    if (layoutPropertyChanged) {
	      if (StateEpoch._stateEpochLayoutInProgress) {
	        console.error("__layoutPropertiesChanged while _stateEpochLayoutInProgress");
	      }
	      this.__layoutPropertiesChanged = true;
	    }
	    if (drawPropertyChanged) {
	      this.__drawPropertiesChanged = true;
	    }
	    if (drawAreaPropertyChanged) {
	      this.__drawAreaChanged = true;
	    }
	    if (!this.__stateChangeQueued) {
	      this.__stateChangeQueued = true;
	      return stateEpoch._addChangingElement(this);
	    }
	  };


	  /*
	  TODO:
	    It would probably be faster overall to:
	  
	      a) move all the __* properties out of _pendingState
	        Probably just promote them to the Element itself
	        DONE
	  
	      b) replace _pendingState with a new, empty object after _applyStateChanges
	        SBD March-2016: I think this is still a good idea.
	          @_pendingState currently contains every property.
	          That's a lot of extra work every state epoch!
	          The problem is, we currently rely on that in many places!
	          One thing to perf-test: We could make an array of the names of props that changed.
	            Then, _applyStateChanges could iterate through that array, pulling values out of @_pendingState.
	            (in this scenario we would keep @_pendingState fully of all properties, as it currently is)
	  
	      c) for faster Element creation
	        - could we just say the Element "consumes" the props passed to it on creation?
	        - then we can alter that props object
	        - every prop in the passed-in props object gets run through the preprocessors/validators
	        - and the result is assigned back to the props object
	        - then the props object BECOMES the first @_pendingState
	        SBD March-2016: I'm less sure this makes sense.
	  
	      d) SBD March-2016
	        I have no idea if this would work, but what would be really cool is if new
	        elements could directly apply there initial properties rather then putting them through
	        the state-epoch pending cycle. This would probalby be a huge savings for object creation,
	        which currently is one of out biggest performance problems.
	  
	        The problem is, new elements still need to go through a StateEpoch for layout...
	   */

	  EpochedObject.prototype._applyStateChanges = function() {
	    this.__stateChangeQueued = false;
	    this.__stateEpochCount++;
	    return mergeInto(this, this._pendingState);
	  };

	  EpochedObject.prototype._deactivatePersistantAnimators = function() {
	    var animator, prop, ref1, results;
	    ref1 = this.animators;
	    results = [];
	    for (prop in ref1) {
	      animator = ref1[prop];
	      results.push(animator.deactivate());
	    }
	    return results;
	  };

	  EpochedObject.prototype._activateContinuousPersistantAnimators = function() {
	    return nextTick((function(_this) {
	      return function() {
	        return _this._elementChanged();
	      };
	    })(this));
	  };

	  EpochedObject.prototype.getPendingCreatedAndAddedToExistingParent = function() {
	    var ref1;
	    return this.__stateEpochCount === 0 && !(((ref1 = this._pendingState._parent) != null ? ref1.__stateEpochCount : void 0) === 0);
	  };

	  EpochedObject.prototype._applyAnimators = function() {
	    var active, animateFromVoid, animator, currentValue, epochCount, frameSecond, hasFromVoidAnimation, newValue, pendingAnimators, pendingValue, prop;
	    if (pendingAnimators = this._pendingState._animators) {
	      animateFromVoid = this.getPendingCreatedAndAddedToExistingParent();
	      frameSecond = stateEpoch.frameSecond, epochCount = stateEpoch.epochCount;
	      for (prop in pendingAnimators) {
	        animator = pendingAnimators[prop];
	        active = animator.active;
	        pendingValue = this._pendingState[prop];
	        currentValue = animateFromVoid && (hasFromVoidAnimation = animator.hasFromVoidAnimation) ? animator.getPreprocessedFromVoid(this) : this.__stateEpochCount === 0 ? pendingValue : this[prop];
	        newValue = active || !propsEq(currentValue, pendingValue) ? animator.animateAbsoluteTime(this, currentValue, pendingValue, frameSecond) : pendingValue;
	        this._pendingState[prop] = newValue;
	      }
	    }
	    return null;
	  };

	  return EpochedObject;

	})(BaseObject);


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var DrawCacheManager, DrawEpoch, DummyEpoch, Epoch, EventEpoch, Foundation, GlobalEpochCycle, IdleEpoch, Map, StateEpoch, arrayWithout, currentSecond, drawCacheManager, drawEpoch, dummyEpoch, durationString, eventEpoch, fastBind, fluxEpoch, globalCount, idleEpoch, isPlainObject, log, miniInspect, reactEpoch, requestAnimationFrame, stateEpoch, time, toMs,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	EventEpoch = __webpack_require__(168).EventEpoch;

	StateEpoch = __webpack_require__(194);

	DrawEpoch = __webpack_require__(202);

	IdleEpoch = __webpack_require__(204);

	DrawCacheManager = __webpack_require__(203);

	log = Foundation.log, requestAnimationFrame = Foundation.requestAnimationFrame, Map = Foundation.Map, miniInspect = Foundation.miniInspect, time = Foundation.time, arrayWithout = Foundation.arrayWithout, currentSecond = Foundation.currentSecond, Epoch = Foundation.Epoch, globalCount = Foundation.globalCount, isPlainObject = Foundation.isPlainObject, durationString = Foundation.durationString, fastBind = Foundation.fastBind;

	toMs = function(s) {
	  return (s * 1000).toFixed(1) + "ms";
	};

	eventEpoch = EventEpoch.eventEpoch;

	drawEpoch = DrawEpoch.drawEpoch;

	stateEpoch = StateEpoch.stateEpoch;

	idleEpoch = IdleEpoch.idleEpoch;

	drawCacheManager = DrawCacheManager.drawCacheManager;

	DummyEpoch = (function(superClass) {
	  extend(DummyEpoch, superClass);

	  function DummyEpoch() {
	    return DummyEpoch.__super__.constructor.apply(this, arguments);
	  }

	  DummyEpoch.singletonClass();

	  return DummyEpoch;

	})(Epoch);

	dummyEpoch = DummyEpoch.dummyEpoch;

	fluxEpoch = reactEpoch = dummyEpoch;

	module.exports = GlobalEpochCycle = (function(superClass) {
	  var timerStack;

	  extend(GlobalEpochCycle, superClass);

	  GlobalEpochCycle.singletonClass();

	  GlobalEpochCycle.classGetter({
	    activeCanvasElements: function() {
	      return this.globalEpochCycle.activeCanvasElements;
	    }
	  });

	  function GlobalEpochCycle() {
	    var boundQueueNextEpoch;
	    GlobalEpochCycle.__super__.constructor.apply(this, arguments);
	    this.cycleQueued = false;
	    this.processingCycle = false;
	    this.activeCanvasElements = [];
	    this._fluxOnIdleOkUntil = currentSecond();
	    this._resetThisCyclesStats();
	    boundQueueNextEpoch = fastBind(this.queueNextEpoch, this);
	    idleEpoch.queueNextEpoch = stateEpoch.queueNextEpoch = drawEpoch.queueNextEpoch = eventEpoch.queueNextEpoch = boundQueueNextEpoch;
	    eventEpoch.logEvent = (function(_this) {
	      return function(name, id) {
	        var ref;
	        return (ref = _this.globalEpochStats) != null ? ref.logEvent(name, id) : void 0;
	      };
	    })(this);
	  }

	  GlobalEpochCycle.prototype.allowFluxOnIdle = function(nextNSeconds) {
	    return this._fluxOnIdleOkUntil = currentSecond() + nextNSeconds;
	  };

	  GlobalEpochCycle.prototype._resetThisCyclesStats = function() {
	    return this.performanceSamples = {};
	  };

	  GlobalEpochCycle.prototype.addPerformanceSample = function(name, value) {
	    if (!this.performanceSamples) {
	      throw new Error("@performanceSamples not set");
	    }
	    return this.performanceSamples[name] = (this.performanceSamples[name] || 0) + value;
	  };

	  timerStack = [];

	  GlobalEpochCycle.prototype.timePerformance = function(name, f) {
	    var start, subTimeTotal, timeResult, tsl;
	    start = currentSecond();
	    timerStack.push(0);
	    f();
	    subTimeTotal = timerStack.pop();
	    timeResult = currentSecond() - start;
	    if ((tsl = timerStack.length) > 0) {
	      timerStack[tsl - 1] += timeResult;
	    }
	    return this.addPerformanceSample(name, timeResult - subTimeTotal);
	  };

	  GlobalEpochCycle.getter({
	    numActivePointers: function() {
	      var canvasElement, count, i, len, ref;
	      count = 0;
	      ref = this.activeCanvasElements;
	      for (i = 0, len = ref.length; i < len; i++) {
	        canvasElement = ref[i];
	        count += canvasElement.getNumActivePointers();
	      }
	      return count;
	    },
	    idle: function() {
	      return reactEpoch.getEpochLength() === 0 && stateEpoch.getEpochLength() === 0 && eventEpoch.getEpochLength() === 0;
	    },
	    epochLength: function() {
	      return idleEpoch.getEpochLength() + eventEpoch.getEpochLength() + stateEpoch.getEpochLength() + reactEpoch.getEpochLength() + fluxEpoch.getEpochLength();
	    }
	  });

	  GlobalEpochCycle.getter({
	    idleEpoch: function() {
	      return idleEpoch;
	    },
	    eventEpoch: function() {
	      return eventEpoch;
	    },
	    stateEpoch: function() {
	      return stateEpoch;
	    },
	    drawEpoch: function() {
	      return drawEpoch;
	    },
	    reactEpoch: function() {
	      return reactEpoch;
	    },
	    fluxEpoch: function() {
	      return fluxEpoch;
	    }
	  });

	  GlobalEpochCycle.prototype.includeReact = function(epoch) {
	    return (reactEpoch = epoch).queueNextEpoch = (function(_this) {
	      return function() {
	        return _this.queueNextEpoch();
	      };
	    })(this);
	  };

	  GlobalEpochCycle.prototype.includeFlux = function(epoch) {
	    return (fluxEpoch = epoch).queueNextEpoch = (function(_this) {
	      return function() {
	        return _this.queueNextEpoch();
	      };
	    })(this);
	  };

	  GlobalEpochCycle.prototype.logEvent = function(name, id) {
	    var ref;
	    return (ref = this.globalEpochStats) != null ? ref.logEvent(name, id) : void 0;
	  };

	  GlobalEpochCycle.prototype.detachCanvasElement = function(toRemoveCe) {
	    return this.activeCanvasElements = arrayWithout(this.activeCanvasElements, toRemoveCe);
	  };

	  GlobalEpochCycle.prototype.attachCanvasElement = function(toAddCe) {
	    return this.activeCanvasElements.push(toAddCe);
	  };

	  GlobalEpochCycle.prototype.processFluxEpoch = function() {
	    return this.timePerformance("flux", (function(_this) {
	      return function() {
	        return fluxEpoch.processEpoch();
	      };
	    })(this));
	  };

	  GlobalEpochCycle.prototype.processIdleEpoch = function() {
	    return this.timePerformance("idle", (function(_this) {
	      return function() {
	        return idleEpoch != null ? idleEpoch.processEpoch() : void 0;
	      };
	    })(this));
	  };

	  GlobalEpochCycle.prototype.processEventEpoch = function() {
	    return this.timePerformance("event", (function(_this) {
	      return function() {
	        return eventEpoch.processEpoch();
	      };
	    })(this));
	  };

	  GlobalEpochCycle.prototype.processReactEpoch = function() {
	    return this.timePerformance("react", (function(_this) {
	      return function() {
	        return reactEpoch.processEpoch();
	      };
	    })(this));
	  };

	  GlobalEpochCycle.prototype.processStateEpoch = function() {
	    return this.timePerformance("aim", (function(_this) {
	      return function() {
	        return stateEpoch.processEpoch();
	      };
	    })(this));
	  };

	  GlobalEpochCycle.prototype.processDrawEpoch = function() {
	    return this.timePerformance("draw", (function(_this) {
	      return function() {
	        return drawEpoch.processEpoch();
	      };
	    })(this));
	  };

	  GlobalEpochCycle.prototype.flushEpochNow = function() {
	    if (this.processingCycle) {
	      return;
	    }
	    this.processingCycle = true;
	    this._processCycleExceptDraw();
	    return this.processingCycle = false;
	  };

	  GlobalEpochCycle.prototype._processCycleExceptDraw = function() {
	    this.processEventEpoch();
	    this.processFluxEpoch();
	    if (this.getIdle()) {
	      this.processIdleEpoch();
	    }
	    reactEpoch.updateGlobalCounts();
	    this.processReactEpoch();
	    globalCount("reactEpochAfter", reactEpoch.getEpochLength());
	    stateEpoch.updateGlobalCounts();
	    this.processStateEpoch();
	    return globalCount("stateEpochAfter", stateEpoch.getEpochLength());
	  };

	  GlobalEpochCycle.prototype.processEpochItems = function(items) {
	    var drawCount, gc, globalEpochFrameTime, i, k, k2, keys, len, reactWastedWork, reactWork, ref, sorted, startTime, v, v2;
	    fluxEpoch._frameSecond = idleEpoch._frameSecond = eventEpoch._frameSecond = reactEpoch._frameSecond = stateEpoch._frameSecond = drawEpoch._frameSecond = this._frameSecond;
	    Foundation.resetGlobalCounts();
	    startTime = currentSecond();
	    this._resetThisCyclesStats();
	    this.processingCycle = true;
	    this._processCycleExceptDraw();
	    if (stateEpoch.getEpochLength() > 0) {
	      this.processStateEpoch();
	    }
	    drawCount = drawEpoch.epochLength;
	    this.processDrawEpoch();
	    this.processingCycle = false;
	    if (this.getEpochLength() > 0) {
	      this.queueNextEpoch();
	    }
	    if (drawCount > 0) {
	      globalEpochFrameTime = currentSecond() - startTime;
	      gc = Foundation.globalCounts;
	      if (false) {
	        keys = Object.keys(gc).sort();
	        sorted = {};
	        for (i = 0, len = keys.length; i < len; i++) {
	          k = keys[i];
	          v = gc[k];
	          if (v > 0 && v < 1) {
	            v = toMs(v);
	          }
	          if (isPlainObject(v)) {
	            for (k2 in v) {
	              v2 = v[k2];
	              if (v2 > 0 && v2 < 1) {
	                v[k2] = toMs(v2);
	              }
	            }
	          }
	          sorted[k] = v;
	        }
	        log({
	          globalCounts: sorted,
	          fps: (1 / globalEpochFrameTime).toFixed(1)
	        });
	        reactWork = (gc["ReactComponent_Created"] || 0) + (gc["ReactVirtualElement_Created"] || 0);
	        reactWastedWork = (gc["ReactComponent_UpdateFromTemporaryComponent_NoChange"] || 0) + (gc["ReactVirtualElement_UpdateFromTemporaryVirtualElement_NoChange"] || 0);
	        if (reactWork > 0) {
	          log({
	            reactWork: reactWork,
	            reactWastedWork: reactWastedWork,
	            reactEfficiency: 1 - reactWastedWork / reactWork
	          });
	        }
	      }
	      return (ref = this.globalEpochStats) != null ? ref.add(startTime, globalEpochFrameTime, this.performanceSamples) : void 0;
	    }
	  };

	  return GlobalEpochCycle;

	})(Epoch);


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(125), __webpack_require__(203)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Foundation, Atomic, DrawCacheManager) {
	  var DrawEpoch, Epoch, Point, drawCacheManager, globalCount, inspect, log, longestCommonSubsequence, point, requestAnimationFrame, select;
	  point = Atomic.point, Point = Atomic.Point;
	  log = Foundation.log, requestAnimationFrame = Foundation.requestAnimationFrame, longestCommonSubsequence = Foundation.longestCommonSubsequence, select = Foundation.select, inspect = Foundation.inspect, Epoch = Foundation.Epoch, globalCount = Foundation.globalCount;
	  drawCacheManager = DrawCacheManager.drawCacheManager;
	  return DrawEpoch = (function(superClass) {
	    extend(DrawEpoch, superClass);

	    function DrawEpoch() {
	      return DrawEpoch.__super__.constructor.apply(this, arguments);
	    }

	    DrawEpoch.singletonClass();

	    DrawEpoch.prototype.processEpochItems = function() {
	      DrawEpoch.__super__.processEpochItems.apply(this, arguments);
	      return drawCacheManager.advanceFrame();
	    };

	    return DrawEpoch;

	  })(Epoch);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(158), __webpack_require__(19), __webpack_require__(125), __webpack_require__(137)], __WEBPACK_AMD_DEFINE_RESULT__ = function(ArtEngineCore, Foundation, Atomic, Canvas) {
	  var BaseObject, Bitmap, CacheBitmap, DrawCacheManager, Map, Matrix, Point, Rectangle, getGlobalEpochCycle, inspect, log, matrix, point, rect, remove, timeout;
	  point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix;
	  inspect = Foundation.inspect, BaseObject = Foundation.BaseObject, Map = Foundation.Map, timeout = Foundation.timeout, remove = Foundation.remove, log = Foundation.log;
	  Bitmap = Canvas.Bitmap;
	  getGlobalEpochCycle = function() {
	    return ArtEngineCore.GlobalEpochCycle.globalEpochCycle;
	  };

	  /*
	  PURPOSE
	  - Keep the maximum byte-size of the cache under a cap.
	  - recycle unused bitmaps since creating bitmaps is costly
	  
	  TODO
	  
	  Stop clearing cached sub-elements when drawing a new cached element.
	   - the DrawCacheManager will reclaim their bitmaps in time
	  
	  Stop tracking caching stats in Element
	  
	  Call advanceFrameTime every global draw-frame
	  Call doneWithCacheBitmap from _clearDrawCache(doNotUpdateDrawCacheManager) unless doNotUpdateDrawCacheManager is true
	  call allocateCacheBitmap when a new cache bitmap is used
	  call useCacheBitmap every time a the drawCache bitmap is used
	   */
	  CacheBitmap = (function(superClass) {
	    extend(CacheBitmap, superClass);

	    function CacheBitmap(element1, bitmap1, lastFrameUsed) {
	      this.element = element1;
	      this.bitmap = bitmap1;
	      this._reset(lastFrameUsed);
	    }

	    CacheBitmap.prototype._reset = function(lastFrameUsed) {
	      this.useCount = 0;
	      return this.lastFrameUsed = lastFrameUsed || 0;
	    };

	    CacheBitmap.prototype.recycle = function(newElement, lastFrameUsed) {
	      this.elementDoneWithCacheBitmap();
	      this.element = newElement;
	      this._reset(lastFrameUsed);
	      this.bitmap.clear();
	      return this.bitmap;
	    };

	    CacheBitmap.prototype.use = function(currentFrameNumber) {
	      this.lastFrameUsed = currentFrameNumber;
	      return this.useCount++;
	    };

	    CacheBitmap.prototype.elementDoneWithCacheBitmap = function() {
	      if (this.element && this.element._drawCacheBitmap === this.bitmap) {
	        this.element.__clearDrawCacheCallbackFromDrawCacheManager();
	      }
	      return this.element = null;
	    };

	    CacheBitmap.getter({
	      byteSize: function() {
	        return this.bitmap.getByteSize();
	      }
	    });

	    return CacheBitmap;

	  })(BaseObject);
	  return DrawCacheManager = (function(superClass) {
	    var byteSizeFromSize, usableBitmap;

	    extend(DrawCacheManager, superClass);

	    DrawCacheManager.byteSizeFromSize = byteSizeFromSize = function(size) {
	      return size.x * size.y * 4;
	    };

	    DrawCacheManager.singletonClass();

	    DrawCacheManager.usableBitmap = usableBitmap = function(bitmap, w, h) {
	      var ref, x, y;
	      ref = bitmap.size, x = ref.x, y = ref.y;
	      return w <= x && h <= y && x * y < w * h * 2;
	    };

	    function DrawCacheManager() {
	      DrawCacheManager.__super__.constructor.apply(this, arguments);
	      this._currentFrameNumber = 0;
	      this._maxCacheByteSize = 64 * 1024 * 1024;
	      this._cacheByteSize = 0;
	      this._unusedCacheByteSize = 0;
	      this._cachedBitmaps = new Map;
	      this._bitmapsCreated = 0;
	      this._unusedCacheBitmaps = [];
	    }

	    DrawCacheManager.getter({
	      currentFrameNumber: function() {
	        return this._currentFrameNumber;
	      },
	      recycleableSortedCacheBitmaps: function() {
	        var currentFrameNumber, recyclable;
	        recyclable = [];
	        currentFrameNumber = this._currentFrameNumber;
	        this._cachedBitmaps.each(function(k, v) {
	          if (v.lastFrameUsed < currentFrameNumber - 1) {
	            return recyclable.push(v);
	          }
	        });
	        return recyclable.sort(function(a, b) {
	          return a.lastFrameUsed - b.lastFrameUsed;
	        });
	      }
	    });

	    DrawCacheManager.prototype.doneWithCacheBitmap = function(element) {
	      var cachedBitmap;
	      if (cachedBitmap = this._cachedBitmaps.remove(element)) {
	        cachedBitmap.elementDoneWithCacheBitmap();
	        this._unusedCacheByteSize += cachedBitmap.getByteSize();
	        return this._unusedCacheBitmaps.push(cachedBitmap);
	      }
	    };

	    DrawCacheManager.prototype.useDrawCache = function(element) {
	      var ref;
	      return (ref = this._cachedBitmaps.get(element)) != null ? ref.use(this._currentFrameNumber) : void 0;
	    };

	    DrawCacheManager.prototype.allocateCacheBitmap = function(element, size) {
	      this.doneWithCacheBitmap(element);
	      return this._recycleUnusedCacheBitmap(element, size) || this._createCacheBitmap(element, size);
	    };

	    DrawCacheManager.prototype.advanceFrame = function() {
	      var cfn;
	      this._currentFrameNumber++;
	      return cfn = this._currentFrameNumber;
	    };

	    DrawCacheManager.prototype._recycleInUseCacheBitmap = function(element, size) {
	      var recyclableCacheBitmap;
	      if (recyclableCacheBitmap = this._findRecycleableCacheBitmap(size)) {
	        this._cachedBitmaps.set(element, this._cachedBitmaps.remove(recyclableCacheBitmap.element));
	        getGlobalEpochCycle().logEvent("recycleUsedCacheBitmap", "recycleUsedCacheBitmap");
	        return recyclableCacheBitmap.recycle(element, this._currentFrameNumber);
	      }
	    };

	    DrawCacheManager.prototype._recycleUnusedCacheBitmap = function(element, size) {
	      var unusedCacheBitmap;
	      if (unusedCacheBitmap = this._getUnusedCacheBitmap(size)) {
	        getGlobalEpochCycle().logEvent("recycleUnusedCacheBitmap", "recycleUnusedCacheBitmap");
	        unusedCacheBitmap.recycle(element, this._currentFrameNumber);
	        this._cachedBitmaps.set(element, unusedCacheBitmap);
	        return unusedCacheBitmap.bitmap;
	      }
	    };

	    DrawCacheManager.prototype._createCacheBitmap = function(element, size) {
	      var bitmap, cacheBitmap, cachedBitmap;
	      if (!this._roomInCacheForNewBitmap(size)) {
	        this._evictCacheBitmaps(size);
	      }
	      this._bitmapsCreated++;
	      getGlobalEpochCycle().logEvent("createCacheBitmap", "createCacheBitmap");
	      bitmap = element.getBitmapFactory().newBitmap(size);
	      cachedBitmap = this._cachedBitmaps.set(element, cacheBitmap = new CacheBitmap(element, bitmap, this._currentFrameNumber));
	      this._cacheByteSize += cachedBitmap.getByteSize();
	      return bitmap;
	    };

	    DrawCacheManager.prototype._getUnusedCacheBitmap = function(size) {
	      var cachedBitmap, i, j, len, ref;
	      ref = this._unusedCacheBitmaps;
	      for (i = j = 0, len = ref.length; j < len; i = ++j) {
	        cachedBitmap = ref[i];
	        if (!(cachedBitmap.bitmap.size.eq(size))) {
	          continue;
	        }
	        this._unusedCacheBitmaps = remove(this._unusedCacheBitmaps, i);
	        this._unusedCacheByteSize -= cachedBitmap.getByteSize();
	        return cachedBitmap;
	      }
	      return void 0;
	    };

	    DrawCacheManager.prototype._findRecycleableCacheBitmap = function(size) {
	      var currentFrameNumber;
	      currentFrameNumber = this._currentFrameNumber;
	      return this._cachedBitmaps.findFirst((function(_this) {
	        return function(cachedBitmap) {
	          return cachedBitmap.lastFrameUsed < currentFrameNumber - 1 && cachedBitmap.bitmap.size.eq(size);
	        };
	      })(this));
	    };

	    DrawCacheManager.prototype._roomInCacheForNewBitmap = function(size) {
	      var byteSize;
	      byteSize = byteSizeFromSize(size);
	      return byteSize + this._cacheByteSize <= this._maxCacheByteSize;
	    };

	    DrawCacheManager.prototype._evictCacheBitmaps = function(size) {
	      var byteSize, cachedBitmap, evictionByteSize, j, len, maxCacheByteSize, ref;
	      byteSize = byteSizeFromSize(size);
	      maxCacheByteSize = this._maxCacheByteSize;
	      evictionByteSize = 0;
	      ref = this.recycleableSortedCacheBitmaps;
	      for (j = 0, len = ref.length; j < len; j++) {
	        cachedBitmap = ref[j];
	        if (cachedBitmap = this._cachedBitmaps.remove(cachedBitmap.element)) {
	          cachedBitmap.elementDoneWithCacheBitmap();
	          byteSize = cachedBitmap.getByteSize();
	          evictionByteSize += byteSize;
	          this._cacheByteSize -= byteSize;
	          if (this._cacheByteSize + byteSize <= maxCacheByteSize) {
	            break;
	          }
	        }
	      }
	      return null;
	    };

	    return DrawCacheManager;

	  })(BaseObject);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Foundation) {
	  var Epoch, IdleEpoch, log;
	  log = Foundation.log, Epoch = Foundation.Epoch;
	  return IdleEpoch = (function(superClass) {
	    extend(IdleEpoch, superClass);

	    function IdleEpoch() {
	      return IdleEpoch.__super__.constructor.apply(this, arguments);
	    }

	    IdleEpoch.singletonClass();

	    IdleEpoch.prototype.queue = function(event) {
	      return this.queueItem(event);
	    };

	    return IdleEpoch;

	  })(Epoch);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(206).addModules({
	  Animator: __webpack_require__(185),
	  EasingFunctions: __webpack_require__(186),
	  EasingPersistantAnimator: __webpack_require__(207),
	  PeriodicPersistantAnimator: __webpack_require__(209),
	  PersistantAnimator: __webpack_require__(208)
	});


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var Animation, Engine,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Engine = __webpack_require__(154);

	module.exports = Engine.Animation || Engine.addNamespace('Animation', Animation = (function(superClass) {
	  extend(Animation, superClass);

	  function Animation() {
	    return Animation.__super__.constructor.apply(this, arguments);
	  }

	  return Animation;

	})(Neptune.Base));


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, EasingFunctions, EasingPersistantAnimator, EventedObject, Events, Foundation, PersistantAnimator, interpolate, isFunction, isNumber, isString, log, max, min,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Events = __webpack_require__(168);

	EasingFunctions = __webpack_require__(186);

	PersistantAnimator = __webpack_require__(208);

	log = Foundation.log, BaseObject = Foundation.BaseObject, isFunction = Foundation.isFunction, isString = Foundation.isString, isNumber = Foundation.isNumber, min = Foundation.min, max = Foundation.max;

	EventedObject = Events.EventedObject;

	interpolate = PersistantAnimator.interpolate;

	module.exports = EasingPersistantAnimator = (function(superClass) {
	  extend(EasingPersistantAnimator, superClass);

	  EasingPersistantAnimator.getter("duration easingFunction");

	  EasingPersistantAnimator.getter({
	    animationPos: function() {
	      return min(1, this.getAnimationSeconds() / this._duration);
	    }
	  });

	  EasingPersistantAnimator.setter({
	    duration: function(d) {
	      return this._duration = isNumber(d) ? max(.001, d) : .25;
	    },
	    easingFunction: function(f) {
	      this._easingFunction = f;
	      if (isString(f)) {
	        if (!(this._easingFunction = EasingFunctions[f])) {
	          console.warn("invalid easing easingFunction: " + f);
	        }
	      }
	      return this._easingFunction || (this._easingFunction = EasingFunctions.easeInQuad);
	    }
	  });

	  function EasingPersistantAnimator(_, options) {
	    if (options == null) {
	      options = {};
	    }
	    EasingPersistantAnimator.__super__.constructor.apply(this, arguments);
	    this.setEasingFunction(options.f || options.easingFunction);
	    this.setDuration(options.d != null ? options.d : options.duration);
	  }

	  EasingPersistantAnimator.prototype.animate = function() {
	    var animationPos, easingFunction, ref, startValue, toValue;
	    ref = this, startValue = ref.startValue, toValue = ref.toValue, animationPos = ref.animationPos, easingFunction = ref.easingFunction;
	    if (1 === animationPos) {
	      this.stop();
	    }
	    return interpolate(startValue, toValue, easingFunction(animationPos));
	  };

	  return EasingPersistantAnimator;

	})(PersistantAnimator);


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, EventedMixin, Events, Foundation, PersistantAnimator, capitalize, eq, inspectedObjectLiteral, isFunction, isPlainObject, isString, log, plainObjectsDeepEq, rubyOr,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Events = __webpack_require__(168);

	log = Foundation.log, BaseObject = Foundation.BaseObject, isFunction = Foundation.isFunction, isString = Foundation.isString, capitalize = Foundation.capitalize, inspectedObjectLiteral = Foundation.inspectedObjectLiteral, plainObjectsDeepEq = Foundation.plainObjectsDeepEq, isPlainObject = Foundation.isPlainObject, eq = Foundation.eq, rubyOr = Foundation.rubyOr;

	EventedMixin = Events.EventedMixin;


	/*
	Useful ideas about optimizing animations and garbage collection: http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html

	1) Properties are marked animatable.
	2) Every animatable propoerty is animated every time it changes.
	3) A new instance of the Animator is created to start the animation.
	   - initalValue
	   - initialTargetValue
	   - initialTime
	4) The animator is called each frame with updates:
	   - possible changes in targetValue
	   - lastFrameTime
	   - currentValue
	   - currentTime
	5) The animator calls "@done()" when it can be released.
	  It need not ever be released. It could be endless.
	6) Objects

	----------------------------------
	INITIAL SUPPORT

	ELEMENT SUPPORT (March 2016)

	  New property: animators
	    Legal values:

	       * basic: just name the property to animate to get the default animator
	      animators: "location"

	       * init a standard animator with custom options:
	      animators:
	        location:
	          d/duration: .25
	          f/function: "easeInQuad"

	       * start a fully custom animator
	      animators:
	        location: new CustomAnimator

	  Animatable properties:

	    Ideally: every concrete property

	    This includes both "location" and "currentLocation".

	    For currentLocation/currentSize, the animator preprocessor is applied on the output
	    of the location and size layouts before _currentLocation or _currentSize are created.

	----------------------------------
	FUTURE FEATURES

	ONE ANIMATOR OVER MULTIPLE PROPS

	  I can imagine situations where you might want one animator to be responsible for multiple props.

	  Maybe a cartoon-physics animator might want to animate some combination of size, location and scale.

	  Clearly, we'd only add this when we really needed it.

	  In the cartoon-physics example, it's a 'canned effect'. You'd probably prefer to have the CartoonPhsyics
	  animator decide what props it needs to animate. So, perhaps you can specify animators w/o specifying props.
	  Instead, the animator itself lists the props it will animate:

	  animators: new CartoonPhysicsAnimator

	  You can always make an array with multiple different animators specified using any legal method.
	  animators: [
	    new CartoonPhysicsAnimator
	    "color"
	  ]

	  Once we have that, we may have more than one animator for the same property. Gut says it works like "merge".
	  The last specified animator gets sole responsibilty for animating that prop.

	  How does an animator for multiple props work? Normally each prop is handled individually. In the case
	  of layout-props, they don't even get handled at the same time as the other props. They get handled during
	  layout. So, I think the multi-prop animator needs to be able to process each prop in isolation.

	ANIMATING WHEN SWITCHING PARENTS

	  Use-case:

	    Show a thumbnail in a list.
	    Tap it to zoom in.
	    Animated from the thumbnail to the full-sized view.

	  How it might work:

	    The Thumbnail gets a unique key.

	    The ZoomIn can set its createdFrom props to be taken from another element via its key.

	  Need:

	    Special-case animated virtual property:
	      elementToAbsMatrix

	    For nicer animations when scaling and angles are involed, we may add these animatable virtual props:
	      absoluteCurrentLocation (new)
	      absoluteCurrentScale (new)
	      absoluteCurrentAngle (new)

	    Enhanced props:
	      added/createdFrom:
	        element: elementKey or element
	        props: props-name list

	    Could allow initializing *From from several source elements or
	    specific props. All results are passed into "merge":

	    added/createdFrom: [
	      {element: elementKey1, props: propsString1}
	      {element: elementKey2, props: propsString2}
	      color: "red"
	      ]

	  How it might look in user-code:

	    Thumbnail = createComponentFactory
	      render: ->
	        {itemId} = @props
	        Element
	          key: "thumbnail:#{itemId}"
	          ...

	    ZoomIn = createComponentFactory
	      render: ->
	        {itemId} = @props
	        Element
	          createdFrom:
	            element: "thumbnail:#{itemId}"
	            props: "elementToAbsMatrix"

	          animators: "elementToAbsMatrix"

	ADDED / REMOVED ANIMATIONS (March 2016)
	  - "from" values
	    Each animatable property can have an initial property which gets
	    set first. Then, next frame, the normal property value gets set,
	    triggering the animator.
	    There are two kinds of initial values:
	      onCreation - if the Element as added to the parent in the parent's constructor
	      onAddition - if the Element as added to the parent sometime later
	    Syntax idea:
	      new Element
	        location: 0
	        addedFrom:    location: -10
	        createdFrom:  location: -20
	        removedTo:    location: -10

	SELECTING ELEMENTS BY KEY

	  When specifying createdFrom: element: elementKey, how do we match the elementKey with
	  a concrete element?

	  There are both performance concerns and usability concerns:

	    performance:
	      - there may be a lot of elements with keys; how do we find a match quickly?
	      - a pre-computed & maintained hash is probably the answer... but that may be a lot of work.
	    useability:
	      - duplicate keys
	      - do we need scoping to reduce key-collisions / avoid "globals" / isolate components?

	  It seems to me that some amount of scoping would both reduce the number of keys that need
	  to be inspected for a lookup / or reduce the work necessary to maintain a precomputed hash.

	ELEMENT "KEY" SCOPING BY COMPONENT

	  We could scope by "Component". ArtReact already has this information, so the user
	  doesn't have to do any additional work.

	  - An Element can be flagged as a Component.
	  - This would automatically be done by React Components.
	  - All Elements in its sub-branch are part of that component,
	  - EXCEPT for any Elements which are themselves Components - i.e. SubComponents.
	  - Any Element can ask for its parent Component.
	  - Every Component maintains a hash of Element keys to Elements for every Element in that Component.
	  - Automatic warnings for duplicate "key" values for children who have keys within a component.
	    When this happens, the second, duplicate key is renamed to be unique via an appended string.

	  Global-scoping vs relative scoping

	  I'd rather avoid anything global, but to handle the "animated thumbnail-zoom-in" use-case, we
	  will need a way for one element to reference another in a different component. I think the
	  rought idea would be some way to express:

	  - "within my parent component with key XYZ"
	  - "within its subcomponent with key ABC"
	  - "select element with key LMO"

	  Basically, we can navigate the 'component-defined-key-namespace-tree' by first scanning UP,
	  then scanning down, and then select an element within the resulting selected component.

	  This avoids ever going to a global scope. There could be other components that use the same
	  keys and it wouldn't interfere with this lookup.

	  How it might look:

	    element:
	      withinParentComponent: "XYZ"
	      findChildComponent: "ABC"
	      findElement: "LMO"

	  We could also decide to have a "selector" shorthand:

	    element: "^XYZ/** /ABC/LMO"

	    HRM - coffeescript doesn't allow * followed by / in a comment block. Makes sense, but I had
	      to add a space after '**' above. Ignore the space :).

	    split on '/'
	    '^' means search up for the first component that matches the rest of the string
	    '**' means match any path of sub-components

	  When "pathing" sub-components and sub-elements are both found in the same key-lookup-hash.
	  The only difference is the key-loopup-hash that is used is found in the first component-element
	  at of above the current element. So, if you path to a sub-component, the next key will select
	  from within that component, but if you path to just an element, the next key could jump you to
	  any other element within the same parent component.

	  Possibly we just make this illegal. If you attempt to path "into" an element which is not a component,
	  it's an error - logged in debug mode and returning a null result.

	  How can we make '**' fast? Each component-element can have a list of all sub-components so we don't
	  have to enumerate all elements. That still requires tree traversal. We could maintain pre-computed
	  hashs, but anytime an anything changes in the tree that could be quite a lot of updates. Every parent
	  needs to be updated since ** could be triggered from any parent to any child.

	----------------------------------
	REACT IMPLICATIONS

	"keys" need to become component-wide, not just Parent-scoped.

	Does this mean we still need the following limitation for Component roots?
	  a) must be a single element
	  b) can't change its Element-type.

	NOTE: Span elements will make this less onerous. Just wrap the root in a Span and you can
	  do whatever you want within that span as-if you were just returning an array of elements.
	 */


	/*
	Animator is created once, when the Element is created (or the animators prop is set).
	It persists as long as the animator property is set and points to it.
	If can be "active" or not. If active, that element will get an epoch update each
	frame, and the animator will get a chance to animate the property each frame.

	Options:
	  on:
	    done: ->   # fires when the animation completes
	    update: -> # fires every time the target object's animated values updated
	    start: ->  # fires when the animation starts
	    abort: ->  # fires when the animation aborts
	  continuous: [false]
	    if true
	      1. the animation starts as soon as the Element is registered
	      2. the animation stops when the Element is unregistered
	 */

	module.exports = PersistantAnimator = (function(superClass) {
	  var interpolate;

	  extend(PersistantAnimator, superClass);

	  PersistantAnimator.interpolate = interpolate = function(startValue, toValue, pos) {
	    var k, out, v;
	    if (isFunction(startValue.interpolate)) {
	      return startValue.interpolate(toValue, pos);
	    } else if (isPlainObject(startValue)) {
	      out = {};
	      for (k in startValue) {
	        v = startValue[k];
	        out[k] = interpolate(v, toValue[k], pos);
	      }
	      return out;
	    } else {
	      return startValue + (toValue - startValue) * pos;
	    }
	  };

	  PersistantAnimator.getter("options prop element startValue currentValue toValue continuous voidValue currentSecond startSecond");

	  PersistantAnimator.getter({
	    active: function() {
	      return this._active || (this._continuous && (!this._element || this._element.isRegistered));
	    },
	    state: function() {
	      return this._state || (this._state = {});
	    }
	  });

	  PersistantAnimator.prototype.deactivate = function() {
	    if (this._active) {
	      return this._deactivate();
	    }
	  };

	  PersistantAnimator.getter({
	    inspectedObjects: function() {
	      var ref;
	      return [
	        inspectedObjectLiteral("PersistantAnimator"), {
	          prop: this.prop,
	          element: (ref = this.element) != null ? ref.inspectedName : void 0,
	          options: this.options
	        }
	      ];
	    }
	  });


	  /*
	  IN:
	    options:
	      animate: (animator) -> nextValue
	        IN:
	          startValue: the value when the aniation started
	          currentValue: the element's current value
	          toValue: the requested target value for the animation
	          secondsSinceStart: seconds since the animation started
	          animator: this PersistantAnimator object
	            animator.state: place to store state
	            animator.element: the element being animated
	            animator.stop: call this when done animating
	            animator.frameSeconds: seconds since the last frame
	  
	        OUT: the next value in the animation
	  
	        SHOULD:
	          Call animator.stop() when the animation is done.
	          The animation can run forever and never call stop if desired.
	          TODO: how do we release a forever animation?
	  
	        STATE:
	          Use animator.state object to store any persistant state the animation function needs.
	          animator.state is reserved for exclusive use by the animate function.
	      continuous: t/f
	      on: handlers
	  
	       * added and removed animation values
	      voidValue:  # both
	      fromVoid:   # added animation
	      toVoid:     # removed animation
	   */

	  function PersistantAnimator(prop, options) {
	    var ref, ref1;
	    PersistantAnimator.__super__.constructor.apply(this, arguments);
	    this._prop = prop;
	    this._options = options;
	    this._active = false;
	    this._startSecond = null;
	    this._currentSecond = null;
	    this._lastSecond = null;
	    this._startValue = null;
	    this._currentValue = null;
	    this._toValue = null;
	    this._element = null;
	    this._animate = options.animate;
	    this._continuous = options.continuous;
	    this._voidValue = rubyOr(options.voidValue, options.toFromVoid, options.fromToVoid, options["void"], options.toFrom, options.fromTo);
	    this._toVoid = (ref = options.toVoid) != null ? ref : options.to;
	    this._fromVoid = (ref1 = options.fromVoid) != null ? ref1 : options.from;
	    if (options != null ? options.on : void 0) {
	      this.on(options.on);
	    }
	  }

	  PersistantAnimator.getter({
	    fromVoid: function() {
	      if (this._voidValue != null) {
	        return this._voidValue;
	      } else {
	        return this._fromVoid;
	      }
	    },
	    toVoid: function() {
	      if (this._voidValue != null) {
	        return this._voidValue;
	      } else {
	        return this._toVoid;
	      }
	    },
	    hasFromVoidAnimation: function() {
	      return this.fromVoid != null;
	    },
	    hasToVoidAnimation: function() {
	      return this.toVoid != null;
	    }
	  });

	  PersistantAnimator.getter({
	    animationSeconds: function() {
	      return this._currentSecond - this._startSecond;
	    },
	    frameSeconds: function() {
	      if (this._active) {
	        return this._currentSecond - this._lastSecond;
	      } else {
	        return 0;
	      }
	    },

	    /*
	    returns a bound function to stop this animator
	    OUT: -> toValue
	      OUT: toValue
	      EFFECT: stops the animator
	     */
	    stop: function() {
	      return this._stop || (this._stop = (function(_this) {
	        return function() {
	          _this._active = false;
	          return _this._toValue;
	        };
	      })(this));
	    }
	  });

	  PersistantAnimator.prototype.startToVoidAnimation = function(_element) {
	    this._element = _element;
	    if (!this.hasToVoidAnimation) {
	      return Promise.reject();
	    }
	    return new Promise((function(_this) {
	      return function(resolve, reject) {
	        if (_this._active) {
	          _this._activate();
	        }
	        _this._element[_this._prop] = _this._toValue = _this.toVoid;
	        return _this.on({
	          done: resolve
	        });
	      };
	    })(this));
	  };

	  PersistantAnimator.prototype.getPreprocessedFromVoid = function(_element) {
	    this._element = _element;
	    return this._element.preprocessProperty(this._prop, this.fromVoid);
	  };

	  PersistantAnimator.prototype.animate = function() {
	    if (this._animate) {
	      return this._animate(this);
	    } else {
	      log("no @_animate");
	      return this.stop();
	    }
	  };

	  PersistantAnimator.prototype._activate = function() {
	    this._lastSecond = this._startSecond = this._currentSecond - this.frameSeconds;
	    this._startValue = this._currentValue;
	    this.queueEvent("start");
	    return this._active = true;
	  };

	  PersistantAnimator.prototype._deactivate = function() {
	    this.queueEvent("done");
	    return this._active = false;
	  };

	  PersistantAnimator.prototype.animateAbsoluteTime = function(_element, _currentValue, toValue, _currentSecond) {
	    var animationSeconds, newValue;
	    this._element = _element;
	    this._currentValue = _currentValue;
	    this._currentSecond = _currentSecond;
	    if (!(this._active && eq(toValue, this._toValue))) {
	      this._activate();
	    }
	    this._toValue = toValue;
	    animationSeconds = this.getAnimationSeconds();
	    newValue = this.animate();
	    if (this._active) {
	      if (animationSeconds > 0) {
	        this.queueEvent("update");
	      }
	      this._element.onNextEpoch((function(_this) {
	        return function() {
	          return _this._element[_this._prop] = _this._toValue;
	        };
	      })(this));
	    } else {
	      this._deactivate();
	    }
	    this._lastSecond = this._currentSecond;
	    return this._element.preprocessProperty(this._prop, newValue);
	  };

	  return PersistantAnimator;

	})(EventedMixin(BaseObject));


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, EasingFunctions, EventedObject, Events, Foundation, PeriodicPersistantAnimator, PersistantAnimator, interpolate, isFunction, isNumber, isString, log, max, min,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Events = __webpack_require__(168);

	EasingFunctions = __webpack_require__(186);

	PersistantAnimator = __webpack_require__(208);

	log = Foundation.log, BaseObject = Foundation.BaseObject, isFunction = Foundation.isFunction, isString = Foundation.isString, isNumber = Foundation.isNumber, min = Foundation.min, max = Foundation.max;

	EventedObject = Events.EventedObject;

	interpolate = PersistantAnimator.interpolate;

	module.exports = PeriodicPersistantAnimator = (function(superClass) {
	  extend(PeriodicPersistantAnimator, superClass);

	  PeriodicPersistantAnimator.getter({
	    animationPos: function() {
	      return (this.getAnimationSeconds() % this._period) / this._period;
	    }
	  });

	  PeriodicPersistantAnimator.property("period");

	  function PeriodicPersistantAnimator(_, options) {
	    if (options == null) {
	      options = {};
	    }
	    PeriodicPersistantAnimator.__super__.constructor.apply(this, arguments);
	    this.period = options.period;
	  }

	  return PeriodicPersistantAnimator;

	})(PersistantAnimator);


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Foundation) {
	  var BaseObject, EngineStat, Map, Stat, arrayWithout, currentSecond, log, miniInspect;
	  log = Foundation.log, Map = Foundation.Map, miniInspect = Foundation.miniInspect, currentSecond = Foundation.currentSecond, arrayWithout = Foundation.arrayWithout, BaseObject = Foundation.BaseObject, Stat = Foundation.Stat;
	  return EngineStat = (function(superClass) {
	    extend(EngineStat, superClass);

	    function EngineStat() {
	      this.reset();
	    }

	    EngineStat.prototype.reset = function() {
	      return this.stats = {};
	    };

	    EngineStat.prototype.add = function(statName, value) {
	      var base;
	      return ((base = this.stats)[statName] || (base[statName] = new Stat)).add(value);
	    };

	    EngineStat.prototype.length = function(statName) {
	      var stat;
	      if (stat = this.stats[statName]) {
	        return stat.length;
	      } else {
	        return 0;
	      }
	    };

	    EngineStat.prototype.log = function() {
	      var greatestPow10LessThanMax, k, ref, smallestMultipleGreaterThanMax, toLog, v;
	      toLog = {};
	      ref = this.stats;
	      for (k in ref) {
	        v = ref[k];
	        greatestPow10LessThanMax = Math.pow(10, Math.floor(Math.log10(v.max)));
	        smallestMultipleGreaterThanMax = (Math.ceil(v.max / greatestPow10LessThanMax)) * greatestPow10LessThanMax;
	        toLog[k] = {
	          min: v.min.toPrecision(5) / 1,
	          av: v.average.toPrecision(5) / 1,
	          max: v.max.toPrecision(5) / 1,
	          hist: v.histogram(10, 0, smallestMultipleGreaterThanMax),
	          histMax: smallestMultipleGreaterThanMax
	        };
	      }
	      return log(toLog);
	    };

	    return EngineStat;

	  })(BaseObject);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(196).addModules({
	  Basics: __webpack_require__(198),
	  FlexLayout: __webpack_require__(197),
	  Infinity: __webpack_require__(199),
	  StateEpochLayout: __webpack_require__(195)
	});


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(213).includeInNamespace(__webpack_require__(214)).addModules({
	  Base: __webpack_require__(219),
	  FillableBase: __webpack_require__(218)
	});

	__webpack_require__(232);

	__webpack_require__(241);

	__webpack_require__(215);

	__webpack_require__(237);


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	var Elements, Engine,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Engine = __webpack_require__(154);

	module.exports = Engine.Elements || Engine.addNamespace('Elements', Elements = (function(superClass) {
	  extend(Elements, superClass);

	  function Elements() {
	    return Elements.__super__.constructor.apply(this, arguments);
	  }

	  return Elements;

	})(Neptune.Base));


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [__webpack_require__(215), __webpack_require__(232), __webpack_require__(237), __webpack_require__(241)];


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(216).addModules({
	  BitmapElement: __webpack_require__(217),
	  RectangleElement: __webpack_require__(220),
	  ShapeElement: __webpack_require__(230),
	  TextElement: __webpack_require__(231)
	});


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var Elements, Shapes,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Elements = __webpack_require__(213);

	module.exports = Elements.Shapes || Elements.addNamespace('Shapes', Shapes = (function(superClass) {
	  extend(Shapes, superClass);

	  function Shapes() {
	    return Shapes.__super__.constructor.apply(this, arguments);
	  }

	  return Shapes;

	})(Neptune.Base));


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, BaseObject, BitmapElement, Canvas, FillableBase, Foundation, Matrix, bound, ceil, createWithPostCreate, inspect, isNumber, isString, log, max, min, point, point0, point1, rect, round,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Canvas = __webpack_require__(137);

	FillableBase = __webpack_require__(218);

	ceil = Math.ceil, round = Math.round;

	inspect = Foundation.inspect, min = Foundation.min, max = Foundation.max, bound = Foundation.bound, log = Foundation.log, createWithPostCreate = Foundation.createWithPostCreate, isString = Foundation.isString, isNumber = Foundation.isNumber, BaseObject = Foundation.BaseObject;

	point = Atomic.point, rect = Atomic.rect, Matrix = Atomic.Matrix, point0 = Atomic.point0, point1 = Atomic.point1;

	module.exports = createWithPostCreate(BitmapElement = (function(superClass) {
	  var sourceToBitmapCache;

	  extend(BitmapElement, superClass);

	  BitmapElement.SourceToBitmapCache = (function(superClass1) {
	    extend(SourceToBitmapCache, superClass1);

	    SourceToBitmapCache.singletonClass();

	    function SourceToBitmapCache() {
	      this._cache = {};
	      this._referenceCounts = {};
	    }

	    SourceToBitmapCache.prototype.get = function(url, initializerPromise) {
	      var base;
	      if (url.match("ImagePicker")) {
	        log("SourceToBitmapCache#get: cached:" + (!!this._cache[url]) + " " + url);
	        log("initializerPromise: " + (!!initializerPromise));
	      }
	      this._referenceCounts[url] = (this._referenceCounts[url] || 0) + 1;
	      return (base = this._cache)[url] || (base[url] = initializerPromise || Canvas.Bitmap.get(url));
	    };

	    SourceToBitmapCache.prototype.release = function(url) {
	      if (!url) {
	        return;
	      }
	      if (!isNumber(this._referenceCounts[url])) {
	        throw new Error("no references for " + url);
	      }
	      if (this._referenceCounts[url] === 0 || !isNumber(this._referenceCounts[url])) {
	        return console.error("invalid referenceCount: " + (inspect(this._referenceCounts[url])) + " for url: " + url);
	      }
	      this._referenceCounts[url]--;
	      if (this._referenceCounts[url] === 0) {
	        delete this._cache[url];
	        return true;
	      } else {
	        return false;
	      }
	    };

	    return SourceToBitmapCache;

	  })(BaseObject);

	  sourceToBitmapCache = BitmapElement.SourceToBitmapCache.singleton;

	  function BitmapElement(options) {
	    BitmapElement.__super__.constructor.apply(this, arguments);
	    this._bitmapToElementMatrix = new Matrix;
	  }

	  BitmapElement.prototype._unregister = function() {
	    sourceToBitmapCache.release(this.getSource());
	    return BitmapElement.__super__._unregister.apply(this, arguments);
	  };

	  BitmapElement.getter({
	    cacheable: function() {
	      return false;
	    }
	  });

	  BitmapElement.prototype.customLayoutChildrenFirstPass = function(size) {
	    var ref;
	    return ((ref = this.getPendingBitmap()) != null ? ref.pointSize : void 0) || point0;
	  };

	  BitmapElement.prototype.customLayoutChildrenSecondPass = function(size) {};

	  BitmapElement.drawProperty({
	    focus: {
	      "default": null,
	      preprocess: function(v) {
	        if (v != null) {
	          return point(v).bound(point0, point1);
	        } else {
	          return null;
	        }
	      }
	    },
	    mode: {
	      "default": "stretch",
	      preprocess: function(v) {
	        return (v != null ? v.toString() : void 0) || null;
	      }
	    },
	    sourceArea: {
	      "default": null,
	      preprocess: function(v) {
	        if (v != null) {
	          return rect(v);
	        } else {
	          return null;
	        }
	      }
	    }
	  });

	  BitmapElement.concreteProperty({

	    /*
	    This works pretty-much like the HTMLImageElement's "src" field.
	    It will fetch a bitmap from the specified URL.
	    It will fire off the following events: onLoad and onError
	    It will set the @bitmap property on success.
	    If it changes, it will attempt to load the new URL and fire another onLoad or onError.
	    
	    NOTE on naming vs HTMLImageElement:
	      The naming choices here are for consistency and full-words.
	      The DOM is inconsistent uses shortend words like "src."
	    
	      DOM     Art.Engine
	      src     source
	      onload  load
	      onerror error
	     */
	    source: {
	      "default": null,
	      validate: function(v) {
	        return !v || isString(v);
	      },
	      postSetter: function(v) {
	        return v && this._loadBitmapFromSource(v);
	      }
	    }
	  });

	  BitmapElement.prototype._loadBitmapFromSource = function(source) {
	    return sourceToBitmapCache.get(source).then((function(_this) {
	      return function(bitmap) {
	        _this.onNextReady(function() {
	          return _this.queueEvent("load", function() {
	            return {
	              bitmap: bitmap
	            };
	          });
	        });
	        return _this.setBitmap(bitmap);
	      };
	    })(this), (function(_this) {
	      return function(error) {
	        console.error(error.stack);
	        return _this.onNextReady(function() {
	          return _this.queueEvent("error", function() {
	            return {
	              error: e
	            };
	          });
	        });
	      };
	    })(this));
	  };

	  BitmapElement.drawLayoutProperty({
	    bitmap: {
	      "default": null,
	      validate: function(v) {
	        return !v || v instanceof Canvas.BitmapBase;
	      }
	    }
	  });

	  BitmapElement.prototype._drawPropertiesChanged = function() {
	    var bitmapSize, currentSize, desiredSourceX, desiredSourceY, effectiveSourceLoc, effectiveSourceSize, effectiveSourceSizeX, effectiveSourceSizeY, scale, sourceLoc, sourceSize, sourceX, sourceY;
	    BitmapElement.__super__._drawPropertiesChanged.apply(this, arguments);
	    if (!this._bitmap) {
	      return;
	    }
	    bitmapSize = this._bitmap.size;
	    this._drawOptions.sourceArea = this._sourceArea ? this._sourceArea.mul(this._bitmap.pixelsPerPoint) : null;
	    sourceSize = this._drawOptions.sourceArea ? this._drawOptions.sourceArea.size : bitmapSize;
	    sourceLoc = this._drawOptions.sourceArea ? this._drawOptions.sourceArea.location : point();
	    currentSize = this.currentSize;
	    return this._bitmapToElementMatrix = (function() {
	      switch (this._mode) {
	        case "stretch":
	          return Matrix.scale(currentSize.div(sourceSize));
	        case "zoom":
	          scale = max(currentSize.x / sourceSize.x, currentSize.y / sourceSize.y);
	          effectiveSourceSizeX = min(bitmapSize.x, ceil(currentSize.x / scale));
	          effectiveSourceSizeY = min(bitmapSize.y, ceil(currentSize.y / scale));
	          if (this._focus) {
	            desiredSourceX = sourceSize.x * this._focus.x - effectiveSourceSizeX * .5;
	            desiredSourceY = sourceSize.y * this._focus.y - effectiveSourceSizeY * .5;
	          } else {
	            desiredSourceX = sourceLoc.x + sourceSize.x * .5 - round(effectiveSourceSizeX * .5);
	            desiredSourceY = sourceLoc.y + sourceSize.y * .5 - round(effectiveSourceSizeY * .5);
	          }
	          sourceX = bound(0, desiredSourceX, bitmapSize.x - effectiveSourceSizeX);
	          sourceY = bound(0, desiredSourceY, bitmapSize.y - effectiveSourceSizeY);
	          this._drawOptions.sourceArea = rect(sourceX, sourceY, effectiveSourceSizeX, effectiveSourceSizeY);
	          return Matrix.scale(scale);
	        case "center":
	          effectiveSourceSize = currentSize.roundOut();
	          effectiveSourceLoc = sourceLoc.add(sourceSize.cc.sub(effectiveSourceSize.cc.round()));
	          this._drawOptions.sourceArea = rect(effectiveSourceLoc, effectiveSourceSize);
	          return new Matrix;
	        case "fit":
	          scale = currentSize.div(sourceSize).min();
	          return Matrix.translate(sourceSize.cc.neg).scale(scale).translate(currentSize.cc);
	        case "min":
	          scale = min(1 / this.devicePixelsPerPoint, currentSize.div(sourceSize).min());
	          return Matrix.translate(sourceSize.cc.neg).scale(scale).translate(currentSize.cc);
	        default:
	          throw new Error("unknown mode: " + this._mode);
	      }
	    }).call(this);
	  };

	  BitmapElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
	    return this._bitmap && target.drawBitmap(this._bitmapToElementMatrix.mul(elementToTargetMatrix), this._bitmap, options);
	  };

	  return BitmapElement;

	})(FillableBase));


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, Base, Canvas, Color, FillableBase, Foundation, GradientFillStyle, Matrix, Point, PointLayout, PointLayoutBase, Rectangle, createWithPostCreate, isNumber, isPlainObject, log, matrix, max, merge, min, point, point0, point1, rect, ref, rgbColor,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Canvas = __webpack_require__(137);

	Base = __webpack_require__(219);

	ref = __webpack_require__(187), PointLayout = ref.PointLayout, PointLayoutBase = ref.PointLayoutBase;

	log = Foundation.log, isPlainObject = Foundation.isPlainObject, min = Foundation.min, max = Foundation.max, createWithPostCreate = Foundation.createWithPostCreate, isNumber = Foundation.isNumber, merge = Foundation.merge;

	rgbColor = Atomic.rgbColor, Color = Atomic.Color, point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix, point0 = Atomic.point0, point1 = Atomic.point1;

	GradientFillStyle = Canvas.GradientFillStyle;

	module.exports = createWithPostCreate(FillableBase = (function(superClass) {
	  var defaultFrom, defaultOffset, defaultTo, noShadow;

	  extend(FillableBase, superClass);

	  function FillableBase() {
	    return FillableBase.__super__.constructor.apply(this, arguments);
	  }

	  FillableBase.registerWithElementFactory = function() {
	    return this !== FillableBase;
	  };

	  FillableBase.getter({
	    cacheable: function() {
	      return this.getHasChildren();
	    }
	  });

	  defaultFrom = new PointLayout();

	  defaultTo = new PointLayout({
	    hh: 1
	  });

	  defaultOffset = new PointLayout({
	    y: 2
	  });

	  noShadow = {
	    color: rgbColor(0, 0, 0, 0),
	    blur: 0,
	    offset: new PointLayout(0)
	  };

	  FillableBase.drawProperty({
	    from: {
	      preprocess: function(v) {
	        return v && (v instanceof PointLayoutBase ? v : new PointLayout(v));
	      }
	    },
	    to: {
	      preprocess: function(v) {
	        return v && (v instanceof PointLayoutBase ? v : new PointLayout(v));
	      }
	    },
	    colors: {
	      "default": null
	    },
	    gradientRadius: {
	      "default": null
	    },
	    shadow: {
	      "default": null,
	      validate: function(v) {
	        return !v || v === true || isPlainObject(v);
	      },
	      preprocess: function(v) {
	        var blur, color, offset;
	        if (!v) {
	          return noShadow;
	        }
	        color = v.color, offset = v.offset, blur = v.blur;
	        color = rgbColor(color || "#0007");
	        offset = offset != null ? offset instanceof PointLayoutBase ? offset : new PointLayout(offset) : defaultOffset;
	        if (blur == null) {
	          blur = 4;
	        }
	        return {
	          blur: blur,
	          offset: offset,
	          color: color
	        };
	      }
	    }
	  });

	  FillableBase.getter({
	    normalizedShadow: function() {
	      var offset, x, y;
	      if (this._shadow === noShadow) {
	        return null;
	      }
	      offset = this._shadow.offset;
	      x = offset.layoutX(this._currentSize);
	      y = offset.layoutY(this._currentSize);
	      return merge(this._shadow, {
	        offsetX: x,
	        offsetY: y
	      });
	    }
	  });

	  FillableBase.prototype._expandRectangleByShadow = function(r, shadow) {
	    var blur, expandBottom, expandLeft, expandRight, expandTop, h, offsetX, offsetY, ref1, w, x, y;
	    if (shadow === noShadow) {
	      return r;
	    }
	    x = r.x, y = r.y, w = r.w, h = r.h;
	    ref1 = this.normalizedShadow, blur = ref1.blur, offsetX = ref1.offsetX, offsetY = ref1.offsetY;
	    offsetX || (offsetX = 0);
	    offsetY || (offsetY = 0);
	    blur || (blur = 0);
	    expandLeft = max(0, blur - offsetX);
	    expandTop = max(0, blur - offsetY);
	    expandRight = max(0, blur + offsetX);
	    expandBottom = max(0, blur + offsetY);
	    return r["with"](x - expandLeft, y - expandTop, w + expandLeft + expandRight, h + expandTop + expandBottom);
	  };

	  FillableBase.virtualProperty({
	    baseDrawArea: function(pending) {
	      return this._expandRectangleByShadow(this.getPreFilteredBaseDrawArea(pending), this.getState(pending)._shadow);
	    }
	  });

	  FillableBase.prototype._prepareDrawOptions = function(drawOptions, compositeMode, opacity) {
	    var _colors, _currentSize, _from, _gradientRadius, _to, gradientScale, r1, r2, ref1, ref2;
	    FillableBase.__super__._prepareDrawOptions.apply(this, arguments);
	    ref1 = this, _colors = ref1._colors, _currentSize = ref1._currentSize;
	    drawOptions.shadow = this.normalizedShadow;
	    drawOptions.colors = null;
	    drawOptions.gradientRadius = null;
	    drawOptions.gradientRadius1 = null;
	    drawOptions.gradientRadius2 = null;
	    drawOptions.from = null;
	    drawOptions.to = null;
	    if (_colors) {
	      ref2 = this, _from = ref2._from, _to = ref2._to, _gradientRadius = ref2._gradientRadius;
	      _from || (_from = defaultFrom);
	      drawOptions.colors = _colors;
	      if (_gradientRadius != null) {
	        _to || (_to = _from);
	        gradientScale = _currentSize.min() / 2;
	        if (isNumber(_gradientRadius)) {
	          drawOptions.gradientRadius = _gradientRadius * gradientScale;
	        } else {
	          r1 = _gradientRadius[0], r2 = _gradientRadius[1];
	          drawOptions.gradientRadius1 = r1 * gradientScale;
	          drawOptions.gradientRadius2 = r2 * gradientScale;
	        }
	      }
	      _to || (_to = defaultTo);
	      drawOptions.from = _from.layout(_currentSize);
	      return drawOptions.to = _to.layout(_currentSize);
	    }
	  };

	  return FillableBase;

	})(Base));


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, Base, Element, Foundation, createWithPostCreate, inspect, rgbColor,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Element = __webpack_require__(184);

	inspect = Foundation.inspect, createWithPostCreate = Foundation.createWithPostCreate;

	rgbColor = Atomic.rgbColor;

	module.exports = createWithPostCreate(Base = (function(superClass) {
	  extend(Base, superClass);

	  Base.registerWithElementFactory = function() {
	    return this !== Base;
	  };

	  function Base() {
	    Base.__super__.constructor.apply(this, arguments);
	    this._drawOptions = {};
	  }

	  Base.drawProperty({
	    color: {
	      "default": null,
	      preprocess: function(v) {
	        if (v) {
	          return rgbColor(v);
	        } else {
	          return null;
	        }
	      }
	    }
	  });

	  Base.prototype.drawBasic = function(target, elementToTargetMatrix, compositeMode, opacity) {
	    this._prepareDrawOptions(this._drawOptions, compositeMode, opacity);
	    return this.fillShape(target, elementToTargetMatrix, this._drawOptions);
	  };

	  Base.prototype._useStagingBitmap = function() {
	    if (this.getHasChildren()) {
	      return Base.__super__._useStagingBitmap.apply(this, arguments);
	    }
	    return this.getChildRequiresParentStagingBitmap() || this.getIsMask();
	  };

	  Base.prototype._drawChildren = function(target, elementToTargetMatrix, usingStagingBitmap) {
	    if (this.hasChildren) {
	      return Base.__super__._drawChildren.apply(this, arguments);
	    }
	    if (usingStagingBitmap) {
	      return this.drawBasic(target, elementToTargetMatrix);
	    } else {
	      return this.drawBasic(target, elementToTargetMatrix, this.getCompositeMode(), this.getOpacity());
	    }
	  };


	  /*
	  Either fillShape or drawBasic must be overridden by each inheriting class
	   */

	  Base.prototype.fillShape = function(target, elementToTargetMatrix, options) {
	    throw new Error("fillShape or drawBasic must be overridden");
	  };


	  /*
	  _prepareDrawOptions
	  Inheriting classes can override & extend to add additional options
	  purpose: to re-use the plain-object for draw options instead of creating a new one every time.
	   */

	  Base.prototype._prepareDrawOptions = function(drawOptions, compositeMode, opacity) {
	    drawOptions.compositeMode = compositeMode;
	    drawOptions.opacity = opacity;
	    return drawOptions.color = this._color;
	  };

	  return Base;

	})(Element));


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, FillableBase, Foundation, Paths, RectangleElement, Text, base, createWithPostCreate, curriedRoundedRectangle, floatEq, isNumber, isPlainObject, pureMerge,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Text = __webpack_require__(221);

	FillableBase = __webpack_require__(218);

	Paths = __webpack_require__(137).Paths;

	pureMerge = Foundation.pureMerge, floatEq = Foundation.floatEq, base = Foundation.base, createWithPostCreate = Foundation.createWithPostCreate, isPlainObject = Foundation.isPlainObject, isNumber = Foundation.isNumber;

	curriedRoundedRectangle = Paths.curriedRoundedRectangle;

	module.exports = createWithPostCreate(RectangleElement = (function(superClass) {
	  extend(RectangleElement, superClass);

	  function RectangleElement() {
	    return RectangleElement.__super__.constructor.apply(this, arguments);
	  }

	  RectangleElement.drawProperty({
	    radius: {
	      "default": 0,
	      validate: function(v) {
	        return !v || isNumber(v) || isPlainObject(v);
	      },
	      preprocess: function(v) {
	        return v || 0;
	      }
	    }
	  });

	  RectangleElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
	    options.radius = this._radius;
	    options.color || (options.color = this._color);
	    return target.drawRectangle(elementToTargetMatrix, this.getPaddedArea(), options);
	  };

	  RectangleElement.prototype.strokeShape = function(target, elementToTargetMatrix, options) {
	    options.radius = this._radius;
	    options.color || (options.color = this._color);
	    return target.strokeRectangle(elementToTargetMatrix, this.getPaddedArea(), options);
	  };

	  RectangleElement.prototype._clipDraw = function(clipArea, target, elementToTargetMatrix) {
	    if (floatEq(this._radius, 0)) {
	      return RectangleElement.__super__._clipDraw.apply(this, arguments);
	    } else {
	      return target.clippedTo(curriedRoundedRectangle(target.pixelSnapRectangle(elementToTargetMatrix, this.getPaddedArea()), this._radius), (function(_this) {
	        return function() {
	          return _this._drawChildren(target, elementToTargetMatrix);
	        };
	      })(this), elementToTargetMatrix);
	    }
	  };

	  RectangleElement.getter({
	    hasCustomClipping: function() {
	      return this._radius > 0;
	    }
	  });

	  return RectangleElement;

	})(FillableBase));


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(222);


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(223).includeInNamespace(__webpack_require__(225)).addModules({
	  Layout: __webpack_require__(227),
	  Metrics: __webpack_require__(228),
	  TextLayoutFragment: __webpack_require__(229)
	});


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Text,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(224);

	module.exports = Art.Text || Art.addNamespace('Text', Text = (function(superClass) {
	  extend(Text, superClass);

	  function Text() {
	    return Text.__super__.constructor.apply(this, arguments);
	  }

	  return Text;

	})(Neptune.Base));


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	var _package;

	module.exports = [
	  {
	    "package": _package = __webpack_require__(226),
	    version: _package.version
	  }
	];


/***/ },
/* 226 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-canvas": "git://github.com/imikimi/art-canvas.git",
			"art-foundation": "git://github.com/imikimi/art-foundation.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.4.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"license": "ISC",
		"name": "art-text",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "1.0.0"
	};

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, BaseObject, Bitmap, Foundation, Layout, Matrix, Metrics, Rectangle, ceil, emptyOptions, flatten, float32Eq, float32Eq0, floor, inspect, isNumber, log, matrix, max, merge, min, nearInfinity, nearInfinityResult, peek, point, pureMerge, rect, time, toFontCss,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Bitmap = __webpack_require__(137).Bitmap;

	Atomic = __webpack_require__(125);

	Metrics = __webpack_require__(228);

	rect = Atomic.rect, matrix = Atomic.matrix, Matrix = Atomic.Matrix, Rectangle = Atomic.Rectangle, point = Atomic.point;

	floor = Math.floor, ceil = Math.ceil;

	log = Foundation.log, inspect = Foundation.inspect, pureMerge = Foundation.pureMerge, flatten = Foundation.flatten, BaseObject = Foundation.BaseObject, nearInfinity = Foundation.nearInfinity, nearInfinityResult = Foundation.nearInfinityResult, peek = Foundation.peek, min = Foundation.min, max = Foundation.max, merge = Foundation.merge, time = Foundation.time, isNumber = Foundation.isNumber, float32Eq = Foundation.float32Eq, float32Eq0 = Foundation.float32Eq0;

	toFontCss = Metrics.toFontCss;

	emptyOptions = {};

	module.exports = Layout = (function(superClass) {
	  var defaultLayoutOptions, defaultText, wordStringToHash;

	  extend(Layout, superClass);

	  Layout.defaultText = defaultText = "";

	  Layout.defaultLayoutOptions = defaultLayoutOptions = {
	    leading: 1.25,
	    align: point("left"),
	    layoutMode: "textualBaseline",
	    overflow: "ellipsis",
	    maxLines: void 0
	  };

	  wordStringToHash = function(wordString) {
	    var j, len, ref, ret, word;
	    ret = {};
	    ref = wordString.split(/\s+/);
	    for (j = 0, len = ref.length; j < len; j++) {
	      word = ref[j];
	      ret[word] = true;
	    }
	    return ret;
	  };

	  Layout.validLayoutOptions = {
	    layoutMode: wordStringToHash("textual textualBaseline tight tight0"),
	    overflow: wordStringToHash("ellipsis visible clipped")
	  };

	  function Layout(text, fontOptions, layoutOptions, layoutAreaWidth, layoutAreaHeight) {
	    if (layoutAreaWidth == null) {
	      layoutAreaWidth = nearInfinity;
	    }
	    if (layoutAreaHeight == null) {
	      layoutAreaHeight = nearInfinity;
	    }
	    if (!(isNumber(layoutAreaWidth) && isNumber(layoutAreaHeight))) {
	      throw new Error("layoutAreaWidth, layoutAreaHeight must be numbers: " + (inspect(layoutAreaHeight)));
	    }
	    this._layoutAreaWidth = layoutAreaWidth;
	    this._layoutAreaHeight = layoutAreaHeight;
	    this._fontOptions = Metrics.normalizeFontOptions(fontOptions || {});
	    this._layoutOptions = layoutOptions = pureMerge(defaultLayoutOptions, layoutOptions);
	    this._text = text || defaultText;
	    this._textLines = text.split("\n");
	    if (layoutOptions.wordWrapWidth) {
	      console.error("Art.Text.Layout#wordWrapWidth is depricated. Pass layoutAreaWidth and layoutAreaHeight into constructor.");
	    }
	    this._maxHeight = layoutOptions.maxHeight;
	    this._overflow = layoutOptions.overflow;
	    this._clipped = this._overflow === "clipped";
	    this._ellipsis = this._overflow === "ellipsis";
	    this._align = point(layoutOptions.align);
	    this._leading = layoutOptions.leading;
	    this._maxLines = layoutOptions.maxLines;
	    this._layoutMode = layoutOptions.layoutMode;
	    this._resetLayout();
	    this._left = this._right = this._top = this._bottom = 0;
	  }

	  Layout.getter("text align leading");

	  Layout.getter({
	    fontStyle: function() {
	      return this._fontOptions.fontStyle;
	    },
	    fontVariant: function() {
	      return this._fontOptions.fontVariant;
	    },
	    fontWeight: function() {
	      return this._fontOptions.fontWeight;
	    },
	    fontFamily: function() {
	      return this._fontOptions.fontFamily;
	    },
	    fontSize: function() {
	      return this._fontOptions.fontSize;
	    },
	    leading: function() {
	      return this._leading;
	    },
	    align: function() {
	      return this._align;
	    },
	    layoutMode: function() {
	      return this._layoutMode;
	    },
	    fragments: function() {
	      this._updateLayout();
	      return this._fragments;
	    },
	    size: function() {
	      this._updateLayout();
	      return this._size || (this._size = point(this._right - this._left, this._bottom - this._top));
	    },
	    area: function() {
	      this._updateLayout();
	      return this._area || (this._area = rect(this._left, this._top, this._right - this._left, this._bottom - this._top));
	    },
	    drawArea: function() {
	      this._updateLayout();
	      return this._drawArea || (this._drawArea = this._computeDrawArea());
	    },
	    fontCss: function() {
	      return this._fontCss || (this._fontCss = toFontCss(this._fontOptions));
	    },
	    lineCount: function() {
	      this._updateLayout();
	      return this._fragments.length;
	    }
	  });

	  Layout.prototype._getFragmentLogicalAreas = function(layoutHeight) {
	    var j, layoutArea, len, ref, results;
	    ref = this.fragments;
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      layoutArea = ref[j].layoutArea;
	      results.push(layoutArea);
	    }
	    return results;
	  };

	  Layout.prototype.draw = function(target, where, options) {
	    var context;
	    if (options == null) {
	      options = emptyOptions;
	    }
	    context = target.context2D;
	    if (!context) {
	      return this.drawToNonArtBitmap(target, where, options);
	    }
	    this._updateLayout();
	    if (target._setupDraw(where, options)) {
	      context.font = this.getFontCss();
	      context.textAlign = 'left';
	      context.textBaseline = 'alphabetic';
	      if (options.stroke) {
	        this._strokeAllFragments(context);
	      } else {
	        this._fillAllFragments(context);
	      }
	      return target._cleanupDraw(options);
	    }
	  };

	  Layout.prototype.stroke = function(target, where, options) {
	    if (options == null) {
	      options = emptyOptions;
	    }
	    return this.draw(target, where, merge(options, {
	      stroke: true
	    }));
	  };

	  Layout.prototype.drawToNonArtBitmap = function(target, where, options) {
	    var bitmap2D, scale;
	    if (options == null) {
	      options = emptyOptions;
	    }
	    scale = where.exactScale;
	    bitmap2D = new Bitmap(this.getSize().mul(scale));
	    this.draw(bitmap2D, Matrix.scale(scale), options);
	    return target.drawBitmap(Matrix.scale(scale.inv).mul(where), bitmap2D);
	  };

	  Layout.prototype.newBitmap = function(options) {
	    var scale, size;
	    if (options == null) {
	      options = emptyOptions;
	    }
	    size = options.size || this.getSize();
	    if (this._align.x > 0 && this._layoutAreaWidth < nearInfinityResult) {
	      size = size.withX(this._layoutAreaWidth);
	    }
	    if (this._align.y > 0 && this._layoutAreaHeight < nearInfinityResult) {
	      size = size.withY(this._layoutAreaHeight);
	    }
	    if (scale = options.scale) {
	      size = size.mul(scale);
	    }
	    return new Bitmap(size);
	  };

	  Layout.prototype.toBitmap = function(options) {
	    var bitmap, drawMatrix, scale;
	    if (options == null) {
	      options = emptyOptions;
	    }
	    drawMatrix = options.drawMatrix || new Matrix;
	    if (scale = options.scale) {
	      drawMatrix = drawMatrix.mul(Matrix.scale(scale));
	    }
	    bitmap = this.newBitmap(options);
	    this.draw(bitmap, drawMatrix, options);
	    return bitmap;
	  };

	  Layout.prototype._fillAllFragments = function(context) {
	    var frag, j, len, ref, results;
	    ref = this.fragments;
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      frag = ref[j];
	      results.push(context.fillText(frag.text, frag.getTextX(), frag.getTextY()));
	    }
	    return results;
	  };

	  Layout.prototype._strokeAllFragments = function(context) {
	    var frag, j, len, ref, results;
	    ref = this.fragments;
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      frag = ref[j];
	      results.push(context.strokeText(frag.text, frag.getTextX(), frag.getTextY()));
	    }
	    return results;
	  };

	  Layout.prototype._drawFragmentAreas = function(context) {
	    var fontSize, frag, j, layoutArea, len, ref, results;
	    fontSize = this.getFontSize();
	    ref = this.fragments;
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      frag = ref[j];
	      layoutArea = frag.layoutArea;
	      results.push(context.fillRect(layoutArea.x, layoutArea.y, layoutArea.w, layoutArea.h));
	    }
	    return results;
	  };

	  Layout.prototype._computeDrawArea = function() {
	    var bottom, fragment, fragments, i, j, left, len, right, top;
	    fragments = this.fragments;
	    if (fragments.length === 1) {
	      return fragments[0].alignedDrawArea;
	    } else {
	      left = top = right = bottom = 0;
	      for (i = j = 0, len = fragments.length; j < len; i = ++j) {
	        fragment = fragments[i];
	        if (i === 0) {
	          left = fragment.getAlignedDrawAreaLeft();
	          top = fragment.getAlignedDrawAreaTop();
	          right = fragment.getAlignedDrawAreaRight();
	          bottom = fragment.getAlignedDrawAreaBottom();
	        } else {
	          left = min(left, fragment.getAlignedDrawAreaLeft());
	          top = min(top, fragment.getAlignedDrawAreaTop());
	          right = max(right, fragment.getAlignedDrawAreaRight());
	          bottom = max(bottom, fragment.getAlignedDrawAreaBottom());
	        }
	      }
	      return new Rectangle(left, top, right - left, bottom - top);
	    }
	  };

	  Layout.prototype._alignFragments = function() {
	    var _align, _layoutAreaHeight, _layoutAreaWidth, area, frag, j, len, offsetY, ref, ref1, results, xAlign, yAlign;
	    ref = this, _layoutAreaWidth = ref._layoutAreaWidth, _layoutAreaHeight = ref._layoutAreaHeight, _align = ref._align, area = ref.area;
	    xAlign = _align.x;
	    yAlign = _align.y;
	    if (_layoutAreaWidth >= nearInfinityResult) {
	      xAlign = 0;
	    }
	    if (_layoutAreaHeight >= nearInfinityResult) {
	      yAlign = 0;
	    }
	    offsetY = (_layoutAreaHeight - area.h) * yAlign;
	    if (float32Eq0(offsetY) && float32Eq0(xAlign)) {
	      return;
	    }
	    ref1 = this.fragments;
	    results = [];
	    for (j = 0, len = ref1.length; j < len; j++) {
	      frag = ref1[j];
	      frag.alignmentOffsetX = (_layoutAreaWidth - frag.layoutW) * xAlign;
	      results.push(frag.alignmentOffsetY = offsetY);
	    }
	    return results;
	  };

	  Layout.prototype._setArea = function(fragment) {
	    this._top = fragment.getTop();
	    this._left = fragment.getLeft();
	    this._bottom = fragment.getBottom();
	    return this._right = fragment.getRight();
	  };

	  Layout.prototype._expandArea = function(fragment) {
	    this._top = min(this._top, fragment.getTop());
	    this._left = min(this._left, fragment.getLeft());
	    this._bottom = max(this._bottom, fragment.getBottom());
	    return this._right = max(this._right, fragment.getRight());
	  };

	  Layout.prototype._generateFragments = function() {
	    var _fontOptions, _layoutAreaWidth, _layoutMode, _textLines, fontCss, fragment, fragments, ref, text, wrappedFragments;
	    ref = this, _fontOptions = ref._fontOptions, _layoutAreaWidth = ref._layoutAreaWidth, _layoutMode = ref._layoutMode, _textLines = ref._textLines, _fontOptions = ref._fontOptions;
	    fontCss = this.getFontCss();
	    return this._fragments = (function() {
	      var j, k, l, len, len1, len2, results;
	      if (_layoutAreaWidth < nearInfinityResult && (_layoutMode === "textual" || _layoutMode === "textualBaseline")) {
	        fragments = [];
	        for (j = 0, len = _textLines.length; j < len; j++) {
	          text = _textLines[j];
	          wrappedFragments = Metrics.wrap(text, _fontOptions, _layoutAreaWidth, fontCss, _layoutMode);
	          for (k = 0, len1 = wrappedFragments.length; k < len1; k++) {
	            fragment = wrappedFragments[k];
	            fragments.push(fragment);
	          }
	        }
	        return fragments;
	      } else {
	        results = [];
	        for (l = 0, len2 = _textLines.length; l < len2; l++) {
	          text = _textLines[l];
	          results.push(Metrics.get(text, _fontOptions, _layoutMode, fontCss));
	        }
	        return results;
	      }
	    })();
	  };

	  Layout.prototype._layoutFragments = function() {
	    var _clipped, _ellipsis, _layoutAreaHeight, _layoutAreaWidth, _maxLines, allFragments, effectiveLeading, fragment, i, j, len, m, offsetX, offsetY, ref, ref1, text, textWithEllipsis;
	    ref = this, _layoutAreaWidth = ref._layoutAreaWidth, _layoutAreaHeight = ref._layoutAreaHeight, _maxLines = ref._maxLines, _clipped = ref._clipped, _ellipsis = ref._ellipsis;
	    offsetX = 0;
	    offsetY = 0;
	    effectiveLeading = this.getFontSize() * this.getLeading();
	    allFragments = this._fragments;
	    if (_maxLines && _maxLines < this._fragments.length) {
	      this._fragments = this._fragments.slice(0, _maxLines);
	    }
	    ref1 = this._fragments;
	    for (i = j = 0, len = ref1.length; j < len; i = ++j) {
	      fragment = ref1[i];
	      fragment.move(offsetX, offsetY);
	      if (i === 0) {
	        this._setArea(fragment);
	      } else {
	        if (_clipped) {
	          if (fragment.getTop() - this._top > _layoutAreaHeight) {
	            this._fragments = this._fragments.slice(0, i);
	            break;
	          }
	        } else if (_ellipsis) {
	          if (fragment.getBottom() - this._top > _layoutAreaHeight) {
	            this._fragments = this._fragments.slice(0, i);
	            break;
	          }
	        }
	        this._expandArea(fragment);
	      }
	      offsetY += effectiveLeading;
	    }
	    if (_ellipsis && this._fragments.length < allFragments.length) {
	      text = peek(this._fragments).text;
	      if (text[text.length - 1] === ".") {
	        text = text.slice(0, text.length - 1);
	      }
	      textWithEllipsis = text + "";
	      while (text.length > 0 && (m = Metrics.get(textWithEllipsis, this._fontOptions, this._layoutMode, this.getFontCss())).layoutW > _layoutAreaWidth) {
	        text = text.slice(0, text.length - 1);
	        textWithEllipsis = text + "";
	      }
	      m.setLayoutLocationFrom(peek(this._fragments));
	      this._fragments[this._fragments.length - 1] = m;
	      return this._expandArea(m);
	    }
	  };

	  Layout.prototype._resetLayout = function() {
	    return this._fragments = this._area = this._size = this._drawArea = null;
	  };

	  Layout.prototype._updateLayout = function() {
	    if (this._fragments) {
	      return;
	    }
	    this._resetLayout();
	    this._generateFragments();
	    this._layoutFragments();
	    return this._alignFragments();
	  };

	  Layout.setter({
	    width: function(width) {
	      this._updateLayout();
	      if (!float32Eq(width, this._layoutAreaWidth)) {
	        this._layoutAreaWidth = width;
	        this._area = null;
	        this._size = null;
	        this._drawArea = null;
	        this._alignFragments();
	      }
	      return null;
	    }
	  });

	  return Layout;

	})(BaseObject);


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {
	/*
	#TODO

	refactor to an object you create
	if either tight or tight0 are requested, calculate both
	for textual, have two areas:
	  textualArea - the current area we compute based on font-size and glyph width
	  textualDrawArea - a pessimistic, but always true, area that covers all pixels
	    since we have no concrete information on this, we'll just make it something like 2x textualArea - or more
	 */
	var Atomic, Canvas, Foundation, Rectangle, TextLayoutFragment, allIndexes, ceil, clone, defineModule, eachMatch, floor, inspect, isObject, isString, log, logL, max, merge, min, point, point0, rect,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Canvas = __webpack_require__(137);

	TextLayoutFragment = __webpack_require__(229);

	point = Atomic.point, rect = Atomic.rect, point0 = Atomic.point0, Rectangle = Atomic.Rectangle;

	defineModule = Foundation.defineModule, merge = Foundation.merge, log = Foundation.log, logL = Foundation.logL, inspect = Foundation.inspect, max = Foundation.max, min = Foundation.min, isObject = Foundation.isObject, isString = Foundation.isString, allIndexes = Foundation.allIndexes, eachMatch = Foundation.eachMatch, clone = Foundation.clone;

	floor = Math.floor, ceil = Math.ceil;

	defineModule(module, function() {
	  var alphaChannelOffset, pixelStep, tightThreshold;
	  alphaChannelOffset = 3;
	  pixelStep = 4;
	  tightThreshold = 127;
	  return Text.Metrics = (function(superClass) {
	    var blankString, defaultFontOptions, noBreaksWrapIndex, tempRectangleToCapturePessimisticDrawArea, toFontCss;

	    extend(Metrics, superClass);

	    function Metrics() {
	      return Metrics.__super__.constructor.apply(this, arguments);
	    }

	    Metrics.defaultFontSizeProportionalDrawAreaPadding = .45;

	    Metrics.defaultFontOptions = defaultFontOptions = {
	      fontStyle: 'normal',
	      fontVariant: 'normal',
	      fontWeight: 'normal',
	      fontSize: 16,
	      fontFamily: 'Times'
	    };

	    Metrics.toFontCss = toFontCss = function(fontOptions) {
	      return (fontOptions.fontStyle || 'normal') + " " + (fontOptions.fontVariant || 'normal') + " " + (fontOptions.fontWeight || 'normal') + " " + (fontOptions.fontSize || 16) + "px " + (fontOptions.fontFamily || 'Times') + ", Times";
	    };

	    Metrics.normalizeFontOptions = function(fontOptions) {
	      fontOptions.fontStyle || (fontOptions.fontStyle = defaultFontOptions.fontStyle);
	      fontOptions.fontVariant || (fontOptions.fontVariant = defaultFontOptions.fontVariant);
	      fontOptions.fontWeight || (fontOptions.fontWeight = defaultFontOptions.fontWeight);
	      fontOptions.fontSize || (fontOptions.fontSize = defaultFontOptions.fontSize);
	      fontOptions.fontFamily || (fontOptions.fontFamily = defaultFontOptions.fontFamily);
	      return fontOptions;
	    };

	    Metrics.get = function(text, fontOptions, layoutMode, fontCss) {
	      if (fontOptions == null) {
	        fontOptions = {};
	      }
	      switch (layoutMode) {
	        case null:
	        case void 0:
	        case "textual":
	          return this._getTextualFontMetrics(text, fontOptions, null, fontCss);
	        case "textualBaseline":
	          return this._getTextualFontMetrics(text, fontOptions, null, fontCss, false);
	        case "tight":
	          return this._getTightFontMetrics(text, 0, fontOptions, fontCss);
	        case "tight0":
	          return this._getTightFontMetrics(text, 0, fontOptions, fontCss);
	        default:
	          throw new Error("invalid layoutMode: " + (inspect(layoutMode)));
	      }
	    };

	    Metrics.getWidth = function(text, fontOptions, fontCss) {
	      var context;
	      context = Metrics.getScratchCanvasBitmap().context;
	      context.font = fontCss || toFontCss(fontOptions);
	      return context.measureText(text).width;
	    };

	    Metrics._wrapOnce = function(context, text, wordWrapWidth) {
	      if (context.measureText(text).width <= wordWrapWidth) {
	        return [text, null];
	      }
	    };

	    Metrics._noBreaksWrapIndex = noBreaksWrapIndex = function(context, text, wordWrapWidth) {
	      var left, leftPixelWidth, leftSlice, m, right, sliced, width;
	      left = 0;
	      leftPixelWidth = 0;
	      leftSlice = null;
	      right = text.length;
	      while (right - left > 1) {
	        m = (left + right) / 2 | 0;
	        if ((width = context.measureText(sliced = text.slice(0, m)).width) > wordWrapWidth) {
	          right = m;
	        } else {
	          leftSlice = sliced;
	          leftPixelWidth = width;
	          left = m;
	        }
	      }
	      if (!leftSlice) {
	        leftSlice = text.slice(0, 1);
	        leftPixelWidth = context.measureText(leftSlice).width;
	      }
	      return [leftPixelWidth, leftSlice];
	    };

	    blankString = "";

	    Metrics.wrap = function(text, fontOptions, wordWrapWidth, fontCss, layoutMode) {
	      var areaIncludesDescender, context, line, linePixelWidth, lines, nextLine, trailingSpace, trailingSpacePixelWidth;
	      if (layoutMode == null) {
	        layoutMode = "textual";
	      }
	      if (text === "") {
	        return [this._getTextualFontMetrics("", fontOptions, 0, fontCss)];
	      }
	      if (wordWrapWidth < 0) {
	        wordWrapWidth = 0;
	      }
	      areaIncludesDescender = layoutMode === "textual";
	      context = this.getScratchCanvasBitmap().context;
	      context.font = fontCss;
	      linePixelWidth = 0;
	      lines = [];
	      line = blankString;
	      trailingSpace = blankString;
	      trailingSpacePixelWidth = 0;
	      nextLine = (function(_this) {
	        return function() {
	          if (linePixelWidth > 0) {
	            lines.push(_this._getTextualFontMetrics(line, fontOptions, linePixelWidth, fontCss, areaIncludesDescender));
	            line = blankString;
	            linePixelWidth = 0;
	            trailingSpace = blankString;
	            return trailingSpacePixelWidth = 0;
	          }
	        };
	      })(this);
	      eachMatch(text, /(\s*[^\s]+)(\s*)/g, function(result) {
	        var _, firstHalfText, pixelWidth, ref, space, whiteSpaceLength, whiteSpacePixelWidth, word, wordLength, wordPixelWidth, wordStart;
	        wordStart = result.index;
	        _ = result[0], word = result[1], space = result[2];
	        wordLength = word.length;
	        whiteSpaceLength = space.length;
	        whiteSpacePixelWidth = context.measureText(space).width;
	        wordPixelWidth = context.measureText(word).width;
	        if (wordPixelWidth > wordWrapWidth) {
	          while (wordPixelWidth > wordWrapWidth) {
	            nextLine();
	            ref = noBreaksWrapIndex(context, word, wordWrapWidth), pixelWidth = ref[0], firstHalfText = ref[1];
	            line = firstHalfText;
	            linePixelWidth = pixelWidth;
	            word = word.slice(firstHalfText.length, word.length);
	            wordPixelWidth = context.measureText(word).width;
	          }
	          nextLine();
	          line = word;
	          linePixelWidth = wordPixelWidth;
	        } else if (trailingSpacePixelWidth + linePixelWidth + wordPixelWidth > wordWrapWidth) {
	          nextLine();
	          line = word;
	          linePixelWidth = wordPixelWidth;
	        } else {
	          line += trailingSpace + word;
	          linePixelWidth += trailingSpacePixelWidth + wordPixelWidth;
	        }
	        trailingSpace = space;
	        return trailingSpacePixelWidth = whiteSpacePixelWidth;
	      });
	      nextLine();
	      return lines;
	    };

	    Metrics._tightFontMetricCache = {};

	    Metrics._getTightFontMetrics = function(text, tightThreshold, fontOptions, fontCss) {
	      var base, previousResult, tightFontMetricCacheKey, upScale;
	      tightFontMetricCacheKey = text + ":" + tightThreshold + ":" + (fontCss || (fontCss = toFontCss(fontOptions)));
	      previousResult = (base = this._tightFontMetricCache)[tightFontMetricCacheKey] || (base[tightFontMetricCacheKey] = text.length === 1 ? (upScale = 2, fontOptions = merge(fontOptions, {
	        fontSize: fontOptions.fontSize * upScale
	      }), fontCss = toFontCss(fontOptions), this._generateTightFontMetrics(text, tightThreshold, fontOptions, fontCss).mul(1 / upScale)) : this._generateTightFontMetrics(text, tightThreshold, fontOptions, fontCss));
	      return previousResult.clone();
	    };

	    tempRectangleToCapturePessimisticDrawArea = new Rectangle;

	    Metrics._generateTightFontMetrics = function(text, tightThreshold, fontOptions, fontCss) {
	      var area, ascender, bottom, data, descender, layoutH, layoutW, left, location, padding, ref, ref1, ref2, ref3, right, scratchBitmap, size, textOffsetX, textOffsetY, top;
	      padding = Metrics.defaultFontSizeProportionalDrawAreaPadding * 2;
	      ref = this.renderTextToScratchBitmap(text, fontOptions, padding), scratchBitmap = ref[0], size = ref[1], location = ref[2];
	      data = scratchBitmap.context.getImageData(0, 0, size.x, size.y).data;
	      ref1 = scratchBitmap.getAutoCropRectangle(tightThreshold), left = ref1.left, right = ref1.right, top = ref1.top, bottom = ref1.bottom;
	      while (left === 0 || top === 0 || right === size.x || bottom === size.y) {
	        this.log("Art.Text.Metrics#_generateTightFontMetrics: " + (inspect(fontOptions, 1)) + ", padding: " + padding + " too small. scratchBitmap.size: " + scratchBitmap.size);
	        padding *= 2;
	        ref2 = this.renderTextToScratchBitmap(text, fontOptions, padding), scratchBitmap = ref2[0], size = ref2[1], location = ref2[2];
	        ref3 = scratchBitmap.getAutoCropRectangle(tightThreshold), left = ref3.left, right = ref3.right, top = ref3.top, bottom = ref3.bottom;
	      }
	      top--;
	      left--;
	      textOffsetX = location.x - left;
	      textOffsetY = location.y - top;
	      layoutW = right - left + 1;
	      layoutH = bottom - top + 1;
	      area = rect(left - location.x, top - location.y, right - left + 1, bottom - top + 1);
	      ascender = location.y - top + 1;
	      descender = bottom - location.y;
	      return new TextLayoutFragment(text, fontOptions, ascender, descender, textOffsetX, textOffsetY, layoutW, layoutH, 0, 0, layoutW, layoutH);
	    };

	    Metrics._getTextualFontMetrics = function(text, fontOptions, alreadyComputedTextWidth, fontCss, areaIncludesDescender) {
	      var area, ascender, descender, fontSize, width;
	      if (areaIncludesDescender == null) {
	        areaIncludesDescender = true;
	      }
	      fontSize = fontOptions.fontSize - 0;
	      ascender = .75 * fontSize;
	      descender = .25 * fontSize;
	      width = alreadyComputedTextWidth != null ? alreadyComputedTextWidth : this.getWidth(text, fontOptions, fontCss);
	      area = rect(0, descender - fontSize, width, fontSize - (areaIncludesDescender ? 0 : descender));
	      this.pessimisticDrawArea(width, fontOptions, tempRectangleToCapturePessimisticDrawArea);
	      return new TextLayoutFragment(text, fontOptions, ascender, descender, -area.x, -area.y, area.w, area.h, tempRectangleToCapturePessimisticDrawArea.x, tempRectangleToCapturePessimisticDrawArea.y, tempRectangleToCapturePessimisticDrawArea.w, tempRectangleToCapturePessimisticDrawArea.h);
	    };

	    Metrics.classGetter({
	      scratchCanvasBitmap: function() {
	        return this._scratchCanvasBitmap || (this._scratchCanvasBitmap = new Canvas.Bitmap(point(10, 10)));
	      }
	    });

	    Metrics.pessimisticDrawArea = function(textWidth, fontOptions, intoRectangle, increasedFontSizeProportionalDrawAreaPadding) {
	      var floatX, floatY, fontSize, h, padding, w, x, y;
	      fontSize = fontOptions.fontSize;
	      padding = fontSize * (increasedFontSizeProportionalDrawAreaPadding || fontOptions.padding || Metrics.defaultFontSizeProportionalDrawAreaPadding);
	      x = Math.floor(floatX = -padding);
	      y = Math.floor(floatY = -padding);
	      w = Math.ceil(floatX + textWidth + padding * 2) - x;
	      h = Math.ceil(floatY + fontSize + padding * 2) - y;
	      if (intoRectangle) {
	        intoRectangle.x = x;
	        intoRectangle.y = y;
	        intoRectangle.w = w;
	        intoRectangle.h = h;
	        return intoRectangle;
	      } else {
	        return rect(x, y, w, h);
	      }
	    };

	    Metrics._scratchBitmap = null;

	    Metrics.renderTextToScratchBitmap = function(text, fontOptions, padding) {
	      var context, drawArea, ref, scratchBitmapSize, size, x, y;
	      drawArea = this.pessimisticDrawArea(this.getWidth(text, fontOptions), fontOptions, null, padding);
	      size = drawArea.size.size;
	      scratchBitmapSize = ((ref = this._scratchBitmap) != null ? ref.size : void 0) || point0;
	      if (!scratchBitmapSize.gt(size)) {
	        this._scratchBitmap = new Canvas.Bitmap(scratchBitmapSize.max(size));
	      } else {
	        this._scratchBitmap.clear();
	      }
	      context = this._scratchBitmap.context;
	      context.textAlign = 'left';
	      context.textBaseline = 'alphabetic';
	      context.font = toFontCss(fontOptions);
	      context.fillText(text, x = -drawArea.x, y = -drawArea.y + fontOptions.fontSize * 3 / 4);
	      return [this._scratchBitmap, size, point(x, y)];
	    };

	    Metrics.debug = function(area, bitmap, location, options) {
	      var image;
	      image = new Canvas.Bitmap(bitmap.size);
	      image.clear("white");
	      image.drawRectangle(location, area, "#ddf");
	      image.drawRectangle(location, rect(area.location.x, 0, area.size.x, 1), "red");
	      image.drawRectangle(location, rect(0, area.location.y, 1, area.size.y), "green");
	      image.drawBitmap(point(), bitmap);
	      return this.log(image, {
	        layoutMode: options.layoutMode
	      });
	    };

	    return Metrics;

	  })(Foundation.BaseObject);
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
	/*
	#TODO

	refactor to an object you create
	if either tight or tight0 are requested, calculate both
	for textual, have two areas:
	  textualArea - the current area we compute based on font-size and glyph width
	  textualDrawArea - a pessimistic, but always true, area that covers all pixels
	    since we have no concrete information on this, we'll just make it something like 2x textualArea - or more
	 */
	var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(125), __webpack_require__(137)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Foundation, Atomic, Canvas) {
	  var BaseObject, TextLayoutFragment, inspect, log, point, point0, rect;
	  point = Atomic.point, rect = Atomic.rect, point0 = Atomic.point0;
	  log = Foundation.log, BaseObject = Foundation.BaseObject, inspect = Foundation.inspect;
	  return TextLayoutFragment = (function(superClass) {
	    extend(TextLayoutFragment, superClass);

	    function TextLayoutFragment(text, font, ascender, descender, textOffsetX, textOffsetY, layoutW, layoutH, drawAreaX, drawAreaY, drawAreaW, drawAreaH) {
	      this.text = text;
	      this.font = font;
	      this.ascender = ascender;
	      this.descender = descender;
	      this.textOffsetX = textOffsetX;
	      this.textOffsetY = textOffsetY;
	      this.layoutW = layoutW;
	      this.layoutH = layoutH;
	      this.drawAreaX = drawAreaX;
	      this.drawAreaY = drawAreaY;
	      this.drawAreaW = drawAreaW;
	      this.drawAreaH = drawAreaH;
	      this.layoutX = this.layoutY = 0;
	      this.alignmentOffsetX = 0;
	      this.alignmentOffsetY = 0;
	    }

	    TextLayoutFragment.prototype.toString = function() {
	      return inspect(this.toPlainObject());
	    };

	    TextLayoutFragment.prototype.mul = function(x) {
	      return new TextLayoutFragment(this.text, this.font, x * this.ascender, x * this.descender, x * this.textOffsetX, x * this.textOffsetY, x * this.layoutW, x * this.layoutH, x * this.drawAreaX, x * this.drawAreaY, x * this.drawAreaW, x * this.drawAreaH);
	    };

	    TextLayoutFragment.prototype.toPlainObject = function() {
	      return {
	        text: this.text,
	        font: this.font,
	        ascender: this.ascender,
	        descender: this.descender,
	        textOffsetX: this.textOffsetX,
	        textOffsetY: this.textOffsetY,
	        layoutX: this.layoutX,
	        layoutY: this.layoutY,
	        layoutW: this.layoutW,
	        layoutH: this.layoutH,
	        drawAreaX: this.drawAreaX,
	        drawAreaY: this.drawAreaY,
	        drawAreaW: this.drawAreaW,
	        drawAreaH: this.drawAreaH,
	        alignmentOffsetX: this.alignmentOffsetX,
	        alignmentOffsetY: this.alignmentOffsetY
	      };
	    };

	    TextLayoutFragment.prototype.clone = function() {
	      return new TextLayoutFragment(this.text, this.font, this.ascender, this.descender, this.textOffsetX, this.textOffsetY, this.layoutW, this.layoutH, this.drawAreaX, this.drawAreaY, this.drawAreaW, this.drawAreaH);
	    };

	    TextLayoutFragment.prototype.move = function(x, y) {
	      this.moveX(x);
	      return this.moveY(y);
	    };

	    TextLayoutFragment.prototype.moveX = function(x) {
	      this.layoutX += x;
	      return this.drawAreaX += x;
	    };

	    TextLayoutFragment.prototype.moveY = function(y) {
	      this.layoutY += y;
	      return this.drawAreaY += y;
	    };

	    TextLayoutFragment.prototype.setLayoutLocationFrom = function(fragment) {
	      this.layoutX = fragment.layoutX;
	      return this.layoutY = fragment.layoutY;
	    };

	    TextLayoutFragment.getter({
	      left: function() {
	        return this.getAlignedLayoutX();
	      },
	      top: function() {
	        return this.getAlignedLayoutY();
	      },
	      bottom: function() {
	        return this.getAlignedLayoutY() + this.layoutH;
	      },
	      right: function() {
	        return this.getAlignedLayoutX() + this.layoutW;
	      },
	      alignedLayoutX: function() {
	        return this.layoutX + this.alignmentOffsetX;
	      },
	      alignedLayoutY: function() {
	        return this.layoutY + this.alignmentOffsetY;
	      },
	      alignedDrawAreaX: function() {
	        return this.drawAreaX + this.alignmentOffsetX;
	      },
	      alignedDrawAreaY: function() {
	        return this.drawAreaY + this.alignmentOffsetY;
	      },
	      layoutArea: function() {
	        return rect(this.layoutX, this.layoutY, this.layoutW, this.layoutH);
	      },
	      alignedLayoutArea: function() {
	        return rect(this.getAlignedLayoutX(), this.getAlignedLayoutY(), this.layoutW, this.layoutH);
	      },
	      alignedDrawArea: function() {
	        return rect(this.getAlignedDrawAreaX(), this.getAlignedDrawAreaY(), this.drawAreaW, this.drawAreaH);
	      },
	      alignedDrawAreaLeft: function() {
	        return this.getAlignedDrawAreaX();
	      },
	      alignedDrawAreaTop: function() {
	        return this.getAlignedDrawAreaY();
	      },
	      alignedDrawAreaRight: function() {
	        return this.getAlignedDrawAreaX() + this.drawAreaW;
	      },
	      alignedDrawAreaBottom: function() {
	        return this.getAlignedDrawAreaY() + this.drawAreaH;
	      },
	      area: function() {
	        console.error("TextLayoutFragment.area is DEPRICATED. Use: TextLayoutFragment#layoutArea");
	        return rect(this.layoutX - this.textOffsetX, this.layoutY - this.textOffsetY, this.layoutW, this.layoutH);
	      },
	      textX: function() {
	        return this.layoutX + this.textOffsetX + this.alignmentOffsetX;
	      },
	      textY: function() {
	        return this.layoutY + this.textOffsetY + this.alignmentOffsetY;
	      }
	    });

	    return TextLayoutFragment;

	  })(BaseObject);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, FillableBase, Foundation, ShapeElement, Text, createWithPostCreate, isFunction, pureMerge,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Text = __webpack_require__(221);

	FillableBase = __webpack_require__(218);

	pureMerge = Foundation.pureMerge, isFunction = Foundation.isFunction, createWithPostCreate = Foundation.createWithPostCreate;

	module.exports = createWithPostCreate(ShapeElement = (function(superClass) {
	  extend(ShapeElement, superClass);

	  function ShapeElement() {
	    ShapeElement.__super__.constructor.apply(this, arguments);
	    this._lastPathFunction = null;
	    this._curriedPathFunction = null;
	  }

	  ShapeElement.drawProperty({
	    fillRule: {
	      "default": "nonzero",
	      validate: function(r) {
	        return r === "nonzero" || r === "evenodd";
	      }
	    },
	    path: {
	      "default": function(context, size) {
	        var h, w;
	        w = size.w, h = size.h;
	        context.beginPath();
	        context.moveTo(0, 0);
	        context.lineTo(0, h);
	        context.lineTo(w, h);
	        context.lineTo(w, 0);
	        context.lineTo(0, 0);
	        return context.closePath();
	      },
	      validate: function(f) {
	        return isFunction(f);
	      }
	    }
	  });

	  ShapeElement.getter({
	    curriedPathFunction: function() {
	      var pathFunction;
	      pathFunction = this.getPath();
	      if (this._lastPathFunction !== pathFunction) {
	        this._lastPathFunction = pathFunction;
	        return this._curriedPathFunction = (function(_this) {
	          return function(context) {
	            return pathFunction(context, _this.currentSize);
	          };
	        })(this);
	      } else {
	        return this._curriedPathFunction;
	      }
	    }
	  });

	  ShapeElement.prototype.drawBasic = function(target, elementToTargetMatrix, compositeMode, opacity) {
	    this._prepareDrawOptions(this._drawOptions, compositeMode, opacity);
	    return this.fillShape(target, elementToTargetMatrix, this._drawOptions);
	  };

	  ShapeElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
	    options.color || (options.color = this._color);
	    options.fillRule = this._fillRule;
	    return target.fillShape(elementToTargetMatrix, options, this.getCurriedPathFunction());
	  };

	  ShapeElement.prototype.strokeShape = function(target, elementToTargetMatrix, options) {
	    options.color || (options.color = this._color);
	    return target.strokeShape(elementToTargetMatrix, options, this.getCurriedPathFunction());
	  };

	  return ShapeElement;

	})(FillableBase));


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, BaseObject, FillableBase, Foundation, GlobalEpochCycle, Text, TextElement, createWithPostCreate, globalEpochCycle, isNumber, isPlainArray, isString, log, merge, normalizeFontOptions, point, propInternalName, propSetterName, pureMerge, rect, shallowClone,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Text = __webpack_require__(221);

	FillableBase = __webpack_require__(218);

	GlobalEpochCycle = __webpack_require__(201);

	log = Foundation.log, BaseObject = Foundation.BaseObject, shallowClone = Foundation.shallowClone, pureMerge = Foundation.pureMerge, merge = Foundation.merge, createWithPostCreate = Foundation.createWithPostCreate, isPlainArray = Foundation.isPlainArray, isString = Foundation.isString, isNumber = Foundation.isNumber;

	point = Atomic.point, rect = Atomic.rect;

	normalizeFontOptions = Text.Metrics.normalizeFontOptions;

	globalEpochCycle = GlobalEpochCycle.globalEpochCycle;

	propInternalName = BaseObject.propInternalName;

	propSetterName = BaseObject._propSetterName;

	module.exports = createWithPostCreate(TextElement = (function(superClass) {
	  extend(TextElement, superClass);

	  TextElement.prototype.defaultSize = {
	    cs: 1
	  };

	  function TextElement() {
	    TextElement.__super__.constructor.apply(this, arguments);
	    this._textLayout = null;
	  }

	  TextElement.getter({
	    cacheable: function() {
	      return true;
	    }
	  });

	  TextElement.drawLayoutProperty({
	    fontSize: {
	      "default": 16,
	      validate: function(v) {
	        return isNumber(v);
	      }
	    },
	    fontFamily: {
	      "default": "Times",
	      validate: function(v) {
	        return isString(v);
	      }
	    },
	    fontStyle: {
	      "default": "normal",
	      validate: function(v) {
	        return isString(v);
	      }
	    },
	    fontVariant: {
	      "default": "normal",
	      validate: function(v) {
	        return isString(v);
	      }
	    },
	    fontWeight: {
	      "default": "normal",
	      validate: function(v) {
	        return isString(v);
	      }
	    },
	    align: {
	      "default": 0,
	      preprocess: function(v) {
	        return point(v);
	      }
	    },
	    layoutMode: {
	      "default": "textualBaseline",
	      validate: function(v) {
	        return isString(v);
	      }
	    },
	    leading: {
	      "default": 1.25,
	      validate: function(v) {
	        return isNumber(v);
	      }
	    },
	    maxLines: {
	      "default": null,
	      validate: function(v) {
	        return (v == null) || isNumber(v);
	      }
	    },
	    overflow: {
	      "default": "ellipsis",
	      validate: function(v) {
	        return isString(v);
	      }
	    },
	    text: {
	      "default": Text.Layout.defaultText,
	      preprocess: function(t) {
	        if (isPlainArray(t)) {
	          return t.join("\n");
	        } else {
	          return "" + t;
	        }
	      }
	    }
	  });

	  TextElement.virtualProperty({
	    font: {
	      getter: function(pending) {
	        var _fontFamily, _fontSize, _fontStyle, _fontVariant, _fontWeight, ref;
	        ref = this.getState(pending), _fontFamily = ref._fontFamily, _fontSize = ref._fontSize, _fontStyle = ref._fontStyle, _fontVariant = ref._fontVariant, _fontWeight = ref._fontWeight;
	        return {
	          fontFamily: _fontFamily,
	          fontSize: _fontSize,
	          fontStyle: _fontStyle,
	          fontVariant: _fontVariant,
	          fontWeight: _fontWeight
	        };
	      }
	    },
	    format: {
	      getter: function(pending) {
	        var _align, _layoutMode, _leading, _maxLines, _overflow, ref;
	        ref = this.getState(pending), _align = ref._align, _layoutMode = ref._layoutMode, _leading = ref._leading, _maxLines = ref._maxLines, _overflow = ref._overflow;
	        return {
	          align: _align,
	          layoutMode: _layoutMode,
	          leading: _leading,
	          maxLines: _maxLines,
	          overflow: _overflow
	        };
	      }
	    }
	  });

	  TextElement.prototype.getBaseDrawArea = function() {
	    var ref;
	    return ((ref = this._textLayout) != null ? ref.getDrawArea() : void 0) || rect();
	  };

	  TextElement.prototype.getPendingBaseDrawArea = function() {
	    var ref;
	    return ((ref = this._textLayout) != null ? ref.getDrawArea() : void 0) || rect();
	  };

	  TextElement.prototype.customLayoutChildrenFirstPass = function(size) {
	    var ret;
	    ret = null;
	    globalEpochCycle.timePerformance("aimTL", (function(_this) {
	      return function() {
	        _this._textLayout = new Text.Layout(_this.getPendingText(), _this.getPendingFont(), _this.getPendingFormat(), size.x, size.y);
	        return ret = _this._textLayout.getSize();
	      };
	    })(this));
	    return ret;
	  };

	  TextElement.prototype.customLayoutChildrenSecondPass = function(size) {
	    this._textLayout.setWidth(size.x);
	    return this._textLayout.size;
	  };

	  TextElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
	    return this._textLayout.draw(target, elementToTargetMatrix, pureMerge(options, {
	      layoutSize: this.getCurrentSize(),
	      color: (options != null ? options.color : void 0) || this._color
	    }));
	  };

	  TextElement.prototype.strokeShape = function(target, elementToTargetMatrix, options) {
	    return this._textLayout.stroke(target, elementToTargetMatrix, pureMerge(options, {
	      layoutSize: this.getCurrentSize(),
	      color: (options != null ? options.color : void 0) || this._color
	    }));
	  };

	  return TextElement;

	})(FillableBase));


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(233).addModules({
	  BlurElement: __webpack_require__(234),
	  FilterElement: __webpack_require__(235),
	  ShadowElement: __webpack_require__(236)
	});


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	var Elements, Filters,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Elements = __webpack_require__(213);

	module.exports = Elements.Filters || Elements.addNamespace('Filters', Filters = (function(superClass) {
	  extend(Filters, superClass);

	  function Filters() {
	    return Filters.__super__.constructor.apply(this, arguments);
	  }

	  return Filters;

	})(Neptune.Base));


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Atomic, BlurElement, FilterElement, Foundation, defineModule,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	FilterElement = __webpack_require__(235);

	defineModule = Foundation.defineModule;

	defineModule(module, BlurElement = (function(superClass) {
	  extend(BlurElement, superClass);

	  function BlurElement() {
	    return BlurElement.__super__.constructor.apply(this, arguments);
	  }

	  BlurElement.prototype.defaultRadius = 10;

	  BlurElement.prototype.defaultCompositeMode = "replace";

	  BlurElement.prototype.filter = function(elementSpaceTarget, scale) {
	    return elementSpaceTarget.blur(this.radius * scale);
	  };

	  return BlurElement;

	})(FilterElement));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, CoreElementsBase, FilterElement, Foundation, Matrix, createWithPostCreate, isString, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	CoreElementsBase = __webpack_require__(219);

	log = Foundation.log, isString = Foundation.isString, createWithPostCreate = Foundation.createWithPostCreate;

	Matrix = Atomic.Matrix;


	/*
	A FilterElement is any Element with a draw method that takes uses "target's" pixels as input to its own draw computations.

	Ex: Blur and Shadow

	TODO - Fully implelement Blur and Shadow's new semantics:

	  Each has a sourceArea, in parent-space, default: rect @parent.size
	 */

	module.exports = createWithPostCreate(FilterElement = (function(superClass) {
	  extend(FilterElement, superClass);

	  function FilterElement() {
	    return FilterElement.__super__.constructor.apply(this, arguments);
	  }

	  FilterElement.registerWithElementFactory = function() {
	    return this !== FilterElement;
	  };


	  /*
	  SBD 2016-02-25: I don't think filterSource is fully supported for anything other than the direct parent
	    I have tried to make FilterElement fully support it, but
	    I think Core.Element is missing critical features for Elements with distant decendent filters.
	    Lines that mention filterSource in Core.Element are all commented out.
	    Somehow, whenever things change, FilterSources need to get an updated list of their FilterElement decendents.
	    Then methods like Element#_accountForOverdraw can correctly check each FilterElement decendent instead of only children.
	   */

	  FilterElement.drawProperty({
	    filterSource: {
	      "default": null,
	      validate: function(v) {
	        return !v || isString(v);
	      }

	      /*
	      Radius is interpeted by FilterElement as the size of the convolution kernel the filter will apply.
	      I.E. each output pixel can only be based on at most:
	        - all pixels +/- "radius" pixel-units on the X and Y dimensions
	        - I.E. the (2 * radius + 1)-square pixels centered on the output pixel
	       */
	    }
	  });

	  FilterElement.drawAreaProperty({
	    radius: {
	      "default": 0,
	      validate: function(v) {
	        return typeof v === "number";
	      }

	      /*
	      Override this for the "simplest" filter control
	      
	      IN:
	        filterScratchBitmap:
	          at start contains the pixels to be filtered
	      
	        pixelData: is an array of RGBA values extracted from filterScratchBitmap
	          length: 4 * filterScratchBitmap.size.area (RGBA sets)
	      
	        scale: number
	          If the scale is 1, then the filter's currentSize is 1:1 pixels in filterScratchBitmap.
	      
	      NOTE: Convert x, y coordinates to array index:
	        (x, y) -> (@filterScratchBitmap.size.x * y + x) * 4
	       */
	    }
	  });

	  FilterElement.prototype.filterPixelData = function(filterScratchBitmap, pixelData, scale) {
	    return pixelData;
	  };


	  /*
	  override this for "normal" filter control.
	  IN:
	    filterScratchBitmap:
	      at start contains the pixels to be filtered
	  
	    scale: number
	      If the scale is 1, then the filter's currentSize is 1:1 pixels in filterScratchBitmap.
	  
	  OUT: filterScratchBitmap with filter results or new bitmap of the same size
	    NOTE: you can, and should if possible, re-use filterScratchBitmap
	   */

	  FilterElement.prototype.filter = function(filterScratchBitmap, scale) {
	    var imageData;
	    imageData = filterScratchBitmap.getImageData();
	    this.filterPixelData(filterScratchBitmap, imageData.data, scale);
	    filterScratchBitmap.putImageData(imageData);
	    return filterScratchBitmap;
	  };

	  FilterElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
	    var filterTarget, filterTargetToElementMatrix, ref, scale;
	    scale = elementToTargetMatrix.exactScaler;
	    ref = this._filterFilterSource(scale, target), filterTargetToElementMatrix = ref.filterTargetToElementMatrix, filterTarget = ref.filterTarget;
	    return target.drawBitmap(filterTargetToElementMatrix.mul(elementToTargetMatrix), filterTarget, options);
	  };

	  FilterElement.prototype.overDraw = function(proposedTargetSpaceDrawArea, parentToTargetMatrix) {
	    var minimumElementSpaceDrawArea, propsedElementSpaceDrawArea, requiredTargetSpaceDrawArea, targetToElementMatrix;
	    targetToElementMatrix = parentToTargetMatrix.inv.mul(this.parentToElementMatrix);
	    propsedElementSpaceDrawArea = targetToElementMatrix.transformBoundingRect(proposedTargetSpaceDrawArea);
	    minimumElementSpaceDrawArea = propsedElementSpaceDrawArea.grow(this.radius).intersection(this.elementSpaceDrawArea);
	    requiredTargetSpaceDrawArea = parentToTargetMatrix.transformBoundingRect(minimumElementSpaceDrawArea);
	    return proposedTargetSpaceDrawArea.union(requiredTargetSpaceDrawArea);
	  };

	  FilterElement.virtualProperty({
	    baseDrawArea: function(pending) {
	      var _currentSize, _radius, baseDrawArea, ref;
	      ref = this.getState(pending), _currentSize = ref._currentSize, _radius = ref._radius;
	      baseDrawArea = this.getElementSpaceSourceDrawArea(pending);
	      if (this._inverted) {
	        this.filterSourceDrawAreaInElementSpace.unionInto(baseDrawArea);
	      }
	      return baseDrawArea.grow(_radius);
	    }
	  });

	  FilterElement.getter({
	    requiresParentStagingBitmap: function() {
	      return true;
	    },
	    isFilter: function() {
	      return true;
	    }
	  });


	  /*
	  IN:
	    pending: if true, use pending data
	    returnChild: see OUT
	  
	  OUT: if returnChild
	      the child of FilterSourceElement which is @ or an ancestor of @
	    else
	      FilterSourceElement
	   */

	  FilterElement.prototype._getFilterSourceElement = function(pending, returnChild) {
	    var c, filterSource, p, state;
	    state = this.getState(pending);
	    if (filterSource = state._filterSource) {
	      p = state._parent;
	      c = this;
	      while (p && p.name !== filterSource) {
	        c = p;
	        p = p.getState(pending)._parent;
	      }
	      if (p) {
	        if (returnChild) {
	          return c;
	        } else {
	          return p;
	        }
	      }
	      console.warn(this.inspectedName + ": no ancestor's name matches filterSource:" + (inspect(filterSource)));
	    }
	    if (returnChild) {
	      return this;
	    } else {
	      return state._parent;
	    }
	  };


	  /*
	  Can only be called when filterSource._currentToTargetMatrix is valid.
	  I.E. in the middle of a draw cycle.
	   */

	  FilterElement.prototype._filterFilterSource = function(scale, bitmapFactory) {
	    var elementSpaceDrawArea, elementToFilterScratchMatrix, filterScratch, filterSource, filterSourceTargetToFilterScratchMatrix;
	    filterSource = this.getFilterSourceElement();
	    elementSpaceDrawArea = this.getElementSpaceDrawArea();
	    elementToFilterScratchMatrix = Matrix.translate(elementSpaceDrawArea.location.neg.add(this.radius)).scale(scale);
	    filterSourceTargetToFilterScratchMatrix = filterSource._currentToTargetMatrix.inv.scale(this.getFilterSourceSizeRatio()).mul(elementToFilterScratchMatrix);
	    filterScratch = bitmapFactory.newBitmap(elementSpaceDrawArea.size.add(this.radius * 2).mul(scale)).drawBitmap(filterSourceTargetToFilterScratchMatrix, filterSource._currentDrawTarget);
	    return {
	      filterTargetToElementMatrix: elementToFilterScratchMatrix.inv,
	      filterTarget: this.filter(filterScratch, scale)
	    };
	  };

	  FilterElement.virtualProperty({
	    filterSourceDrawArea: function(pending) {
	      var filterSourceChildElement, filterSourceElement;
	      filterSourceElement = this.getFilterSourceElement(pending);
	      filterSourceChildElement = this.getFilterSourceChildElement(pending);
	      return filterSourceElement._computeElementSpaceDrawArea(filterSourceChildElement);
	    },
	    filterSourceSize: function(pending) {
	      return this.getFilterSourceElement(pending).getCurrentSize(pending);
	    },
	    filterSourceSizeRatio: function(pending) {
	      var _currentSize, filterSourceSize;
	      _currentSize = this.getState(pending)._currentSize;
	      filterSourceSize = this.getFilterSourceSize(pending);
	      if (_currentSize.eq(filterSourceSize)) {
	        return 1;
	      } else {
	        return _currentSize.div(filterSourceSize);
	      }
	    },
	    elementSpaceSourceDrawArea: function(pending) {
	      return this.getFilterSourceDrawArea(pending).mul(this.getFilterSourceSizeRatio(pending));
	    },
	    filterSourceElement: function(pending) {
	      return this._getFilterSourceElement(pending);
	    },
	    filterSourceChildElement: function(pending) {
	      return this._getFilterSourceElement(pending, true);
	    },
	    filterSourceDrawAreaInElementSpace: function(pending) {
	      return this.getFilterSourceElement(pending).getElementToElementMatrix(this).transformBoundingRect(this.getFilterSourceDrawArea(pending));
	    }
	  });

	  return FilterElement;

	})(CoreElementsBase));


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, FilterElement, Foundation, ShadowElement, createWithPostCreate, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	FilterElement = __webpack_require__(235);

	createWithPostCreate = Foundation.createWithPostCreate, log = Foundation.log;

	module.exports = createWithPostCreate(ShadowElement = (function(superClass) {
	  extend(ShadowElement, superClass);

	  function ShadowElement() {
	    return ShadowElement.__super__.constructor.apply(this, arguments);
	  }

	  ShadowElement.prototype.defaultCompositeMode = "destOver";

	  ShadowElement.drawProperty({
	    inverted: {
	      "default": false
	    }
	  });

	  ShadowElement.prototype.filter = function(elementSpaceTarget, scale) {
	    elementSpaceTarget.blurAlpha(this._radius * scale, {
	      inverted: this.inverted
	    });
	    return elementSpaceTarget.drawRectangle(null, elementSpaceTarget.size, {
	      color: this._color,
	      compositeMode: "targetAlphaMask"
	    });
	  };


	  /*
	  NOTES
	    Okay, we have two options:
	  
	    a) we override fillShape here:
	      we render to a stagingBitmap in element-space, but with borders expanded sufficiently
	      Then we have to "fill" those borders with @_color after the filtered data has been provided.
	  
	    b) we hook it into the filter processes itself and pre-enlarge the filter-source bitmap to be large enough
	      to include the extra pixels we need. This means more filter work which isn't necessary.
	   */

	  return ShadowElement;

	})(FilterElement));


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(238).addModules({
	  PagingScrollElementWip: __webpack_require__(239),
	  PagingScrollElement: __webpack_require__(240)
	});


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var Elements, Widgets,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Elements = __webpack_require__(213);

	module.exports = Elements.Widgets || Elements.addNamespace('Widgets', Widgets = (function(superClass) {
	  extend(Widgets, superClass);

	  function Widgets() {
	    return Widgets.__super__.constructor.apply(this, arguments);
	  }

	  return Widgets;

	})(Neptune.Base));


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	var AnimatorSupport, Atomic, BaseModule, BaseObject, Element, EventEpoch, Foundation, GestureRecognizer, Matrix, PagingScrollElementWip, Point, Rectangle, ScrollAnimator, abs, absGt, absGte, absLt, absLte, animatorSpringConstant, animatorSpringFriction, bound, brakingFactor, ceil, createGestureRecognizer, createWithPostCreate, crossScrollProperties, currentSecond, eventEpoch, first, flickSpeedMultiplier, formattedInspect, inspect, isPlainArray, isPoint, last, log, matrix, max, maxChange, maxMagnitude, merge, min, minMagnitude, minimumFlickVelocity, neq, peek, point, point0, pointNearInfinity, rect, requestAnimationFrame, round, scrollProperties, timeout,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	EventEpoch = __webpack_require__(168).EventEpoch;

	Element = __webpack_require__(184);

	GestureRecognizer = __webpack_require__(165);

	log = Foundation.log, inspect = Foundation.inspect, currentSecond = Foundation.currentSecond, bound = Foundation.bound, round = Foundation.round, first = Foundation.first, last = Foundation.last, peek = Foundation.peek, min = Foundation.min, max = Foundation.max, abs = Foundation.abs, merge = Foundation.merge, createWithPostCreate = Foundation.createWithPostCreate, BaseObject = Foundation.BaseObject, timeout = Foundation.timeout, ceil = Foundation.ceil, round = Foundation.round, isPlainArray = Foundation.isPlainArray, BaseModule = Foundation.BaseModule, absLt = Foundation.absLt, absLte = Foundation.absLte, absGt = Foundation.absGt, absGte = Foundation.absGte, minMagnitude = Foundation.minMagnitude, maxMagnitude = Foundation.maxMagnitude, maxChange = Foundation.maxChange, absLt = Foundation.absLt, requestAnimationFrame = Foundation.requestAnimationFrame, formattedInspect = Foundation.formattedInspect, neq = Foundation.neq;

	point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix, isPoint = Atomic.isPoint;

	point0 = Point.point0, pointNearInfinity = Point.pointNearInfinity;

	eventEpoch = EventEpoch.eventEpoch;

	createGestureRecognizer = GestureRecognizer.createGestureRecognizer;

	scrollProperties = {
	  vertical: "y",
	  horizontal: "x"
	};

	crossScrollProperties = {
	  vertical: "x",
	  horizontal: "y"
	};

	brakingFactor = 3;

	minimumFlickVelocity = 300;

	animatorSpringConstant = 300;

	animatorSpringFriction = 25;

	flickSpeedMultiplier = 1;


	/*
	PagingScrollElement

	guarantee:
	  Will never scroll more than one "windowSize" per frame.
	  That means you need at least as many "pages" as it will take to display one more window-full of content
	  above or below the current displayed content.

	margins:
	  Margins on paging elements are currently not supported.
	  We could relatively easilly support constant margins.
	  Anything more complex gets a little tedious.
	  Recomendation: Use Padding instead of Margins.

	events:
	  currentPageChanged:
	    oldCurrentPage: element
	    currentPage:    element
	  scrollUpdate:
	    currentPage:          element           - @currentPage
	    currentGeometry:      plain object      - @currentGeometry
	    pagesBeforeBaseline:  array of elements - @pagesBeforeBaseline
	    pagesAfterBaseline:   array of elements - @pagesAfterBaseline

	naming:

	  All "positions" are scalers.
	  All "positions" are relative to the top/left of the PagingScrollElement.
	  Positive values indicate more to the bottom/right of the PagingScrollElement.

	  "scrollPosition" is the main geometry value for the PagingScrollElement.

	  I chose "scrollPosition" over just "position" or "location".
	  location vs position: http://www.eng-tips.com/viewthread.cfm?qid=180516
	    position can be used to refer to internal configuration, which scrollPosition is,
	    but location cannot. This avoids confusion with Element's currentLocations.

	Implementation Notes:

	  When to use "pending" property values:
	    - use pending values only as inputs to computation that results in setting another property
	    - use current (non-pending) poperty values for all getters
	 */


	/*
	ScrollAnimator

	scrollElement api:
	  @getter
	    minScrollPosition:
	    maxScrollPosition:
	    scrollPosition:

	  @setter
	    scrollPosition: (scrollPosition) ->

	onIdle is called when all animations and gestures have stopped.
	 */

	ScrollAnimator = (function(superClass1) {
	  var frameCount, missCount;

	  extend(ScrollAnimator, superClass1);

	  function ScrollAnimator(scrollElement, maximumVelocity1) {
	    this.scrollElement = scrollElement;
	    this.maximumVelocity = maximumVelocity1;
	    ScrollAnimator.__super__.constructor.apply(this, arguments);
	    this._referenceFrame = this.scrollElement.getPendingReferenceFrame();
	    this._velocity = 0;
	    this._mode = "tracking";

	    /*
	    modes:
	      braking:      friction only
	      spring:       spring
	      tracking:     direct tracking, no physics
	     */
	  }

	  ScrollAnimator.getter("desiredScrollPosition", {
	    mode: function() {
	      return this._mode;
	    },
	    minScrollPosition: function() {
	      return this.scrollElement.getMinScrollPositionInReferenceFrame(this._referenceFrame);
	    },
	    maxScrollPosition: function() {
	      return this.scrollElement.getMaxScrollPositionInReferenceFrame(this._referenceFrame);
	    },
	    scrollPosition: function() {
	      return this.scrollElement.getScrollPositionInReferenceFrame(this._referenceFrame);
	    },
	    animationDone: function() {
	      switch (this.mode) {
	        case "spring":
	          return this.velocityIsSlow() && this._desiredScrollPosition === this.getScrollPosition();
	        case "braking":
	          return this.velocityIsSlow();
	        default:
	          return !this._activeTouch;
	      }
	    },
	    animationContinues: function() {
	      return !this.getAnimationDone();
	    }
	  });

	  ScrollAnimator.setter("desiredScrollPosition", {
	    mode: function(v) {
	      return this._mode = v;
	    },
	    referenceFrame: function(v) {
	      return this._referenceFrame = v;
	    },
	    scrollPosition: function(l) {
	      return this.scrollElement.setScrollPositionInReferenceFrame(round(l), this._referenceFrame);
	    },
	    activeTouch: function(v) {
	      if (!(this._activeTouch = !!v)) {
	        this.mode = "spring";
	        return this._desiredScrollPosition = this.boundLocation(this._desiredScrollPosition);
	      }
	    }
	  });

	  ScrollAnimator.prototype.addToDesiredScrollPosition = function(delta) {
	    return this._desiredScrollPosition += delta;
	  };

	  ScrollAnimator.prototype.animateToLocation = function(desiredScrollPosition) {
	    this.mode = "spring";
	    return this._desiredScrollPosition = desiredScrollPosition;
	  };

	  ScrollAnimator.prototype.boundLocation = function(scrollPosition) {
	    return bound(this.getMinScrollPosition(), scrollPosition, this.getMaxScrollPosition());
	  };

	  ScrollAnimator.prototype.startTracking = function(desiredScrollPosition, referenceFrame) {
	    this._referenceFrame = referenceFrame;
	    this.mode = "tracking";
	    this._velocity = 0;
	    this.setDesiredScrollPosition(desiredScrollPosition);
	    return this._activeTouch = true;
	  };

	  ScrollAnimator.prototype.addVelocity = function(v) {
	    this._velocity = v;
	    return this.mode = "braking";
	  };

	  ScrollAnimator.prototype.velocityIsSlow = function() {
	    return absLte(this._velocity, 60);
	  };

	  frameCount = 0;

	  missCount = 0;

	  ScrollAnimator.prototype.frameUpdate = function(frameTime) {
	    var acceleration, boundedLocation, boundedTargetLocation, currentToTargetVector, distanceSquared, frictionAcceleration, frictionConstant, maxBeyond, maxV, minV, scrollPosition, springAcceleration, springConstant, targetScrollPosition, tookFrames, windowSize;
	    tookFrames = Math.round(frameTime * 60);
	    frameCount++;
	    if (absLt(frameTime * 60 - 1, .25)) {

	    } else {
	      if (tookFrames > 1) {
	        missCount++;
	      }
	    }
	    scrollPosition = this.getScrollPosition();
	    targetScrollPosition = this._desiredScrollPosition;
	    this._velocity = maxMagnitude(this._velocity, this.maximumVelocity);
	    switch (this._mode) {
	      case "tracking":
	        windowSize = this.scrollElement.windowSize;
	        boundedTargetLocation = this.boundLocation(targetScrollPosition);
	        maxBeyond = windowSize / 3;
	        minV = min(boundedTargetLocation, targetScrollPosition);
	        maxV = max(boundedTargetLocation, targetScrollPosition);
	        targetScrollPosition = bound(minV, boundedTargetLocation + Math.atan((targetScrollPosition - boundedTargetLocation) / maxBeyond) * (2 / Math.PI) * maxBeyond, maxV);
	        this._velocity = 0;
	        this.setScrollPosition(targetScrollPosition);
	        break;
	      case "braking":
	        this._activeTouch = false;
	        frictionConstant = brakingFactor;
	        frictionAcceleration = this._velocity * -frictionConstant;
	        acceleration = frictionAcceleration;
	        this._velocity += acceleration * frameTime;
	        scrollPosition = scrollPosition + this._velocity * frameTime;
	        this.setScrollPosition(scrollPosition);
	        if (scrollPosition !== (boundedLocation = this.boundLocation(scrollPosition))) {
	          this.mode = "spring";
	          this._desiredScrollPosition = boundedLocation;
	        }
	        break;
	      case "spring":
	        currentToTargetVector = targetScrollPosition - scrollPosition;
	        distanceSquared = currentToTargetVector * currentToTargetVector;
	        springConstant = animatorSpringConstant;
	        frictionConstant = animatorSpringFriction;
	        springAcceleration = currentToTargetVector * springConstant;
	        frictionAcceleration = this._velocity * -frictionConstant;
	        acceleration = springAcceleration + frictionAcceleration;
	        this._velocity = this._velocity + acceleration * frameTime;
	        this.setScrollPosition(this.velocityIsSlow() && abs(scrollPosition - targetScrollPosition) <= 1 ? targetScrollPosition : scrollPosition + minMagnitude(this._velocity * frameTime, 1));
	    }
	    if (!this.getAnimationContinues()) {
	      log("frameUpdate " + this._mode + ": DONE (miss rate: " + missCount + " / " + frameCount + ")");
	    }
	    return this.getAnimationContinues();
	  };

	  return ScrollAnimator;

	})(BaseObject);

	AnimatorSupport = function(superClass) {
	  return AnimatorSupport = (function(superClass1) {
	    extend(AnimatorSupport, superClass1);

	    function AnimatorSupport() {
	      return AnimatorSupport.__super__.constructor.apply(this, arguments);
	    }

	    AnimatorSupport.getter({
	      animatorsActive: function() {
	        return !!this._activeAnimators;
	      }
	    });

	    AnimatorSupport.prototype.initAnimatorSupport = function() {
	      this._lastTime = 0;
	      this._activeAnimators = null;
	      return this._frameUpdateQueued = false;
	    };

	    AnimatorSupport.prototype.startAnimator = function(animator) {
	      if (this.getAnimatorsActive()) {
	        this._activeAnimators.push(animator);
	      } else {
	        this._activeAnimators = [animator];
	        this._lastTime = currentSecond();
	        this.getAnimatorsActive();
	      }
	      this._startAnimatorLoop();
	      return animator;
	    };


	    /*
	    OUT: newAnimator
	    SIDE-EFFECT:
	      if oldAnimator is in @_activeAnimators
	      then: replaced it with newAnimator
	      else: @startAnimator newAnimator
	    
	    POST ASSERTIONS
	      newAnimator is in @_activeAnimators
	      oldAnimator is NOT in @_activeAnimators
	     */

	    AnimatorSupport.prototype.replaceAnimator = function(newAnimator, oldAnimator) {
	      var index;
	      if (!(this._activeAnimators && oldAnimator)) {
	        return this.startAnimator(newAnimator);
	      }
	      index = this._activeAnimators.indexOf(oldAnimator);
	      if (!(index >= 0)) {
	        return this.startAnimator(newAnimator);
	      }
	      return this._activeAnimators[index] = newAnimator;
	    };

	    AnimatorSupport.prototype.stopAllAnimators = function() {
	      return this._activeAnimators = null;
	    };

	    AnimatorSupport.prototype._frameUpdate = function(frameTime) {
	      var animator, i, j, len, nextAnimators, now, ref;
	      if (!this._activeAnimators) {
	        return;
	      }
	      now = frameTime;
	      frameTime = now - this._lastTime;
	      nextAnimators = null;
	      ref = this._activeAnimators;
	      for (i = j = 0, len = ref.length; j < len; i = ++j) {
	        animator = ref[i];
	        if (animator.frameUpdate(frameTime)) {
	          if (nextAnimators != null) {
	            nextAnimators.push(animator);
	          }
	        } else {
	          this.queueEvent("animatorDone", {
	            animator: animator
	          });
	          nextAnimators || (nextAnimators = this._activeAnimators.slice(0, i));
	        }
	      }
	      if (nextAnimators) {
	        if (nextAnimators.length === 0) {
	          this._activeAnimators = null;
	          this.queueEvent("allAnimatorsDone");
	        } else {
	          this._activeAnimators = nextAnimators;
	        }
	      }
	      return this._lastTime = now;
	    };

	    AnimatorSupport.prototype._startAnimatorLoop = function() {
	      if (this._frameUpdateQueued) {
	        return;
	      }
	      return requestAnimationFrame((function(_this) {
	        return function(frameTimeMs) {
	          var queueNextFrameUpdate;
	          _this._lastTime = frameTimeMs / 1000;
	          queueNextFrameUpdate = function() {
	            if (!_this.getAnimatorsActive()) {
	              return;
	            }
	            _this._frameUpdateQueued = true;
	            return requestAnimationFrame(function(frameTimeMs) {
	              _this._frameUpdateQueued = false;
	              _this._frameUpdate(frameTimeMs / 1000);
	              return queueNextFrameUpdate();
	            });
	          };
	          return queueNextFrameUpdate();
	        };
	      })(this));
	    };

	    return AnimatorSupport;

	  })(superClass);
	};

	module.exports = createWithPostCreate(PagingScrollElementWip = (function(superClass1) {
	  var defaultReferenceFrame;

	  extend(PagingScrollElementWip, superClass1);

	  function PagingScrollElementWip() {
	    this.initAnimatorSupport();
	    this._initGestureProps();
	    this._pages = null;
	    this._currentPage = null;
	    this._atEnd = false;
	    this._atStart = true;
	    this._scrollPositionRelativeToChildrenAlignment = false;
	    this._scrollContents = this._pagesBeforeBaselineWrapper = this._pagesAfterBaselineWrapper = null;
	    this._setVerticalAxis();
	    PagingScrollElementWip.__super__.constructor.apply(this, arguments);
	    self.pagingScrollElement = this;
	    this._updateHiddenChildren();
	  }

	  PagingScrollElementWip.prototype.preprocessEventHandlers = function(handlerMap) {
	    return merge(this._externalHandlerMap = handlerMap, {
	      mouseWheel: (function(_this) {
	        return function(event) {
	          var horizontal, position, scrollValue, windowSize;
	          _this._mostRecentMouseWheelEvent = event;
	          windowSize = _this.windowSize;
	          scrollValue = (horizontal = _this.scroll === "horizontal") ? event.props.deltaX || 0 : event.props.deltaY || 0;
	          switch (event.props.deltaMode) {
	            case "line":
	              scrollValue *= 16;
	              break;
	            case "page":
	              scrollValue *= windowSize * .75;
	          }
	          if (!_this.getActiveScrollAnimator()) {
	            _this.startScrollAnimatorTracking();
	          }
	          scrollValue = bound(-windowSize, -scrollValue, windowSize);
	          position = _this.getScrollAnimator().desiredScrollPosition + scrollValue;
	          _this.getScrollAnimator().desiredScrollPosition = bound(_this.getScrollAnimator().minScrollPosition, position, _this.getScrollAnimator().maxScrollPosition);
	          return timeout(100).then(function() {
	            if (_this._mostRecentMouseWheelEvent !== event) {
	              return;
	            }
	            return _this.endScrollAnimatorTracking();
	          });
	        };
	      })(this),
	      animatorDone: (function(_this) {
	        return function(arg) {
	          var animator, props;
	          props = arg.props;
	          animator = props.animator;
	          if (animator === _this._scrollAnimator) {
	            return _this._scrollAnimator = null;
	          }
	        };
	      })(this)
	    }, createGestureRecognizer({
	      custom: {
	        resume: this.gestureResume.bind(this),
	        recognize: this.gestureRecognize.bind(this),
	        begin: this.gestureBegin.bind(this),
	        move: this.gestureMove.bind(this),
	        end: this.gestureEnd.bind(this)
	      }
	    }));
	  };

	  PagingScrollElementWip.prototype._setVerticalAxis = function() {
	    this.newPoint = function(mainV, crossV) {
	      if (crossV == null) {
	        crossV = 0;
	      }
	      return point(crossV, mainV);
	    };
	    this.getPagePosition = function(page) {
	      return (page != null ? page.transformToAncestorSpaceY(0, this) : void 0) || 0;
	    };
	    return this.getMainCoordinate = function(pnt) {
	      return pnt.y;
	    };
	  };

	  PagingScrollElementWip.prototype._setHorizontalAxis = function() {
	    this.newPoint = function(mainV, crossV) {
	      if (crossV == null) {
	        crossV = 0;
	      }
	      return point(mainV, crossV);
	    };
	    this.getPagePosition = function(page) {
	      return (page != null ? page.transformToAncestorSpaceX(0, this) : void 0) || 0;
	    };
	    return this.getMainCoordinate = function(pnt) {
	      return pnt.x;
	    };
	  };

	  PagingScrollElementWip.prototype.getPageSize = function(page) {
	    if (!page) {
	      return 0;
	    } else {
	      return this.getMainCoordinate(page.getCurrentSize());
	    }
	  };

	  PagingScrollElementWip.prototype.getPageEdgeOffset = function(arg) {
	    var atEndEdge, page;
	    page = arg.page, atEndEdge = arg.atEndEdge;
	    if (atEndEdge) {
	      return this.getPageSize(page);
	    } else {
	      return 0;
	    }
	  };

	  PagingScrollElementWip.prototype.getPageCenter = function(page) {
	    return this.getPagePosition(page) + this.getPageSize(page) / 2;
	  };

	  defaultReferenceFrame = {
	    page: null,
	    atEndEdge: false
	  };

	  PagingScrollElementWip.concreteProperty({
	    referenceFrame: {
	      "default": defaultReferenceFrame,
	      postSetter: function(newReferenceFrame, previousReferenceFrame) {
	        var delta;
	        if (newReferenceFrame === previousReferenceFrame) {
	          console.warn("referenceFrame_postSetter - frame didnt' change");
	        }
	        this._addToScrollPosition(delta = this.getReferenceFrameDelta(newReferenceFrame, previousReferenceFrame));
	        this._updatePointerReferenceFrame(newReferenceFrame);
	        this._queueUpdateEvent(newReferenceFrame, previousReferenceFrame);
	        return this._updatePagesSplit();
	      }
	    },
	    pages: {
	      "default": [],
	      validate: function(pages) {
	        return isPlainArray(pages);
	      },
	      postSetter: function(pages, oldPages) {
	        var atEndEdge, page, ref, referenceFrame;
	        ref = referenceFrame = this.getPendingReferenceFrame(), page = ref.page, atEndEdge = ref.atEndEdge;
	        if (this._atEnd) {
	          atEndEdge = true;
	          page = last(pages);
	        }
	        if (this._atStart || !page) {
	          atEndEdge = false;
	          page = first(pages);
	        }
	        if (referenceFrame.page && 0 > pages.indexOf(referenceFrame.page)) {
	          console.warn("PagingScrollElement#pages setter: New page list does not contain the current referenceFrame. ALWAYS include the current referenceFrame when setting pages. Screen will jump!\n\npage keys: " + (inspect((function() {
	            var j, len, results;
	            results = [];
	            for (j = 0, len = pages.length; j < len; j++) {
	              page = pages[j];
	              results.push(page.key);
	            }
	            return results;
	          })())));
	        }
	        if (referenceFrame.page !== page || referenceFrame.atEndEdge !== atEndEdge) {
	          this.setReferenceFrame({
	            page: page,
	            atEndEdge: atEndEdge
	          });
	        } else {
	          this._updatePagesSplit();
	        }
	        if (oldPages.length > 0) {
	          return this.onNextReady((function(_this) {
	            return function() {
	              return _this._updateAtStartAndAtEnd();
	            };
	          })(this));
	        }
	      }
	    },
	    scrollPosition: {
	      "default": 0,
	      postSetter: function(position) {
	        this.onNextReady((function(_this) {
	          return function() {
	            return _this._updateAtStartAndAtEnd();
	          };
	        })(this));
	        return this._setScrollContentsLocation(position);
	      }
	    }
	  });

	  PagingScrollElementWip.prototype._updatePagesSplit = function(pages, referenceFrame) {
	    var atEndEdge, page, splitIndex;
	    if (pages == null) {
	      pages = this.getPendingPages();
	    }
	    if (referenceFrame == null) {
	      referenceFrame = this.getPendingReferenceFrame();
	    }
	    page = referenceFrame.page, atEndEdge = referenceFrame.atEndEdge;
	    splitIndex = pages.indexOf(page);
	    if (splitIndex < 0) {
	      if (page) {
	        console.warn("PagingScrollElement#_updatePagesSplit: could not find the old referenceFrame.page(key: " + (page.key || page.inspectedName) + ") in the new children. New current page picked; display WILL jump.");
	      }
	      splitIndex = 0;
	    }
	    if (atEndEdge) {
	      splitIndex++;
	    }
	    this._pagesBeforeBaselineWrapper.setChildren(pages.slice(0, splitIndex));
	    return this._pagesAfterBaselineWrapper.setChildren(pages.slice(splitIndex));
	  };

	  PagingScrollElementWip.layoutProperty({
	    scroll: {
	      "default": "vertical",
	      validate: function(v) {
	        return v === "vertical" || v === "horizontal";
	      },
	      postSetter: function(newV, oldValue) {
	        if (newV === "vertical") {
	          this._setVerticalAxis();
	        } else {
	          this._setHorizontalAxis();
	        }
	        return this._updateHiddenChildren(newV);
	      }
	    }
	  });

	  PagingScrollElementWip.prototype.getReferenceFrameDelta = function(toReferenceFrame, fromReferenceFrame) {
	    var edgeDelta, positionDelta;
	    if (toReferenceFrame == null) {
	      toReferenceFrame = defaultReferenceFrame;
	    }
	    if (fromReferenceFrame == null) {
	      fromReferenceFrame = defaultReferenceFrame;
	    }
	    if (toReferenceFrame === fromReferenceFrame) {
	      return 0;
	    }
	    positionDelta = toReferenceFrame.page === fromReferenceFrame.page ? 0 : this.getPagePosition(toReferenceFrame.page) - this.getPagePosition(fromReferenceFrame.page);
	    edgeDelta = this.getPageEdgeOffset(toReferenceFrame) - this.getPageEdgeOffset(fromReferenceFrame);
	    return positionDelta + edgeDelta;
	  };

	  PagingScrollElementWip.prototype.getScrollPositionInReferenceFrame = function(targetReferenceFrame) {
	    return this.getScrollPosition() + this.getReferenceFrameDelta(targetReferenceFrame, this.getReferenceFrame());
	  };

	  PagingScrollElementWip.prototype.setScrollPositionInReferenceFrame = function(scrollPosition, referenceFrame) {
	    var pendingReferenceFrame;
	    if (referenceFrame == null) {
	      referenceFrame = this.getPendingReferenceFrame();
	    }
	    this.onNextReady((function(_this) {
	      return function() {
	        return _this._updateReferenceFrame();
	      };
	    })(this));
	    pendingReferenceFrame = this.getPendingReferenceFrame();
	    scrollPosition += this.getReferenceFrameDelta(pendingReferenceFrame, referenceFrame);
	    return this.setScrollPosition(scrollPosition);
	  };

	  PagingScrollElementWip.getter({
	    minScrollPosition: function() {
	      return this.getMinScrollPositionInReferenceFrame(this.getReferenceFrame());
	    },
	    maxScrollPosition: function() {
	      return this.getMaxScrollPositionInReferenceFrame(this.getReferenceFrame());
	    },
	    boundedScrollPosition: function() {
	      return bound(this.getMinScrollPosition(), this.getScrollPosition(), this.getMaxScrollPosition());
	    }
	  });

	  PagingScrollElementWip.prototype.getMinScrollPositionInReferenceFrame = function(referenceFrame) {
	    var afterSize, beforeSize, windowSize;
	    windowSize = this.getWindowSize();
	    beforeSize = this.getPagesBeforeBaselineSize();
	    afterSize = this.getPagesAfterBaselineSize();
	    if (beforeSize + afterSize <= windowSize) {
	      return 0;
	    }
	    return windowSize - afterSize + this.getReferenceFrameDelta(referenceFrame, this.getReferenceFrame());
	  };

	  PagingScrollElementWip.prototype.getMaxScrollPositionInReferenceFrame = function(referenceFrame) {
	    var afterSize, beforeSize, delta, windowSize;
	    windowSize = this.getWindowSize();
	    beforeSize = this.getPagesBeforeBaselineSize();
	    afterSize = this.getPagesAfterBaselineSize();
	    delta = this.getReferenceFrameDelta(referenceFrame, this.getReferenceFrame());
	    if (beforeSize + afterSize <= windowSize) {
	      return 0;
	    }
	    return beforeSize + delta;
	  };

	  PagingScrollElementWip.prototype.jumpToStart = function() {
	    return this.setScrollPositionInReferenceFrame(0, {
	      page: first(this.getPendingPages()),
	      atEndEdge: false
	    });
	  };

	  PagingScrollElementWip.prototype.jumpToEnd = function() {
	    if (this.getPagesFitInWindow()) {
	      return this.jumpToStart();
	    } else {
	      return this.setScrollPositionInReferenceFrame(this.getWindowSize(), {
	        page: last(this.getPendingPages()),
	        atEndEdge: true
	      });
	    }
	  };

	  PagingScrollElementWip.getter({
	    atEnd: function() {
	      return this._atEnd;
	    },
	    atStart: function() {
	      return this._atStart;
	    },
	    inMiddle: function() {
	      return !this._atEnd && !this._atStart;
	    },
	    pagesFitInWindow: function() {
	      return this.getWindowSize() >= this.getTotalPageSize();
	    },
	    windowSize: function() {
	      return this.getMainCoordinate(this.getCurrentSize());
	    },
	    currentPagePosition: function() {
	      return this.getMainCoordinate(this._scrollContents.getPendingCurrentLocation());
	    },
	    pagesBeforeBaselineSize: function() {
	      return this.getMainCoordinate(this._pagesBeforeBaselineWrapper.getPendingCurrentSize());
	    },
	    pagesAfterBaselineSize: function() {
	      return this.getMainCoordinate(this._pagesAfterBaselineWrapper.getPendingCurrentSize());
	    },
	    pagesBeforeBaseline: function() {
	      return this._pagesBeforeBaselineWrapper.getChildren();
	    },
	    pagesAfterBaseline: function() {
	      return this._pagesAfterBaselineWrapper.getChildren();
	    },
	    totalPageSize: function() {
	      return this.getPagesBeforeBaselineSize() + this.getPagesAfterBaselineSize();
	    },
	    pagesOnScreenBeforeBaseline: function() {
	      var averagePageSize, count, j, page, pages, pixelsLeft, pixelsOnScreen, ref, totalSize;
	      pixelsOnScreen = this.getScrollPosition();
	      totalSize = 0;
	      count = 0;
	      ref = pages = this._pagesBeforeBaselineWrapper.getChildren();
	      for (j = ref.length - 1; j >= 0; j += -1) {
	        page = ref[j];
	        count++;
	        totalSize += this.getMainCoordinate(page.getCurrentSize());
	        if (totalSize >= pixelsOnScreen) {
	          break;
	        }
	      }
	      if (totalSize < pixelsOnScreen && pages.length > 0 && totalSize > 0) {
	        averagePageSize = totalSize / pages.length;
	        pixelsLeft = pixelsOnScreen - totalSize;
	        count += ceil(pixelsLeft / averagePageSize);
	      }
	      return count;
	    },
	    pagesOnScreenAfterBaseline: function() {
	      var averagePageSize, count, j, len, page, pages, pixelsLeft, pixelsOnScreen, ref, totalSize;
	      pixelsOnScreen = this.getWindowSize() - this.getScrollPosition();
	      totalSize = 0;
	      count = 0;
	      ref = pages = this._pagesAfterBaselineWrapper.getChildren();
	      for (j = 0, len = ref.length; j < len; j++) {
	        page = ref[j];
	        count++;
	        totalSize += this.getMainCoordinate(page.getCurrentSize());
	        if (totalSize >= pixelsOnScreen) {
	          break;
	        }
	      }
	      if (totalSize < pixelsOnScreen && pages.length > 0 && totalSize > 0) {
	        averagePageSize = totalSize / pages.length;
	        pixelsLeft = pixelsOnScreen - totalSize;
	        count += ceil(pixelsLeft / averagePageSize);
	      }
	      return count;
	    },
	    currentGeometry: function() {
	      var currentPos, numPages, pixelsAfter, pixelsBefore, suggestedPageSpread, totalPageSize, windowSize;
	      windowSize = this.getWindowSize();
	      currentPos = this.getCurrentPagePosition();
	      pixelsBefore = this.getPagesBeforeBaselineSize();
	      pixelsAfter = this.getPagesAfterBaselineSize();
	      numPages = this._pages.length;
	      totalPageSize = pixelsBefore + pixelsAfter;
	      suggestedPageSpread = this.getPagesOnScreenBeforeBaseline() + this.getPagesOnScreenAfterBaseline();
	      return {
	        currentPagePosition: currentPos,
	        windowSize: windowSize,
	        numPages: numPages,
	        numPagesBeforeBaseline: this._pagesBeforeBaselineWrapper.getChildren().length,
	        numPagesAfterBaseline: this._pagesAfterBaselineWrapper.getChildren().length,
	        totalPageSize: totalPageSize,
	        focusedPageBeforeBaseline: this.getReferenceFrame().atEndEdge,
	        suggestedPageSpread: suggestedPageSpread,
	        pixelsOffscreenBeforeWindow: pixelsBefore - currentPos,
	        pixelsOffscreenAfterWindow: pixelsAfter - windowSize + currentPos,
	        pagesBeforeBaselineSize: pixelsBefore,
	        pagesAfterBaselineSize: pixelsAfter
	      };
	    }
	  });

	  PagingScrollElementWip.prototype._initGestureProps = function() {
	    this._flicked = false;
	    this._pointerStartPosition = 0;
	    this._pointerReferenceFrame = null;
	    this._lastPointerEventTime = null;
	    this._flickSpeed = 0;
	    this._gestureActive = false;
	    return this._scrollAnimator = null;
	  };

	  PagingScrollElementWip.getter({
	    activeScrollAnimator: function() {
	      return this._scrollAnimator;
	    },
	    scrollAnimator: function() {
	      var maximumVelocity;
	      maximumVelocity = this.getWindowSize() * 60 / 2;
	      return this._scrollAnimator || (this._scrollAnimator = this.startAnimator(new ScrollAnimator(this, maximumVelocity)));
	    },
	    debugState: function() {
	      var child, ref, referenceFrame;
	      referenceFrame = this.referenceFrame;
	      return {
	        referenceFrame: {
	          page: (ref = referenceFrame.page) != null ? ref.inspectedName : void 0,
	          atEndEdge: referenceFrame.atEndEdge
	        },
	        pagesBefore: (function() {
	          var j, len, ref1, results;
	          ref1 = this._pagesBeforeBaselineWrapper.children;
	          results = [];
	          for (j = 0, len = ref1.length; j < len; j++) {
	            child = ref1[j];
	            results.push(child.inspectedName + " " + ((this.getMainCoordinate(child.currentSize)) | 0));
	          }
	          return results;
	        }).call(this),
	        pagesAfter: (function() {
	          var j, len, ref1, results;
	          ref1 = this._pagesAfterBaselineWrapper.children;
	          results = [];
	          for (j = 0, len = ref1.length; j < len; j++) {
	            child = ref1[j];
	            results.push(child.inspectedName + " " + ((this.getMainCoordinate(child.currentSize)) | 0));
	          }
	          return results;
	        }).call(this),
	        geometry: this.currentGeometry
	      };
	    }
	  });

	  PagingScrollElementWip.prototype.gestureRecognize = function(arg) {
	    var delta;
	    delta = arg.delta;
	    if (this._scroll === "vertical") {
	      return 1 > delta.absoluteAspectRatio;
	    } else {
	      return 1 < delta.absoluteAspectRatio;
	    }
	  };

	  PagingScrollElementWip.prototype.gestureBegin = function(e) {
	    var location, timeStamp;
	    location = e.location, timeStamp = e.timeStamp;
	    this._flickSpeed = 0;
	    this._gestureActive = true;
	    location = this.getMainCoordinate(location);
	    this._pointerReferenceFrame = this._referenceFrame;
	    this._pointerStartPosition = location - this._scrollPosition;
	    this._lastPointerEventTime = timeStamp;
	    if (this.getActiveScrollAnimator()) {
	      this._flicked = false;
	      return timeout(60, (function(_this) {
	        return function() {
	          var referenceFrame, scrollPosition;
	          if (!_this._flicked && _this._gestureActive) {
	            _this._pointerReferenceFrame = _this._referenceFrame;
	            scrollPosition = _this.getPendingScrollPosition();
	            referenceFrame = _this.getPendingReferenceFrame();
	            _this._pointerStartPosition = location - scrollPosition;
	            return _this.getScrollAnimator().startTracking(scrollPosition, referenceFrame);
	          }
	        };
	      })(this));
	    } else {
	      return this.startScrollAnimatorTracking();
	    }
	  };

	  PagingScrollElementWip.prototype.gestureResume = function(e) {
	    return !!this.getActiveScrollAnimator();
	  };

	  PagingScrollElementWip.prototype.gestureMove = function(e) {
	    var delta, deltaV, location, scrollAnimator, timeStamp;
	    timeStamp = e.timeStamp, delta = e.delta, location = e.location;
	    location = this.getMainCoordinate(location);
	    delta = this.getMainCoordinate(deltaV = delta);
	    scrollAnimator = this.getScrollAnimator();
	    if (timeStamp > this._lastPointerEventTime) {
	      this._flickSpeed = deltaV.getMagnitude() / (timeStamp - this._lastPointerEventTime);
	      this._flickDirection = (delta / abs(delta)) || 1;
	      this._lastPointerEventTime = timeStamp;
	    }
	    return scrollAnimator.setDesiredScrollPosition(location - this._pointerStartPosition);
	  };

	  PagingScrollElementWip.prototype.gestureEnd = function(e) {
	    var scrollAnimator;
	    this._gestureActive = false;
	    if (absGt(this._flickSpeed, minimumFlickVelocity)) {
	      scrollAnimator = this.getScrollAnimator();
	      scrollAnimator.addVelocity(this._flickSpeed * this._flickDirection * flickSpeedMultiplier);
	      return this._flicked = true;
	    } else {
	      return this.endScrollAnimatorTracking();
	    }
	  };

	  PagingScrollElementWip.prototype.startScrollAnimatorTracking = function() {
	    return this.getScrollAnimator().startTracking(this._scrollPosition, this._referenceFrame);
	  };

	  PagingScrollElementWip.prototype.endScrollAnimatorTracking = function() {
	    var scrollAnimator;
	    if (!(scrollAnimator = this.getActiveScrollAnimator())) {
	      return;
	    }
	    scrollAnimator.setReferenceFrame(this.getReferenceFrame());
	    scrollAnimator.setDesiredScrollPosition(this.getScrollPosition());
	    return scrollAnimator.setActiveTouch(false);
	  };


	  /*
	  When children are set "from outside", we split them based on the @_currentPage and set then as
	  grandchildren - children of the direct, but hidden children:
	    _pagesBeforeBaselineWrapper or
	    _pagesAfterBaselineWrapper
	  
	  Why? This allows us to leverage existing row and column layouts to do most of
	  the heavy lifting for actual element layout.
	   */

	  PagingScrollElementWip.prototype.setChildren = function(newPages, oldChildren) {
	    var newChildren;
	    if (oldChildren == null) {
	      oldChildren = this.getPendingChildren();
	    }
	    newChildren = !((oldChildren != null ? oldChildren.length : void 0) > 0) ? (this._updateHiddenChildren(), [this._scrollContents]) : oldChildren;
	    this.setPages(newPages);
	    return PagingScrollElementWip.__super__.setChildren.call(this, newChildren);
	  };

	  PagingScrollElementWip.prototype._updatePointerReferenceFrame = function(newReferenceFrame) {
	    var delta, ref, ref1;
	    if (!this._pointerReferenceFrame) {
	      return;
	    }
	    delta = this.getReferenceFrameDelta(newReferenceFrame, this._pointerReferenceFrame);
	    this._pointerStartPosition -= delta;
	    if ((ref = this.getActiveScrollAnimator()) != null) {
	      ref.addToDesiredScrollPosition(delta);
	    }
	    return (ref1 = this.getActiveScrollAnimator()) != null ? ref1.setReferenceFrame(this._pointerReferenceFrame = newReferenceFrame) : void 0;
	  };

	  PagingScrollElementWip.prototype._getPageUnderPosition = function(testPosition) {
	    var child, j, len, ref, relativeTestPosition, size, wrapper;
	    relativeTestPosition = testPosition - this.getScrollPosition();
	    wrapper = relativeTestPosition < 0 ? (relativeTestPosition += this.getMainCoordinate(this._pagesBeforeBaselineWrapper.getCurrentSize()), this._pagesBeforeBaselineWrapper) : this._pagesAfterBaselineWrapper;
	    ref = wrapper.getChildren();
	    for (j = 0, len = ref.length; j < len; j++) {
	      child = ref[j];
	      size = this.getMainCoordinate(child.getCurrentSize());
	      if (relativeTestPosition < size) {
	        return child;
	      }
	      relativeTestPosition -= size;
	    }
	    console.warn("PagingScrollElement#_getPageUnderPosition: could not find page under position");
	    return null;
	  };

	  PagingScrollElementWip.getter({
	    contentsFitInWindow: function() {
	      return this.getTotalPageSize() <= this.getWindowSize();
	    }
	  });

	  PagingScrollElementWip.prototype._setScrollContentsLocation = function(scrollPosition) {
	    var axis;
	    if (this.getContentsFitInWindow()) {
	      this._scrollContents.setAxis(axis = this.getPendingChildrenAlignment());
	      this._scrollContents.setLocation({
	        ps: axis,
	        plus: this.newPoint(scrollPosition)
	      });
	      this._scrollPositionRelativeToChildrenAlignment = true;
	      return this.onNextReady((function(_this) {
	        return function() {
	          return _this._setAtStart();
	        };
	      })(this));
	    } else {
	      if (this._scrollPositionRelativeToChildrenAlignment) {
	        log(scrollPosition += this.getWindowSize());
	      }
	      this._scrollContents.setAxis(point0);
	      this._scrollContents.setLocation(this.newPoint(scrollPosition));
	      return this._scrollPositionRelativeToChildrenAlignment = false;
	    }
	  };

	  PagingScrollElementWip.prototype._setReferenceFrameIfChanged = function(referenceFrame) {
	    if (neq(referenceFrame, this.getReferenceFrame())) {
	      return this.setReferenceFrame(referenceFrame);
	    }
	  };

	  PagingScrollElementWip.prototype._setAtStart = function() {
	    this._setReferenceFrameIfChanged({
	      page: first(this.getPages())
	    });
	    this._atStart = true;
	    this._atEnd = false;
	    return true;
	  };

	  PagingScrollElementWip.prototype._setAtEnd = function() {
	    this._setReferenceFrameIfChanged({
	      atEndEdge: true,
	      page: last(this.getPages())
	    });
	    this._atStart = false;
	    this._atEnd = true;
	    return true;
	  };

	  PagingScrollElementWip.prototype._updateAtStartAndAtEnd = function() {
	    var scrollPosition;
	    scrollPosition = this.getScrollPosition();
	    if (this.getContentsFitInWindow()) {
	      return this._setAtStart();
	    } else {
	      if (scrollPosition >= this.getMaxScrollPosition()) {
	        return this._setAtStart();
	      } else if (scrollPosition <= this.getMinScrollPosition()) {
	        return this._setAtEnd();
	      }
	    }
	  };

	  PagingScrollElementWip.prototype._addToScrollPosition = function(delta) {
	    return this.setScrollPosition(this.getPendingScrollPosition() + delta);
	  };


	  /*
	  update currentPage to be the page that overlaps the center-line of the view-window
	  
	  need to:
	    update scrollPosition
	    need to @_setChildren
	   */

	  PagingScrollElementWip.prototype._updateReferenceFrame = function() {
	    var atEndEdge, centerPosition, newCurrentPage, pageCenterPosition, referenceFrame, scrollPosition;
	    if (this._updateAtStartAndAtEnd()) {
	      return;
	    }
	    scrollPosition = this.getScrollPosition();
	    centerPosition = this.getWindowSize() / 2;
	    newCurrentPage = this._getPageUnderPosition(centerPosition);
	    if (!newCurrentPage) {
	      console.warn("_updateReferenceFrame: no newCurrentPage");
	    }
	    pageCenterPosition = this.getPageCenter(newCurrentPage);
	    atEndEdge = centerPosition > pageCenterPosition;
	    referenceFrame = this.getReferenceFrame();
	    if (referenceFrame.page !== newCurrentPage || referenceFrame.atEndEdge !== atEndEdge) {
	      return this.setReferenceFrame({
	        page: newCurrentPage,
	        atEndEdge: atEndEdge
	      });
	    }
	  };

	  PagingScrollElementWip.prototype._queueUpdateEvent = function(newReferenceFrame, previousReferenceFrame) {
	    return this.onNextReady((function(_this) {
	      return function() {
	        var referenceFrame;
	        referenceFrame = _this.getReferenceFrame();
	        return _this.queueEvent("scrollUpdate", {
	          previousReferenceFrame: previousReferenceFrame,
	          referenceFrame: referenceFrame,
	          focusedPage: referenceFrame.page,
	          currentGeometry: _this.getCurrentGeometry(),
	          pagesBeforeBaseline: _this.getPagesBeforeBaseline(),
	          pagesAfterBaseline: _this.getPagesAfterBaseline()
	        });
	      };
	    })(this));
	  };

	  PagingScrollElementWip.prototype._sizeChanged = function(newSize, oldSize) {
	    this._updateAtStartAndAtEnd(this.scrollPosition, newSize);
	    this._queueUpdateEvent();
	    return PagingScrollElementWip.__super__._sizeChanged.apply(this, arguments);
	  };

	  PagingScrollElementWip.prototype._scrollContentsChildChanged = function() {
	    var bsp;
	    if (!this._scrollAnimator) {
	      if (this.contentsFitInWindow || this.scrollPosition !== (bsp = this.boundedScrollPosition)) {
	        return this.setScrollPosition(bsp);
	      }
	    }
	  };

	  PagingScrollElementWip.prototype._updateHiddenChildren = function(scrollMode) {
	    var commonSizeLayout;
	    if (scrollMode == null) {
	      scrollMode = this.getPendingScroll();
	    }
	    this._scrollContents || (this._scrollContents = new Element({
	      key: "scrollContents",
	      receivePointerEvents: "passToChildren"
	    }, this._pagesBeforeBaselineWrapper = new Element({
	      key: "pagesBeforeBaseline",
	      on: {
	        sizeChanged: (function(_this) {
	          return function() {
	            return _this._scrollContentsChildChanged();
	          };
	        })(this)
	      }
	    }), this._pagesAfterBaselineWrapper = new Element({
	      key: "pagesAfterBaseline",
	      on: {
	        sizeChanged: (function(_this) {
	          return function() {
	            return _this._scrollContentsChildChanged();
	          };
	        })(this)
	      }
	    })));
	    if (scrollMode === "horizontal") {
	      commonSizeLayout = {
	        hh: 1,
	        wcw: 1
	      };
	      this._pagesBeforeBaselineWrapper.setAxis("topRight");
	      this._pagesBeforeBaselineWrapper.setChildrenLayout("row");
	      this._pagesAfterBaselineWrapper.setChildrenLayout("row");
	    } else {
	      commonSizeLayout = {
	        ww: 1,
	        hch: 1
	      };
	      this._pagesBeforeBaselineWrapper.setAxis("bottomLeft");
	      this._pagesBeforeBaselineWrapper.setChildrenLayout("column");
	      this._pagesAfterBaselineWrapper.setChildrenLayout("column");
	    }
	    this._scrollContents.setSize(commonSizeLayout);
	    this._pagesBeforeBaselineWrapper.setSize(commonSizeLayout);
	    return this._pagesAfterBaselineWrapper.setSize(commonSizeLayout);
	  };

	  return PagingScrollElementWip;

	})(AnimatorSupport(Element)));


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	var AnimatorSupport, Atomic, BaseObject, Element, EventEpoch, Foundation, GestureRecognizer, Matrix, PagingScrollElement, Point, Rectangle, ScrollAnimator, abs, absGt, absGte, absLt, absLte, animatorSpringConstant, animatorSpringFriction, bound, brakingFactor, ceil, createGestureRecognizer, createWithPostCreate, crossScrollProperties, currentSecond, eventEpoch, first, flickSpeedMultiplier, inspect, isPlainArray, isPoint, last, log, matrix, max, maxChange, maxMagnitude, merge, min, minMagnitude, minimumFlickVelocity, peek, point, point0, pointNearInfinity, rect, requestAnimationFrame, round, scrollProperties, timeout,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	EventEpoch = __webpack_require__(168).EventEpoch;

	Element = __webpack_require__(184);

	GestureRecognizer = __webpack_require__(165);

	log = Foundation.log, inspect = Foundation.inspect, currentSecond = Foundation.currentSecond, bound = Foundation.bound, round = Foundation.round, first = Foundation.first, last = Foundation.last, peek = Foundation.peek, min = Foundation.min, max = Foundation.max, abs = Foundation.abs, merge = Foundation.merge, createWithPostCreate = Foundation.createWithPostCreate, BaseObject = Foundation.BaseObject, timeout = Foundation.timeout, ceil = Foundation.ceil, round = Foundation.round, isPlainArray = Foundation.isPlainArray, absLt = Foundation.absLt, absLte = Foundation.absLte, absGt = Foundation.absGt, absGte = Foundation.absGte, minMagnitude = Foundation.minMagnitude, maxMagnitude = Foundation.maxMagnitude, maxChange = Foundation.maxChange, absLt = Foundation.absLt, requestAnimationFrame = Foundation.requestAnimationFrame;

	point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix, isPoint = Atomic.isPoint;

	point0 = Point.point0, pointNearInfinity = Point.pointNearInfinity;

	eventEpoch = EventEpoch.eventEpoch;

	createGestureRecognizer = GestureRecognizer.createGestureRecognizer;

	scrollProperties = {
	  vertical: "y",
	  horizontal: "x"
	};

	crossScrollProperties = {
	  vertical: "x",
	  horizontal: "y"
	};

	brakingFactor = 3;

	minimumFlickVelocity = 300;

	animatorSpringConstant = 300;

	animatorSpringFriction = 25;

	flickSpeedMultiplier = 1;


	/*
	TODO: Pages should be able to have margins!
	  But we have a big problem. Pages are split across two parents and the two parents
	  can't inherit the children's margins.

	I'm more and more thinking I want a fully custom ArtEngine layout for PSE.
	It would make a lot of things simpler to understand...
	 */


	/*
	PagingScrollElement

	guarantee:
	  Will never scroll more than one "windowSize" per frame.
	  That means you need at least as many "pages" as it will take to display one more window-full of content
	  above or below the current displayed content.

	margins:
	  Margins on paging elements are currently not supported.
	  We could relatively easilly support constant margins.
	  Anything more complex gets a little tedious.
	  Recomendation: Use Padding instead of Margins.

	events:
	  currentPageChanged:
	    oldCurrentPage: element
	    currentPage:    element
	  scrollUpdate:
	    currentPage:          element           - @currentPage
	    currentGeometry:      plain object      - @currentGeometry
	    pagesBeforeBaseline:  array of elements - @pagesBeforeBaseline
	    pagesAfterBaseline:   array of elements - @pagesAfterBaseline

	naming:

	  All "positions" are scalers.
	  All "positions" are relative to the top/left of the PagingScrollElement.
	  Positive values indicate more to the bottom/right of the PagingScrollElement.

	  "scrollPosition" is the main geometry value for the PagingScrollElement.

	  I chose "scrollPosition" over just "position" or "location".
	  location vs position: http://www.eng-tips.com/viewthread.cfm?qid=180516
	    position can be used to refer to internal configuration, which scrollPosition is,
	    but location cannot. This avoids confusion with Element's currentLocations.

	Implementation Notes:

	  When to use "pending" property values:
	    - use pending values only as inputs to computation that results in setting another property
	    - use current (non-pending) poperty values for all getters
	 */


	/*
	ScrollAnimator

	scrollElement api:
	  @getter
	    minScrollPosition:
	    maxScrollPosition:
	    scrollPosition:

	  @setter
	    scrollPosition: (scrollPosition) ->

	onIdle is called when all animations and gestures have stopped.
	 */

	ScrollAnimator = (function(superClass1) {
	  var frameCount, missCount;

	  extend(ScrollAnimator, superClass1);

	  function ScrollAnimator(scrollElement, maximumVelocity1) {
	    this.scrollElement = scrollElement;
	    this.maximumVelocity = maximumVelocity1;
	    ScrollAnimator.__super__.constructor.apply(this, arguments);
	    this._referenceFrame = this.scrollElement.getPendingReferenceFrame();
	    this._velocity = 0;
	    this._mode = "tracking";

	    /*
	    modes:
	      braking:      friction only
	      spring:       spring
	      tracking:     direct tracking, no physics
	     */
	  }

	  ScrollAnimator.getter("desiredScrollPosition", {
	    mode: function() {
	      return this._mode;
	    },
	    minScrollPosition: function() {
	      return this.scrollElement.getMinScrollPositionInReferenceFrame(this._referenceFrame);
	    },
	    maxScrollPosition: function() {
	      return this.scrollElement.getMaxScrollPositionInReferenceFrame(this._referenceFrame);
	    },
	    scrollPosition: function() {
	      return this.scrollElement.getScrollPositionInReferenceFrame(this._referenceFrame);
	    },
	    animationDone: function() {
	      switch (this.mode) {
	        case "spring":
	          return this.velocityIsSlow() && this._desiredScrollPosition === this.getScrollPosition();
	        case "braking":
	          return this.velocityIsSlow();
	        default:
	          return !this._activeTouch;
	      }
	    },
	    animationContinues: function() {
	      return !this.getAnimationDone();
	    }
	  });

	  ScrollAnimator.setter("desiredScrollPosition", {
	    mode: function(v) {
	      return this._mode = v;
	    },
	    referenceFrame: function(v) {
	      return this._referenceFrame = v;
	    },
	    scrollPosition: function(l) {
	      return this.scrollElement.setScrollPositionInReferenceFrame(round(l), this._referenceFrame);
	    },
	    activeTouch: function(v) {
	      if (!(this._activeTouch = !!v)) {
	        this.mode = "spring";
	        return this._desiredScrollPosition = this.boundLocation(this._desiredScrollPosition);
	      }
	    }
	  });

	  ScrollAnimator.prototype.addToDesiredScrollPosition = function(delta) {
	    return this._desiredScrollPosition += delta;
	  };

	  ScrollAnimator.prototype.animateToLocation = function(desiredScrollPosition) {
	    this.mode = "spring";
	    return this._desiredScrollPosition = desiredScrollPosition;
	  };

	  ScrollAnimator.prototype.boundLocation = function(scrollPosition) {
	    return bound(this.getMinScrollPosition(), scrollPosition, this.getMaxScrollPosition());
	  };

	  ScrollAnimator.prototype.startTracking = function(desiredScrollPosition, referenceFrame) {
	    this._referenceFrame = referenceFrame;
	    this.mode = "tracking";
	    this._velocity = 0;
	    this.setDesiredScrollPosition(desiredScrollPosition);
	    return this._activeTouch = true;
	  };

	  ScrollAnimator.prototype.addVelocity = function(v) {
	    this._velocity = v;
	    return this.mode = "braking";
	  };

	  ScrollAnimator.prototype.velocityIsSlow = function() {
	    return absLte(this._velocity, 60);
	  };

	  frameCount = 0;

	  missCount = 0;

	  ScrollAnimator.prototype.frameUpdate = function(frameTime) {
	    var acceleration, boundedLocation, boundedTargetLocation, currentToTargetVector, distanceSquared, frictionAcceleration, frictionConstant, maxBeyond, maxV, minV, scrollPosition, springAcceleration, springConstant, targetScrollPosition, tookFrames, windowSize;
	    tookFrames = Math.round(frameTime * 60);
	    frameCount++;
	    if (absLt(frameTime * 60 - 1, .25)) {

	    } else {
	      if (tookFrames > 1) {
	        missCount++;
	      }
	    }
	    scrollPosition = this.getScrollPosition();
	    targetScrollPosition = this._desiredScrollPosition;
	    this._velocity = maxMagnitude(this._velocity, this.maximumVelocity);
	    switch (this._mode) {
	      case "tracking":
	        windowSize = this.scrollElement.windowSize;
	        boundedTargetLocation = this.boundLocation(targetScrollPosition);
	        maxBeyond = windowSize / 3;
	        minV = min(boundedTargetLocation, targetScrollPosition);
	        maxV = max(boundedTargetLocation, targetScrollPosition);
	        targetScrollPosition = bound(minV, boundedTargetLocation + Math.atan((targetScrollPosition - boundedTargetLocation) / maxBeyond) * (2 / Math.PI) * maxBeyond, maxV);
	        this._velocity = 0;
	        this.setScrollPosition(targetScrollPosition);
	        break;
	      case "braking":
	        this._activeTouch = false;
	        frictionConstant = brakingFactor;
	        frictionAcceleration = this._velocity * -frictionConstant;
	        acceleration = frictionAcceleration;
	        this._velocity += acceleration * frameTime;
	        scrollPosition = scrollPosition + this._velocity * frameTime;
	        this.setScrollPosition(scrollPosition);
	        if (scrollPosition !== (boundedLocation = this.boundLocation(scrollPosition))) {
	          this.mode = "spring";
	          this._desiredScrollPosition = boundedLocation;
	        }
	        break;
	      case "spring":
	        currentToTargetVector = targetScrollPosition - scrollPosition;
	        distanceSquared = currentToTargetVector * currentToTargetVector;
	        springConstant = animatorSpringConstant;
	        frictionConstant = animatorSpringFriction;
	        springAcceleration = currentToTargetVector * springConstant;
	        frictionAcceleration = this._velocity * -frictionConstant;
	        acceleration = springAcceleration + frictionAcceleration;
	        this._velocity = this._velocity + acceleration * frameTime;
	        this.setScrollPosition(this.velocityIsSlow() && abs(scrollPosition - targetScrollPosition) <= 1 ? targetScrollPosition : scrollPosition + minMagnitude(this._velocity * frameTime, 1));
	    }
	    if (!this.getAnimationContinues()) {
	      log("frameUpdate " + this._mode + ": DONE (miss rate: " + missCount + " / " + frameCount + ")");
	    }
	    return this.getAnimationContinues();
	  };

	  return ScrollAnimator;

	})(BaseObject);

	AnimatorSupport = function(superClass) {
	  return AnimatorSupport = (function(superClass1) {
	    extend(AnimatorSupport, superClass1);

	    function AnimatorSupport() {
	      return AnimatorSupport.__super__.constructor.apply(this, arguments);
	    }

	    AnimatorSupport.getter({
	      animatorsActive: function() {
	        return !!this._activeAnimators;
	      }
	    });

	    AnimatorSupport.prototype.initAnimatorSupport = function() {
	      this._lastTime = 0;
	      this._activeAnimators = null;
	      return this._frameUpdateQueued = false;
	    };

	    AnimatorSupport.prototype.startAnimator = function(animator) {
	      if (this.getAnimatorsActive()) {
	        this._activeAnimators.push(animator);
	      } else {
	        this._activeAnimators = [animator];
	        this._lastTime = currentSecond();
	        this.getAnimatorsActive();
	      }
	      this._startAnimatorLoop();
	      return animator;
	    };


	    /*
	    OUT: newAnimator
	    SIDE-EFFECT:
	      if oldAnimator is in @_activeAnimators
	      then: replaced it with newAnimator
	      else: @startAnimator newAnimator
	    
	    POST ASSERTIONS
	      newAnimator is in @_activeAnimators
	      oldAnimator is NOT in @_activeAnimators
	     */

	    AnimatorSupport.prototype.replaceAnimator = function(newAnimator, oldAnimator) {
	      var index;
	      if (!(this._activeAnimators && oldAnimator)) {
	        return this.startAnimator(newAnimator);
	      }
	      index = this._activeAnimators.indexOf(oldAnimator);
	      if (!(index >= 0)) {
	        return this.startAnimator(newAnimator);
	      }
	      return this._activeAnimators[index] = newAnimator;
	    };

	    AnimatorSupport.prototype.stopAllAnimators = function() {
	      return this._activeAnimators = null;
	    };

	    AnimatorSupport.prototype._frameUpdate = function(frameTime) {
	      var animator, i, j, len, nextAnimators, now, ref;
	      if (!this._activeAnimators) {
	        return;
	      }
	      now = frameTime;
	      frameTime = now - this._lastTime;
	      nextAnimators = null;
	      ref = this._activeAnimators;
	      for (i = j = 0, len = ref.length; j < len; i = ++j) {
	        animator = ref[i];
	        if (animator.frameUpdate(frameTime)) {
	          if (nextAnimators != null) {
	            nextAnimators.push(animator);
	          }
	        } else {
	          this.queueEvent("animatorDone", {
	            animator: animator
	          });
	          nextAnimators || (nextAnimators = this._activeAnimators.slice(0, i));
	        }
	      }
	      if (nextAnimators) {
	        if (nextAnimators.length === 0) {
	          this._activeAnimators = null;
	          this.queueEvent("allAnimatorsDone");
	        } else {
	          this._activeAnimators = nextAnimators;
	        }
	      }
	      return this._lastTime = now;
	    };

	    AnimatorSupport.prototype._startAnimatorLoop = function() {
	      if (this._frameUpdateQueued) {
	        return;
	      }
	      return requestAnimationFrame((function(_this) {
	        return function(frameTimeMs) {
	          var queueNextFrameUpdate;
	          _this._lastTime = frameTimeMs / 1000;
	          queueNextFrameUpdate = function() {
	            if (!_this.getAnimatorsActive()) {
	              return;
	            }
	            _this._frameUpdateQueued = true;
	            return requestAnimationFrame(function(frameTimeMs) {
	              _this._frameUpdateQueued = false;
	              _this._frameUpdate(frameTimeMs / 1000);
	              return queueNextFrameUpdate();
	            });
	          };
	          return queueNextFrameUpdate();
	        };
	      })(this));
	    };

	    return AnimatorSupport;

	  })(superClass);
	};

	module.exports = createWithPostCreate(PagingScrollElement = (function(superClass1) {
	  var defaultReferenceFrame;

	  extend(PagingScrollElement, superClass1);

	  function PagingScrollElement() {
	    this.initAnimatorSupport();
	    this._initGestureProps();
	    this._pages = null;
	    this._currentPage = null;
	    this._atEnd = false;
	    this._atStart = true;
	    this._scrollContents = this._pagesBeforeBaselineWrapper = this._pagesAfterBaselineWrapper = null;
	    this._setVerticalAxis();
	    PagingScrollElement.__super__.constructor.apply(this, arguments);
	    self.pagingScrollElement = this;
	    this._updateHiddenChildren();
	    this.onNextReady((function(_this) {
	      return function() {
	        if (_this.startAtEnd) {
	          return _this.jumpToEnd();
	        }
	      };
	    })(this));
	  }

	  PagingScrollElement.prototype.preprocessEventHandlers = function(handlerMap) {
	    return merge(this._externalHandlerMap = handlerMap, {
	      mouseWheel: (function(_this) {
	        return function(event) {
	          var horizontal, position, scrollValue, windowSize;
	          _this._mostRecentMouseWheelEvent = event;
	          windowSize = _this.windowSize;
	          scrollValue = (horizontal = _this.scroll === "horizontal") ? event.props.deltaX || 0 : event.props.deltaY || 0;
	          switch (event.props.deltaMode) {
	            case "line":
	              scrollValue *= 16;
	              break;
	            case "page":
	              scrollValue *= windowSize * .75;
	          }
	          if (!_this.getActiveScrollAnimator()) {
	            _this.startScrollAnimatorTracking();
	          }
	          scrollValue = bound(-windowSize, -scrollValue, windowSize);
	          position = _this.getScrollAnimator().desiredScrollPosition + scrollValue;
	          _this.getScrollAnimator().desiredScrollPosition = bound(_this.getScrollAnimator().minScrollPosition, position, _this.getScrollAnimator().maxScrollPosition);
	          return timeout(100).then(function() {
	            if (_this._mostRecentMouseWheelEvent !== event) {
	              return;
	            }
	            return _this.endScrollAnimatorTracking();
	          });
	        };
	      })(this),
	      animatorDone: (function(_this) {
	        return function(arg) {
	          var animator, props;
	          props = arg.props;
	          animator = props.animator;
	          if (animator === _this._scrollAnimator) {
	            return _this._scrollAnimator = null;
	          }
	        };
	      })(this)
	    }, createGestureRecognizer({
	      custom: {
	        resume: this.gestureResume.bind(this),
	        recognize: this.gestureRecognize.bind(this),
	        begin: this.gestureBegin.bind(this),
	        move: this.gestureMove.bind(this),
	        end: this.gestureEnd.bind(this)
	      }
	    }));
	  };

	  PagingScrollElement.prototype._setVerticalAxis = function() {
	    this.newPoint = function(mainV, crossV) {
	      if (crossV == null) {
	        crossV = 0;
	      }
	      return point(crossV, mainV);
	    };
	    this.getPagePosition = function(page) {
	      return (page != null ? page.transformToAncestorSpaceY(0, this) : void 0) || 0;
	    };
	    return this.getMainCoordinate = function(pnt) {
	      return pnt.y;
	    };
	  };

	  PagingScrollElement.prototype._setHorizontalAxis = function() {
	    this.newPoint = function(mainV, crossV) {
	      if (crossV == null) {
	        crossV = 0;
	      }
	      return point(mainV, crossV);
	    };
	    this.getPagePosition = function(page) {
	      return (page != null ? page.transformToAncestorSpaceX(0, this) : void 0) || 0;
	    };
	    return this.getMainCoordinate = function(pnt) {
	      return pnt.x;
	    };
	  };

	  PagingScrollElement.prototype.getPageSize = function(page) {
	    if (!page) {
	      return 0;
	    } else {
	      return this.getMainCoordinate(page.getCurrentSize());
	    }
	  };

	  PagingScrollElement.prototype.getPageEdgeOffset = function(arg) {
	    var atEndEdge, page;
	    page = arg.page, atEndEdge = arg.atEndEdge;
	    if (atEndEdge) {
	      return this.getPageSize(page);
	    } else {
	      return 0;
	    }
	  };

	  PagingScrollElement.prototype.getPageCenter = function(page) {
	    return this.getPagePosition(page) + this.getPageSize(page) / 2;
	  };

	  defaultReferenceFrame = {
	    page: null,
	    atEndEdge: false
	  };

	  PagingScrollElement.concreteProperty({
	    startAtEnd: {
	      "default": false
	    },
	    referenceFrame: {
	      "default": defaultReferenceFrame,
	      postSetter: function(newReferenceFrame, previousReferenceFrame) {
	        var delta;
	        if (newReferenceFrame === previousReferenceFrame) {
	          console.warn("referenceFrame_postSetter - frame didn't change");
	        }
	        this._addToScrollPosition(delta = this.getReferenceFrameDelta(newReferenceFrame, previousReferenceFrame));
	        this._updatePointerReferenceFrame(newReferenceFrame);
	        this._queueUpdateEvent(newReferenceFrame, previousReferenceFrame);
	        return this._updatePagesSplit();
	      }
	    },
	    pages: {
	      "default": [],
	      validate: function(pages) {
	        return isPlainArray(pages);
	      },
	      postSetter: function(pages, oldPages) {
	        var atEndEdge, page, ref, referenceFrame;
	        ref = referenceFrame = this.getPendingReferenceFrame(), page = ref.page, atEndEdge = ref.atEndEdge;
	        if (this._atEnd) {
	          atEndEdge = true;
	          page = last(pages);
	        }
	        if (this._atStart || !page) {
	          atEndEdge = false;
	          page = first(pages);
	        }
	        if (referenceFrame.page && 0 > pages.indexOf(referenceFrame.page)) {
	          console.warn("PagingScrollElement#pages setter: New page list does not contain the current referenceFrame. ALWAYS include the current referenceFrame when setting pages. Screen will jump!\n\npage keys: " + (inspect((function() {
	            var j, len, results;
	            results = [];
	            for (j = 0, len = pages.length; j < len; j++) {
	              page = pages[j];
	              results.push(page.key);
	            }
	            return results;
	          })())));
	        }
	        if (referenceFrame.page !== page || referenceFrame.atEndEdge !== atEndEdge) {
	          this.setReferenceFrame({
	            page: page,
	            atEndEdge: atEndEdge
	          });
	        } else {
	          this._updatePagesSplit();
	        }
	        if (oldPages.length > 0) {
	          return this.onNextReady((function(_this) {
	            return function() {
	              return _this._updateAtStartAndAtEnd();
	            };
	          })(this));
	        }
	      }
	    },
	    scrollPosition: {
	      "default": 0,
	      postSetter: function(position) {
	        this.onNextReady((function(_this) {
	          return function() {
	            return _this._updateAtStartAndAtEnd();
	          };
	        })(this));

	        /*
	        TODO
	        NOTES on childrenAlignment:
	          This doesn't work yet.
	        
	          This needs to update whenever the size of children or parent changes.
	        
	          This code only updates when scrollPosition changes.
	         */
	        return this._scrollContents.setLocation(this.newPoint(position));
	      }
	    }
	  });

	  PagingScrollElement.prototype._updatePagesSplit = function(pages, referenceFrame) {
	    var atEndEdge, page, splitIndex;
	    if (pages == null) {
	      pages = this.getPendingPages();
	    }
	    if (referenceFrame == null) {
	      referenceFrame = this.getPendingReferenceFrame();
	    }
	    page = referenceFrame.page, atEndEdge = referenceFrame.atEndEdge;
	    splitIndex = pages.indexOf(page);
	    if (splitIndex < 0) {
	      if (page) {
	        console.warn("PagingScrollElement#_updatePagesSplit: could not find the old referenceFrame.page(key: " + (page.key || page.inspectedName) + ") in the new children. New current page picked; display WILL jump.");
	      }
	      splitIndex = 0;
	    }
	    if (atEndEdge) {
	      splitIndex++;
	    }
	    this._pagesBeforeBaselineWrapper.setChildren(pages.slice(0, splitIndex));
	    return this._pagesAfterBaselineWrapper.setChildren(pages.slice(splitIndex));
	  };

	  PagingScrollElement.layoutProperty({
	    scroll: {
	      "default": "vertical",
	      validate: function(v) {
	        return v === "vertical" || v === "horizontal";
	      },
	      postSetter: function(newV, oldValue) {
	        if (newV === "vertical") {
	          this._setVerticalAxis();
	        } else {
	          this._setHorizontalAxis();
	        }
	        return this._updateHiddenChildren(newV);
	      }
	    }
	  });

	  PagingScrollElement.prototype.getReferenceFrameDelta = function(toReferenceFrame, fromReferenceFrame) {
	    var edgeDelta, positionDelta;
	    if (toReferenceFrame == null) {
	      toReferenceFrame = defaultReferenceFrame;
	    }
	    if (fromReferenceFrame == null) {
	      fromReferenceFrame = defaultReferenceFrame;
	    }
	    if (toReferenceFrame === fromReferenceFrame) {
	      return 0;
	    }
	    positionDelta = toReferenceFrame.page === fromReferenceFrame.page ? 0 : this.getPagePosition(toReferenceFrame.page) - this.getPagePosition(fromReferenceFrame.page);
	    edgeDelta = this.getPageEdgeOffset(toReferenceFrame) - this.getPageEdgeOffset(fromReferenceFrame);
	    return positionDelta + edgeDelta;
	  };

	  PagingScrollElement.prototype.getScrollPositionInReferenceFrame = function(targetReferenceFrame) {
	    return this.getScrollPosition() + this.getReferenceFrameDelta(targetReferenceFrame, this.getReferenceFrame());
	  };

	  PagingScrollElement.prototype.setScrollPositionInReferenceFrame = function(scrollPosition, referenceFrame) {
	    var pendingReferenceFrame;
	    if (referenceFrame == null) {
	      referenceFrame = this.getPendingReferenceFrame();
	    }
	    this.onNextReady((function(_this) {
	      return function() {
	        return _this._updateReferenceFrame();
	      };
	    })(this));
	    pendingReferenceFrame = this.getPendingReferenceFrame();
	    scrollPosition += this.getReferenceFrameDelta(pendingReferenceFrame, referenceFrame);
	    return this.setScrollPosition(scrollPosition);
	  };

	  PagingScrollElement.getter({
	    minScrollPosition: function() {
	      return this.getMinScrollPositionInReferenceFrame(this.getReferenceFrame());
	    },
	    maxScrollPosition: function() {
	      return this.getMaxScrollPositionInReferenceFrame(this.getReferenceFrame());
	    }
	  });

	  PagingScrollElement.prototype.getMinScrollPositionInReferenceFrame = function(referenceFrame) {
	    var afterSize, beforeSize, windowSize;
	    windowSize = this.getWindowSize();
	    beforeSize = this.getPagesBeforeBaselineSize();
	    afterSize = this.getPagesAfterBaselineSize();
	    if (beforeSize + afterSize <= windowSize) {
	      return 0;
	    }
	    return windowSize - afterSize + this.getReferenceFrameDelta(referenceFrame, this.getReferenceFrame());
	  };

	  PagingScrollElement.prototype.getMaxScrollPositionInReferenceFrame = function(referenceFrame) {
	    var afterSize, beforeSize, delta, windowSize;
	    windowSize = this.getWindowSize();
	    beforeSize = this.getPagesBeforeBaselineSize();
	    afterSize = this.getPagesAfterBaselineSize();
	    delta = this.getReferenceFrameDelta(referenceFrame, this.getReferenceFrame());
	    if (beforeSize + afterSize <= windowSize) {
	      return 0;
	    }
	    return beforeSize + delta;
	  };

	  PagingScrollElement.prototype.jumpToStart = function() {
	    return this.setScrollPositionInReferenceFrame(0, {
	      page: first(this.getPendingPages()),
	      atEndEdge: false
	    });
	  };

	  PagingScrollElement.prototype.jumpToEnd = function() {
	    log("jumpToEnd");
	    if (this.getPagesFitInWindow()) {
	      return this.jumpToStart();
	    } else {
	      return this.setScrollPositionInReferenceFrame(this.getWindowSize(), {
	        page: last(this.getPendingPages()),
	        atEndEdge: true
	      });
	    }
	  };

	  PagingScrollElement.getter({
	    atEnd: function() {
	      return this._atEnd;
	    },
	    atStart: function() {
	      return this._atStart;
	    },
	    inMiddle: function() {
	      return !this._atEnd && !this._atStart;
	    },
	    pagesFitInWindow: function() {
	      return this.getWindowSize() >= this.getTotalPageSize();
	    },
	    windowSize: function() {
	      return this.getMainCoordinate(this.getCurrentSize());
	    },
	    currentPagePosition: function() {
	      return this.getMainCoordinate(this._scrollContents.getCurrentLocation());
	    },
	    pagesBeforeBaselineSize: function() {
	      return this.getMainCoordinate(this._pagesBeforeBaselineWrapper.getCurrentSize());
	    },
	    pagesAfterBaselineSize: function() {
	      return this.getMainCoordinate(this._pagesAfterBaselineWrapper.getCurrentSize());
	    },
	    pagesBeforeBaseline: function() {
	      return this._pagesBeforeBaselineWrapper.getChildren();
	    },
	    pagesAfterBaseline: function() {
	      return this._pagesAfterBaselineWrapper.getChildren();
	    },
	    totalPageSize: function() {
	      return this.getPagesBeforeBaselineSize() + this.getPagesAfterBaselineSize();
	    },
	    pagesOnScreenBeforeBaseline: function() {
	      var averagePageSize, count, j, page, pages, pixelsLeft, pixelsOnScreen, ref, totalSize;
	      pixelsOnScreen = this.getScrollPosition();
	      totalSize = 0;
	      count = 0;
	      ref = pages = this._pagesBeforeBaselineWrapper.getChildren();
	      for (j = ref.length - 1; j >= 0; j += -1) {
	        page = ref[j];
	        count++;
	        totalSize += this.getMainCoordinate(page.getCurrentSize());
	        if (totalSize >= pixelsOnScreen) {
	          break;
	        }
	      }
	      if (totalSize < pixelsOnScreen && pages.length > 0 && totalSize > 0) {
	        averagePageSize = totalSize / pages.length;
	        pixelsLeft = pixelsOnScreen - totalSize;
	        count += ceil(pixelsLeft / averagePageSize);
	      }
	      return count;
	    },
	    pagesOnScreenAfterBaseline: function() {
	      var averagePageSize, count, j, len, page, pages, pixelsLeft, pixelsOnScreen, ref, totalSize;
	      pixelsOnScreen = this.getWindowSize() - this.getScrollPosition();
	      totalSize = 0;
	      count = 0;
	      ref = pages = this._pagesAfterBaselineWrapper.getChildren();
	      for (j = 0, len = ref.length; j < len; j++) {
	        page = ref[j];
	        count++;
	        totalSize += this.getMainCoordinate(page.getCurrentSize());
	        if (totalSize >= pixelsOnScreen) {
	          break;
	        }
	      }
	      if (totalSize < pixelsOnScreen && pages.length > 0 && totalSize > 0) {
	        averagePageSize = totalSize / pages.length;
	        pixelsLeft = pixelsOnScreen - totalSize;
	        count += ceil(pixelsLeft / averagePageSize);
	      }
	      return count;
	    },
	    currentGeometry: function() {
	      var currentPos, numPages, pixelsAfter, pixelsBefore, suggestedPageSpread, totalPageSize, windowSize;
	      windowSize = this.getWindowSize();
	      currentPos = this.getCurrentPagePosition();
	      pixelsBefore = this.getPagesBeforeBaselineSize();
	      pixelsAfter = this.getPagesAfterBaselineSize();
	      numPages = this._pages.length;
	      totalPageSize = pixelsBefore + pixelsAfter;
	      suggestedPageSpread = this.getPagesOnScreenBeforeBaseline() + this.getPagesOnScreenAfterBaseline();
	      return {
	        currentPagePosition: currentPos,
	        windowSize: windowSize,
	        numPages: numPages,
	        numPagesBeforeBaseline: this._pagesBeforeBaselineWrapper.getChildren().length,
	        numPagesAfterBaseline: this._pagesAfterBaselineWrapper.getChildren().length,
	        totalPageSize: totalPageSize,
	        focusedPageBeforeBaseline: this.getReferenceFrame().atEndEdge,
	        suggestedPageSpread: suggestedPageSpread,
	        pixelsOffscreenBeforeWindow: pixelsBefore - currentPos,
	        pixelsOffscreenAfterWindow: pixelsAfter - windowSize + currentPos,
	        pagesBeforeBaselineSize: pixelsBefore,
	        pagesAfterBaselineSize: pixelsAfter
	      };
	    }
	  });

	  PagingScrollElement.prototype._initGestureProps = function() {
	    this._flicked = false;
	    this._pointerStartPosition = 0;
	    this._pointerReferenceFrame = null;
	    this._lastPointerEventTime = null;
	    this._flickSpeed = 0;
	    this._gestureActive = false;
	    return this._scrollAnimator = null;
	  };

	  PagingScrollElement.getter({
	    activeScrollAnimator: function() {
	      return this._scrollAnimator;
	    },
	    scrollAnimator: function() {
	      var maximumVelocity;
	      maximumVelocity = this.getWindowSize() * 60 / 2;
	      return this._scrollAnimator || (this._scrollAnimator = this.startAnimator(new ScrollAnimator(this, maximumVelocity)));
	    },
	    debugState: function() {
	      var child, ref, referenceFrame;
	      referenceFrame = this.referenceFrame;
	      return {
	        referenceFrame: {
	          page: (ref = referenceFrame.page) != null ? ref.inspectedName : void 0,
	          atEndEdge: referenceFrame.atEndEdge
	        },
	        pagesBefore: (function() {
	          var j, len, ref1, results;
	          ref1 = this._pagesBeforeBaselineWrapper.children;
	          results = [];
	          for (j = 0, len = ref1.length; j < len; j++) {
	            child = ref1[j];
	            results.push(child.inspectedName + " " + ((this.getMainCoordinate(child.currentSize)) | 0));
	          }
	          return results;
	        }).call(this),
	        pagesAfter: (function() {
	          var j, len, ref1, results;
	          ref1 = this._pagesAfterBaselineWrapper.children;
	          results = [];
	          for (j = 0, len = ref1.length; j < len; j++) {
	            child = ref1[j];
	            results.push(child.inspectedName + " " + ((this.getMainCoordinate(child.currentSize)) | 0));
	          }
	          return results;
	        }).call(this),
	        geometry: this.currentGeometry
	      };
	    }
	  });

	  PagingScrollElement.prototype.gestureRecognize = function(arg) {
	    var delta;
	    delta = arg.delta;
	    if (this._scroll === "vertical") {
	      return 1 > delta.absoluteAspectRatio;
	    } else {
	      return 1 < delta.absoluteAspectRatio;
	    }
	  };

	  PagingScrollElement.prototype.gestureBegin = function(e) {
	    var location, timeStamp;
	    location = e.location, timeStamp = e.timeStamp;
	    this._flickSpeed = 0;
	    this._gestureActive = true;
	    location = this.getMainCoordinate(location);
	    this._pointerReferenceFrame = this._referenceFrame;
	    this._pointerStartPosition = location - this._scrollPosition;
	    this._lastPointerEventTime = timeStamp;
	    if (this.getActiveScrollAnimator()) {
	      this._flicked = false;
	      return timeout(60, (function(_this) {
	        return function() {
	          var referenceFrame, scrollPosition;
	          if (!_this._flicked && _this._gestureActive) {
	            _this._pointerReferenceFrame = _this._referenceFrame;
	            scrollPosition = _this.getPendingScrollPosition();
	            referenceFrame = _this.getPendingReferenceFrame();
	            _this._pointerStartPosition = location - scrollPosition;
	            return _this.getScrollAnimator().startTracking(scrollPosition, referenceFrame);
	          }
	        };
	      })(this));
	    } else {
	      return this.startScrollAnimatorTracking();
	    }
	  };

	  PagingScrollElement.prototype.gestureResume = function(e) {
	    return !!this.getActiveScrollAnimator();
	  };

	  PagingScrollElement.prototype.gestureMove = function(e) {
	    var delta, deltaV, location, scrollAnimator, timeStamp;
	    timeStamp = e.timeStamp, delta = e.delta, location = e.location;
	    location = this.getMainCoordinate(location);
	    delta = this.getMainCoordinate(deltaV = delta);
	    scrollAnimator = this.getScrollAnimator();
	    if (timeStamp > this._lastPointerEventTime) {
	      this._flickSpeed = deltaV.getMagnitude() / (timeStamp - this._lastPointerEventTime);
	      this._flickDirection = (delta / abs(delta)) || 1;
	      this._lastPointerEventTime = timeStamp;
	    }
	    return scrollAnimator.setDesiredScrollPosition(location - this._pointerStartPosition);
	  };

	  PagingScrollElement.prototype.gestureEnd = function(e) {
	    var scrollAnimator;
	    this._gestureActive = false;
	    if (absGt(this._flickSpeed, minimumFlickVelocity)) {
	      scrollAnimator = this.getScrollAnimator();
	      scrollAnimator.addVelocity(this._flickSpeed * this._flickDirection * flickSpeedMultiplier);
	      return this._flicked = true;
	    } else {
	      return this.endScrollAnimatorTracking();
	    }
	  };

	  PagingScrollElement.prototype.startScrollAnimatorTracking = function() {
	    return this.getScrollAnimator().startTracking(this._scrollPosition, this._referenceFrame);
	  };

	  PagingScrollElement.prototype.endScrollAnimatorTracking = function() {
	    var scrollAnimator;
	    if (!(scrollAnimator = this.getActiveScrollAnimator())) {
	      return;
	    }
	    scrollAnimator.setReferenceFrame(this.getReferenceFrame());
	    scrollAnimator.setDesiredScrollPosition(this.getScrollPosition());
	    return scrollAnimator.setActiveTouch(false);
	  };


	  /*
	  When children are set "from outside", we split them based on the @_currentPage and set then as
	  grandchildren - children of the direct, but hidden children:
	    _pagesBeforeBaselineWrapper or
	    _pagesAfterBaselineWrapper
	  
	  Why? This allows us to leverage existing row and column layouts to do most of
	  the heavy lifting for actual element layout.
	   */

	  PagingScrollElement.prototype.setChildren = function(newPages, oldChildren) {
	    var newChildren;
	    if (oldChildren == null) {
	      oldChildren = this.getPendingChildren();
	    }
	    newChildren = !((oldChildren != null ? oldChildren.length : void 0) > 0) ? (this._updateHiddenChildren(), [this._scrollContents]) : oldChildren;
	    this.setPages(newPages);
	    return PagingScrollElement.__super__.setChildren.call(this, newChildren);
	  };

	  PagingScrollElement.prototype._updatePointerReferenceFrame = function(newReferenceFrame) {
	    var delta, ref, ref1;
	    if (!this._pointerReferenceFrame) {
	      return;
	    }
	    delta = this.getReferenceFrameDelta(newReferenceFrame, this._pointerReferenceFrame);
	    this._pointerStartPosition -= delta;
	    if ((ref = this.getActiveScrollAnimator()) != null) {
	      ref.addToDesiredScrollPosition(delta);
	    }
	    return (ref1 = this.getActiveScrollAnimator()) != null ? ref1.setReferenceFrame(this._pointerReferenceFrame = newReferenceFrame) : void 0;
	  };

	  PagingScrollElement.prototype._getPageUnderPosition = function(testPosition) {
	    var child, j, len, ref, relativeTestPosition, size, wrapper;
	    relativeTestPosition = testPosition - this.getScrollPosition();
	    wrapper = relativeTestPosition < 0 ? (relativeTestPosition += this.getMainCoordinate(this._pagesBeforeBaselineWrapper.getCurrentSize()), this._pagesBeforeBaselineWrapper) : this._pagesAfterBaselineWrapper;
	    ref = wrapper.getChildren();
	    for (j = 0, len = ref.length; j < len; j++) {
	      child = ref[j];
	      size = this.getMainCoordinate(child.getCurrentSize());
	      if (relativeTestPosition < size) {
	        return child;
	      }
	      relativeTestPosition -= size;
	    }
	    console.warn("PagingScrollElement#_getPageUnderPosition: could not find page under position");
	    return null;
	  };

	  PagingScrollElement.prototype._updateAtStartAndAtEnd = function() {
	    var newAtEnd, newAtStart, pages, scrollPosition;
	    scrollPosition = this.getScrollPosition();
	    if (this.getTotalPageSize() <= this.getWindowSize()) {
	      newAtStart = true;
	      newAtEnd = false;
	    } else {
	      newAtEnd = scrollPosition <= this.getMinScrollPosition();
	      newAtStart = scrollPosition >= this.getMaxScrollPosition();
	    }
	    pages = this.getPages();
	    if (newAtStart && newAtStart !== this._atStart) {
	      this.setReferenceFrame({
	        page: first(pages)
	      });
	    } else if (newAtEnd && newAtEnd !== this._atEnd) {
	      this.setReferenceFrame({
	        atEndEdge: true,
	        page: last(pages)
	      });
	    }
	    this._atEnd = newAtEnd;
	    this._atStart = newAtStart;
	    return newAtEnd || newAtStart;
	  };

	  PagingScrollElement.prototype._addToScrollPosition = function(delta) {
	    return this.setScrollPosition(this.getPendingScrollPosition() + delta);
	  };


	  /*
	  update currentPage to be the page that overlaps the center-line of the view-window
	  
	  need to:
	    update scrollPosition
	    need to @_setChildren
	   */

	  PagingScrollElement.prototype._updateReferenceFrame = function() {
	    var atEndEdge, centerPosition, newCurrentPage, pageCenterPosition, referenceFrame, scrollPosition;
	    if (this._updateAtStartAndAtEnd()) {
	      return;
	    }
	    scrollPosition = this.getScrollPosition();
	    centerPosition = this.getWindowSize() / 2;
	    newCurrentPage = this._getPageUnderPosition(centerPosition);
	    if (!newCurrentPage) {
	      console.warn("_updateReferenceFrame: no newCurrentPage");
	    }
	    pageCenterPosition = this.getPageCenter(newCurrentPage);
	    atEndEdge = centerPosition > pageCenterPosition;
	    referenceFrame = this.getReferenceFrame();
	    if (referenceFrame.page !== newCurrentPage || referenceFrame.atEndEdge !== atEndEdge) {
	      return this.setReferenceFrame({
	        page: newCurrentPage,
	        atEndEdge: atEndEdge
	      });
	    }
	  };

	  PagingScrollElement.prototype._queueUpdateEvent = function(newReferenceFrame, previousReferenceFrame) {
	    return this.onNextReady((function(_this) {
	      return function() {
	        var referenceFrame;
	        referenceFrame = _this.getReferenceFrame();
	        return _this.queueEvent("scrollUpdate", {
	          previousReferenceFrame: previousReferenceFrame,
	          referenceFrame: referenceFrame,
	          focusedPage: referenceFrame.page,
	          currentGeometry: _this.getCurrentGeometry(),
	          pagesBeforeBaseline: _this.getPagesBeforeBaseline(),
	          pagesAfterBaseline: _this.getPagesAfterBaseline()
	        });
	      };
	    })(this));
	  };

	  PagingScrollElement.prototype._sizeChanged = function(newSize, oldSize) {
	    this._queueUpdateEvent();
	    return PagingScrollElement.__super__._sizeChanged.apply(this, arguments);
	  };

	  PagingScrollElement.prototype._updateHiddenChildren = function(scrollMode) {
	    var commonSizeLayout;
	    if (scrollMode == null) {
	      scrollMode = this.getPendingScroll();
	    }
	    this._scrollContents || (this._scrollContents = new Element({
	      key: "scrollContents",
	      receivePointerEvents: "passToChildren"
	    }, this._pagesBeforeBaselineWrapper = new Element({
	      key: "pagesBeforeBaseline"
	    }), this._pagesAfterBaselineWrapper = new Element({
	      key: "pagesAfterBaseline"
	    })));
	    if (scrollMode === "horizontal") {
	      commonSizeLayout = {
	        hh: 1,
	        wcw: 1
	      };
	      this._pagesBeforeBaselineWrapper.setAxis("topRight");
	      this._pagesBeforeBaselineWrapper.setChildrenLayout("row");
	      this._pagesAfterBaselineWrapper.setChildrenLayout("row");
	    } else {
	      commonSizeLayout = {
	        ww: 1,
	        hch: 1
	      };
	      this._pagesBeforeBaselineWrapper.setAxis("bottomLeft");
	      this._pagesBeforeBaselineWrapper.setChildrenLayout("column");
	      this._pagesAfterBaselineWrapper.setChildrenLayout("column");
	    }
	    this._scrollContents.setSize(commonSizeLayout);
	    this._pagesBeforeBaselineWrapper.setSize(commonSizeLayout);
	    return this._pagesAfterBaselineWrapper.setSize(commonSizeLayout);
	  };

	  return PagingScrollElement;

	})(AnimatorSupport(Element)));


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(242).addModules({
	  FillElement: __webpack_require__(243),
	  OutlineElement: __webpack_require__(244)
	});


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	var Elements, ShapeChildren,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Elements = __webpack_require__(213);

	module.exports = Elements.ShapeChildren || Elements.addNamespace('ShapeChildren', ShapeChildren = (function(superClass) {
	  extend(ShapeChildren, superClass);

	  function ShapeChildren() {
	    return ShapeChildren.__super__.constructor.apply(this, arguments);
	  }

	  return ShapeChildren;

	})(Neptune.Base));


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, Canvas, FillElement, FillableBase, Foundation, GradientFillStyle, createWithPostCreate, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Canvas = __webpack_require__(137);

	FillableBase = __webpack_require__(218);

	log = Foundation.log, createWithPostCreate = Foundation.createWithPostCreate;

	GradientFillStyle = Canvas.GradientFillStyle;

	module.exports = createWithPostCreate(FillElement = (function(superClass) {
	  var _drawOptionsTemp;

	  extend(FillElement, superClass);

	  function FillElement() {
	    return FillElement.__super__.constructor.apply(this, arguments);
	  }

	  FillElement.virtualProperty({
	    preFilteredBaseDrawArea: function(pending) {
	      return this.getParent().getPreFilteredBaseDrawArea(pending);
	    }
	  });


	  /*
	  NOTE:
	  
	  _prepareDrawOptions replaces values, even with null ones.
	  Hence, we prepare two separate draw optons and the merge them.
	   */

	  _drawOptionsTemp = {};

	  FillElement.prototype.drawBasic = function(target, elementToTargetMatrix, compositeMode, opacity) {
	    var base, k, v;
	    if (typeof (base = this._parent)._prepareDrawOptions === "function") {
	      base._prepareDrawOptions(this._drawOptions, compositeMode, opacity);
	    }
	    this._prepareDrawOptions(_drawOptionsTemp, compositeMode, opacity);
	    for (k in _drawOptionsTemp) {
	      v = _drawOptionsTemp[k];
	      if (v) {
	        this._drawOptions[k] = v;
	      }
	    }
	    return this._parent.fillShape(target, elementToTargetMatrix, this._drawOptions);
	  };

	  return FillElement;

	})(FillableBase));


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, Color, FillableBase, Foundation, Matrix, OutlineElement, Point, Rectangle, color, createWithPostCreate, isPlainArray, log, matrix, merge, point, rect,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	FillableBase = __webpack_require__(218);

	merge = Foundation.merge, createWithPostCreate = Foundation.createWithPostCreate, log = Foundation.log, isPlainArray = Foundation.isPlainArray;

	color = Atomic.color, Color = Atomic.Color, point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix;

	module.exports = createWithPostCreate(OutlineElement = (function(superClass) {
	  var validLineCaps, validLineJoins;

	  extend(OutlineElement, superClass);

	  function OutlineElement() {
	    return OutlineElement.__super__.constructor.apply(this, arguments);
	  }

	  validLineCaps = ["butt", "round", "square"];

	  validLineJoins = ["round", "bevel", "miter"];

	  OutlineElement.drawProperty({
	    lineWidth: {
	      "default": 1,
	      validate: function(v) {
	        return typeof v === "number";
	      }
	    },
	    lineCap: {
	      "default": "butt",
	      validate: function(v) {
	        return indexOf.call(validLineCaps, v) >= 0;
	      }
	    },
	    lineJoin: {
	      "default": "miter",
	      validate: function(v) {
	        return indexOf.call(validLineJoins, v) >= 0;
	      }
	    },
	    lineDash: {
	      "default": null,
	      validate: function(v) {
	        return !v || isPlainArray(v);
	      }
	    },
	    filled: {
	      "default": false
	    },
	    miterLimit: {
	      "default": 10,
	      validate: function(v) {
	        return !v || typeof v === "number";
	      },
	      preprocess: function(v) {
	        if (v != null) {
	          return v;
	        } else {
	          return 10;
	        }
	      }
	    }
	  });

	  OutlineElement.virtualProperty({
	    drawAreaPadding: function(pending) {
	      var _lineJoin, _lineWidth, _miterLimit, ref;
	      ref = this.getState(pending), _lineWidth = ref._lineWidth, _lineJoin = ref._lineJoin, _miterLimit = ref._miterLimit;
	      return _lineWidth * (_lineJoin === "miter" ? _miterLimit / 2 : .5);
	    }
	  });

	  OutlineElement.prototype.getPreFilteredBaseDrawArea = function(pending) {
	    return OutlineElement.__super__.getPreFilteredBaseDrawArea.apply(this, arguments).grow(this.getDrawAreaPadding(pending));
	  };

	  OutlineElement.getter({
	    cacheable: function() {
	      return this.getHasChildren();
	    }
	  });

	  OutlineElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
	    if (this._filled) {
	      this._parent.fillShape(target, elementToTargetMatrix, options);
	    }
	    return this._parent.strokeShape(target, elementToTargetMatrix, options);
	  };

	  OutlineElement.prototype._prepareDrawOptions = function(drawOptions, compositeMode, opacity) {
	    OutlineElement.__super__._prepareDrawOptions.apply(this, arguments);
	    drawOptions.lineWidth = this._lineWidth;
	    drawOptions.lineCap = this._lineCap;
	    drawOptions.lineJoin = this._lineJoin;
	    drawOptions.lineDash = this._lineDash;
	    return drawOptions.miterLimit = this._miterLimit;
	  };

	  return OutlineElement;

	})(FillableBase));


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(246).addModules({
	  SynchronizedDomOverlay: __webpack_require__(247),
	  TextInput: __webpack_require__(248)
	});


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	var Engine, Forms,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Engine = __webpack_require__(154);

	module.exports = Engine.Forms || Engine.addNamespace('Forms', Forms = (function(superClass) {
	  extend(Forms, superClass);

	  function Forms() {
	    return Forms.__super__.constructor.apply(this, arguments);
	  }

	  return Forms;

	})(Neptune.Base));


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, Element, Foundation, SynchronizedDomOverlay, float32Eq, inspect, log, merge, point, point1, rect,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Element = __webpack_require__(184);

	log = Foundation.log, merge = Foundation.merge, inspect = Foundation.inspect, float32Eq = Foundation.float32Eq;

	rect = Atomic.rect, point1 = Atomic.point1, point = Atomic.point;

	module.exports = SynchronizedDomOverlay = (function(superClass) {
	  extend(SynchronizedDomOverlay, superClass);

	  function SynchronizedDomOverlay(options) {
	    if (options == null) {
	      options = {};
	    }
	    this._attachedToCanvasElement = null;
	    this._updateQueued = false;
	    this.setDomElement(options.domElement);
	    SynchronizedDomOverlay.__super__.constructor.apply(this, arguments);
	  }

	  SynchronizedDomOverlay.getter({
	    domElement: function() {
	      return this._domElement;
	    }
	  });

	  SynchronizedDomOverlay.setter({
	    domElement: function(domElement) {
	      this._detachDomElement();
	      this._domElement = domElement;
	      this._domElement.style.position = "fixed";
	      this._domElement.style.top = "0";
	      return this.onNextReady((function(_this) {
	        return function() {
	          return _this._attachDomElement();
	        };
	      })(this));
	    }
	  });

	  SynchronizedDomOverlay.prototype.preprocessEventHandlers = function(handlerMap) {
	    return SynchronizedDomOverlay.__super__.preprocessEventHandlers.call(this, merge(handlerMap, {
	      rootElementChanged: (function(_this) {
	        return function(e) {
	          return _this._rootElementChanged(e);
	        };
	      })(this)
	    }));
	  };

	  SynchronizedDomOverlay.prototype._rootElementChanged = function(e) {
	    return this.onNextReady((function(_this) {
	      return function() {
	        return _this._attachDomElement();
	      };
	    })(this));
	  };

	  SynchronizedDomOverlay.prototype._unregister = function() {
	    SynchronizedDomOverlay.__super__._unregister.apply(this, arguments);
	    return this._detachDomElement();
	  };

	  SynchronizedDomOverlay.prototype._queueUpdate = function() {
	    if (this._updateQueued || !this._attachedToCanvasElement) {
	      return;
	    }
	    this._updateQueued = true;
	    return this.onNextReady((function(_this) {
	      return function() {
	        _this._updateQueued = false;
	        _this._updateDomLayout();
	        return _this._queueUpdate();
	      };
	    })(this), false);
	  };

	  SynchronizedDomOverlay.prototype._updateDomLayout = function() {
	    var m, newCanvasElement, opacity, r, size, sx, sy, x, y;
	    if (this._attachedToCanvasElement !== (newCanvasElement = this.getCanvasElement())) {
	      this._attachDomElement(newCanvasElement);
	    }
	    if (!this._attachedToCanvasElement) {
	      return;
	    }
	    m = this.getElementToDocumentMatrix();
	    x = m.getLocationX();
	    y = m.getLocationY();
	    size = this.getPaddedSize();
	    sx = m.getScaleX();
	    sy = m.getScaleY();
	    r = rect(x, y, size.x, size.y).round();
	    opacity = this.getAbsOpacity();
	    this._domElement.style.opacity = opacity;
	    this._domElement.style.left = r.x + "px";
	    this._domElement.style.top = r.y + "px";
	    this._domElement.style.width = r.w + "px";
	    this._domElement.style.height = r.h + "px";
	    return this._domElement.style.transform = !float32Eq(sx, 1) || !float32Eq(sy, 1) ? (this._domElement.style["transform-origin"] = "left top", "scale(" + sx + ", " + sy + ")") : "none";
	  };

	  SynchronizedDomOverlay.prototype._detachDomElement = function() {
	    var ref;
	    if (!this._attachedToCanvasElement) {
	      return;
	    }
	    if ((ref = this._domElement) != null) {
	      ref.parentElement.removeChild(this._domElement);
	    }
	    return this._attachedToCanvasElement = null;
	  };

	  SynchronizedDomOverlay.prototype._attachDomElement = function() {
	    var canvasElement;
	    if (!this.isRegistered) {
	      return;
	    }
	    canvasElement = this.getCanvasElement();
	    if (this._attachedToCanvasElement) {
	      if (canvasElement === this._attachedToCanvasElement) {
	        return;
	      }
	      this._detachDomElement();
	    }
	    if (canvasElement) {
	      this._attachedToCanvasElement = canvasElement;
	      canvasElement.htmlCanvasElement.parentElement.appendChild(this._domElement);
	      return this._queueUpdate();
	    }
	  };

	  return SynchronizedDomOverlay;

	})(Element);


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, Foundation, Input, SynchronizedDomOverlay, TextArea, TextInput, createElementFromHtml, createWithPostCreate, inspect, log, merge, ref, rgbColor, select, timeout, wordsArray,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	SynchronizedDomOverlay = __webpack_require__(247);

	rgbColor = Atomic.rgbColor;

	createElementFromHtml = Foundation.Browser.Dom.createElementFromHtml;

	ref = Foundation.Browser.DomElementFactories, TextArea = ref.TextArea, Input = ref.Input;

	log = Foundation.log, merge = Foundation.merge, select = Foundation.select, inspect = Foundation.inspect, createWithPostCreate = Foundation.createWithPostCreate, wordsArray = Foundation.wordsArray, timeout = Foundation.timeout;

	module.exports = createWithPostCreate(TextInput = (function(superClass) {
	  extend(TextInput, superClass);

	  function TextInput(options) {
	    var Factory, props;
	    if (options == null) {
	      options = {};
	    }
	    props = {
	      placeholder: options.placeholder || "",
	      type: options.type,
	      maxlength: options.maxLength || options.maxlength,
	      autocapitalize: options.autoCapitalize || options.autocapitalize,
	      autocomplete: options.autoComplete || options.autocomplete,
	      autocorrect: options.autoCorrect || options.autocorrect
	    };
	    Factory = props.type === "textarea" ? (delete props.type, TextArea) : (props.type || (props.type = 'text'), Input);
	    options.domElement = Factory(props, options.attrs, options.style, {
	      value: options.value || "",
	      style: {
	        resize: "none",
	        backgroundColor: 'transparent',
	        border: '0px',
	        color: rgbColor(options.color || "black").toString(),
	        fontFamily: options.fontFamily || "Arial",
	        fontSize: (options.fontSize || 16) + "px",
	        margin: "0",
	        outline: "0",
	        padding: "0",
	        textAlign: options.align || "left",
	        verticalAlign: "bottom"
	      },
	      on: {
	        keydown: (function(_this) {
	          return function(keyboardEvent) {
	            var ref1;
	            return (ref1 = _this.getCanvasElement()) != null ? ref1.keyDownEvent(keyboardEvent) : void 0;
	          };
	        })(this),
	        keyup: (function(_this) {
	          return function(keyboardEvent) {
	            var ref1;
	            return (ref1 = _this.getCanvasElement()) != null ? ref1.keyUpEvent(keyboardEvent) : void 0;
	          };
	        })(this),
	        change: (function(_this) {
	          return function(event) {
	            return _this.checkIfValueChanged();
	          };
	        })(this),
	        input: (function(_this) {
	          return function(event) {
	            return _this.checkIfValueChanged();
	          };
	        })(this),
	        select: (function(_this) {
	          return function(event) {
	            return _this.queueEvent("selectionChanged");
	          };
	        })(this),
	        focus: (function(_this) {
	          return function(event) {
	            _this._canvasElementToFocusOnBlur = _this.getCanvasElement();
	            return _this._focus();
	          };
	        })(this),
	        blur: (function(_this) {
	          return function(event) {
	            if (_this._canvasElementToFocusOnBlur) {
	              timeout(0, function() {
	                if (document.body === document.activeElement) {
	                  return _this._canvasElementToFocusOnBlur.focusCanvas();
	                }
	              });
	            }
	            return _this._blur();
	          };
	        })(this)
	      }
	    });
	    TextInput.__super__.constructor.apply(this, arguments);
	    this.willConsumeKeyboardEvent = {
	      order: "beforeAncestors",
	      allowBrowserDefault: true
	    };
	    this.lastValue = this.value;
	  }

	  TextInput.prototype.preprocessEventHandlers = function(handlerMap) {
	    return merge(TextInput.__super__.preprocessEventHandlers.apply(this, arguments), {
	      focus: (function(_this) {
	        return function() {
	          if (!_this.domElement.focused) {
	            return _this.domElement.focus();
	          }
	        };
	      })(this),
	      blur: (function(_this) {
	        return function() {
	          if (_this.domElement.focused) {
	            return _this.domElement.blur();
	          }
	        };
	      })(this),
	      keyPress: (function(_this) {
	        return function(arg) {
	          var props;
	          props = arg.props;
	          if (props.key === "Enter") {
	            _this.handleEvent("enter", {
	              value: _this.value
	            });
	          }
	          if (props.key === "Escape") {
	            return _this.handleEvent("escape", {
	              value: _this.value
	            });
	          }
	        };
	      })(this)
	    });
	  };

	  TextInput.prototype._unregister = function() {
	    var ref1;
	    if ((ref1 = this._canvasElementToFocusOnBlur) != null) {
	      ref1.focusCanvas();
	    }
	    return TextInput.__super__._unregister.apply(this, arguments);
	  };

	  TextInput.prototype.checkIfValueChanged = function() {
	    if (this.lastValue !== this.value) {
	      this.lastValue = this.value;
	      return this.queueEvent("valueChanged", {
	        value: this.value,
	        lastValue: this.lastValue
	      });
	    }
	  };

	  TextInput.virtualProperty({
	    value: {
	      getter: function(pending) {
	        return this.domElement.value;
	      },
	      setter: function(v) {
	        v = v != null ? "" + v : "";
	        if (this.domElement.value !== v) {
	          return this.domElement.value = v;
	        }
	      }
	    },
	    color: {
	      getter: function() {
	        return rgbColor(this.domElement.style.color);
	      },
	      setter: function(c) {
	        self.domElement = this.domElement;
	        return this.domElement.style.color = rgbColor(c).toString();
	      }
	    }
	  });

	  TextInput.prototype.selectAll = function() {
	    return this.domElement.select();
	  };

	  return TextInput;

	})(SynchronizedDomOverlay));


/***/ },
/* 249 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-canvas": "git://github.com/imikimi/art-canvas.git",
			"art-events": "git://github.com/imikimi/art-events.git",
			"art-foundation": "git://github.com/imikimi/art-foundation.git",
			"art-text": "git://github.com/imikimi/art-text.git",
			"art-xbd": "git://github.com/imikimi/art-xbd.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"javascript-detect-element-resize": "^0.5.3",
			"json-loader": "^0.5.4",
			"keyboardevent-key-polyfill": "^1.0.2",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.5.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"license": "ISC",
		"name": "art-engine",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "1.15.1"
	};

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, FullScreenApp, Meta, Promise, log, parseQuery;

	Foundation = __webpack_require__(19);

	Promise = Foundation.Promise, parseQuery = Foundation.parseQuery, log = Foundation.log;

	Meta = Foundation.Browser.DomElementFactories.Meta;

	module.exports = FullScreenApp = (function() {
	  function FullScreenApp() {}

	  FullScreenApp._domReady = function() {
	    var DomConsole, Engine, query;
	    Engine = __webpack_require__(152);
	    query = parseQuery();
	    log("Art.Engine.FullScreenApp options:\n  ?dev=true\n    show DomConsole\n  ?perfGraphs=true\n    show performance graphs");
	    if (query.dev === "true" || query.perfGraphs === "true") {

	      /*
	      TODO:
	      this indirectly requires jquery...
	      1) dom-console doesn't really need jquery, it just needs a refactor
	      2) I'd like a way to easily build production vs dev code.
	      3) DomConsole should only be included in dev code.
	       */
	      DomConsole = __webpack_require__(251);
	      DomConsole.enable();
	      if (query.perfGraphs === "true") {
	        Engine.DevTools.GlobalEpochStats.enable();
	      }
	    }
	    return log("Art.Engine.FullScreenApp: app ready");
	  };

	  FullScreenApp.init = function(config) {
	    var appReadyPromise;
	    if (config == null) {
	      config = {};
	    }
	    document.onreadystatechange = (function(_this) {
	      return function() {
	        if (document.readyState === "interactive") {
	          _this._domReady();
	          return appReadyPromise.resolve();
	        }
	      };
	    })(this);
	    module.exports = appReadyPromise = new Promise;
	    this.writeDom(config);
	    return appReadyPromise;
	  };

	  FullScreenApp.writeDom = function(arg) {
	    var content, fontFamilies, fontFamily, fontFamilyInits, html, name, nameContentMetas, newLine, scriptLinks, scriptUrl, scripts, sheetUrl, styleSheetLinks, styleSheets, title;
	    title = arg.title, styleSheets = arg.styleSheets, scripts = arg.scripts, fontFamilies = arg.fontFamilies;
	    document.title = title || "Art App";
	    scripts || (scripts = []);
	    styleSheets || (styleSheets = []);
	    fontFamilies || (fontFamilies = []);
	    styleSheetLinks = (function() {
	      var i, len, results;
	      results = [];
	      for (i = 0, len = styleSheets.length; i < len; i++) {
	        sheetUrl = styleSheets[i];
	        results.push("<link rel='stylesheet' href='" + sheetUrl + "' />");
	      }
	      return results;
	    })();
	    scriptLinks = (function() {
	      var i, len, results;
	      results = [];
	      for (i = 0, len = scripts.length; i < len; i++) {
	        scriptUrl = scripts[i];
	        if (scriptUrl) {
	          results.push("<script type='text/javascript' src='" + scriptUrl + "'></script>");
	        }
	      }
	      return results;
	    })();

	    /*
	    To include an external font:
	    
	      Make sure you load your font with @font-face first in one of the included styleSheets.
	      Make sure you add the font-family string specified in your font-face definition to the fontFamilies list.
	    
	    This is needed to ensure the font loads.
	    TODO: should we us an actual font-loader?
	     */
	    fontFamilyInits = (function() {
	      var i, len, results;
	      results = [];
	      for (i = 0, len = fontFamilies.length; i < len; i++) {
	        fontFamily = fontFamilies[i];
	        results.push("<div style='font-family:" + fontFamily + ";position:absolute;font-size:0;'>T</div>");
	      }
	      return results;
	    })();
	    newLine = "\n    ";
	    nameContentMetas = {
	      "viewport": "user-scalable=no, width=device-width, initial-scale=1.0",
	      "apple-mobile-web-app-capable": "yes",
	      "apple-mobile-web-app-status-bar-style": "black-translucent",
	      "format-detection": "telephone=no"
	    };
	    document.head.appendChild(Meta({
	      charset: "utf-8"
	    }));
	    document.head.appendChild(Meta({
	      "http-equiv": "X-UA-Compatible",
	      content: "IE=edge,chrome=1"
	    }));
	    for (name in nameContentMetas) {
	      content = nameContentMetas[name];
	      document.head.appendChild(Meta({
	        name: name,
	        content: content
	      }));
	    }
	    html = "<html>\n  <head>\n    " + (styleSheetLinks.join(newLine)) + "\n  </head>\n\n  <style>\n    html {\n      height: 100%;\n    }\n    body {\n      padding: 0px;\n      margin: 0px;\n      background-color: #eee;\n      overflow: hidden;\n      font-size: 0px;\n      height: 100%;\n    }\n  </style>\n\n  <body>\n    " + (fontFamilyInits.join(newLine)) + "\n    " + (scriptLinks.join(newLine)) + "\n  </body>\n</html>";
	    return document.write(html);
	  };

	  return FullScreenApp;

	})();


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(252);


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(253).includeInNamespace(__webpack_require__(255)).addModules({
	  Chart: __webpack_require__(265),
	  Console: __webpack_require__(256),
	  ToolBar: __webpack_require__(261)
	});

	__webpack_require__(262);


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	var DevTools, DomConsole,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	DevTools = __webpack_require__(254);

	module.exports = DevTools.DomConsole || DevTools.addNamespace('DomConsole', DomConsole = (function(superClass) {
	  extend(DomConsole, superClass);

	  function DomConsole() {
	    return DomConsole.__super__.constructor.apply(this, arguments);
	  }

	  return DomConsole;

	})(Neptune.Base));


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	var Art, DevTools,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(22);

	module.exports = Art.DevTools || Art.addNamespace('DevTools', DevTools = (function(superClass) {
	  extend(DevTools, superClass);

	  function DevTools() {
	    return DevTools.__super__.constructor.apply(this, arguments);
	  }

	  return DevTools;

	})(Neptune.Base));


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, console,
	  slice = [].slice;

	Foundation = __webpack_require__(19);

	console = __webpack_require__(256).console;

	module.exports = [
	  {
	    enable: function() {
	      Foundation.Log.alternativeLogger = console;
	      this.enabled = true;
	      return console.show();
	    },
	    disable: function() {
	      this.enabled = false;
	      Foundation.Log.alternativeLogger = null;
	      console.hide();
	      return console.reset();
	    },
	    hide: function() {
	      return console.hide();
	    },
	    show: function() {
	      return console.show();
	    },
	    reset: function() {
	      return console.reset();
	    },
	    increaseWidth: function() {
	      return console.increaseWidth();
	    },
	    decreaseWidth: function() {
	      return console.decreaseWidth();
	    },
	    foo: function() {
	      return "foo";
	    },
	    getShown: function() {
	      return console != null ? console.getShown() : void 0;
	    },
	    logCore: function() {
	      var ref;
	      return (ref = console.logCore).call.apply(ref, [console].concat(slice.call(arguments)));
	    },
	    logF: function() {
	      var ref;
	      return (ref = console.logF).call.apply(ref, [console].concat(slice.call(arguments)));
	    },
	    log: function() {
	      var ref;
	      return (ref = console.log).call.apply(ref, [console].concat(slice.call(arguments)));
	    }
	  }
	];


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	To customize how an object shows up in the DOM console, add
	getInspectedObjects member method. For more info, see base_object.coffee
	 */
	var Atomic, BaseObject, Color, Console, Div, Foundation, Img, InspectedObjectLiteral, Li, Map, Pre, Promise, Span, ToolBar, Ul, clone, colorRegex, containsImages, containsPromises, createWithPostCreate, deepAll, deepEach, deepMap, domConsoleId, escapeJavascriptString, flatten, hasProperties, htmlEscape, insertBetweenEveryElement, inspect, inspectLean, isArray, isFunction, isHTMLImageElement, isImage, isNumber, isPlainArray, isPlainObject, isString, merge, nextTick, objectKeyCount, packageLogArgs, point, point0, ref, resolveImages, rgbColor, timeout, toInspectedObjects,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  slice = [].slice;

	if (self.document) {
	  __webpack_require__(257);
	}

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	ToolBar = __webpack_require__(261);

	rgbColor = Atomic.rgbColor, Color = Atomic.Color, point = Atomic.point, point0 = Atomic.point0;

	BaseObject = Foundation.BaseObject, inspect = Foundation.inspect, clone = Foundation.clone, merge = Foundation.merge, Map = Foundation.Map, nextTick = Foundation.nextTick, timeout = Foundation.timeout, flatten = Foundation.flatten, isArray = Foundation.isArray, isString = Foundation.isString, isFunction = Foundation.isFunction, isNumber = Foundation.isNumber, createWithPostCreate = Foundation.createWithPostCreate, colorRegex = Foundation.colorRegex, Promise = Foundation.Promise, containsPromises = Foundation.containsPromises, deepAll = Foundation.deepAll, toInspectedObjects = Foundation.toInspectedObjects, isPlainArray = Foundation.isPlainArray, isPlainObject = Foundation.isPlainObject, hasProperties = Foundation.hasProperties, objectKeyCount = Foundation.objectKeyCount, InspectedObjectLiteral = Foundation.InspectedObjectLiteral, deepEach = Foundation.deepEach, deepMap = Foundation.deepMap, inspectLean = Foundation.inspectLean, escapeJavascriptString = Foundation.escapeJavascriptString;

	isHTMLImageElement = global.HTMLImageElement ? function(obj) {
	  return obj instanceof HTMLImageElement;
	} : function() {
	  return false;
	};

	isImage = function(o) {
	  return isHTMLImageElement(o) || isFunction(o.toImage);
	};

	containsImages = function(plainStructure) {
	  var foundImages;
	  foundImages = false;
	  deepEach(plainStructure, function(v) {
	    return foundImages || (foundImages = isImage(v));
	  });
	  return foundImages;
	};

	resolveImages = function(plainStructure) {
	  return deepAll(deepMap(plainStructure, function(element) {
	    if (!isImage(element)) {
	      return element;
	    }
	    return Promise.then(function() {
	      if (isHTMLImageElement(element)) {
	        return element;
	      } else {
	        return element.toImage();
	      }
	    }).then(function(htmlImageElement) {
	      htmlImageElement;
	      if (htmlImageElement.complete) {
	        return htmlImageElement;
	      } else {
	        return new Promise(function(resolve) {
	          return htmlImageElement.onload = function() {
	            return resolve(htmlImageElement);
	          };
	        });
	      }
	    });
	  }));
	};

	ref = Foundation.Browser.DomElementFactories, Div = ref.Div, Pre = ref.Pre, Span = ref.Span, Img = ref.Img, Li = ref.Li, Ul = ref.Ul;

	isImage = function(o) {
	  return o && ((typeof o.toImage === "function") || o.constructor === HTMLImageElement);
	};

	htmlEscape = function(str) {
	  return str;
	};

	insertBetweenEveryElement = function(array, el) {
	  var first, j, len, res, v;
	  res = [];
	  first = true;
	  for (j = 0, len = array.length; j < len; j++) {
	    v = array[j];
	    if (first) {
	      first = false;
	    } else {
	      res.push(el);
	    }
	    res.push(v);
	  }
	  return res;
	};

	domConsoleId = 'artDomConsole';

	packageLogArgs = function(args) {
	  if (args.length === 1) {
	    return args[0];
	  } else {
	    return args;
	  }
	};

	module.exports = createWithPostCreate(Console = (function(superClass) {
	  var isColor, literalToDomHelper, logCount, logSerializer, noOptions, toggleCollapsable;

	  extend(Console, superClass);

	  Console.singletonClass();

	  Console.postCreate = function() {
	    self.domConsole = this.singleton;
	    return Console.__super__.constructor.postCreate.apply(this, arguments);
	  };

	  function Console() {
	    window.domConsole = this;
	    this._width = 500;
	    this._devicePixelRatio = Foundation.Browser.Dom.getDevicePixelRatio();
	    this.initDom();
	  }

	  Console.prototype.reset = function() {
	    return this.domContainer.innerHTML = "";
	  };

	  Console.prototype.hide = function() {
	    return this.domConsoleParent.style.display = "none";
	  };

	  Console.prototype.show = function() {
	    return this.domConsoleParent.style.display = "block";
	  };

	  Console.prototype.increaseWidth = function() {
	    return this.width += 25;
	  };

	  Console.prototype.decreaseWidth = function() {
	    return this.width -= 25;
	  };

	  Console.getter({
	    shown: function() {
	      return this.domContainer.style.display === "block";
	    }
	  });

	  toggleCollapsable = function(el) {
	    var child, j, len, ref1;
	    ref1 = el.parentElement.children;
	    for (j = 0, len = ref1.length; j < len; j++) {
	      child = ref1[j];
	      child.style.display = "block";
	    }
	    return el.style.display = "none";
	  };

	  Console.setter({
	    width: function(w) {
	      this._width = w;
	      return this.domConsoleParent.style.width = w + "px";
	    }
	  });

	  Console.getter("width");

	  Console.prototype.initDom = function() {
	    var bodyChildren, child, delay, fixMochaStats, maxAttempts, mocha;
	    mocha = document.getElementById("mocha");
	    bodyChildren = (function() {
	      var j, len, ref1, results;
	      ref1 = document.body.childNodes;
	      results = [];
	      for (j = 0, len = ref1.length; j < len; j++) {
	        child = ref1[j];
	        results.push(child);
	      }
	      return results;
	    })();
	    document.body.appendChild(Div(null, Div({
	      style: {
	        display: "flex",
	        flexDirection: "row",
	        position: "fixed",
	        left: "0",
	        right: "0",
	        top: "0",
	        bottom: "0"
	      }
	    }, Div({
	      id: domConsoleId + "Area",
	      style: {
	        flex: "1 1 auto",
	        overflow: "scroll"
	      }
	    }, bodyChildren), this.domConsoleParent = Div({
	      style: {
	        overflow: "auto",
	        backgroundColor: "white",
	        top: "0",
	        bottom: "0",
	        paddingTop: "25px",
	        flex: "0 0 auto",
	        width: this._width + "px",
	        borderLeft: "1px solid #aaa"
	      }
	    }, this.domContainer = Div({
	      "class": "domConsole",
	      style: {
	        padding: "5px"
	      },
	      on: {
	        click: (function(_this) {
	          return function(arg) {
	            var results, target;
	            target = arg.target;
	            results = [];
	            while (target) {
	              if (target.className.match("collapsable")) {
	                toggleCollapsable(target);
	                break;
	              }
	              results.push(target = target.parentElement);
	            }
	            return results;
	          };
	        })(this)
	      }
	    }))), ToolBar()));
	    if (mocha) {
	      maxAttempts = 8;
	      delay = 125 / 2;
	      fixMochaStats = function() {
	        var ms;
	        if (!maxAttempts--) {
	          console.log("domConsoleMocha fixMochaStats... giving up; sorry for the ugly screen");
	          return;
	        }
	        delay *= 2;
	        if (ms = document.getElementById("mocha-stats")) {
	          return ms.style.position = "relative";
	        } else {
	          console.log("domConsoleMocha fixMochaStats... (waiting " + delay + "ms for #mocha-stats div to appear: " + maxAttempts + ")");
	          return timeout(delay, fixMochaStats);
	        }
	      };
	      return timeout(delay, fixMochaStats);
	    }
	  };

	  Console.prototype.appendLog = function(domElement) {
	    this.domContainer.appendChild(Div({
	      "class": "logLine"
	    }, domElement));
	    return nextTick((function(_this) {
	      return function() {
	        return _this.domConsoleParent.scrollTop = _this.domConsoleParent.scrollHeight;
	      };
	    })(this));
	  };

	  Console.prototype.log = function() {
	    var args;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    this.logCore(packageLogArgs(args));
	    return args[args.length - 1];
	  };

	  Console.prototype.logF = function(options) {
	    this.logCore(options.log, null, null, options);
	    return options.log;
	  };

	  Console.prototype.format = function(domEl, options) {
	    var backgroundColor, label, labelColor;
	    label = options.label, labelColor = options.labelColor, backgroundColor = options.backgroundColor;
	    if (label) {
	      domEl = Div({
	        style: {
	          backgroundColor: backgroundColor || "yellow"
	        }
	      }, Div(label, {
	        style: {
	          color: labelColor,
	          fontWeight: "bold"
	        }
	      }), Div({
	        style: {
	          paddingLeft: "10px"
	        }
	      }, domEl));
	    }
	    return domEl;
	  };

	  Console.prototype.arrayKidsToDomArray = function(arrayOfInspectedObjects, Factory, options, addCommasAndBrackets) {
	    var child, i, kids;
	    options.maxDepth--;
	    kids = (function() {
	      var j, len, results;
	      results = [];
	      for (i = j = 0, len = arrayOfInspectedObjects.length; j < len; i = ++j) {
	        child = arrayOfInspectedObjects[i];
	        if (i > 50) {
	          break;
	        }
	        if (i === 50) {
	          results.push(Factory({
	            "class": "value"
	          }, "array length: " + arrayOfInspectedObjects.length + " (showing the first " + i + ")"));
	        } else {
	          results.push(Factory({
	            "class": "value"
	          }, this.toDom(child, options)));
	        }
	      }
	      return results;
	    }).call(this);
	    options.maxDepth++;
	    if (addCommasAndBrackets) {
	      kids = this.addCommasAndBrackets(kids, "[", "]");
	    }
	    return kids;
	  };

	  Console.prototype.arrayToDomBasic = function(arrayOfInspectedObjects, options) {
	    var l;
	    if (options.maxDepth === 0) {
	      return Span({
	        "class": "array maxdepth " + options["class"]
	      }, arrayOfInspectedObjects.length === 0 ? "[]" : arrayOfInspectedObjects.length <= 5 && (l = inspectLean(arrayOfInspectedObjects)).length <= 30 ? "[" + l + "]" : "[... " + arrayOfInspectedObjects.length + "]");
	    }
	    return Span({
	      "class": "array " + options["class"]
	    }, this.arrayKidsToDomArray(arrayOfInspectedObjects, Span, options, true));
	  };

	  Console.prototype.arrayToDom = function(arrayOfInspectedObjects, options) {
	    if (options.treeView) {
	      return this.arrayToDomTreeView(arrayOfInspectedObjects, options);
	    } else {
	      return this.arrayToDomBasic(arrayOfInspectedObjects, options);
	    }
	  };

	  Console.prototype.addCommasAndBrackets = function(kids, leftBracket, rightBracket, typeName) {
	    var i, j, kid, len;
	    for (i = j = 0, len = kids.length; j < len; i = ++j) {
	      kid = kids[i];
	      if (i + 1 < kids.length) {
	        kid.appendChild(Span(", "));
	      }
	    }
	    return flatten(leftBracket, typeName, kids, rightBracket);
	  };

	  Console.prototype.mapKidsToDomArray = function(inspectedObject, Factory, options, addCommasAndBrackets) {
	    var k, kids, v;
	    options.maxDepth--;
	    kids = (function() {
	      var results;
	      results = [];
	      for (k in inspectedObject) {
	        v = inspectedObject[k];
	        results.push(Factory(null, Span({
	          "class": "key"
	        }, k + ": "), Span({
	          "class": "value"
	        }, this.toDom(v, options))));
	      }
	      return results;
	    }).call(this);
	    options.maxDepth++;
	    if (addCommasAndBrackets) {
	      return this.addCommasAndBrackets(kids, "{", "}");
	    } else {
	      return kids;
	    }
	  };

	  Console.prototype.objectToDomBasic = function(inspectedObject, options) {
	    var inside, l, length;
	    if (options.maxDepth === 0) {
	      length = objectKeyCount(inspectedObject);
	      inside = length === 0 ? "" : length <= 5 ? (l = inspectLean(inspectedObject)).length <= 40 ? l : Object.keys(inspectedObject).join(' ') : "" + length;
	      return Span({
	        "class": "object maxdepth " + options["class"]
	      }, "{" + inside + "}");
	    }
	    return Span({
	      "class": "object"
	    }, this.mapKidsToDomArray(inspectedObject, Span, options, true));
	  };

	  Console.prototype.treeViewCollapsable = function(collapsablePair, options) {
	    collapsablePair[options.collapsed ? 0 : 1].style.display = "none";
	    return collapsablePair;
	  };

	  Console.prototype.arrayToDomTreeView = function(arrayOfInspectedObjects, options) {
	    if (arrayOfInspectedObjects.length === 0) {
	      return Span({
	        "class": "array"
	      }, "[]");
	    }
	    return this.treeViewCollapsable([
	      Ul({
	        "class": "array collapsable open"
	      }, this.arrayKidsToDomArray(arrayOfInspectedObjects, Li, options)), Ul({
	        "class": "array collapsable closed"
	      }, this.arrayToDomBasic(arrayOfInspectedObjects, merge(options, {
	        maxDepth: 1,
	        treeView: false
	      })))
	    ], options);
	  };

	  Console.prototype.objectToDomTreeView = function(inspectedObject, options) {
	    if (!hasProperties(inspectedObject)) {
	      return Span({
	        "class": "object"
	      }, "{}");
	    }
	    return this.treeViewCollapsable([
	      Ul({
	        "class": "object collapsable open"
	      }, this.mapKidsToDomArray(inspectedObject, Li, options)), Ul({
	        "class": "object collapsable closed"
	      }, this.objectToDomBasic(inspectedObject, merge(options, {
	        maxDepth: 1,
	        treeView: false
	      })))
	    ], options);
	  };

	  Console.prototype.objectToDom = function(inspectedObject, options) {
	    if (options.treeView) {
	      return this.objectToDomTreeView(inspectedObject, options);
	    } else {
	      return this.objectToDomBasic(inspectedObject, options);
	    }
	  };

	  literalToDomHelper = function(classes, literalString) {
	    var Factory;
	    Factory = literalString.match(/\s\s+|\n/) ? Pre : Span;
	    return Factory({
	      "class": classes
	    }, literalString);
	  };

	  Console.prototype.literalToDom = function(inspectedObject) {
	    return literalToDomHelper("literal", isString(inspectedObject) ? escapeJavascriptString(inspectedObject) : "" + inspectedObject);
	  };

	  Console.prototype.errorLiteralToDom = function(inspectedObject) {
	    return literalToDomHelper("errorLiteral", inspectedObject.toString());
	  };

	  Console.prototype.colorToDom = function(clr) {
	    var clrString, displayString;
	    displayString = isString(clrString = clr) ? (clr = rgbColor(clr), "'" + clrString + "'") : clr.toString();
	    return Span({
	      "class": "inspected",
	      style: {
	        backgroundColor: clr,
	        padding: "0 5px",
	        color: clr.perceptualLightness < .8 && clr.a > .25 ? 'white' : 'black'
	      }
	    }, "" + displayString);
	  };

	  Console.prototype.imgToDom = function(image) {
	    var maxImageDisplaySize, minImageDisplaySize, scale, size;
	    minImageDisplaySize = point(0);
	    maxImageDisplaySize = point(1024, 512).mul(this._devicePixelRatio);
	    size = point(image.width, image.height);
	    scale = 1 / this._devicePixelRatio;
	    if (!size.gte(minImageDisplaySize)) {
	      scale *= Math.ceil(minImageDisplaySize.div(size).min());
	    } else if (!size.lt(maxImageDisplaySize)) {
	      scale *= maxImageDisplaySize.div(size).min();
	    }
	    return Img({
	      src: image.src
	    }, size.gt(point0) ? {
	      style: {
	        width: (image.naturalWidth * scale | 0) + "px",
	        height: (image.naturalHeight * scale | 0) + "px"
	      }
	    } : void 0);
	  };

	  isColor = function(obj) {
	    return (obj instanceof Color) || (isString(obj) && obj.match(colorRegex));
	  };

	  Console.prototype.toDom = function(inspectedObject, options) {
	    if (options == null) {
	      options = {};
	    }
	    if (inspectedObject == null) {
	      return this.literalToDom(inspectedObject);
	    } else if (inspectedObject instanceof InspectedObjectLiteral) {
	      if (isColor(inspectedObject.literal)) {
	        return this.colorToDom(inspectedObject.literal);
	      } else if (inspectedObject.isError) {
	        console.error(inspectedObject.literal);
	        return this.errorLiteralToDom(inspectedObject.literal);
	      } else {
	        return literalToDomHelper("literal", inspectedObject.literal);
	      }
	    } else if (isHTMLImageElement(inspectedObject)) {
	      return this.imgToDom(inspectedObject);
	    } else if (isColor(inspectedObject)) {
	      return this.colorToDom(inspectedObject);
	    } else if (isPlainArray(inspectedObject)) {
	      return this.arrayToDom(inspectedObject, options);
	    } else if (isPlainObject(inspectedObject)) {
	      return this.objectToDom(inspectedObject, options);
	    } else {
	      return this.literalToDom(inspectedObject);
	    }
	  };

	  logSerializer = new Promise.Serializer;

	  logCount = 1;

	  noOptions = {};

	  Console.prototype.logCore = function(m, callStack, options) {
	    var formatSystemMessage, hasPromises, localLogCount, ret;
	    if (options == null) {
	      options = noOptions;
	    }
	    formatSystemMessage = function(params) {
	      var failure, pending, success;
	      success = params.success, failure = params.failure, pending = params.pending;
	      return {
	        backgroundColor: failure ? "#fff0f0" : "white",
	        labelColor: success ? "green" : failure ? "#a00" : pending ? "blue" : void 0,
	        label: (success || failure || pending) + ": (log #" + localLogCount + ")"
	      };
	    };
	    localLogCount = logCount;
	    if (hasPromises = containsPromises(m)) {
	      options = merge(options, formatSystemMessage({
	        pending: "RESOLVING PROMISES"
	      }));
	    }
	    if (options.isError) {
	      options = merge(options, formatSystemMessage({
	        failure: "ERROR"
	      }));
	    }
	    ret = logSerializer.then((function(_this) {
	      return function() {
	        var maxDepth;
	        options.treeView = true;
	        maxDepth = options.maxDepth;
	        if (!isNumber(maxDepth)) {
	          maxDepth = 20;
	        }
	        if (typeof m === "string" && !m.match(colorRegex)) {
	          return _this.appendLog(_this.format(Pre(m), options));
	        } else {
	          return Promise.then(function() {
	            var inspected;
	            if (containsImages(inspected = toInspectedObjects(m))) {
	              return resolveImages(inspected);
	            } else {
	              return inspected;
	            }
	          }).then(function(inspected) {
	            var domEl;
	            domEl = _this.toDom(inspected, options);
	            return _this.appendLog(_this.format(domEl, options));
	          });
	        }
	      };
	    })(this));
	    logSerializer["catch"](function(e) {
	      return console.error("Error in DomConsole.Console", e);
	    });
	    if (hasPromises) {
	      deepAll(m, function(promiseResult) {
	        return {
	          'promise.then': promiseResult
	        };
	      }).then((function(_this) {
	        return function(resolvedM) {
	          return _this.logCore(resolvedM, callStack, merge(options, formatSystemMessage({
	            success: "ALL PROMISES RESOLVED"
	          })));
	        };
	      })(this))["catch"]((function(_this) {
	        return function(rejected) {
	          return _this.logCore(rejected, callStack, merge(options, formatSystemMessage({
	            failure: "ONE OR MORE PROMISES WERE REJECTED"
	          })));
	        };
	      })(this));
	    }
	    logCount++;
	    return ret;
	  };

	  return Console;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(258);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(260)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../../node_modules/css-loader/index.js!./style.css", function() {
				var newContent = require("!!./../../../../../node_modules/css-loader/index.js!./style.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(259)();
	// imports


	// module
	exports.push([module.id, "@charset \"UTF-8\";\n.domConsole {\n  }\n  .domConsole img {\n    image-rendering: -moz-crisp-edges;\n    image-rendering: -o-crisp-edges;\n    image-rendering: -webkit-optimize-contrast;\n    image-rendering: crisp-edges;\n    -ms-interpolation-mode: nearest-neighbor;\n    border: 1px solid rgba(255, 255, 255, 0); }\n    .domConsole img:hover {\n      border: 1px solid #bbbbbb; }\n  .domConsole ul {\n    list-style-type: none; }\n  .domConsole .collapsable {\n    cursor: pointer;\n    margin: 0;\n    padding: 0;\n    padding-left: 12px;\n    margin-bottom: 5px;\n    position: relative;\n    border-left: 1px solid transparent; }\n    .domConsole .collapsable:before {\n      content: \"\\25BE\";\n      position: absolute;\n      left: 2px;\n      top: 0;\n      bottom: 0; }\n    .domConsole .collapsable:hover {\n      border-left: 1px solid #cccc44;\n      border-radius: 5px; }\n  .domConsole .collapsable.closed {\n    overflow: hidden;\n    height: 14px;\n  }\n  .domConsole .collapsable.closed.array:before {\n    content: \"\\25B9\"; }\n  .domConsole .collapsable.open.array:before {\n    content: \"\\25BF\"; }\n  .domConsole .collapsable.closed.object:before {\n    content: \"\\25B8\"; }\n  .domConsole .collapsable.open.object:before {\n    content: \"\\25BE\"; }\n  .domConsole pre {\n    margin: 0;\n    color: #555555; }\n  .domConsole .logLine {\n    font-family: \"Courier\";\n    font-size: 12px;\n    color: #aaaaaa;\n    border-right: 2px solid transparent; }\n    .domConsole .logLine .literal {\n      color: green; }\n    .domConsole .logLine .errorLiteral {\n      color: red; }\n    .domConsole .logLine .object .key {\n      color: #bbbb00; }\n    .domConsole .logLine:hover {\n      border-right: 2px solid #e0e0e0; }\n  .domConsole h1 {\n    margin-bottom: 20px;\n    margin-top: 40px; }\n  .domConsole h2 {\n    margin-bottom: 15px;\n    margin-top: 30px; }\n  .domConsole h3 {\n    margin-bottom: 10px;\n    margin-top: 20px; }\n  .domConsole h1 .logLine {\n    font-size: 24px;\n    border-bottom: 4px solid #e0e0e0; }\n  .domConsole h2 .logLine {\n    font-size: 20px;\n    border-bottom: 3px solid #e0e0e0; }\n  .domConsole h3 .logLine {\n    font-size: 16px;\n    border-bottom: 2px solid #e0e0e0; }\n", ""]);

	// exports


/***/ },
/* 259 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;

		if(media) {
			styleElement.setAttribute("media", media)
		}

		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}

	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;

		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		var blob = new Blob([css], { type: "text/css" });

		var oldSrc = linkElement.href;

		linkElement.href = URL.createObjectURL(blob);

		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	To customize how an object shows up in the DOM console, add
	getInspectedObjects member method. For more info, see base_object.coffee
	 */
	var A, BaseObject, Component, Div, DomConsole, Foundation, ToolBar, createWithPostCreate, ref, wordsArray,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	DomConsole = __webpack_require__(253);

	Component = __webpack_require__(262).Component;

	BaseObject = Foundation.BaseObject, createWithPostCreate = Foundation.createWithPostCreate, wordsArray = Foundation.wordsArray;

	ref = Foundation.Browser.DomElementFactories, Div = ref.Div, A = ref.A;

	module.exports = createWithPostCreate(ToolBar = (function(superClass) {
	  extend(ToolBar, superClass);

	  function ToolBar() {
	    return ToolBar.__super__.constructor.apply(this, arguments);
	  }

	  ToolBar.prototype.render = function() {
	    var action, shown;
	    shown = this.state.shown;
	    return Div({
	      style: {
	        position: "fixed",
	        top: 0,
	        right: 0,
	        display: "flex",
	        flexDirection: "row",
	        borderBottom: "1px solid #aaa",
	        borderLeft: "1px solid #aaa",
	        fontSize: "10px",
	        fontFamily: "Arial",
	        justifyContent: "flex-end",
	        backgroundColor: "#f7f3df"
	      }
	    }, Div({
	      style: {
	        margin: "5px"
	      }
	    }, "Art.Foundation.DomConsole"), (function() {
	      var i, len, ref1, results;
	      ref1 = ["reset", "show", "hide", "increaseWidth", "decreaseWidth"];
	      results = [];
	      for (i = 0, len = ref1.length; i < len; i++) {
	        action = ref1[i];
	        results.push((function(_this) {
	          return function(action) {
	            return Div({
	              style: {
	                margin: "5px"
	              }
	            }, A({
	              href: "#",
	              on: {
	                click: function() {
	                  return DomConsole[action]();
	                }
	              }
	            }, action));
	          };
	        })(this)(action));
	      }
	      return results;
	    }).call(this));
	  };

	  return ToolBar;

	})(Component));


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(263).addModules({
	  Component: __webpack_require__(264)
	});


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	var DomConsole, PseudoReact,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	DomConsole = __webpack_require__(253);

	module.exports = DomConsole.PseudoReact || DomConsole.addNamespace('PseudoReact', PseudoReact = (function(superClass) {
	  extend(PseudoReact, superClass);

	  function PseudoReact() {
	    return PseudoReact.__super__.constructor.apply(this, arguments);
	  }

	  return PseudoReact;

	})(Neptune.Base));


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Component, Div, Foundation, createObjectTreeFactory, merge, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	ref = Foundation.Browser.DomElementFactories, Div = ref.Div, createObjectTreeFactory = ref.createObjectTreeFactory;

	merge = Foundation.merge, BaseObject = Foundation.BaseObject;


	/*
	PseudoReact.Component
	---------------------

	Difference between this and real React:

	  - There is no virtual-dom!
	  - There is no life-cycle!
	  - There is no @refs
	  - Methods ARE NOT BOUND to instances

	  - @setState and @state are minimally supported
	    - setState is epoched, on a per-component basis
	    - setting the state results in a full @rerender

	  - @rerender is provided for manually rerendering

	  - @rerender DOEST NOT DIFF! It just re-generates EVERYTHING.
	    There are NO INCREMENTAL UPDATES within a Component.
	    However, you can rerender a sub-component and the parent
	    component will not need to be re-rendered.

	  - @render returns an HTMLElement instead of a virtual-element.

	  - Component-factories don't actually return components, they return HTMLElements.
	    WHY? So they can be used in @render functions in the normal React-style.
	 */

	module.exports = Component = (function(superClass) {
	  extend(Component, superClass);

	  Component.postCreate = function() {
	    return this.toComponentFactory();
	  };

	  Component.toComponentFactory = function() {
	    return createObjectTreeFactory((function(_this) {
	      return function(props, children) {
	        props.children || (props.children = children);
	        return (new _this(props)).rerender();
	      };
	    })(this));
	  };

	  function Component(props1) {
	    this.props = props1 != null ? props1 : {};
	    this.state = this.getInitialState();
	    this._pendingState = null;
	  }

	  Component.prototype.getInitialState = function() {
	    return {};
	  };

	  Component.prototype.getPendingState = function() {
	    if (this._pendingState) {
	      return this._pendingState;
	    }
	    this._queueApplyPendingState();
	    return this._pendingState = {};
	  };

	  Component.prototype._queueApplyPendingState = function() {
	    return setTimeout(((function(_this) {
	      return function() {
	        return _this._applyPendingState();
	      };
	    })(this)), 0);
	  };

	  Component.prototype._applyPendingState = function() {
	    var k, ref1, v;
	    ref1 = this._pendingState;
	    for (k in ref1) {
	      v = ref1[k];
	      this.state[k] = v;
	    }
	    this.rerender();
	    return this._pendingState = null;
	  };

	  Component.prototype._setState = function(k, v) {
	    return this.getPendingState()[k] = v;
	  };

	  Component.prototype.setState = function(a, b) {
	    var k, results, v;
	    if (a.constructor === Object) {
	      results = [];
	      for (k in a) {
	        v = a[k];
	        results.push(this._setState(k, v));
	      }
	      return results;
	    } else {
	      return this._setState(a, b);
	    }
	  };

	  Component.prototype.rerender = function() {
	    var oldRootElement, ref1;
	    oldRootElement = this._rootElement;
	    this._render();
	    if (oldRootElement != null) {
	      if ((ref1 = oldRootElement.parentElement) != null) {
	        ref1.replaceChild(this._rootElement, oldRootElement);
	      }
	    }
	    return this._rootElement;
	  };

	  Component.prototype.render = function() {
	    return Div();
	  };

	  Component.prototype._render = function() {
	    return this._rootElement = this.render();
	  };

	  return Component;

	})(BaseObject);


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, Chart, Foundation, Matrix, inspect, log, point, rect, rgbColor;

	Atomic = __webpack_require__(125);

	Foundation = __webpack_require__(19);

	point = Atomic.point, rgbColor = Atomic.rgbColor, rect = Atomic.rect, Matrix = Atomic.Matrix;

	inspect = Foundation.inspect, log = Foundation.log;

	module.exports = Chart = (function() {
	  function Chart() {}

	  Chart.bar = function(numbers, options) {
	    var barArea, barColor, barWidth, bgColor, chartBgColor, drawArea, drawMatrix, fontSize, height, i, j, k, len, len1, margin, maxNumber, minWidth, out, percent, pixelsPerPoint, pos, range, size, textColor;
	    if (options == null) {
	      options = {};
	    }
	    range = options.range;
	    pixelsPerPoint = options.pixelsPerPoint || 2;
	    fontSize = options.fontSize || 10;
	    margin = options.margin || (range ? fontSize * 1.4 : 0);
	    bgColor = rgbColor(options.bgColor || rgbColor(1, 1, 1, 0));
	    chartBgColor = rgbColor(options.chartBgColor || "#fff7f0");
	    barColor = rgbColor(options.barColor || "rgba(0,0,0,.5)");
	    textColor = rgbColor(options.textColor || "orange");
	    minWidth = options.minWidth || 50;
	    size = options.size || point(numbers.length * 4, 50 + 2 * margin);
	    if (options.barWidth) {
	      size = size.withX(numbers.length * options.barWidth);
	    }
	    if (size.x < minWidth) {
	      size = size.withX(minWidth);
	    }
	    barWidth = size.x / numbers.length;
	    drawMatrix = Matrix.scale(pixelsPerPoint);
	    out = new Art.Canvas.Bitmap(size.mul(pixelsPerPoint));
	    out.pixelsPerPoint = pixelsPerPoint;
	    out.clear(bgColor);
	    drawArea = rect(0, margin, size.w, size.h - 2 * margin);
	    out.drawRectangle(drawMatrix, drawArea, chartBgColor);
	    pos = drawArea.left;
	    maxNumber = 0;
	    for (j = 0, len = numbers.length; j < len; j++) {
	      i = numbers[j];
	      if (i > maxNumber) {
	        maxNumber = i;
	      }
	    }
	    for (k = 0, len1 = numbers.length; k < len1; k++) {
	      i = numbers[k];
	      percent = i / maxNumber;
	      height = drawArea.h * percent;
	      barArea = rect(pos, drawArea.bottom - height, barWidth, height).round();
	      out.drawRectangle(drawMatrix, barArea, barColor);
	      pos += barWidth;
	    }
	    if (range) {
	      out.drawText(Matrix.translate(0, fontSize).mul(drawMatrix), "max: " + maxNumber, {
	        size: fontSize,
	        color: textColor
	      });
	      out.drawText(Matrix.translate(0, size.y).mul(drawMatrix), range[0], {
	        size: fontSize,
	        color: textColor
	      });
	      out.drawText(Matrix.translate(size).mul(drawMatrix), range[1], {
	        size: fontSize,
	        color: textColor,
	        align: "right"
	      });
	    }
	    return out;
	  };

	  return Chart;

	})();


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(267).addModules({
	  GlobalEpochStats: __webpack_require__(268)
	});


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	var DevTools, Engine,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Engine = __webpack_require__(154);

	module.exports = Engine.DevTools || Engine.addNamespace('DevTools', DevTools = (function(superClass) {
	  extend(DevTools, superClass);

	  function DevTools() {
	    return DevTools.__super__.constructor.apply(this, arguments);
	  }

	  return DevTools;

	})(Neptune.Base));


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(19), __webpack_require__(125), __webpack_require__(137), __webpack_require__(157)], __WEBPACK_AMD_DEFINE_RESULT__ = function(Foundation, Atomic, Canvas, EngineCore) {
	  var GlobalEpochCycle, GlobalEpochStat, GlobalEpochStats, Map, Matrix, aimColor, currentSecond, floor, globalEpochCycle, log, max, min, miniInspect, peek, point, reactColor, rect, rgbColor, timeout;
	  log = Foundation.log, Map = Foundation.Map, miniInspect = Foundation.miniInspect, currentSecond = Foundation.currentSecond, max = Foundation.max, min = Foundation.min, timeout = Foundation.timeout, peek = Foundation.peek;
	  point = Atomic.point, rect = Atomic.rect, Matrix = Atomic.Matrix, rgbColor = Atomic.rgbColor;
	  GlobalEpochCycle = EngineCore.GlobalEpochCycle;
	  globalEpochCycle = GlobalEpochCycle.globalEpochCycle;
	  floor = Math.floor;
	  reactColor = rgbColor("gold");
	  aimColor = rgbColor("#9c3");
	  GlobalEpochStat = (function(superClass) {
	    var statColors, statFields;

	    extend(GlobalEpochStat, superClass);

	    function GlobalEpochStat(sampleTime1, total1, sampleSet1) {
	      this.sampleTime = sampleTime1;
	      this.total = total1;
	      this.sampleSet = sampleSet1;
	    }

	    GlobalEpochStat.statFields = statFields = ["total", "draw", "aim", "aimLayout", "aimTL", "aimRR", "react", "reactAim", "reactLC", "reactRender", "event", "flux"];

	    GlobalEpochStat.statColors = statColors = {
	      total: "gray",
	      draw: "#39c",
	      aim: aimColor,
	      aimLayout: aimColor.withLightness(aimColor.lightness * .9),
	      aimTL: aimColor.withLightness(aimColor.lightness * .8),
	      aimRR: aimColor.withLightness(aimColor.lightness * .7),
	      react: reactColor,
	      reactAim: reactColor.withLightness(reactColor.lightness * .9),
	      reactLC: reactColor.withLightness(reactColor.lightness * .8),
	      reactRender: reactColor.withLightness(reactColor.lightness * .7),
	      event: "#ff6347",
	      flux: "#d936a3"
	    };

	    GlobalEpochStat.prototype.getStacked = function(sampleName) {
	      var i, sn, sum;
	      if (sampleName === "total") {
	        return this.total;
	      }
	      sum = 0;
	      for (i = statFields.length - 1; i >= 0; i += -1) {
	        sn = statFields[i];
	        sum += this.sampleSet[sn] || 0;
	        if (sn === sampleName) {
	          break;
	        }
	      }
	      return sum;
	    };

	    GlobalEpochStat.prototype.drawSample = function(bitmap, drawMatrix, sampleWidth, sampleField, h) {
	      var sample, sampleTime, x, y;
	      sampleTime = this.sampleTime;
	      sample = this.getStacked(sampleField);
	      x = floor(drawMatrix.transformX(sampleTime, sample));
	      y = floor(drawMatrix.transformY(sampleTime, sample));
	      return bitmap.drawRectangle(null, rect(x, y, sampleWidth, h - y), {
	        color: statColors[sampleField]
	      });
	    };

	    return GlobalEpochStat;

	  })(Foundation.BaseObject);
	  return GlobalEpochStats = (function(superClass) {
	    extend(GlobalEpochStats, superClass);

	    GlobalEpochStats.classGetter({
	      enabled: function() {
	        return !!globalEpochCycle.globalEpochStats;
	      }
	    });

	    GlobalEpochStats.enable = function() {
	      log("Enabled globalEpochStats");
	      globalEpochCycle.globalEpochStats = new this;
	      return true;
	    };

	    GlobalEpochStats.toggle = function() {
	      if (this.enabled) {
	        return this.disable();
	      } else {
	        return this.enable();
	      }
	    };

	    GlobalEpochStats.disable = function() {
	      log("Disabled globalEpochStats");
	      globalEpochCycle.globalEpochStats = null;
	      return false;
	    };

	    function GlobalEpochStats() {
	      this.reset();
	    }

	    GlobalEpochStats.prototype.reset = function() {
	      this.maxMs = 2 / 60;
	      this.stats = [];
	      this.nextEventIdIndex = 0;
	      this.eventsById = {};
	      this.eventLegend = {};
	      this._minSampleTime = null;
	      return this._maxSampleTime = null;
	    };

	    GlobalEpochStats.prototype.add = function(sampleTime, total, sampleSet) {
	      var ges;
	      this.stats.push(ges = new GlobalEpochStat(sampleTime, total, sampleSet));
	      this.maxMs = max(this.maxMs, total * 1.5);
	      this.logAndResetWhenIdle();
	      return this.addSampleTime(sampleTime);
	    };

	    GlobalEpochStats.prototype.addSampleTime = function(time) {
	      this._minSampleTime = min(time, this._minSampleTime || time);
	      return this._maxSampleTime = max(time, this._maxSampleTime || time);
	    };

	    GlobalEpochStats.prototype.logEvent = function(name, id) {
	      var base, clr, colors, ebi, now;
	      now = currentSecond();
	      this.addSampleTime(now);
	      colors = {
	        generateDrawCache: "green",
	        animation: "#77f",
	        animationAborted: "#f77",
	        animationDone: "#77f",
	        "default": "gray"
	      };
	      clr = colors[name] || colors["default"];
	      ebi = (base = this.eventsById)[id] || (base[id] = {
	        startTime: now,
	        endTime: now,
	        index: this.nextEventIdIndex++,
	        events: [],
	        name: name,
	        clr: clr
	      });
	      ebi.startTime = min(now, ebi.startTime);
	      ebi.endTime = max(now, ebi.endTime);
	      this.eventLegend[name] = clr;
	      return ebi.events.push({
	        time: now,
	        name: name,
	        clr: clr
	      });
	    };

	    GlobalEpochStats.getter({
	      minSampleTime: function() {
	        return this._minSampleTime;
	      },
	      maxSampleTime: function() {
	        return this._maxSampleTime;
	      },
	      sampleTimeRange: function() {
	        return this.maxSampleTime - this.minSampleTime;
	      }
	    });

	    GlobalEpochStats.prototype.drawAllSamplesForOneField = function(bitmap, drawMatrix, sampleField) {
	      var h, i, len, ref, sampleTimeRange, sampleWidth, size, stat, stats, w;
	      size = bitmap.size;
	      w = size.w, h = size.h;
	      ref = this, sampleTimeRange = ref.sampleTimeRange, stats = ref.stats;
	      sampleWidth = floor((w / sampleTimeRange) / 60);
	      for (i = 0, len = stats.length; i < len; i++) {
	        stat = stats[i];
	        stat.drawSample(bitmap, drawMatrix, sampleWidth, sampleField, h);
	      }
	      return null;
	    };

	    GlobalEpochStats.prototype.getDrawMatrix = function(size) {
	      var h, legendWidth, maxMs, minSampleTime, ref, sampleTimeRange, sampleWidth, w, xScale, yScale;
	      w = size.w, h = size.h;
	      legendWidth = 80;
	      w -= legendWidth;
	      ref = this, sampleTimeRange = ref.sampleTimeRange, minSampleTime = ref.minSampleTime, maxMs = ref.maxMs;
	      sampleWidth = floor((w / sampleTimeRange) / 60);
	      xScale = (w - sampleWidth) / sampleTimeRange;
	      yScale = h / maxMs;
	      return Matrix.scaleXY(1, -1).translateXY(-minSampleTime, 0).scaleXY(xScale, yScale).translateXY(legendWidth, h);
	    };

	    GlobalEpochStats.prototype.drawLabeledHLine = function(bitmap, x1, x2, y, clr, label) {
	      bitmap.drawRectangle(null, rect(x1, y, x2 - x1, 1), {
	        color: rgbColor(clr)
	      });
	      return bitmap.drawText(point(x1, y - 5), label, {
	        size: 14,
	        color: rgbColor(clr)
	      });
	    };

	    GlobalEpochStats.prototype.drawEvents = function(bitmap, drawMatrix) {
	      var clr, endTime, eventTimeLineHeight, events, h, id, index, name, ref, ref1, ref2, results, startTime, time, w, x, x1, x2, y;
	      ref = bitmap.size, w = ref.w, h = ref.h;
	      eventTimeLineHeight = floor(h / 20);
	      ref1 = this.eventsById;
	      results = [];
	      for (id in ref1) {
	        ref2 = ref1[id], index = ref2.index, startTime = ref2.startTime, endTime = ref2.endTime, clr = ref2.clr, events = ref2.events, name = ref2.name;
	        x1 = floor(drawMatrix.transformX(startTime, 0));
	        x2 = floor(drawMatrix.transformX(endTime, 0));
	        y = (index + 1) * eventTimeLineHeight;
	        this.drawLabeledHLine(bitmap, x1, x2, y, clr, name);
	        results.push((function() {
	          var i, len, ref3, results1;
	          results1 = [];
	          for (i = 0, len = events.length; i < len; i++) {
	            ref3 = events[i], time = ref3.time, name = ref3.name, clr = ref3.clr;
	            x = floor(drawMatrix.transformX(time, 0));
	            results1.push(bitmap.drawRectangle(null, rect(x, y, 1, eventTimeLineHeight * (1 / 3)), {
	              color: clr
	            }));
	          }
	          return results1;
	        })());
	      }
	      return results;
	    };

	    GlobalEpochStats.prototype.log = function() {
	      var averageFps, averageFrameTimeMs, averageFrameTimeMsY, bitmap, ce, clr, drawMatrix, field, fiveMsY, h, i, j, legend, len, len1, missedFrames, perfectFrameCount, ref, ref1, ref2, sampleField, size, tenMsY, totalFrames, w, y;
	      if (!(this.stats.length > 0)) {
	        return;
	      }
	      !((ref = Neptune.Art.DevTools.DomConsole) != null ? ref.enabled : void 0) && (ce = GlobalEpochCycle.activeCanvasElements[0]);
	      bitmap = new Canvas.Bitmap(size = ce ? ce.canvasBitmap.size : point(1000, 600));
	      w = size.w, h = size.h;
	      bitmap.clear("#fff");
	      drawMatrix = this.getDrawMatrix(size);
	      y = floor(drawMatrix.transformY(0, 1 / 60));
	      tenMsY = floor(drawMatrix.transformY(0, 1 / 100));
	      fiveMsY = floor(drawMatrix.transformY(0, 1 / 200));
	      bitmap.drawRectangle(null, rect(0, y, w, 1), {
	        color: "#0007"
	      });
	      ref1 = GlobalEpochStat.statFields;
	      for (i = 0, len = ref1.length; i < len; i++) {
	        sampleField = ref1[i];
	        this.drawAllSamplesForOneField(bitmap, drawMatrix, sampleField);
	      }
	      legend = {};
	      this.drawLabeledHLine(bitmap, 40, w, tenMsY, "#0007", "10ms");
	      this.drawLabeledHLine(bitmap, 40, w, fiveMsY, "#0007", "5ms");
	      this.drawEvents(bitmap, drawMatrix);
	      totalFrames = this.stats.length;
	      averageFrameTimeMs = this.sampleTimeRange / totalFrames;
	      perfectFrameCount = this.sampleTimeRange * 60 + .5 | 0;
	      missedFrames = perfectFrameCount - totalFrames;
	      averageFrameTimeMsY = floor(drawMatrix.transformY(0, averageFrameTimeMs));
	      if ((averageFps = 1 / averageFrameTimeMs + .5 | 0) < 55) {
	        this.drawLabeledHLine(bitmap, 40, w, y, "#0007", "60fps - 16.7ms");
	      }
	      this.drawLabeledHLine(bitmap, 40, w, averageFrameTimeMsY, "#0007", "average: " + averageFps + "fps (miss-rate: " + ((100 * missedFrames / perfectFrameCount).toPrecision(2)) + "% " + missedFrames + "/" + perfectFrameCount + ")");
	      y = 0;
	      ref2 = GlobalEpochStat.statFields;
	      for (j = 0, len1 = ref2.length; j < len1; j++) {
	        field = ref2[j];
	        clr = GlobalEpochStat.statColors[field];
	        bitmap.drawRectangle(null, rect(0, y, 75, 23), {
	          color: clr
	        });
	        bitmap.drawText(point(5, y + 18), field, {
	          size: 16,
	          color: rgbColor("white")
	        });
	        y += 25;
	      }
	      bitmap.drawBorder(null, bitmap.size, "#eee");
	      if (ce) {
	        log("showing GlobalEpochStats");
	        return ce.canvasBitmap.drawBitmap(null, bitmap, {
	          opacity: .9
	        });
	      } else {
	        return log(bitmap);
	      }
	    };

	    GlobalEpochStats.prototype.logAndResetWhenIdle = function() {
	      var samples;
	      samples = this.stats.length;
	      if (samples > 0) {
	        return timeout(1000, (function(_this) {
	          return function() {
	            if (samples === _this.stats.length && GlobalEpochStats.enabled) {
	              _this.log();
	              return _this.reset();
	            }
	          };
	        })(this));
	      }
	    };

	    return GlobalEpochStats;

	  })(Foundation.BaseObject);
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(270).addModules({
	  V1Loader: __webpack_require__(271),
	  V1Writer: __webpack_require__(280)
	});


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	var Engine, File,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Engine = __webpack_require__(154);

	module.exports = Engine.File || Engine.addNamespace('File', File = (function(superClass) {
	  extend(File, superClass);

	  function File() {
	    return File.__super__.constructor.apply(this, arguments);
	  }

	  return File;

	})(Neptune.Base));


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	var Atomic, BaseObject, Binary, Canvas, Core, Element, Elements, EncodedImage, Foundation, Promise, StateEpoch, V1Loader, Xbd, compositeModes, inspect, layoutModes, log, lowerCamelCase, matrix, merge, mergeInto, point, rect, stateEpoch, supportedCompositeModes,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Canvas = __webpack_require__(137);

	Xbd = __webpack_require__(272);

	Core = __webpack_require__(157);

	Elements = __webpack_require__(212);

	Binary = Foundation.Binary, inspect = Foundation.inspect, BaseObject = Foundation.BaseObject, Promise = Foundation.Promise, log = Foundation.log, mergeInto = Foundation.mergeInto, lowerCamelCase = Foundation.lowerCamelCase, merge = Foundation.merge;

	point = Atomic.point, rect = Atomic.rect, matrix = Atomic.matrix;

	EncodedImage = Binary.EncodedImage;

	Element = Core.Element, StateEpoch = Core.StateEpoch;

	stateEpoch = StateEpoch.stateEpoch;

	compositeModes = {
	  normal: 0,
	  add: 1,
	  sub: 2,
	  mul: 3,
	  destOver: 4,
	  replace: 5,
	  alphaMask: 6,
	  inverseAlphaMask: 7,
	  erase: 8,
	  0: "normal",
	  1: "add",
	  2: "sub",
	  3: "mul",
	  4: "destOver",
	  5: "replace",
	  6: "alphaMask",
	  7: "inverseAlphaMask",
	  8: "erase"
	};

	supportedCompositeModes = {
	  normal: "normal",
	  add: "add"
	};

	layoutModes = {
	  leftAddWidthFixed: 0,
	  rightAddWidthFixed: 1,
	  centeredWidthFixed: 2,
	  leftAddWidthChildren: 3,
	  rightAddWidthChildren: 4,
	  centeredWidthChildren: 5,
	  bothAdd: 6,
	  bothMul: 7,
	  bothStretch: 8,
	  0: "leftAddWidthFixed",
	  1: "rightAddWidthFixed",
	  2: "centeredWidthFixed",
	  3: "leftAddWidthChildren",
	  4: "rightAddWidthChildren",
	  5: "centeredWidthChildren",
	  6: "bothAdd",
	  7: "bothMul",
	  8: "bothStretch"
	};

	module.exports = V1Loader = (function(superClass) {
	  extend(V1Loader, superClass);

	  function V1Loader() {
	    return V1Loader.__super__.constructor.apply(this, arguments);
	  }

	  V1Loader.singletonClass();

	  V1Loader.load = function(data, bitmapFactory) {
	    return this.singleton.load(data, bitmapFactory);
	  };

	  V1Loader.prototype.load = function(data, bitmapFactory1) {
	    this.bitmapFactory = bitmapFactory1 != null ? bitmapFactory1 : Canvas.Bitmap;
	    return this.decodeTopTag(Xbd.parse(data).tag("art_file")).then((function(_this) {
	      return function(artFile) {
	        var child;
	        artFile.axis = point();
	        artFile.location = point();
	        artFile.children = (function() {
	          var i, len, ref, results;
	          ref = artFile.getPendingChildren();
	          results = [];
	          for (i = 0, len = ref.length; i < len; i++) {
	            child = ref[i];
	            if (!child.getPendingIsMask()) {
	              results.push(child);
	            }
	          }
	          return results;
	        })();
	        artFile.bitmapFactory = _this.bitmapFactory;
	        return stateEpoch.onNextReady(function() {
	          return artFile;
	        });
	      };
	    })(this));
	  };

	  V1Loader.objectFactory = {
	    art_file: function() {
	      return new Element;
	    },
	    pego: function() {
	      return new Element;
	    },
	    art_stencil_shape: function() {
	      return new Element;
	    },
	    art_bitmap: function(tag, loader) {
	      var bitmap, bitmap_id;
	      bitmap_id = tag.attrs["bitmap_id"];
	      bitmap = loader.bitmaps[bitmap_id];
	      return new Elements.BitmapElement({
	        bitmap: bitmap
	      });
	    }
	  };

	  V1Loader.prototype.decodeBitmapsTag = function(bitmapsTag) {
	    var promises, tag;
	    if (!bitmapsTag) {
	      return Promise.resolve();
	    }
	    this.bitmaps = [];
	    promises = (function() {
	      var i, len, ref, results;
	      ref = bitmapsTag.tags;
	      results = [];
	      for (i = 0, len = ref.length; i < len; i++) {
	        tag = ref[i];
	        results.push((function(_this) {
	          return function(tag) {
	            return EncodedImage.toImage(tag.attrs.pixel_data).then(function(image) {
	              var bitmapId;
	              bitmapId = tag.attrs.bitmap_id | 0;
	              return _this.bitmaps[bitmapId] = _this.bitmapFactory.newBitmap(image);
	            });
	          };
	        })(this)(tag));
	      }
	      return results;
	    }).call(this);
	    return Promise.all(promises);
	  };

	  V1Loader.prototype.decodeTopTag = function(topTag) {
	    return this.decodeBitmapsTag(topTag.tag("bitmaps")).then((function(_this) {
	      return function() {
	        return _this.createElementFromTag(topTag);
	      };
	    })(this));
	  };

	  V1Loader.prototype.createElement = function(tag) {
	    var constructor;
	    constructor = V1Loader.objectFactory[tag.name];
	    if (!constructor) {
	      this.log("WARNING: unknown object type: " + tag.name + ". Defaulting to Art.Engine.Core.Element");
	      return new Element;
	    } else {
	      return constructor(tag, this);
	    }
	  };

	  V1Loader.prototype.populateChildrenFromTag = function(parent, childrenTag) {
	    var child, children, i, j, len, len1, postChildren, ref, results, route, shapeChildren;
	    shapeChildren = [];
	    children = [];
	    postChildren = [];
	    route = {
	      "-stencil": shapeChildren,
	      "+stencil": shapeChildren,
	      "stencil": shapeChildren,
	      "normal": children,
	      "post": postChildren
	    };
	    ref = childrenTag.tags;
	    for (i = 0, len = ref.length; i < len; i++) {
	      child = ref[i];
	      route[child.attrs.stack_mode || "normal"].push(this.createElementFromTag(child, parent));
	    }
	    parent.setChildren(children);
	    if (shapeChildren.length > 0) {
	      shapeChildren[0].isMask = true;
	      parent.addChild(shapeChildren[0]);
	      if (shapeChildren.length > 1) {
	        this.log("WARNING - loading more than one mask (shape/stencil) child not currently supported! (using first one only)");
	      }
	    }
	    results = [];
	    for (j = 0, len1 = postChildren.length; j < len1; j++) {
	      child = postChildren[j];
	      results.push(parent.addChild(child));
	    }
	    return results;
	  };

	  V1Loader.prototype.decodeHorizontalLinearLayout = function(object, layout, l, s, locationOut, sizeOut) {
	    switch (layout) {
	      case layoutModes.leftAddWidthFixed:
	        mergeInto(locationOut, {
	          x: l
	        });
	        return mergeInto(sizeOut, {
	          w: s
	        });
	      case layoutModes.rightAddWidthFixed:
	        mergeInto(locationOut, {
	          x: l,
	          xpw: 1
	        });
	        return mergeInto(sizeOut, {
	          w: s
	        });
	      case layoutModes.centeredWidthFixed:
	        mergeInto(locationOut, {
	          xpw: l
	        });
	        return mergeInto(sizeOut, {
	          w: s
	        });
	      case layoutModes.bothAdd:
	        mergeInto(locationOut, {
	          x: l
	        });
	        return mergeInto(sizeOut, {
	          w: s,
	          wpw: 1
	        });
	      case layoutModes.bothMul:
	        mergeInto(locationOut, {
	          xpw: l
	        });
	        return mergeInto(sizeOut, {
	          wpw: s
	        });
	      case layoutModes.bothStretch:
	      case layoutModes.centeredWidthChildren:
	      case layoutModes.rightAddWidthChildren:
	      case layoutModes.leftAddWidthChildren:
	        return this.log("WARNING: unsupported layout " + layoutModes[layout] + " for " + channel + " loc=" + location + " size=" + size);
	    }
	  };

	  V1Loader.prototype.decodeVerticalLinearLayout = function(object, layout, l, s, locationOut, sizeOut) {
	    switch (layout) {
	      case layoutModes.leftAddWidthFixed:
	        mergeInto(locationOut, {
	          y: l
	        });
	        return mergeInto(sizeOut, {
	          h: s
	        });
	      case layoutModes.rightAddWidthFixed:
	        mergeInto(locationOut, {
	          y: l,
	          yph: 1
	        });
	        return mergeInto(sizeOut, {
	          h: s
	        });
	      case layoutModes.centeredWidthFixed:
	        mergeInto(locationOut, {
	          yph: l
	        });
	        return mergeInto(sizeOut, {
	          h: s
	        });
	      case layoutModes.bothAdd:
	        mergeInto(locationOut, {
	          y: l
	        });
	        return mergeInto(sizeOut, {
	          h: s,
	          hph: 1
	        });
	      case layoutModes.bothMul:
	        mergeInto(locationOut, {
	          yph: l
	        });
	        return mergeInto(sizeOut, {
	          hph: s
	        });
	      case layoutModes.bothStretch:
	      case layoutModes.centeredWidthChildren:
	      case layoutModes.rightAddWidthChildren:
	      case layoutModes.leftAddWidthChildren:
	        return this.log("WARNING: unsupported layout " + layoutModes[layout] + " for " + channel + " loc=" + location + " size=" + size);
	    }
	  };

	  V1Loader.prototype.decodeLayout = function(object, tag, parent) {
	    var hVal, location, size, wVal, xLayout, xVal, yLayout, yVal;
	    xLayout = (tag.attrs.x_layout_mode || layoutModes.leftAddWidthFixed) | 0;
	    yLayout = (tag.attrs.y_layout_mode || layoutModes.leftAddWidthFixed) | 0;
	    xVal = (tag.attrs.x_val || 0) - 0;
	    yVal = (tag.attrs.y_val || 0) - 0;
	    wVal = (tag.attrs.w_val || 0) - 0;
	    hVal = (tag.attrs.h_val || 0) - 0;
	    location = {};
	    size = {};
	    this.decodeHorizontalLinearLayout(object, xLayout, xVal, wVal, location, size);
	    this.decodeVerticalLinearLayout(object, yLayout, yVal, hVal, location, size);
	    object.location = location;
	    return object.size = size;
	  };

	  V1Loader.prototype.setCompositeMode = function(object, mode) {
	    if (!supportedCompositeModes[compositeModes[mode]]) {
	      this.log("WARNING: unknown composite mode: " + mode);
	    }
	    return object.compositeMode = supportedCompositeModes[compositeModes[mode]] || "normal";
	  };

	  V1Loader.prototype.createElementFromTag = function(tag, parent) {
	    var children, k, object, ref, tagKey, userProps, v;
	    if (parent == null) {
	      parent = null;
	    }
	    object = this.createElement(tag);
	    object.axis = point(tag.attrs.handle || point(.5, .5));
	    this.decodeLayout(object, tag, parent);
	    userProps = {};
	    ref = tag.attrs;
	    for (k in ref) {
	      v = ref[k];
	      switch (k) {
	        case "name":
	          object.name = v;
	          break;
	        case "matrix":
	          object.elementToParentMatrix = matrix(v);
	          break;
	        case "art_engine_version":
	          break;
	        case "kimi_editor_version":
	          break;
	        case "composite_mode":
	          this.setCompositeMode(object, v);
	          break;
	        case "drop_in_enabled":
	          userProps.dropInEnabled = true;
	          break;
	        case "lock_mode":
	          break;
	        case "handle":
	        case "w_val":
	        case "h_val":
	        case "x_val":
	        case "y_val":
	        case "x_layout_mode":
	        case "y_layout_mode":
	        case "stack_mode":
	          break;
	        default:
	          tagKey = tag.name + ":" + k;
	          switch (tagKey) {
	            case "art_file:bitmaps":
	            case "art_bitmap:bitmap_id":
	              break;
	            default:
	              userProps[lowerCamelCase(k)] = v.toString();
	              this.log("WARNING: unknown tag:attribute: " + tagKey + " (ignored)");
	          }
	      }
	    }
	    object.userProps = userProps;
	    if (children = tag.tags.children) {
	      this.populateChildrenFromTag(object, children);
	    }
	    return object;
	  };

	  return V1Loader;

	})(BaseObject);


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(273);


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(274).includeInNamespace(__webpack_require__(276)).addModules({
	  XbdDictionary: __webpack_require__(278),
	  XbdTag: __webpack_require__(277)
	});


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Xbd,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(275);

	module.exports = Art.Xbd || Art.addNamespace('Xbd', Xbd = (function(superClass) {
	  extend(Xbd, superClass);

	  function Xbd() {
	    return Xbd.__super__.constructor.apply(this, arguments);
	  }

	  return Xbd;

	})(Neptune.Base));


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	var Xbd, XbdTag, _package;

	Xbd = __webpack_require__(274);

	XbdTag = __webpack_require__(277);

	module.exports = [
	  [XbdTag, "fromXbd", "createTagFactories"], {
	    parse: XbdTag.fromXbd,
	    "package": _package = __webpack_require__(279),
	    version: _package.version
	  }
	];


/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Binary, Foundation, WriteStream, Xbd, XbdDictionary, XbdTag, binary, countKeys, createObjectTreeFactories, inspect, isFunction, log, plainObjectsDeepEq, stream, upperCamelCase,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Xbd = __webpack_require__(274);

	XbdDictionary = __webpack_require__(278);

	Binary = Foundation.Binary, isFunction = Foundation.isFunction, BaseObject = Foundation.BaseObject, log = Foundation.log, countKeys = Foundation.countKeys, upperCamelCase = Foundation.upperCamelCase, createObjectTreeFactories = Foundation.createObjectTreeFactories, plainObjectsDeepEq = Foundation.plainObjectsDeepEq, inspect = Foundation.inspect;

	binary = Binary.binary, stream = Binary.stream, WriteStream = Binary.WriteStream;

	module.exports = XbdTag = (function(superClass) {
	  var indentString, writeXbdHeader, xbdHeader;

	  extend(XbdTag, superClass);


	  /*
	  IN:
	    tagNames: string or array of strings which is compactFlattened
	      every string is split into tag-names with this pattern: /[a-z0-9_]+/ig
	    factoryNameSuffix: DEFAULT: 'Tag'
	      Optional suffix for the names of the factories returned.
	      Factor names are upperCamelCased from the tag-names and then the suffix is appended.
	  OUT:
	    map from upperCamelCase(tag-names) to:
	      -> XbdTag
	      IN:
	        any sequence:
	          plainObjects (which are merged into attrs)
	          XbdTags (which become sub-tags)
	          or arrays which are flattened
	  
	      OUT: XbdTag
	  
	  Example:
	    {MyTag, TagA, TagB} = createTagFactories "myTag tagA tagB"
	    rootTag = MyTag
	      foo: "bar"
	      TagA()
	      TagA foo: "far"
	      TagB fab: "bar"
	   */

	  XbdTag.createTagFactories = function(tagNames, factoryNameSuffix) {
	    if (factoryNameSuffix == null) {
	      factoryNameSuffix = 'Tag';
	    }
	    return createObjectTreeFactories({
	      suffix: factoryNameSuffix
	    }, tagNames, function(tagName, attrs, subTags) {
	      return new XbdTag(tagName, attrs, subTags);
	    });
	  };

	  XbdTag.fromXbd = function(input) {
	    var header;
	    input = stream(input);
	    header = input.read(xbdHeader.length);
	    return XbdTag._parse(input, XbdDictionary.parse(input, "tag names"), XbdDictionary.parse(input, "attribute names"), XbdDictionary.parse(input, "attribute values"));
	  };


	  /*
	  IN:
	    name: string
	    attrs: map of keys to string/binary-string values
	    tags: array of sub-tags
	   */

	  function XbdTag(name1, attrs1, tags1) {
	    this.name = name1;
	    this.attrs = attrs1 != null ? attrs1 : {};
	    this.tags = tags1 != null ? tags1 : [];
	  }

	  XbdTag.prototype.inspect = function() {
	    return this.toXml('  ');
	  };

	  XbdTag.prototype.eq = function(b) {
	    return b && plainObjectsDeepEq(this.plainObjects, b.plainObjects);
	  };


	  /*
	  toXbd
	  IN:  inputs are for internal use. Pass in 0 args.
	  OUT: promise.then (xbdBinaryString) ->
	  
	  Example:
	  
	    myRootTag.toXbd()
	    .then (binaryString) ->
	      binaryString.utf8Array # do something with it
	   */

	  XbdTag.prototype.toXbd = function() {
	    var attrNamesDictionary, attrValuesDictionary, ref, tagNamesDictionary, writeStream;
	    ref = this, tagNamesDictionary = ref.tagNamesDictionary, attrNamesDictionary = ref.attrNamesDictionary, attrValuesDictionary = ref.attrValuesDictionary;
	    writeXbdHeader(writeStream = new WriteStream);
	    return tagNamesDictionary.writeWithPromise(writeStream).then(function() {
	      return attrNamesDictionary.writeWithPromise(writeStream);
	    }).then(function() {
	      return attrValuesDictionary.writeWithPromise(writeStream);
	    }).then((function(_this) {
	      return function() {
	        return _this._getBinaryStringPromise(tagNamesDictionary, attrNamesDictionary, attrValuesDictionary);
	      };
	    })(this)).then(function(binaryString) {
	      writeStream.writeAsiString(binaryString);
	      return writeStream.binaryStringPromise;
	    });
	  };

	  XbdTag.prototype.tag = function(name) {
	    var i, len, ref, tag;
	    ref = this.tags;
	    for (i = 0, len = ref.length; i < len; i++) {
	      tag = ref[i];
	      if (tag.name === name) {
	        return tag;
	      }
	    }
	    return null;
	  };

	  XbdTag.prototype.toString = function() {
	    return this.toXml("  ");
	  };

	  XbdTag.prototype.toPlainObjects = function() {
	    var attrs, i, k, len, out, ref, ref1, tag, v;
	    out = [this.name];
	    if (0 < countKeys(this.attrs)) {
	      attrs = {};
	      ref = this.attrs;
	      for (k in ref) {
	        v = ref[k];
	        attrs[k] = v.toString();
	      }
	      out.push(attrs);
	    }
	    if (this.tags.length > 0) {
	      ref1 = this.tags;
	      for (i = 0, len = ref1.length; i < len; i++) {
	        tag = ref1[i];
	        out.push(tag.toPlainObjects());
	      }
	    }
	    return out;
	  };

	  XbdTag.prototype.toXml = function(indent) {
	    var attr_xml;
	    if (indent == null) {
	      indent = "";
	    }
	    attr_xml = "";
	    if (this.attrs && (attr_xml = this._attributesXml())) {
	      attr_xml = " " + attr_xml;
	    }
	    if (this.tags.length === 0) {
	      return "<" + this.name + attr_xml + "/>";
	    } else {
	      return "<" + this.name + attr_xml + ">\n" + (this._tagsXml(indent)) + "\n</" + this.name + ">";
	    }
	  };

	  XbdTag.getter({
	    xbdPromise: function() {
	      return this.toXbd();
	    },
	    xml: function() {
	      return this.toXml();
	    },
	    plainObjects: function() {
	      return this.toPlainObjects();
	    },
	    tagNamesDictionary: function(dictionary) {
	      var i, len, ref, tag;
	      if (dictionary == null) {
	        dictionary = new XbdDictionary([], 'tag names');
	      }
	      dictionary.add(this.name);
	      ref = this.tags;
	      for (i = 0, len = ref.length; i < len; i++) {
	        tag = ref[i];
	        tag.getTagNamesDictionary(dictionary);
	      }
	      return dictionary;
	    },
	    attrNamesDictionary: function(dictionary) {
	      var i, k, len, ref, ref1, tag, v;
	      if (dictionary == null) {
	        dictionary = new XbdDictionary([], 'attribute names');
	      }
	      ref = this.attrs;
	      for (k in ref) {
	        v = ref[k];
	        dictionary.add(k);
	      }
	      ref1 = this.tags;
	      for (i = 0, len = ref1.length; i < len; i++) {
	        tag = ref1[i];
	        tag.getAttrNamesDictionary(dictionary);
	      }
	      return dictionary;
	    },
	    attrValuesDictionary: function(dictionary) {
	      var i, k, len, ref, ref1, tag, v;
	      if (dictionary == null) {
	        dictionary = new XbdDictionary([], 'attribute values');
	      }
	      ref = this.attrs;
	      for (k in ref) {
	        v = ref[k];
	        dictionary.add(v);
	      }
	      ref1 = this.tags;
	      for (i = 0, len = ref1.length; i < len; i++) {
	        tag = ref1[i];
	        tag.getAttrValuesDictionary(dictionary);
	      }
	      return dictionary;
	    }
	  });

	  xbdHeader = "SBDXML\x01\x00";

	  writeXbdHeader = function(writeStream) {
	    writeStream.write("SBDXML");
	    return writeStream.write([1, 0]);
	  };

	  indentString = function(str, indentStr) {
	    return indentStr + str.split("\n").join("\n" + indentStr);
	  };

	  XbdTag.prototype._attributesXml = function() {
	    var k, out, v;
	    out = (function() {
	      var ref, results;
	      ref = this.attrs;
	      results = [];
	      for (k in ref) {
	        v = ref[k];
	        results.push(k + "='" + v + "'");
	      }
	      return results;
	    }).call(this);
	    return out.join(" ");
	  };

	  XbdTag.prototype._tagsXml = function(indent) {
	    var out;
	    out = this.tags.map(function(tag) {
	      return tag.toXml(indent);
	    });
	    return indentString(out.join("\n"), indent);
	  };

	  XbdTag.prototype._getAttributesBinaryStringPromise = function(attrNamesDictionary, attrValuesDictionary) {
	    var name, ref, value, writeStream;
	    writeStream = new WriteStream;
	    ref = this.attrs;
	    for (name in ref) {
	      value = ref[name];
	      writeStream.writeAsi(attrNamesDictionary.get(name));
	      writeStream.writeAsi(attrValuesDictionary.get(value));
	    }
	    return writeStream.binaryStringPromise;
	  };

	  XbdTag.prototype._writeSubTagsWithPromise = function(writeStream, tagNamesDictionary, attrNamesDictionary, attrValuesDictionary) {
	    var index, processNext;
	    index = 0;
	    processNext = (function(_this) {
	      return function() {
	        var ref, tag;
	        if (tag = (ref = _this.tags) != null ? ref[index++] : void 0) {
	          return tag._getBinaryStringPromise(tagNamesDictionary, attrNamesDictionary, attrValuesDictionary).then(function(binaryString) {
	            writeStream.writeAsiString(binaryString);
	            return processNext();
	          });
	        } else {
	          return Promise.resolve();
	        }
	      };
	    })(this);
	    return processNext();
	  };

	  XbdTag.prototype._getBinaryStringPromise = function(tagNamesDictionary, attrNamesDictionary, attrValuesDictionary) {
	    var writeStream;
	    writeStream = new WriteStream;
	    writeStream.writeAsi(tagNamesDictionary.get(this.name));
	    return this._getAttributesBinaryStringPromise(attrNamesDictionary, attrValuesDictionary).then((function(_this) {
	      return function(attributesBinaryString) {
	        writeStream.writeAsiString(attributesBinaryString);
	        return _this._writeSubTagsWithPromise(writeStream, tagNamesDictionary, attrNamesDictionary, attrValuesDictionary);
	      };
	    })(this)).then(function() {
	      return writeStream.binaryStringPromise;
	    });
	  };

	  XbdTag._parse = function(stream, tagsd, attrsd, valuesd) {
	    var attrData, attrs, n, name, name1, subTag, tagData, tags, v;
	    tagData = stream.readAsiString();
	    name = tagsd.readString(tagData).toString();
	    attrData = tagData.readAsiString();
	    attrs = null;
	    while (!attrData.done()) {
	      if (!attrs) {
	        attrs = {};
	      }
	      n = attrsd.readString(attrData).toString();
	      v = valuesd.readString(attrData);
	      attrs[n] = v;
	    }
	    tags = [];
	    while (!tagData.done()) {
	      subTag = XbdTag._parse(tagData, tagsd, attrsd, valuesd);
	      tags.push(subTag);
	      tags[name1 = subTag.name] || (tags[name1] = subTag);
	    }
	    return new XbdTag(name, attrs, tags);
	  };

	  return XbdTag;

	})(BaseObject);


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Binary, WriteStream, XbdDictionary, binary, inspect, log, ref, stream,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(19), Binary = ref.Binary, BaseObject = ref.BaseObject, log = ref.log, inspect = ref.inspect;

	binary = Binary.binary, WriteStream = Binary.WriteStream, stream = Binary.stream;

	module.exports = XbdDictionary = (function(superClass) {
	  extend(XbdDictionary, superClass);

	  XbdDictionary.parse = function(stream, name) {
	    var encodedDictionary, i, len, lengths, strings;
	    encodedDictionary = stream.readAsiString();
	    lengths = (function() {
	      var j, ref1, results;
	      results = [];
	      for (i = j = 0, ref1 = encodedDictionary.readAsi(); 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
	        results.push(encodedDictionary.readAsi());
	      }
	      return results;
	    })();
	    strings = (function() {
	      var j, len1, results;
	      results = [];
	      for (j = 0, len1 = lengths.length; j < len1; j++) {
	        len = lengths[j];
	        results.push(encodedDictionary.read(len));
	      }
	      return results;
	    })();
	    return new XbdDictionary(strings, name);
	  };

	  function XbdDictionary(strings1, name1) {
	    this.strings = strings1;
	    this.name = name1;
	  }


	  /*
	  IN: string: any legal input to binary()
	  OUT: index/id for string
	  EFFECT:
	    string = binary string
	    strings was added OR, if already present, nothing changed
	   */

	  XbdDictionary.prototype.add = function(string) {
	    var index;
	    string = binary(string);
	    if (0 <= (index = this._indexOf(string))) {
	      return index;
	    } else {
	      this.strings.push(string);
	      return this.strings.length;
	    }
	  };


	  /*
	  IN: string: any legal input to binary()
	    NOTE: string is converted to a BinaryString for comparisions
	  OUT: returns index of first match in @strings
	   */

	  XbdDictionary.prototype.get = function(string) {
	    var index;
	    string = binary(string);
	    if (0 <= (index = this._indexOf(string))) {
	      return index;
	    } else {
	      throw new Error("string not found in dictionary: " + (inspect(string)));
	    }
	  };

	  XbdDictionary.prototype.readString = function(stream) {
	    var id, string;
	    id = stream.readAsi();
	    string = this.strings[id];
	    if (!string) {
	      throw "string id(" + id + ") not in " + this.name + " dictionary. keys = '" + (Object.keys(this.strings)) + "'";
	    }
	    return string;
	  };

	  XbdDictionary.getter({
	    binaryStringPromise: function() {
	      var j, k, len1, len2, normalizedStrings, s, string, writeStream;
	      writeStream = new WriteStream;
	      normalizedStrings = this._getNormalizeStrings();
	      writeStream.writeAsi(normalizedStrings.length);
	      for (j = 0, len1 = normalizedStrings.length; j < len1; j++) {
	        s = normalizedStrings[j];
	        writeStream.writeAsi(s.length);
	      }
	      for (k = 0, len2 = normalizedStrings.length; k < len2; k++) {
	        string = normalizedStrings[k];
	        writeStream.write(string);
	      }
	      return writeStream.binaryStringPromise;
	    }
	  });

	  XbdDictionary.prototype.writeWithPromise = function(writeStream) {
	    return this.binaryStringPromise.then(function(binaryString) {
	      return writeStream.writeAsiString(binaryString);
	    });
	  };

	  XbdDictionary.prototype._getNormalizeStrings = function() {
	    var j, len1, ref1, results, s;
	    ref1 = this.strings;
	    results = [];
	    for (j = 0, len1 = ref1.length; j < len1; j++) {
	      s = ref1[j];
	      results.push(binary(s));
	    }
	    return results;
	  };

	  XbdDictionary.prototype._indexOf = function(binaryString) {
	    var i, j, len1, ref1, s;
	    ref1 = this.strings;
	    for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
	      s = ref1[i];
	      if (s.eq(binaryString)) {
	        return i;
	      }
	    }
	    return -1;
	  };

	  return XbdDictionary;

	})(BaseObject);


/***/ },
/* 279 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-foundation": "git://github.com/imikimi/art-foundation.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.4.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"license": "ISC",
		"name": "art-xbd",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "0.0.4"
	};

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var ArtBitmapTag, ArtFileTag, ArtRectangleTag, ArtSolidFillTag, ArtStencilShapeTag, Atomic, BaseObject, BitmapTag, BitmapsTag, Canvas, ChildrenTag, Core, Elements, Foundation, PegoTag, RootTag, V1Writer, Xbd, XbdTag, createObjectTreeFactories, createTagFactories, createWithPostCreate, elementNameToV1NameMap, elementToTagFactory, floatEq, log, point, propsEq, ref,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Atomic = __webpack_require__(125);

	Canvas = __webpack_require__(137);

	Xbd = __webpack_require__(272);

	Core = __webpack_require__(157);

	Elements = __webpack_require__(212);

	BaseObject = Foundation.BaseObject, log = Foundation.log, createObjectTreeFactories = Foundation.createObjectTreeFactories, createWithPostCreate = Foundation.createWithPostCreate, floatEq = Foundation.floatEq;

	point = Atomic.point;

	XbdTag = Xbd.XbdTag, createTagFactories = Xbd.createTagFactories;

	propsEq = Core.EpochedObject.propsEq;

	ref = createTagFactories("Root bitmaps bitmap art_file pego art_bitmap children art_stencil_shape art_rectangle art_solid_fill"), ArtFileTag = ref.ArtFileTag, PegoTag = ref.PegoTag, ArtBitmapTag = ref.ArtBitmapTag, ChildrenTag = ref.ChildrenTag, ArtStencilShapeTag = ref.ArtStencilShapeTag, ArtRectangleTag = ref.ArtRectangleTag, ArtSolidFillTag = ref.ArtSolidFillTag, BitmapsTag = ref.BitmapsTag, BitmapTag = ref.BitmapTag, RootTag = ref.RootTag;

	elementNameToV1NameMap = {
	  Element: "pego",
	  BitmapElement: "art_bitmap"
	};

	elementToTagFactory = {
	  Element: PegoTag,
	  RectangleElement: PegoTag,
	  BitmapElement: ArtBitmapTag
	};


	/*
	RectangleElement needs to have the following pattern:

	  <pego handle="(0,0)" w_val='50' h_val='100'>
	    <children>
	      <art_stencil_shape stack_mode="+stencil" x_layout_mode="7" x_val="0.5" w_val="1" y_layout_mode="7" y_val="0.5" h_val="1">
	        <art_rectangle/>
	      </art_stencil_shape>
	      <art_solid_fill color="ffff00ff"/>
	    </children>
	  </pego>
	 */

	module.exports = createWithPostCreate(module, V1Writer = (function(superClass) {
	  extend(V1Writer, superClass);

	  V1Writer.singletonClass();

	  V1Writer.toArtFileTags = function(element) {
	    return V1Writer.singleton.toArtFileTags(element);
	  };

	  V1Writer.toEncodedArtFile = function(element) {
	    return V1Writer.singleton.toEncodedArtFile(element);
	  };

	  function V1Writer() {
	    this._toXbdTag = bind(this._toXbdTag, this);
	    this.toEncodedArtFile = bind(this.toEncodedArtFile, this);
	    V1Writer.__super__.constructor.apply(this, arguments);
	    this.reset();
	  }

	  V1Writer.prototype.reset = function() {
	    this.bitmapTags = {};
	    return this.bitmapTagCount = 0;
	  };


	  /*
	  IN: any Art.Engine.Element
	  OUT: promise.then (binaryString) ->
	   */

	  V1Writer.prototype.toArtFileTags = function(rootElement) {
	    this.reset();
	    return rootElement.onNextReady().then((function(_this) {
	      return function() {
	        return _this._generateBitmapsTag(rootElement);
	      };
	    })(this)).then((function(_this) {
	      return function() {
	        return Promise.all([_this._encodeProps(rootElement), _this._getChildrenTagPromise(rootElement)]);
	      };
	    })(this)).then((function(_this) {
	      return function(arg) {
	        var childrenTag, encodedProps;
	        encodedProps = arg[0], childrenTag = arg[1];
	        encodedProps.art_engine_version = "0.0.2";
	        encodedProps.kimi_editor_version = "0.6.0";
	        return RootTag(ArtFileTag(encodedProps, childrenTag, _this.bitmapsTag));
	      };
	    })(this));
	  };

	  V1Writer.prototype.toEncodedArtFile = function(element) {
	    return this.toArtFileTags(element).then(function(tag) {
	      return tag.toXbd();
	    });
	  };

	  V1Writer.prototype._encodeLayout = function(element, encodedProps) {
	    var angle, axis, currentLocation, currentSize, e2p, matrix;
	    currentSize = element.currentSize, currentLocation = element.currentLocation, axis = element.axis;
	    e2p = element.getElementToParentMatrix();
	    matrix = e2p.withLocation(0).toArray().join(',');
	    if (matrix !== "1,1,0,0,0,0") {
	      encodedProps.matrix = matrix;
	    }
	    if (!floatEq(0, angle = e2p.getAngle())) {
	      encodedProps.angle = "" + angle;
	    }
	    encodedProps.w_val = currentSize.x.toString();
	    encodedProps.h_val = currentSize.y.toString();
	    if (!propsEq(currentLocation, point())) {
	      encodedProps.x_val = currentLocation.x.toString();
	      encodedProps.y_val = currentLocation.y.toString();
	    }
	    if (!propsEq(axis, point(.5))) {
	      return encodedProps.handle = "(" + axis.x + "," + axis.y + ")";
	    }
	  };

	  V1Writer.prototype._addTagForBitmap = function(arg) {
	    var bitmap, encodedBitmap, uniqueId, userProps;
	    bitmap = arg.bitmap, userProps = arg.userProps;
	    uniqueId = bitmap.uniqueId;
	    if (this.bitmapTags[uniqueId]) {
	      return Promise.resolve();
	    }
	    if (userProps) {
	      encodedBitmap = userProps.encodedBitmap;
	    }
	    return Promise.resolve().then((function(_this) {
	      return function() {
	        return encodedBitmap || bitmap.toJpg();
	      };
	    })(this)).then((function(_this) {
	      return function(encodedBitmap) {
	        return _this.bitmapTags[uniqueId] = BitmapTag({
	          bitmap_id: _this.bitmapTagCount++,
	          pixel_data: encodedBitmap
	        });
	      };
	    })(this));
	  };

	  V1Writer.prototype._populateBitmapSubTagsRecursive = function(element) {
	    var bitmap, children;
	    bitmap = element.bitmap, children = element.children;
	    return Promise.resolve().then((function(_this) {
	      return function() {
	        return bitmap && _this._addTagForBitmap(element);
	      };
	    })(this)).then((function(_this) {
	      return function() {
	        var child;
	        return Promise.all((function() {
	          var i, len, results;
	          results = [];
	          for (i = 0, len = children.length; i < len; i++) {
	            child = children[i];
	            results.push(this._populateBitmapSubTagsRecursive(child));
	          }
	          return results;
	        }).call(_this));
	      };
	    })(this));
	  };

	  V1Writer.prototype._generateBitmapsTag = function(element) {
	    return this._populateBitmapSubTagsRecursive(element).then((function(_this) {
	      return function() {
	        var k, tag;
	        if (_this.bitmapTagCount > 0) {
	          return _this.bitmapsTag = BitmapsTag((function() {
	            var ref1, results;
	            ref1 = this.bitmapTags;
	            results = [];
	            for (k in ref1) {
	              tag = ref1[k];
	              results.push(tag);
	            }
	            return results;
	          }).call(_this));
	        }
	      };
	    })(this));
	  };

	  V1Writer.prototype._encodeProps = function(element) {
	    var bitmapTag, encodedProps, k, minimalProps, v;
	    minimalProps = element.minimalProps;
	    encodedProps = {};
	    for (k in minimalProps) {
	      v = minimalProps[k];
	      switch (k) {
	        case "userProps":
	          if (v.dropInEnabled) {
	            encodedProps.drop_in_enabled = "true";
	            encodedProps.lock_mode = "2";
	          }
	          break;
	        case "compositeMode":
	          if (v === "alphaMask") {
	            encodedProps.stack_mode = "+stencil";
	          }
	          break;
	        case "key":
	          encodedProps.name = v.toString();
	          break;
	        case "elementToParentMatrix":
	          encodedProps.matrix = v.toString();
	          break;
	        case "bitmap":
	          if (!(bitmapTag = this.bitmapTags[v.uniqueId])) {
	            console.warn("Bitmap missing: " + v.uniqueId);
	          }
	          encodedProps.bitmap_id = bitmapTag.attrs.bitmap_id;
	          break;
	        case "location":
	        case "children":
	        case "parent":
	        case "currentSize":
	        case "size":
	        case "axis":
	        case "color":
	        case "scale":
	        case "angle":
	          break;
	        default:
	          console.warn("Art.Engine.V1Writer: ignored unsupported prop type: elementType: " + element["class"].name + ", propType: " + k);
	      }
	    }
	    this._encodeLayout(element, encodedProps);
	    return encodedProps;
	  };

	  V1Writer.prototype._getChildrenTagPromise = function(element) {
	    return Promise.resolve().then((function(_this) {
	      return function() {
	        var child, ref1;
	        switch (element["class"].name) {
	          case "RectangleElement":
	            return ChildrenTag(null, ArtStencilShapeTag({
	              stack_mode: "+stencil",
	              x_layout_mode: "7",
	              x_val: "0.5",
	              w_val: "1",
	              y_layout_mode: "7",
	              y_val: "0.5",
	              h_val: "1"
	            }, ArtRectangleTag()), ArtSolidFillTag({
	              color: ((ref1 = element.color) != null ? ref1.rawRgbaHexString : void 0) || "000000ff"
	            }));
	          default:
	            return Promise.all((function() {
	              var i, len, ref2, results;
	              ref2 = element.children;
	              results = [];
	              for (i = 0, len = ref2.length; i < len; i++) {
	                child = ref2[i];
	                results.push(this._toXbdTag(child));
	              }
	              return results;
	            }).call(_this)).then(function(savedChildren) {
	              return savedChildren.length > 0 && ChildrenTag(savedChildren);
	            });
	        }
	      };
	    })(this));
	  };

	  V1Writer.prototype._toXbdTag = function(element) {
	    var TagFactory;
	    if (!(TagFactory = elementToTagFactory[element["class"].name])) {
	      console.warn("Art.Engine.V1Writer: unsupported Element type: " + element["class"].name);
	      return null;
	    }
	    return Promise.all([this._encodeProps(element), this._getChildrenTagPromise(element)]).then((function(_this) {
	      return function(arg) {
	        var childrenTag, encodedProps;
	        encodedProps = arg[0], childrenTag = arg[1];
	        return TagFactory(encodedProps, childrenTag);
	      };
	    })(this));
	  };

	  return V1Writer;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(282);


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	var Aim, CanvasElement, Element, ElementFactory, Engine, FullScreenApp, React, log,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	log = __webpack_require__(19).log;

	Engine = __webpack_require__(152);

	React = __webpack_require__(283);

	ElementFactory = Engine.ElementFactory, Element = Engine.Element, CanvasElement = Engine.CanvasElement, FullScreenApp = Engine.FullScreenApp;

	module.exports = React;

	Aim = __webpack_require__(300);

	React.addElementFactories = function(elementClassNames) {
	  var factories, k, ref, v;
	  ref = factories = Aim.createVirtualElementFactories(React.VirtualElementArtEngine, elementClassNames);
	  for (k in ref) {
	    v = ref[k];
	    React[k] || (React[k] = v);
	  }
	  return factories;
	};

	React.VirtualElementArtEngine = (function(superClass) {
	  extend(VirtualElementArtEngine, superClass);

	  function VirtualElementArtEngine() {
	    return VirtualElementArtEngine.__super__.constructor.apply(this, arguments);
	  }

	  VirtualElementArtEngine.prototype._updateElementProps = function(newProps) {
	    var addedOrChanged, removed;
	    addedOrChanged = (function(_this) {
	      return function(k, v) {
	        return _this.element.setProperty(k, v);
	      };
	    })(this);
	    removed = (function(_this) {
	      return function(k, v) {
	        return _this.element.resetProperty(k);
	      };
	    })(this);
	    return this._updateElementPropsHelper(newProps, addedOrChanged, removed);
	  };

	  VirtualElementArtEngine.prototype._setElementChildren = function(childElements) {
	    return this.element.setChildren(childElements);
	  };

	  VirtualElementArtEngine.prototype._newElement = function(elementClassName, props, childElements, bindToOrCreateNewParentElementProps) {
	    var element;
	    element = ElementFactory.newElement(this.elementClassName, props, childElements);
	    if (bindToOrCreateNewParentElementProps) {
	      if (bindToOrCreateNewParentElementProps instanceof Element) {
	        bindToOrCreateNewParentElementProps.addChild(element);
	      } else {
	        props = merge(bindToOrCreateNewParentElementProps, {
	          webgl: Browser.Parse.query().webgl === "true",
	          children: [element]
	        });
	        new CanvasElement(props);
	      }
	    }
	    element.creator = this;
	    return element;
	  };

	  VirtualElementArtEngine.prototype._newErrorElement = function() {
	    return this._newElement("RectangleElement", {
	      key: "ART_REACT_ERROR_CREATING_CHILD_PLACEHOLDER",
	      color: "orange"
	    });
	  };

	  return VirtualElementArtEngine;

	})(React.VirtualElement);

	React.fullScreenReactAppInit = function(a, b) {
	  var initOptions, topComponent;
	  initOptions = isPlainObject(a) ? (topComponent = b, a) : (topComponent = a, b || {});
	  return FullScreenApp.init(initOptions).then(function() {
	    return Promise.resolve(topComponent).then(function(topComponent) {
	      return topComponent.instantiateAsTopComponent();
	    });
	  })["catch"](function(error) {
	    return log.error("ArtReact.fullScreenReactAppInit failed", error);
	  });
	};

	React.addElementFactories();


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(284).includeInNamespace(__webpack_require__(286));

	__webpack_require__(287);


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	var Art, React,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(285);

	module.exports = Art.React || Art.addNamespace('React', React = (function(superClass) {
	  extend(React, superClass);

	  function React() {
	    return React.__super__.constructor.apply(this, arguments);
	  }

	  return React;

	})(Neptune.Base));


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(287);


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(288).includeInNamespace(__webpack_require__(289)).addModules({
	  Component: __webpack_require__(290),
	  HotStyleProps: __webpack_require__(298),
	  ReactArtEngineEpoch: __webpack_require__(292),
	  VirtualElement: __webpack_require__(299),
	  VirtualNode: __webpack_require__(291)
	});


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	var Core, React,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	React = __webpack_require__(284);

	module.exports = React.Core || React.addNamespace('Core', Core = (function(superClass) {
	  extend(Core, superClass);

	  function Core() {
	    return Core.__super__.constructor.apply(this, arguments);
	  }

	  return Core;

	})(Neptune.Base));


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	var Component, _package, arrayWith, isPlainArray, isString, log, reactArtEngineEpoch, ref;

	Component = __webpack_require__(290);

	reactArtEngineEpoch = __webpack_require__(292).reactArtEngineEpoch;

	ref = __webpack_require__(19), isPlainArray = ref.isPlainArray, isString = ref.isString, arrayWith = ref.arrayWith, log = ref.log;

	module.exports = [
	  [Component, "createAndInstantiateTopComponent", "createComponentFactory"], {
	    instantiateTopComponent: function(componentInstance, bindToOrCreateNewParentElementProps) {
	      console.warn("React.instantiateTopComponent is DEPRICATED. Use: componentInstance.instantiateAsTopComponent");
	      return componentInstance.instantiateAsTopComponent(bindToOrCreateNewParentElementProps);
	    },
	    onNextReady: function(callback) {
	      return reactArtEngineEpoch.onNextReady(callback);
	    },
	    "package": _package = __webpack_require__(297),
	    version: _package.version,
	    objectTreeFactoryOptions: {
	      mergePropsInto: function(into, props) {
	        var k, oldValue, v;
	        for (k in props) {
	          v = props[k];
	          into[k] = k === "text" && isPlainArray(v) && isPlainArray(oldValue = into[k]) ? oldValue.concat(v) : v;
	        }
	        return into;
	      },
	      preprocessElement: function(element) {
	        if (isString(element)) {
	          return {
	            text: [element]
	          };
	        } else {
	          return element;
	        }
	      }
	    }
	  }
	];


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var ArtEngineCore, BaseObject, Foundation, GlobalEpochCycle, HotLoader, InstanceFunctionBindingMixin, React, ReactArtEngineEpoch, StateEpoch, VirtualNode, arrayWithout, clone, compactFlatten, countStep, createObjectTreeFactory, createWithPostCreate, defineModule, fastBind, formattedInspect, getModuleBeingDefined, globalCount, globalEpochCycle, inspect, isArray, isFunction, isObject, isString, keepIfRubyTrue, log, merge, mergeInto, onNextStateEpochReady, reactArtEngineEpoch, runHot, select, shallowClone, slice, stackTime, stateEpoch, time, timePerformance, upperCamelCase,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	VirtualNode = __webpack_require__(291);

	ReactArtEngineEpoch = __webpack_require__(292);

	defineModule = Foundation.defineModule, log = Foundation.log, merge = Foundation.merge, mergeInto = Foundation.mergeInto, clone = Foundation.clone, shallowClone = Foundation.shallowClone, inspect = Foundation.inspect, compactFlatten = Foundation.compactFlatten, keepIfRubyTrue = Foundation.keepIfRubyTrue, BaseObject = Foundation.BaseObject, fastBind = Foundation.fastBind, slice = Foundation.slice, isObject = Foundation.isObject, isString = Foundation.isString, isArray = Foundation.isArray, isFunction = Foundation.isFunction, globalCount = Foundation.globalCount, time = Foundation.time, stackTime = Foundation.stackTime, countStep = Foundation.countStep, createWithPostCreate = Foundation.createWithPostCreate, arrayWithout = Foundation.arrayWithout, upperCamelCase = Foundation.upperCamelCase, createObjectTreeFactory = Foundation.createObjectTreeFactory, select = Foundation.select, formattedInspect = Foundation.formattedInspect, getModuleBeingDefined = Foundation.getModuleBeingDefined, InstanceFunctionBindingMixin = Foundation.InstanceFunctionBindingMixin;

	reactArtEngineEpoch = ReactArtEngineEpoch.reactArtEngineEpoch;

	React = __webpack_require__(288);

	HotLoader = __webpack_require__(293).HotLoader;

	runHot = HotLoader.runHot;

	if (ArtEngineCore = Neptune.Art.Engine.Core) {
	  StateEpoch = ArtEngineCore.StateEpoch, GlobalEpochCycle = ArtEngineCore.GlobalEpochCycle;
	  stateEpoch = StateEpoch.stateEpoch;
	  globalEpochCycle = GlobalEpochCycle.globalEpochCycle;
	  onNextStateEpochReady = function(f) {
	    return stateEpoch.onNextReady(f);
	  };
	  timePerformance = function(name, f) {
	    return globalEpochCycle.timePerformance(name, f);
	  };
	} else {
	  onNextStateEpochReady = function(f) {
	    return reactArtEngineEpoch.onNextReady(f);
	  };
	  timePerformance = function(name, f) {
	    return f();
	  };
	}


	/*
	React.js vs ReactArtEngine
	--------------------------

	Generaly, ReactArtEngine is designed to work just like React.js. There is
	some evolution, though, which I try to note below. -SBD

	ReactArtEngine: "Instantiation"
	-------------------------------

	This is not a concept in React.js. It isn't important to the client, but it
	is useful to understand in the implementation.

	In-short: an non-instantiated component only has properties. It doesn't have
	state and it isn't rendered. An instantiated component has state and gets
	rendered at least once.

	When a component is used in a render function, and with every re-render, it
	an instance-object is created with standard javascript "new ComponentType."
	However, that component instance is only a shell - it contains the
	properties passed into the constructor and nothing else.

	Once the entire render is done, the result is diffed against the current
	Virtual-AIM. The component instance is compared against existing components
	via the diff rules. If an existing, matching component exists, that
	component is updated and the new instance is discard. However, if an
	existing match doesn't exist, then the new component instance is
	"instantiated" and added to the virtual-Aim.

	QUESTIONS
	---------

	I just discovered it is possible, and useful, for a component to be rendered
	after it is unmounted. I don't think this is consistent with Facebook-React.

	Possible: if @setState is called after it is unmounted, it will trigger a
	render. This can happen in FluxComponents when a subscription updates.

	Useful: Why does this even make sense? Well, with Art.Engine we have
	removedAnimations. That means the element still exists even though it has been
	"removed." It exists until the animation completes. It is therefor useful to
	continue to receive updates from React, where appropriate, during that "sunset"
	time.

	Thoughts: I think this is OK, though this changes what "unmounted" means. I just
	fixed a bug where @state got altered without going through preprocessState first
	when state changes after the component was unmounted. How should I TEST this???
	 */

	defineModule(module, function() {
	  var Component;
	  return Component = (function(superClass) {
	    var defaultComponentDidMount, defaultComponentDidUpdate, defaultComponentWillMount, defaultComponentWillReceiveProps, defaultComponentWillUnmount, defaultComponentWillUpdate, defaultPreprocessProps, defaultPreprocessState, emptyArray, emptyProps, emptyState, getModule, sf, unknownModule;

	    extend(Component, superClass);

	    Component.abstractClass();

	    Component.nonBindingFunctions = "getInitialState componentWillReceiveProps componentWillMount componentWillUnmount componentWillUpdate componentDidMount componentDidUpdate render".split(/\s+/);

	    Component.created = 0;

	    Component.topComponentInstances = [];

	    Component.rerenderAll = function() {
	      var component, j, len, ref, results;
	      ref = this.topComponentInstances;
	      results = [];
	      for (j = 0, len = ref.length; j < len; j++) {
	        component = ref[j];
	        results.push(component.rerenderAll());
	      }
	      return results;
	    };

	    Component.prototype.rerenderAll = function() {
	      var component, j, len, ref, results;
	      this._queueRerender();
	      ref = this.subComponents;
	      results = [];
	      for (j = 0, len = ref.length; j < len; j++) {
	        component = ref[j];
	        results.push(component.rerenderAll());
	      }
	      return results;
	    };

	    Component.createAndInstantiateTopComponent = function(spec) {
	      return Component.createComponentFactory(spec).instantiateAsTopComponent();
	    };

	    unknownModule = {};

	    Component.createComponentFactory = function(spec, BaseClass) {
	      var AnonymousComponent, _module, anonymousComponentName, componentClass;
	      if (BaseClass == null) {
	        BaseClass = Component;
	      }
	      componentClass = (function() {
	        if ((spec != null ? spec.prototype : void 0) instanceof Component) {
	          return spec;
	        } else if ((spec != null ? spec.constructor : void 0) === Object) {
	          _module = getModule(spec) || unknownModule;
	          _module.uniqueComponentNameId || (_module.uniqueComponentNameId = 1);
	          anonymousComponentName = "Anonymous" + (BaseClass.getClassName());
	          anonymousComponentName += "_" + (_module.uniqueComponentNameId++);
	          anonymousComponentName += _module.id ? "_Module" + _module.id : '_ModuleUnknown';
	          return AnonymousComponent = (function(superClass1) {
	            var k, v;

	            extend(AnonymousComponent, superClass1);

	            function AnonymousComponent() {
	              return AnonymousComponent.__super__.constructor.apply(this, arguments);
	            }

	            AnonymousComponent._name = anonymousComponentName;

	            for (k in spec) {
	              v = spec[k];
	              AnonymousComponent.prototype[k] = v;
	            }

	            return AnonymousComponent;

	          })(BaseClass);
	        } else {
	          throw new Error("Specification Object or class inheriting from Component required.");
	        }
	      }).call(this);
	      return createWithPostCreate(componentClass);
	    };

	    Component.getModule = getModule = function(spec) {
	      if (spec == null) {
	        spec = this.prototype;
	      }
	      return spec.module || spec.hotModule || getModuleBeingDefined();
	    };

	    Component.getCanHotReload = function() {
	      var ref;
	      return (ref = this.getModule()) != null ? ref.hot : void 0;
	    };

	    Component._hotReloadUpdate = function(_moduleState) {
	      var hotInstances, instance, j, len, name, results;
	      this._moduleState = _moduleState;
	      name = this.getClassName();
	      if (hotInstances = this._moduleState.hotInstances) {
	        log({
	          HotReload: {
	            Component: this,
	            instanceCount: hotInstances.length,
	            forEachInstance: "instance.componentDidHotReload()"
	          }
	        });
	        results = [];
	        for (j = 0, len = hotInstances.length; j < len; j++) {
	          instance = hotInstances[j];
	          results.push(instance._componentDidHotReload());
	        }
	        return results;
	      }
	    };

	    Component.allComponents = {};

	    Component.postCreateConcreteClass = function(arg) {
	      var classModuleState, hotReloadEnabled;
	      classModuleState = arg.classModuleState, hotReloadEnabled = arg.hotReloadEnabled;
	      Component.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
	      if (hotReloadEnabled) {
	        this._hotReloadUpdate(classModuleState);
	      }
	      return this.toComponentFactory();
	    };

	    Component.toComponentFactory = function() {
	      return createObjectTreeFactory(merge(React.objectTreeFactoryOptions, {
	        inspectedName: this.getName() + "ComponentFactory",
	        "class": this,
	        bind: "instantiateAsTopComponent"
	      }), (function(_this) {
	        return function(props, children) {
	          var instance;
	          if (children.length > 0) {
	            props.children = children;
	          }
	          instance = new _this(props);
	          instance._validateChildren(props != null ? props.children : void 0);
	          return instance;
	        };
	      })(this));
	    };

	    Component.instantiateAsTopComponent = function(props, options) {
	      return new this(props).instantiateAsTopComponent(options);
	    };

	    Component.extendableProperty({
	      stateFields: {}
	    });

	    Component.stateFields = sf = function(fields) {
	      var field, initialValue, results;
	      this.extendStateFields(fields);
	      results = [];
	      for (field in fields) {
	        initialValue = fields[field];
	        results.push((function(_this) {
	          return function(field) {
	            _this.addSetter(field, function(v) {
	              return this.setState(field, v);
	            });
	            return _this.addGetter(field, function() {
	              return this.state[field];
	            });
	          };
	        })(this)(field));
	      }
	      return results;
	    };

	    Component.stateField = sf;

	    Component.createdComponents = null;

	    Component.pushCreatedComponent = function(c) {
	      this.createdComponents || (this.createdComponents = []);
	      return this.createdComponents.push(c);
	    };

	    Component.resetCreatedComponents = function() {
	      return this.createdComponents = null;
	    };

	    emptyProps = {};

	    function Component(props) {
	      if (props == null) {
	        props = emptyProps;
	      }
	      Component.created++;
	      globalCount("ReactComponent_Created");
	      Component.__super__.constructor.call(this, props);
	      this.state = {};
	      this.refs = null;
	      this._pendingState = null;
	      this._virtualAimBranch = null;
	      this._mounted = false;
	      this._wasMounted = false;
	      this._bindList = null;
	      this._applyingPendingState = false;
	      Component.pushCreatedComponent(this);
	    }


	    /*
	    SEE: VirtualElement#withElement for more
	    IN: f = (concreteElement) -> x
	    OUT: promise.then (x) ->
	     */

	    Component.prototype.withElement = function(f) {
	      return this._virtualAimBranch.withElement(f);
	    };

	    Component.prototype.instantiateAsTopComponent = function(bindToOrCreateNewParentElementProps) {
	      Component.topComponentInstances.push(this);
	      return this._instantiate(null, bindToOrCreateNewParentElementProps);
	    };

	    Component.prototype.unbindTopComponent = function() {
	      var index;
	      if (!(0 <= (index = Component.topComponentInstances.indexOf(this)))) {
	        throw new Error("not a top component!");
	      }
	      Component.topComponentInstances = arrayWithout(Component.topComponentInstances, index);
	      return this._unmount();
	    };

	    Component.getter({
	      inspectedName: function() {
	        return "" + this.className + (this.key ? "-" + this.key : '');
	      },
	      mounted: function() {
	        return this._mounted;
	      }
	    });

	    Component.prototype.onNextReady = function(callback, forceEpoch) {
	      if (forceEpoch == null) {
	        forceEpoch = true;
	      }
	      return onNextStateEpochReady(callback, forceEpoch, this);
	    };

	    Component.prototype.setState = function(newState, callback, callbackB) {
	      var _state, k, testState, v;
	      if (isString(newState)) {
	        return this._setSingleState(newState, callback, callbackB);
	      }
	      this.onNextReady(callback);
	      if (newState) {
	        testState = this._pendingState || this.state;
	        _state = null;
	        for (k in newState) {
	          v = newState[k];
	          if (!(testState[k] !== v)) {
	            continue;
	          }
	          _state || (_state = this._getStateToSet());
	          _state[k] = v;
	        }
	      }
	      return newState;
	    };

	    Component.prototype.replaceState = function(newState, callback) {
	      this._setPendingState(newState);
	      return this.onNextReady(callback);
	    };

	    Component.prototype.forceUpdate = function(callback) {
	      this._getPendingState();
	      return this.onNextReady(callback);
	    };

	    Component.prototype.getInitialState = function() {
	      return {};
	    };


	    /*
	    Called each time webpack hot-reloads a module.
	    It is important that this change the components state to trigger a rerender.
	    Make sure you add module: module to your component definition or
	    run your definition in a runHot module, -> function
	     */

	    Component.prototype.componentDidHotReload = function() {
	      var count;
	      count = (this.state._hotModuleReloadCount || 0) + 1;
	      return this.setState({
	        _hotModuleReloadCount: count
	      });
	    };

	    Component.prototype.componentWillReceiveProps = defaultComponentWillReceiveProps = function(newProps) {};

	    Component.prototype.componentWillMount = defaultComponentWillMount = function() {};

	    Component.prototype.componentWillUnmount = defaultComponentWillUnmount = function() {};

	    Component.prototype.componentWillUpdate = defaultComponentWillUpdate = function(newProps, newState) {};

	    Component.prototype.componentDidMount = defaultComponentDidMount = function() {};

	    Component.prototype.componentDidUpdate = defaultComponentDidUpdate = function(oldProps, oldState) {};


	    /*
	    Function:     preprocessProps
	    
	    When:         Called on component instantiation and any time props are updated
	    
	    IN:           newProps - The props received from the render call which created/updated this component
	    
	    OUT:          plain Object - becomes @props. Can be newProps, based on newProps or entirely new.
	    
	    Guarantee:    @props will allways be passed through preprocessProps before it is set.
	                  i.e. Your render code will never see a @props that hasen't been preprocessed.
	    
	    Be sure your preprocessProps: (requirements)
	      - returns a plain Object
	      - doesn't modify the newProps object passed in (create and return new object to add/alter props)
	      - call super!
	    
	    Examples:
	       * minimal
	      preprocessProps: ->
	        merge super, myProp: 123
	    
	       * a little of everything
	      preprocessProps: ->
	        newProps = super
	        @setState foo: newProps.foo
	        merge newProps, myProp: "dude: #{newProps.foo}"
	    
	    Okay:
	      you can call @setState (Art.Flux.Component does exactly this!)
	    
	    Description:
	      Either return exactly newProps which were passed in OR create a new, plain object.
	      The returned object can contain anything you want.
	      These are the props the component will see in any subsequent lifecycle calls.
	    
	    NOTE: Unique to Art.React. Not in Facebook's React.
	    
	    NOTES RE Facebook.React:
	      Why add this? Well, often you want to apply a transformation to @props whenever its set OR it changes.
	      With Facebook.React there is no one lifecycle place for this. Component instantiation/mounting
	      and component updating are kept separate. I have found it is very error-prone to implement
	      this common functionality manually on each component that needs it.
	     */

	    Component.prototype.preprocessProps = defaultPreprocessProps = function(newProps) {
	      return newProps;
	    };


	    /*
	    Function:     preprocessState
	    
	    When:         preprocessState is called:
	                    immediatly after getInitialState
	                    after preprocessProps
	                    after componentWillUpdate
	                    before rendering
	    
	    IN:           newState - the state which is proposed to become @state
	    OUT:          object which will become @state. Can be newState, be based on newState or completely new.
	    
	    Guarantees:   @state will allways be passed through preprocessState before it is set.
	                  i.e. Your render code will never see a @state that hasen't been preprocessed.
	    
	    NOTES RE Facebook.React:
	      Why add this? Well, often you want to apply a transformation to @state whenever it is initialized
	      OR it changes. With Facebook.React there is no one lifecycle place for this. Component
	      instantiation/mounting and component updating are kept separate. I have found it is very
	      error-prone to implement this common functionality manually on each component that needs it.
	    
	      An example of this is FluxComponents. They alter state implicitly as the subscription data comes in, and
	      and component instantiation. preprocessState makes it easy to transform any data written via FluxComponents
	      into a standard form.
	    
	    SBD NOTES TO SELF:
	      I think:
	        - it is OK to directly mutate newState, can we declare this offically part of the API?
	        - calls to @setState in preprocessState will be applied NEXT epoch.
	        - could make getInitialState obsolete, but I think we'll keep it around for convenience and consistency
	     */

	    Component.prototype.preprocessState = defaultPreprocessState = function(newState) {
	      return newState;
	    };

	    Component.prototype.find = function(pattern, arg, matches, path) {
	      var child, findAll, functionResult, j, len, matchFound, pathString, ref, ref1, usedFunction, verbose;
	      ref = arg != null ? arg : {}, findAll = ref.findAll, verbose = ref.verbose;
	      if (matches == null) {
	        matches = [];
	      }
	      pathString = path ? path + "/" + this.inspectedName : this.inspectedName;
	      matchFound = (usedFunction = isFunction(pattern)) ? !!(functionResult = pattern(this)) : pathString.match(pattern);
	      if (matchFound) {
	        if (verbose) {
	          this.log(usedFunction ? {
	            matched: pathString,
	            functionResult: functionResult
	          } : {
	            matched: pathString
	          });
	        }
	        matches.push(this);
	      } else if (verbose === "all") {
	        this.log(usedFunction ? {
	          notMatched: pathString,
	          functionResult: functionResult
	        } : {
	          notMatched: pathString
	        });
	      }
	      if ((!matchFound || findAll) && this.subComponents) {
	        ref1 = this.subComponents;
	        for (j = 0, len = ref1.length; j < len; j++) {
	          child = ref1[j];
	          child.find(pattern, arguments[1], matches);
	        }
	      }
	      return matches;
	    };

	    Component.prototype.toCoffeescript = function(indent) {
	      return this._virtualAimBranch.toCoffeescript(indent);
	    };

	    Component.prototype.getPendingState = function() {
	      return this._pendingState || this.state;
	    };

	    Component.prototype._getStateToSet = function() {
	      if (this._wasMounted) {
	        return this._getPendingState();
	      } else {
	        return this.state;
	      }
	    };

	    Component.prototype._setSingleState = function(stateKey, stateValue, callback) {
	      this.onNextReady(callback);
	      if (this._pendingState || this.state[stateKey] !== stateValue) {
	        this._getStateToSet()[stateKey] = stateValue;
	      }
	      return stateValue;
	    };

	    Component.prototype._queueRerender = function() {
	      return this._getPendingState();
	    };

	    Component.prototype._setPendingState = function(state) {
	      if (!(this._pendingState || this._applyingPendingState)) {
	        reactArtEngineEpoch.addChangingComponent(this);
	      }
	      return this._pendingState = state ? shallowClone(state) : {};
	    };

	    Component.prototype._getPendingState = function() {
	      return this._pendingState || this._setPendingState(this.state);
	    };

	    Component.prototype._unmount = function() {
	      var ref;
	      this._removeHotInstance();
	      this._componentWillUnmount();
	      if ((ref = this._virtualAimBranch) != null) {
	        ref._unmount();
	      }
	      return this._mounted = false;
	    };

	    Component.prototype._addHotInstance = function() {
	      var moduleState;
	      if (moduleState = this["class"]._moduleState) {
	        return (moduleState.hotInstances || (moduleState.hotInstances = [])).push(this);
	      }
	    };

	    Component.prototype._removeHotInstance = function() {
	      var hotInstances, index, moduleState;
	      if (moduleState = this["class"]._moduleState) {
	        hotInstances = moduleState.hotInstances;
	        if (hotInstances && 0 <= (index = hotInstances.indexOf(this))) {
	          return moduleState.hotInstances = arrayWithout(hotInstances, index);
	        }
	      }
	    };

	    emptyState = {};

	    Component.prototype._instantiate = function(parentComponent, bindToOrCreateNewParentElementProps) {
	      var __state, initialState;
	      Component.__super__._instantiate.apply(this, arguments);
	      globalCount("ReactComponent_Instantiated");
	      this.bindFunctionsToInstance();
	      this.props = this._preprocessProps(this.props);
	      this._addHotInstance();
	      this._componentWillMount();
	      initialState = this.getInitialState();
	      __state = this.state;
	      this.state = emptyState;
	      this.state = this._preprocessState(merge(this.getStateFields(), __state, initialState));
	      this._virtualAimBranch = this._renderCaptureRefs();
	      this._virtualAimBranch._instantiate(this, bindToOrCreateNewParentElementProps);
	      this.element = this._virtualAimBranch.element;
	      this._componentDidMount();
	      this._wasMounted = this._mounted = true;
	      return this;
	    };

	    emptyArray = [];

	    Component.prototype._renderCaptureRefs = function() {
	      var ret;
	      ret = null;
	      timePerformance("reactRender", (function(_this) {
	        return function() {
	          globalCount("ReactComponent_Rendered");
	          VirtualNode.assignRefsTo = _this.refs = {};
	          Component.resetCreatedComponents();
	          ret = _this.render();
	          if (!(ret instanceof VirtualNode)) {
	            throw new Error(_this.className + ": render must return a VirtualNode. Got: " + (inspect(ret)));
	          }
	          _this.subComponents = Component.createdComponents || emptyArray;
	          return VirtualNode.assignRefsTo = null;
	        };
	      })(this));
	      return ret;
	    };

	    Component.prototype._updateRefsAfterReRender = function() {
	      var _updateTarget, c, i, j, k, len, ref, ref1, results, update, v;
	      ref = this.refs;
	      for (k in ref) {
	        v = ref[k];
	        if (_updateTarget = this.refs[k]._updateTarget) {
	          this.refs[k] = _updateTarget;
	        }
	      }
	      ref1 = this.subComponents;
	      results = [];
	      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
	        c = ref1[i];
	        if (update = c._updateTarget) {
	          results.push(this.subComponents[i] = update);
	        }
	      }
	      return results;
	    };

	    Component.prototype._canUpdateFrom = function(b) {
	      return this["class"] === b["class"] && this.key === b.key;
	    };

	    Component.prototype._shouldReRenderComponent = function(componentInstance) {
	      return this._propsChanged(componentInstance) || this._pendingState;
	    };

	    Component.prototype._reRenderComponent = function() {
	      var newRenderResult, ref;
	      newRenderResult = this._renderCaptureRefs();
	      if (this._virtualAimBranch._canUpdateFrom(newRenderResult)) {
	        this._virtualAimBranch._updateFrom(newRenderResult);
	        this._updateRefsAfterReRender();
	      } else {
	        console.error("REACT-ART-ENGINE ERROR - The render function's top-level Component/VirtualElement changed 'too much.' The VirtualNode returned by a component's render function cannot change its Type or Key.\n\nSolution: Wrap your changing VirtualNode with a non-changing VirtualElement.\n\nOffending component: " + this.classPathName + "\nOffending component assigned to: self.offendingComponent");
	        console.log("CHANGED-TOO-MUCH-ERROR-DETAILS - all these properties must be the same on the oldRoot and newRoot", {
	          oldRoot: select(this._virtualAimBranch, "key", "elementClassName", "class"),
	          newRoot: select(newRenderResult, "key", "elementClassName", "class")
	        });
	        self.offendingComponent = this;
	        if ((ref = this._virtualAimBranch) != null) {
	          ref._unmount();
	        }
	        (this._virtualAimBranch = newRenderResult)._instantiate(this);
	      }
	      return this.element = this._virtualAimBranch.element;
	    };

	    Component.prototype._updateFrom = function(componentInstance) {
	      Component.__super__._updateFrom.apply(this, arguments);
	      if (this._shouldReRenderComponent(componentInstance)) {
	        globalCount("ReactComponent_UpdateFromTemporaryComponent_Changed");
	        this._applyPendingState(componentInstance.props);
	      } else {
	        globalCount("ReactComponent_UpdateFromTemporaryComponent_NoChange");
	      }
	      return this;
	    };

	    Component.prototype._applyPendingState = function(newProps) {
	      var newState, oldProps, oldState;
	      if (!(this._pendingState || newProps)) {
	        return;
	      }
	      this._applyingPendingState = true;
	      if (newProps) {
	        newProps = this._preprocessProps(newProps);
	        this._componentWillReceiveProps(newProps);
	      }
	      oldProps = this.props;
	      oldState = this.state;
	      newProps || (newProps = oldProps);
	      newState = this._pendingState || oldState;
	      this._componentWillUpdate(newProps, newState);

	      /*
	      React.js forbids calling setState from componentWillUpdate, but I see no reason for this.
	      This next line safely supports state updates in componentWillUpdate in a pure-functionalish way:
	        after a setState in @componentWillUpdate,
	        the new state will not be visible in the remainder of that @componetWillUpdate call
	        but it will be visible in any subsquent lifecycle call such as @render
	       */
	      newState = this._pendingState || oldState;
	      this._pendingState = null;
	      this.props = newProps;
	      this.state = this._preprocessState(newState);
	      this._applyingPendingState = false;
	      this._reRenderComponent();
	      return this._componentDidUpdate(oldProps, oldState);
	    };

	    Component.prototype._componentWillReceiveProps = function(newProps) {
	      if (defaultComponentWillReceiveProps === this.componentWillReceiveProps) {
	        return;
	      }
	      return timePerformance("reactLC", (function(_this) {
	        return function() {
	          return _this.componentWillReceiveProps(newProps);
	        };
	      })(this));
	    };

	    Component.prototype._preprocessProps = function(props) {
	      if (defaultPreprocessProps === this.preprocessProps) {
	        return props;
	      }
	      timePerformance("reactLC", (function(_this) {
	        return function() {
	          return props = _this.preprocessProps(props);
	        };
	      })(this));
	      return props;
	    };

	    Component.prototype._preprocessState = function(state) {
	      if (defaultPreprocessState === this.preprocessState) {
	        return state;
	      }
	      timePerformance("reactLC", (function(_this) {
	        return function() {
	          return state = _this.preprocessState(state);
	        };
	      })(this));
	      return state;
	    };

	    Component.prototype._componentWillMount = function() {
	      if (defaultComponentWillMount === this.componentWillMount) {
	        return;
	      }
	      return timePerformance("reactLC", (function(_this) {
	        return function() {
	          return _this.componentWillMount();
	        };
	      })(this));
	    };

	    Component.prototype._componentDidHotReload = function() {
	      this.bindFunctionsToInstance();
	      try {
	        return this.componentDidHotReload();
	      } catch (error) {}
	    };

	    Component.prototype._componentWillUnmount = function() {
	      if (defaultComponentWillUnmount === this.componentWillUnmount) {
	        return;
	      }
	      return timePerformance("reactLC", (function(_this) {
	        return function() {
	          return _this.componentWillUnmount();
	        };
	      })(this));
	    };

	    Component.prototype._componentWillUpdate = function(newProps, newState) {
	      if (!defaultComponentWillUpdate) {
	        return;
	      }
	      return timePerformance("reactLC", (function(_this) {
	        return function() {
	          return _this.componentWillUpdate(newProps, newState);
	        };
	      })(this));
	    };

	    Component.prototype._componentDidMount = function() {
	      if (defaultComponentDidMount === this.componentDidMount) {
	        return;
	      }
	      return this.onNextReady((function(_this) {
	        return function() {
	          return timePerformance("reactLC", function() {
	            return _this.componentDidMount();
	          });
	        };
	      })(this));
	    };

	    Component.prototype._componentDidUpdate = function(oldProps, oldState) {
	      if (defaultComponentDidUpdate === this.componentDidUpdate) {
	        return;
	      }
	      return this.onNextReady((function(_this) {
	        return function() {
	          return timePerformance("reactLC", function() {
	            return _this.componentDidUpdate(oldProps, oldState);
	          });
	        };
	      })(this));
	    };

	    return Component;

	  })(InstanceFunctionBindingMixin(VirtualNode));
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Foundation, ReactArtEngineEpoch, VirtualNode, compact, deepEach, emptyObject, flatten, globalCount, inspect, isObject, isPlainObject, keepIfRubyTrue, log, objectKeyCount, propsEq, reactArtEngineEpoch, shallowClone,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  slice = [].slice;

	Foundation = __webpack_require__(19);

	ReactArtEngineEpoch = __webpack_require__(292);

	log = Foundation.log, compact = Foundation.compact, globalCount = Foundation.globalCount, flatten = Foundation.flatten, BaseObject = Foundation.BaseObject, shallowClone = Foundation.shallowClone, inspect = Foundation.inspect, objectKeyCount = Foundation.objectKeyCount, isObject = Foundation.isObject, deepEach = Foundation.deepEach, isPlainObject = Foundation.isPlainObject, keepIfRubyTrue = Foundation.keepIfRubyTrue, propsEq = Foundation.propsEq;

	reactArtEngineEpoch = ReactArtEngineEpoch.reactArtEngineEpoch;

	emptyObject = {};

	module.exports = VirtualNode = (function(superClass) {
	  extend(VirtualNode, superClass);

	  VirtualNode.prototype.onNextReady = function(f, forceEpoch) {
	    if (forceEpoch == null) {
	      forceEpoch = true;
	    }
	    return reactArtEngineEpoch.onNextReady(f, forceEpoch, this);
	  };

	  VirtualNode.assignRefsTo = null;

	  function VirtualNode(props) {
	    if (props == null) {
	      props = emptyObject;
	    }
	    this._updateTarget = null;
	    this._parentComponent = null;
	    this.key = props.key;
	    this.props = props;
	    this._propsLength = -1;
	    this.element = null;
	    VirtualNode._assignRefs(this);
	  }

	  VirtualNode.getter({
	    propsLength: function() {
	      if (this._propsLength >= 0) {
	        return this._propsLength;
	      } else {
	        return this._propsLength = objectKeyCount(this.props);
	      }
	    }
	  });

	  VirtualNode.setter({
	    propsLength: function(v) {
	      return this._propsLength = v;
	    }
	  });


	  /*
	  Evaluate "f" in the thread the Element exists in.
	  
	  IN: (element) -> plainObjects
	  OUT: promise returning function's plain-object-result
	  
	   * TODO: add worker support
	   */

	  VirtualNode.prototype.withElement = function(f) {
	    return new Promise((function(_this) {
	      return function(resolve) {
	        return resolve(f(_this.element));
	      };
	    })(this));
	  };


	  /*
	  Lighter-weight than "withElement"
	  
	  IN:
	    method: string
	    args: 0 or more additional arguments
	  OUT: promise returning function's plain-object-result
	  
	  Equivelent to:
	    @withElement (element) -> element[method] args...
	   */

	  VirtualNode.prototype.sendToElement = function() {
	    var args, method;
	    method = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    return new Promise((function(_this) {
	      return function(resolve) {
	        var ref;
	        return resolve((ref = _this.element)[method].apply(ref, args));
	      };
	    })(this));
	  };

	  VirtualNode._separateConstructionParams = function(args, propsOut, childrenOut) {
	    return deepEach(args, function(obj) {
	      var k, results, v;
	      if (isPlainObject(obj)) {
	        results = [];
	        for (k in obj) {
	          v = obj[k];
	          results.push(propsOut[k] = v);
	        }
	        return results;
	      } else if (keepIfRubyTrue(obj)) {
	        return childrenOut.push(obj);
	      }
	    });
	  };

	  VirtualNode._assignRefs = function(node) {
	    var key;
	    if ((key = node.key) && this.assignRefsTo) {
	      if (this.assignRefsTo[key]) {
	        return console.warn("WARNING: Duplicate key found. This MUST be fixed for correct operation.\n  key: " + (inspect(key)) + "\n  new VirtualNode: " + node.inspectedName + "\n  old VirtualNode: " + this.assignRefsTo[key].inspectedName);
	      } else {
	        return this.assignRefsTo[key] = node;
	      }
	    }
	  };

	  VirtualNode.prototype._validateChildren = function(children) {
	    var child, i, len;
	    if (!children) {
	      return children;
	    }
	    for (i = 0, len = children.length; i < len; i++) {
	      child = children[i];
	      if (!(child instanceof VirtualNode)) {
	        console.warn({
	          "invalid VirtualNode child": child,
	          parent: this
	        });
	        if (isObject(child)) {
	          console.warn("Hint: Did you place properties AFTER a child element?");
	        }
	        throw new Error("VirtualNode child is not a VirtualNode.\ninvalid child: " + (inspect(child)) + "\nparent: " + this.inspectedName);
	      }
	    }
	    return children;
	  };

	  VirtualNode.prototype._propsChanged = function(virtualNode) {
	    var _propsLength, k, newProps, ref, v;
	    newProps = virtualNode.props;
	    _propsLength = 0;
	    ref = this.props;
	    for (k in ref) {
	      v = ref[k];
	      _propsLength++;
	      if (!propsEq(v, newProps[k])) {
	        return true;
	      }
	    }
	    this._propsLength = _propsLength;
	    return _propsLength !== virtualNode.getPropsLength();
	  };

	  VirtualNode.prototype._updateFrom = function(sourceNode) {
	    return sourceNode._updateTarget = this;
	  };

	  VirtualNode.prototype._canUpdateFrom = function(sourceNode) {
	    return false;
	  };

	  VirtualNode.prototype._instantiate = function(parentComponent, bindToOrCreateNewParentElementProps) {
	    this._parentComponent = parentComponent;
	    return this;
	  };

	  return VirtualNode;

	})(BaseObject);


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	var ArtEngineCore, BaseObject, Epoch, Foundation, GlobalEpochCycle, ReactArtEngineEpoch, clone, globalCount, inspect, isWebWorker, log, merge, peek, stackTime, timeout,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	log = Foundation.log, merge = Foundation.merge, clone = Foundation.clone, peek = Foundation.peek, inspect = Foundation.inspect, timeout = Foundation.timeout, BaseObject = Foundation.BaseObject, Epoch = Foundation.Epoch, globalCount = Foundation.globalCount, stackTime = Foundation.stackTime, isWebWorker = Foundation.isWebWorker, timeout = Foundation.timeout;

	module.exports = ReactArtEngineEpoch = (function(superClass) {
	  extend(ReactArtEngineEpoch, superClass);

	  function ReactArtEngineEpoch() {
	    return ReactArtEngineEpoch.__super__.constructor.apply(this, arguments);
	  }

	  ReactArtEngineEpoch.singletonClass();

	  ReactArtEngineEpoch.prototype.addChangingComponent = function(component) {
	    return this.queueItem(component);
	  };

	  ReactArtEngineEpoch.prototype.processEpochItems = function(changingComponents) {
	    return globalCount("ReactArtEngineEpoch processEpochItems", stackTime((function(_this) {
	      return function() {
	        var component, i, len, results;
	        results = [];
	        for (i = 0, len = changingComponents.length; i < len; i++) {
	          component = changingComponents[i];
	          results.push(component._applyPendingState());
	        }
	        return results;
	      };
	    })(this)));
	  };

	  return ReactArtEngineEpoch;

	})(Epoch);

	if (ArtEngineCore = Neptune.Art.Engine.Core) {
	  GlobalEpochCycle = ArtEngineCore.GlobalEpochCycle;
	  GlobalEpochCycle.singleton.includeReact(ReactArtEngineEpoch.singleton);
	}


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(294);


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(295).addModules({
	  HotLoader: __webpack_require__(296)
	});


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	var DevTools, Webpack,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	DevTools = __webpack_require__(254);

	module.exports = DevTools.Webpack || DevTools.addNamespace('Webpack', Webpack = (function(superClass) {
	  extend(Webpack, superClass);

	  function Webpack() {
	    return Webpack.__super__.constructor.apply(this, arguments);
	  }

	  return Webpack;

	})(Neptune.Base));


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, HotLoader, log, peek, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(19), BaseObject = ref.BaseObject, peek = ref.peek, log = ref.log;

	module.exports = HotLoader = (function(superClass) {
	  extend(HotLoader, superClass);

	  HotLoader.singletonClass();

	  HotLoader.runHot = function(m, f) {
	    return HotLoader.singleton.runHot(m, f);
	  };

	  HotLoader.getModuleState = function() {
	    return peek(HotLoader.singleton._modulePersistantState);
	  };

	  function HotLoader() {
	    this._modulePersistantState = [];
	  }

	  HotLoader.prototype.runHot = function(_module, f) {
	    var base, res;
	    if (_module != null ? _module.hot : void 0) {
	      this._modulePersistantState.push(((base = _module.hot).data || (base.data = {
	        modulePersistantState: {}
	      })).modulePersistantState);
	      _module.hot.accept();
	      _module.hot.dispose(function(data) {
	        return data.modulePersistantState = _module.hot.data.modulePersistantState;
	      });
	    }
	    res = f(peek(this._modulePersistantState));
	    if (_module != null ? _module.hot : void 0) {
	      this._modulePersistantState.pop();
	    }
	    return res;
	  };

	  return HotLoader;

	})(BaseObject);


/***/ },
/* 297 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-engine": "git://github.com/imikimi/art-engine.git",
			"art-engine-remote": "git://github.com/imikimi/art-engine-remote.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.4.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"description": "Art.React is inspired by Facebook's React. In fact, it is much the same. However, ArtReact is designed from the ground up to run with the Art.Engine.",
		"license": "ISC",
		"name": "art-react",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "1.1.0"
	};

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	var Component, Foundation, HotStyleProps,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Component = __webpack_require__(290);

	module.exports = HotStyleProps = (function(superClass) {
	  extend(HotStyleProps, superClass);

	  function HotStyleProps() {
	    return HotStyleProps.__super__.constructor.apply(this, arguments);
	  }

	  HotStyleProps.postCreate = function(arg) {
	    var hotReloaded;
	    hotReloaded = arg.hotReloaded;
	    if (hotReloaded) {
	      Component.rerenderAll();
	    }
	    return HotStyleProps.__super__.constructor.postCreate.apply(this, arguments);
	  };

	  return HotStyleProps;

	})(Foundation.BaseObject);


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, Browser, Foundation, Promise, VirtualElement, VirtualNode, compactFlatten, globalCount, inspect, isPlainObject, isWebWorker, keepIfRubyTrue, log, merge, objectDiff, propsEq, shallowClone, stackTime, time,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	VirtualNode = __webpack_require__(291);

	log = Foundation.log, compactFlatten = Foundation.compactFlatten, globalCount = Foundation.globalCount, time = Foundation.time, stackTime = Foundation.stackTime, BaseObject = Foundation.BaseObject, shallowClone = Foundation.shallowClone, inspect = Foundation.inspect, keepIfRubyTrue = Foundation.keepIfRubyTrue, stackTime = Foundation.stackTime, isPlainObject = Foundation.isPlainObject, compactFlatten = Foundation.compactFlatten, isWebWorker = Foundation.isWebWorker, objectDiff = Foundation.objectDiff, Browser = Foundation.Browser, merge = Foundation.merge, Promise = Foundation.Promise, propsEq = Foundation.propsEq;

	module.exports = VirtualElement = (function(superClass) {
	  var emptyProps;

	  extend(VirtualElement, superClass);

	  VirtualElement.created = 0;

	  VirtualElement.instantiated = 0;

	  emptyProps = {};

	  function VirtualElement(elementClassName, props, children) {
	    VirtualElement.created++;
	    this.elementClassName = elementClassName;
	    VirtualElement.__super__.constructor.call(this, props || emptyProps);
	    this.children = this._validateChildren(compactFlatten(children, keepIfRubyTrue));
	  }

	  VirtualElement.getter({
	    inspectedName: function() {
	      var elementClassName, key, ref;
	      ref = this, key = ref.key, elementClassName = ref.elementClassName;
	      return "VirtualElement-" + elementClassName + (key ? "-" + key : '');
	    }
	  });

	  VirtualElement.prototype.toCoffeescript = function(indent) {
	    var child, k, subIndent, v;
	    if (indent == null) {
	      indent = "";
	    }
	    return compactFlatten([
	      "" + indent + this.elementClassName, (function() {
	        var ref, results;
	        if (Object.keys(this.props).length === 0) {
	          return "{}";
	        } else {
	          ref = this.props;
	          results = [];
	          for (k in ref) {
	            v = ref[k];
	            results.push("\n  " + indent + k + ": " + (inspect(v)));
	          }
	          return results;
	        }
	      }).call(this), (function() {
	        var j, len, ref, ref1, results;
	        if (((ref = this.children) != null ? ref.length : void 0) > 0) {
	          subIndent = indent + "  ";
	          ref1 = this.children;
	          results = [];
	          for (j = 0, len = ref1.length; j < len; j++) {
	            child = ref1[j];
	            results.push("\n" + (child.toCoffeescript(subIndent)));
	          }
	          return results;
	        }
	      }).call(this)
	    ]).join('');
	  };


	  /*
	  EFFECT: execute the function 'f' with the Concrete-Element associated with this VirtualElement.
	  IN: f = (concreteElement) -> x
	  OUT: promise.then (x) ->
	  
	  OVERRIDE: OK
	  
	  PURPOSE: This is provided for the web-worker React so you can access the concrete element even though it is
	    in another context. In that case, "f" will be serialized and any closure will be lost...
	   */

	  VirtualElement.prototype.withElement = function(f) {
	    return new Promise((function(_this) {
	      return function(resolve) {
	        return resolve(f(_this.element));
	      };
	    })(this));
	  };

	  VirtualElement.prototype._updateElementProps = function(newProps) {};

	  VirtualElement.prototype._setElementChildren = function(childElements) {};

	  VirtualElement.prototype._newElement = function(elementClassName, props, childElements, bindToOrCreateNewParentElementProps) {
	    return elementClassName;
	  };

	  VirtualElement.prototype._newErrorElement = function() {
	    return null;
	  };

	  VirtualElement.prototype._findOldChildToUpdate = function(child) {
	    var i, j, len, oldChild, oldChildren;
	    oldChildren = this.children;
	    for (i = j = 0, len = oldChildren.length; j < len; i = ++j) {
	      oldChild = oldChildren[i];
	      if (oldChild) {
	        if (oldChild._canUpdateFrom(child)) {
	          oldChildren[i] = null;
	          return oldChild;
	        }
	      }
	    }
	    return null;
	  };

	  VirtualElement.prototype._canUpdateFrom = function(b) {
	    return this.elementClassName === b.elementClassName && this.key === b.key;
	  };


	  /*
	  _fastUpdateChildren
	    if no Nodes were added, removed or changed "types"
	      _updateFrom newChild for all oldChildren
	      return true
	    else
	       * use _slowUpdateChildren instead
	      return false
	   */

	  VirtualElement.prototype._fastUpdateChildren = function(newChildren) {
	    var i, j, l, len, len1, oldChild, oldChildren;
	    oldChildren = this.children;
	    if (oldChildren.length !== newChildren.length) {
	      return false;
	    }
	    for (i = j = 0, len = oldChildren.length; j < len; i = ++j) {
	      oldChild = oldChildren[i];
	      if (!oldChild._canUpdateFrom(newChildren[i])) {
	        return false;
	      }
	    }
	    for (i = l = 0, len1 = oldChildren.length; l < len1; i = ++l) {
	      oldChild = oldChildren[i];
	      oldChild._updateFrom(newChildren[i]);
	    }
	    return true;
	  };

	  VirtualElement.prototype._slowUpdateChildren = function(newChildren) {
	    var child, childElements, finalChild, i, j, len, newChild, oldChild, oldChildren;
	    oldChildren = this.children;
	    childElements = (function() {
	      var j, len, results;
	      results = [];
	      for (i = j = 0, len = newChildren.length; j < len; i = ++j) {
	        newChild = newChildren[i];
	        finalChild = (oldChild = this._findOldChildToUpdate(newChild)) ? newChildren[i] = oldChild._updateFrom(newChild) : newChild._instantiate(this._parentComponent);
	        results.push(finalChild.element);
	      }
	      return results;
	    }).call(this);
	    for (j = 0, len = oldChildren.length; j < len; j++) {
	      child = oldChildren[j];
	      if (child) {
	        child._unmount();
	      }
	    }
	    this._setElementChildren(childElements);
	    return this.children = newChildren;
	  };


	  /*
	  returns true if children changed
	    if true, element.setChildren was called
	    if false, the children individually may change, but
	      this element's children are the same set
	   */

	  VirtualElement.prototype._updateChildren = function(newChildren) {
	    if (this._fastUpdateChildren(newChildren)) {
	      return false;
	    } else {
	      this._slowUpdateChildren(newChildren);
	      return true;
	    }
	  };

	  VirtualElement.prototype._unmount = function() {
	    var child, j, len, ref, results;
	    ref = this.children;
	    results = [];
	    for (j = 0, len = ref.length; j < len; j++) {
	      child = ref[j];
	      results.push(child._unmount());
	    }
	    return results;
	  };

	  VirtualElement.prototype._updateFrom = function(newNode) {
	    var childrenChanged, propsChanged;
	    VirtualElement.__super__._updateFrom.apply(this, arguments);
	    if (!this.element) {
	      return;
	    }
	    propsChanged = this._updateElementProps(newNode.props);
	    childrenChanged = this._updateChildren(newNode.children);
	    return this;
	  };


	  /*
	  create element or componentInstance
	  fully generate Virtual-AIM subbranch
	  fully create all AIM elements
	  returns this
	   */

	  VirtualElement.prototype._instantiate = function(parentComponent, bindToOrCreateNewParentElementProps) {
	    var c, childElements, e, i;
	    VirtualElement.__super__._instantiate.apply(this, arguments);
	    VirtualElement.instantiated++;
	    childElements = (function() {
	      var j, len, ref, results;
	      ref = this.children;
	      results = [];
	      for (i = j = 0, len = ref.length; j < len; i = ++j) {
	        c = ref[i];
	        try {
	          c._instantiate(parentComponent);
	          results.push(c.element);
	        } catch (error) {
	          e = error;
	          console.error(e.stack);
	          console.error("Error instantiating child:\n  childIndex " + i + "\n  error: " + e + "\n  child: " + c + "\n  elementClassName: " + this.elementClassName + "\n  props: " + (inspect(this.props)));
	          results.push(this._newErrorElement());
	        }
	      }
	      return results;
	    }).call(this);
	    this.element = this._newElement(this.elementClassName, this.props, childElements, bindToOrCreateNewParentElementProps);
	    return this;
	  };

	  VirtualElement.prototype._updateElementPropsHelper = function(newProps, addedOrChanged, removed) {
	    var newPropsLength, noChange, noChangeCount, oldProps, oldPropsLength;
	    oldPropsLength = this.getPropsLength();
	    oldProps = this.props;
	    noChangeCount = 0;
	    noChange = function() {
	      return noChangeCount++;
	    };
	    newPropsLength = this.setPropsLength(objectDiff(newProps, oldProps, addedOrChanged, removed, addedOrChanged, noChange, propsEq));
	    if (newPropsLength === noChangeCount && oldPropsLength === newPropsLength) {
	      return false;
	    } else {
	      this.props = newProps;
	      return true;
	    }
	  };

	  return VirtualElement;

	})(VirtualNode);


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	var Aim, Foundation, React, VirtualElement, createObjectTreeFactories, createObjectTreeFactory, getNextPageIndexes, log, mergeInto, objectTreeFactoryOptions, standardArtEngineElementClassNames;

	Foundation = __webpack_require__(19);

	React = __webpack_require__(287);

	log = Foundation.log, createObjectTreeFactories = Foundation.createObjectTreeFactories, mergeInto = Foundation.mergeInto, createObjectTreeFactory = Foundation.createObjectTreeFactory;

	VirtualElement = React.VirtualElement, objectTreeFactoryOptions = React.objectTreeFactoryOptions;

	getNextPageIndexes = __webpack_require__(301).getNextPageIndexes;

	standardArtEngineElementClassNames = "BitmapElement BlurElement CanvasElement ShapeElement Element FillElement OutlineElement PagingScrollElement RectangleElement ShadowElement TextElement TextInput";

	module.exports = Aim = (function() {
	  function Aim() {}

	  Aim.createVirtualElementFactories = function(VirtualElementClass, elementClassNames) {
	    if (elementClassNames == null) {
	      elementClassNames = standardArtEngineElementClassNames;
	    }
	    mergeInto(this, createObjectTreeFactories(objectTreeFactoryOptions, elementClassNames, function(elementClassName) {
	      return function(props, children) {
	        return new VirtualElementClass(elementClassName, props, children);
	      };
	    }));
	    this.bindHelperFunctions();
	    return this;
	  };

	  Aim.bindHelperFunctions = function() {
	    return this.PagingScrollElement.getNextPageIndexes = getNextPageIndexes;
	  };

	  return Aim;

	})();


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	var Foundation, PagingScrollElement, bound, max, min;

	Foundation = __webpack_require__(19);

	max = Foundation.max, min = Foundation.min, bound = Foundation.bound;


	/*
	SBD: I'm not sure where best to put getNextPageIndexes, so I'm putting it here for now.
	It is potentially needed by any react component using PagingScrollElement. I'd put it on the
	actual PagingScrollElement Element class, but that class isn't loaded when doing React in
	a web-worker.

	getNextPageIndexes could be reusable with any PagingScrollElement where pages are indexed
	and the maxPageIndex and minPageIndex are known. It's even OK if maxPageIndex and
	minPageIndex change - as long as they don't change too much per frame.

	IN:
	  lastPageIndexes =
	      firstPageIndex: 0
	      lastPageIndex:  2

	    essentially, this is the output from last call. For the first call, do 0 and 2

	  currentGeometry =
	      suggestedPagesBeforeFocusedPage: 1
	      suggestedPagesAfterFocusedPage:  1

	    set from currentGeometry from the last onScollChange event

	  focusedPageIndex = integer;       the current focused page index
	  maxKeep =          integer >= 0;  see below
	  maxPrerender =     integer >= 0;  see below
	  maxPageIndex =     integer;       see below
	  minPageIndex =     0 (integer);   see below

	OUT:
	  null if nothing changed, else, returns the next range of pages to render for PagingScrollElement:
	    firstPageIndex: integer
	    lastPageIndex:  integer

	Supports:
	  minPageIndex / maxPageIndex: output page indexes will be: minPageIndex <= output page index <= maxPageIndex
	  maxKeep: maximum number of already rendered pages to keep even though they are no longer
	    in the suggested + prerender window
	  maxPrerender: in addition to the suggestedPages from PagingScrollElement, render this many extra pages.
	    This is useful if the pages trigger external network requests which ideally would be complete before
	    the page is displayed on screen. If pages are showing up that are not fully loaded, increase this
	    value.

	    Down-sides:
	      increased initial render time
	      increased memory use

	    Up-sides:
	      should not significantly effect performance after initial render, even during scrolling
	      gives external data requests triggered by page renders more time to complete before the page is onscreen
	 */

	module.exports = PagingScrollElement = (function() {
	  function PagingScrollElement() {}

	  PagingScrollElement.getNextPageIndexes = function(lastPageIndexes, suggestedPageSpread, focusedPageIndex, maxKeep, maxPrerender, maxPageIndex, minPageIndex) {
	    var firstPageIndex, lastPageIndex, newFirstPageIndex, newLastPageIndex;
	    if (minPageIndex == null) {
	      minPageIndex = 0;
	    }
	    firstPageIndex = lastPageIndexes.firstPageIndex, lastPageIndex = lastPageIndexes.lastPageIndex;
	    newFirstPageIndex = focusedPageIndex - suggestedPageSpread - maxPrerender;
	    newLastPageIndex = focusedPageIndex + suggestedPageSpread + maxPrerender;
	    firstPageIndex = max(minPageIndex, bound(newFirstPageIndex - maxKeep, firstPageIndex, newFirstPageIndex));
	    lastPageIndex = min(maxPageIndex, bound(newLastPageIndex, lastPageIndex, newLastPageIndex + maxKeep));
	    if (firstPageIndex === lastPageIndexes.firstPageIndex && lastPageIndex === lastPageIndexes.lastPageIndex) {
	      return null;
	    } else {
	      return {
	        firstPageIndex: firstPageIndex,
	        lastPageIndex: lastPageIndex
	      };
	    }
	  };

	  return PagingScrollElement;

	})();


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(152);

	__webpack_require__(281);

	module.exports = __webpack_require__(303);


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(304).includeInNamespace(__webpack_require__(306));

	__webpack_require__(307);

	__webpack_require__(319);

	__webpack_require__(324);

	__webpack_require__(314);


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Flux,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(305);

	module.exports = Art.Flux || Art.addNamespace('Flux', Flux = (function(superClass) {
	  extend(Flux, superClass);

	  function Flux() {
	    return Flux.__super__.constructor.apply(this, arguments);
	  }

	  return Flux;

	})(Neptune.Base));


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var FluxComponent, FluxCore, FluxModel, FluxStore, FluxSubscriptionsMixin, ModelRegistry, _package, defineModule, fluxStore;

	defineModule = __webpack_require__(19).defineModule;

	FluxCore = __webpack_require__(307);

	FluxComponent = __webpack_require__(314).FluxComponent;

	FluxStore = FluxCore.FluxStore, ModelRegistry = FluxCore.ModelRegistry, FluxModel = FluxCore.FluxModel, FluxSubscriptionsMixin = FluxCore.FluxSubscriptionsMixin;

	fluxStore = FluxStore.fluxStore;

	defineModule(module, [
	  {
	    FluxSubscriptionsMixin: FluxSubscriptionsMixin,
	    FluxStore: FluxStore,
	    FluxModel: FluxModel,
	    ModelRegistry: ModelRegistry,
	    FluxComponent: FluxComponent,
	    ApplicationState: __webpack_require__(317),
	    models: ModelRegistry.models,
	    createFluxComponentFactory: FluxComponent.createFluxComponentFactory,
	    fluxStore: fluxStore,
	    _reset: function() {
	      fluxStore._reset();
	      return ModelRegistry._reset();
	    },
	    "package": _package = __webpack_require__(318),
	    version: _package.version
	  }
	]);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(308).addModules({
	  FluxEntry: __webpack_require__(309),
	  FluxModel: __webpack_require__(310),
	  FluxStore: __webpack_require__(311),
	  FluxSubscriptionsMixin: __webpack_require__(313),
	  ModelRegistry: __webpack_require__(312)
	});


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	var Core, Flux,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Flux = __webpack_require__(304);

	module.exports = Flux.Core || Flux.addNamespace('Core', Core = (function(superClass) {
	  extend(Core, superClass);

	  function Core() {
	    return Core.__super__.constructor.apply(this, arguments);
	  }

	  return Core;

	})(Neptune.Base));


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Epoch, FluxEntry, Foundation, Unique, clone, defineModule, failure, inspect, isPlainObject, log, merge, pending, propsEq, pushIfNotPresent, removeFirstMatch, shallowClone, success,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	log = Foundation.log, BaseObject = Foundation.BaseObject, merge = Foundation.merge, removeFirstMatch = Foundation.removeFirstMatch, pushIfNotPresent = Foundation.pushIfNotPresent, Epoch = Foundation.Epoch, shallowClone = Foundation.shallowClone, inspect = Foundation.inspect, Unique = Foundation.Unique, clone = Foundation.clone, isPlainObject = Foundation.isPlainObject, propsEq = Foundation.propsEq, defineModule = Foundation.defineModule, CommunicationStatus = Foundation.CommunicationStatus;

	pending = CommunicationStatus.pending, success = CommunicationStatus.success, failure = CommunicationStatus.failure;

	defineModule(module, FluxEntry = (function(superClass) {
	  var warnCantSetField, warnUnsettableFields;

	  extend(FluxEntry, superClass);

	  FluxEntry.warnCantSetField = warnCantSetField = function(newFluxRecord, oldFluxRecord, field) {
	    var newValue, oldValue;
	    newValue = newFluxRecord[field];
	    oldValue = oldFluxRecord != null ? oldFluxRecord[field] : void 0;
	    if (newFluxRecord.hasOwnProperty(field) && newValue !== oldValue) {
	      return console.warn(FluxEntry.namespacePath + ": Do not put/post the '" + field + "' field (new value == " + (inspect(newValue)) + ", old value == " + (inspect(oldValue)) + "). Ignored.");
	    }
	  };

	  FluxEntry.warnUnsettableFields = warnUnsettableFields = function(newFluxRecord, oldFluxRecord) {
	    warnCantSetField(newFluxRecord, oldFluxRecord, "key");
	    return warnCantSetField(newFluxRecord, oldFluxRecord, "modelName");
	  };

	  function FluxEntry(modelName, key) {
	    FluxEntry.__super__.constructor.apply(this, arguments);
	    this._fluxRecord = {
	      status: pending,
	      key: key,
	      modelName: modelName
	    };
	    this._subscribers = [];
	    this._previousFluxRecord = null;
	  }

	  FluxEntry.getter("previousFluxRecord fluxRecord subscribers", {
	    dataChanged: function() {
	      var ref, ref1;
	      return !propsEq((ref = this._fluxRecord) != null ? ref.data : void 0, (ref1 = this._previousFluxRecord) != null ? ref1.data : void 0);
	    },
	    fluxRecordChanged: function() {
	      return !propsEq(this._fluxRecord, this._previousFluxRecord);
	    },
	    subscriberCount: function() {
	      return this._subscribers.length;
	    },
	    key: function() {
	      return this._fluxRecord.key;
	    },
	    modelName: function() {
	      return this._fluxRecord.modelName;
	    }
	  });

	  FluxEntry.setter({
	    fluxRecord: function(newFluxRecord) {
	      var key, modelName, ref;
	      ref = this._fluxRecord, key = ref.key, modelName = ref.modelName;
	      warnUnsettableFields(newFluxRecord, this._fluxRecord);
	      newFluxRecord.key = key;
	      newFluxRecord.modelName = modelName;
	      if (!isPlainObject(newFluxRecord)) {
	        throw new Error("fluxRecord must be an object");
	      }
	      return this._fluxRecord = newFluxRecord;
	    }
	  });

	  FluxEntry.getter({
	    plainStructure: function() {
	      return {
	        fluxRecord: this._fluxRecord,
	        subscribers: this._subscribers
	      };
	    },
	    hasSubscribers: function() {
	      return this._subscribers.length > 0;
	    }
	  });

	  FluxEntry.prototype._merge = function(src) {
	    if (!isPlainObject(src)) {
	      throw new Error("fluxRecord must be an object");
	    }
	    this._fluxRecord = src._fluxRecord;
	    return this._subscribers = this._subscribers.concat(src._subscribers);
	  };

	  FluxEntry.prototype._notifySubscribers = function() {
	    var i, len, ref, subscriber;
	    if (!this._previousFluxRecord) {
	      return;
	    }
	    ref = this._subscribers;
	    for (i = 0, len = ref.length; i < len; i++) {
	      subscriber = ref[i];
	      subscriber(this._fluxRecord, this._previousFluxRecord);
	    }
	    return this._previousFluxRecord = null;
	  };

	  FluxEntry.prototype._updateFluxRecord = function(updateFunction) {
	    this._previousFluxRecord || (this._previousFluxRecord = this._fluxRecord);
	    this.setFluxRecord((typeof updateFunction === "function" ? updateFunction(this._fluxRecord) : void 0) || {});
	    if (propsEq(this._fluxRecord, this._previousFluxRecord)) {
	      return this._previousFluxRecord = null;
	    }
	  };

	  FluxEntry.prototype._subscribe = function(subscriber) {
	    return pushIfNotPresent(this._subscribers, subscriber);
	  };

	  FluxEntry.prototype._unsubscribe = function(subscriber) {
	    return removeFirstMatch(this._subscribers, subscriber);
	  };

	  return FluxEntry;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, FluxModel, Foundation, InstanceFunctionBindingMixin, ModelRegistry, Promise, capitalize, compactFlatten, decapitalize, defineModule, emailRegexp, failure, fluxStore, globalCount, inspect, isFunction, isNumber, isString, isoDateRegexp, log, missing, nextTick, pending, pluralize, pureMerge, ref, shallowClone, success, time, urlRegexp, validStatus,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	ref = Foundation.CommunicationStatus, missing = ref.missing, success = ref.success, pending = ref.pending, failure = ref.failure, validStatus = ref.validStatus, defineModule = ref.defineModule;

	fluxStore = __webpack_require__(311).fluxStore;

	ModelRegistry = __webpack_require__(312);

	log = Foundation.log, BaseObject = Foundation.BaseObject, decapitalize = Foundation.decapitalize, pluralize = Foundation.pluralize, pureMerge = Foundation.pureMerge, shallowClone = Foundation.shallowClone, isString = Foundation.isString, emailRegexp = Foundation.emailRegexp, urlRegexp = Foundation.urlRegexp, isNumber = Foundation.isNumber, nextTick = Foundation.nextTick, capitalize = Foundation.capitalize, inspect = Foundation.inspect, isFunction = Foundation.isFunction, pureMerge = Foundation.pureMerge, isoDateRegexp = Foundation.isoDateRegexp, time = Foundation.time, globalCount = Foundation.globalCount, compactFlatten = Foundation.compactFlatten, InstanceFunctionBindingMixin = Foundation.InstanceFunctionBindingMixin, Promise = Foundation.Promise, defineModule = Foundation.defineModule;

	defineModule(module, FluxModel = (function(superClass) {
	  extend(FluxModel, superClass);

	  FluxModel.abstractClass();

	  FluxModel.register = function() {
	    this.singletonClass();
	    return ModelRegistry.register(this.getSingleton());
	  };

	  FluxModel.prototype.register = function() {
	    return ModelRegistry.register(this);
	  };

	  FluxModel.postCreateConcreteClass = function(arg) {
	    var hotReloaded;
	    hotReloaded = arg.hotReloaded;
	    if (hotReloaded) {
	      this.singleton.bindFunctionsToInstance();
	    } else {
	      this.register();
	    }
	    return FluxModel.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
	  };


	  /*
	  INPUT: zero or more strings or arrays of strings
	    - arbitrary nesting of arrays is OK
	    - nulls are OK, they are ignored
	  OUTPUT: null
	  
	  NOTE: @aliases can be called multiple times.
	  
	  example:
	    class Post extends FluxModel
	      @aliases "chapterPost"
	  
	  purpose:
	    - declare alternative names to access this model.
	    - allows you to use the shortest form of FluxComponent subscriptions for each alias:
	        @subscriptions "chapterPost"
	      in addition to the model's class name:
	        @subscriptions "post"
	   */

	  FluxModel.aliases = function() {
	    this._aliases = compactFlatten(arguments, this._aliases);
	    return null;
	  };

	  FluxModel.prototype.onNextReady = function(f) {
	    return fluxStore.onNextReady(f);
	  };

	  function FluxModel(name) {
	    FluxModel.__super__.constructor.apply(this, arguments);
	    this._name = name || decapitalize(this["class"].getName());
	    this.bindFunctionsToInstance();
	  }

	  FluxModel.classGetter({
	    models: function() {
	      return ModelRegistry.models;
	    },
	    fluxStore: function() {
	      return fluxStore;
	    }
	  });

	  FluxModel.getter({
	    models: function() {
	      return ModelRegistry.models;
	    },
	    fluxStore: function() {
	      return fluxStore;
	    },
	    singlesModel: function() {
	      return this._singlesModel || this;
	    }
	  });

	  FluxModel.prototype.subscribe = function(fluxKey, subscriptionFunction) {
	    return fluxStore.subscribe(this._name, fluxKey, subscriptionFunction);
	  };

	  FluxModel.getter("name");


	  /*
	  load the requested data for the given key and update the fluxStore
	  
	  required:
	    Should ALWAYS call fluxStore.update immediately OR once the data is available.
	    Clients will assume that a call to "load" forces a reload of the data in the fluxStore.
	  
	  optional:
	    If the data is immediately available, you can return the fluxRecord instead of "null"
	    If load was called because of a new Component being mounted and its subscriptions initialized,
	      returning the fluxRecord immediately will guarantee the Component has valid data for its
	      first render.
	  
	  Note:
	    Typically called automatically by the fluxStore when a Component subscribes to
	    data from this model with the given key.
	  
	  The simplest possible load function:
	    load: (key) -> @updateFluxStore key, {}
	  
	  The "load" function below is:
	    Simplest "load" with immediate fluxRecord return.
	    Immediate return means:
	     - fluxStore.subscribe() will return the fluxRecord returned from this "load"
	     - FluxComponent subscriptions will update state in time for the inital render.
	  
	  inputs:
	    key: string
	  
	  side effects:
	    expected to call fluxStore.update @_name, key, fluxRecord
	      - when fluxRecord.status is no longer pending
	      - optionally as progress is made loading the fluxRecord.data
	  
	  returns: null OR fluxRecord if the value is immediately available
	    NOTE: load can return null or fluxRecord as it chooses. The client shouldn't
	      rely on the fact that it returned a fluxRecord with a set of inputs, it might not
	      the next time.
	  
	  Optionally, you can implement one of to altenative load functions with Promise support:
	  
	    loadData:       (key) ->
	                      promise.then (data) ->
	                      promise.catch (a validStatus or error info, status becomes failure) ->
	    loadFluxRecord: (key) -> promise.then (fluxRecord) ->
	  
	    @load will take care of updating FluxStore.
	   */

	  FluxModel.prototype.load = function(key) {
	    if (this.loadData) {
	      Promise.then((function(_this) {
	        return function() {
	          return _this.loadData(key);
	        };
	      })(this)).then((function(_this) {
	        return function(data) {
	          return _this.updateFluxStore(key, {
	            status: success,
	            data: data
	          });
	        };
	      })(this))["catch"]((function(_this) {
	        return function(error) {
	          if (validStatus(error)) {
	            return _this.updateFluxStore(key, {
	              status: error
	            });
	          } else {
	            return _this.updateFluxStore(key, {
	              status: failure,
	              error: error
	            });
	          }
	        };
	      })(this));
	      return null;
	    } else if (this.loadFluxRecord) {
	      this.loadFluxRecord(key).then((function(_this) {
	        return function(fluxRecord) {
	          return _this.updateFluxStore(key, fluxRecord);
	        };
	      })(this))["catch"]((function(_this) {
	        return function(error) {
	          return _this.updateFluxStore(key, {
	            status: failure,
	            error: error
	          });
	        };
	      })(this));
	      return null;
	    } else {
	      return this.updateFluxStore(key, {
	        status: missing
	      });
	    }
	  };

	  FluxModel.prototype.reload = function(key) {
	    return this.load(key);
	  };

	  FluxModel.prototype.updateFluxStore = function(key, fluxRecord) {
	    return fluxStore.update(this._name, key, fluxRecord);
	  };

	  FluxModel.prototype.fluxStoreGet = function(key) {
	    return fluxStore.get(this._name, key);
	  };

	  FluxModel.prototype.toFluxKey = function(key) {
	    if (!isString(key)) {
	      throw "FluxModel " + this.name + ": Must implement custom toFluxKey for non-string fluxKeys like: " + (inspect(key));
	    }
	    return key;
	  };

	  FluxModel.prototype.fluxStoreEntryUpdated = function(entry) {};

	  FluxModel.prototype.fluxStoreEntryAdded = function(entry) {};

	  FluxModel.prototype.fluxStoreEntryRemoved = function(entry) {};


	  /*
	  localStorage helper methods
	   */

	  FluxModel.prototype._localStoreKey = function(id) {
	    return "fluxModel:" + this._name + ":" + id;
	  };

	  FluxModel.prototype._localStoreGet = function(id) {
	    var data;
	    if (data = localStorage.getItem(this._localStoreKey(id))) {
	      return JSON.parse(data);
	    } else {
	      return null;
	    }
	  };

	  FluxModel.prototype._localStoreSet = function(id, data) {
	    return localStorage.setItem(this._localStoreKey(id), JSON.stringify(data));
	  };

	  return FluxModel;

	})(InstanceFunctionBindingMixin(BaseObject)));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Epoch, FluxEntry, FluxStore, Foundation, GlobalEpochCycle, ModelRegistry, Unique, clone, consistentJsonStringify, defineModule, failure, globalCount, inspect, isFunction, isString, log, merge, missing, pending, pushIfNotPresent, ref, ref1, removeFirstMatch, success, time, timeout,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	FluxEntry = __webpack_require__(309);

	ModelRegistry = __webpack_require__(312);

	BaseObject = Foundation.BaseObject, merge = Foundation.merge, removeFirstMatch = Foundation.removeFirstMatch, pushIfNotPresent = Foundation.pushIfNotPresent, removeFirstMatch = Foundation.removeFirstMatch, Epoch = Foundation.Epoch, log = Foundation.log, isFunction = Foundation.isFunction, Unique = Foundation.Unique, clone = Foundation.clone, consistentJsonStringify = Foundation.consistentJsonStringify, isString = Foundation.isString, timeout = Foundation.timeout, globalCount = Foundation.globalCount, time = Foundation.time, inspect = Foundation.inspect, defineModule = Foundation.defineModule, CommunicationStatus = Foundation.CommunicationStatus;

	success = CommunicationStatus.success, pending = CommunicationStatus.pending, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure;

	defineModule(module, FluxStore = (function(superClass) {
	  extend(FluxStore, superClass);

	  FluxStore.singletonClass();

	  function FluxStore() {
	    FluxStore.__super__.constructor.apply(this, arguments);
	    this._reset();
	  }

	  FluxStore.getter("length");

	  FluxStore.prototype.get = function(modelName, key) {
	    var ref;
	    return (ref = this._getEntry(modelName, key)) != null ? ref.fluxRecord : void 0;
	  };

	  FluxStore.prototype.getSubscribers = function(modelName, key) {
	    var ref;
	    return (ref = this._getEntry(modelName, key)) != null ? ref.subscribers : void 0;
	  };

	  FluxStore.prototype.getHasSubscribers = function(modelName, key) {
	    var ref;
	    return !!((ref = this._getEntry(modelName, key)) != null ? ref.getHasSubscribers() : void 0);
	  };


	  /*
	  subscribe to all changes to the fluxStore FluxEntry identified by modelName and Key.
	  
	  subscribers:
	    are notified on all changes to the entry's:
	      @fluxRecord object
	      @subscribers list
	    are NOT explicitly notified of when the entry is first added or removed
	      However, when an entry is added, subscribers will be notified that a change happened.
	      When an entry is removed, subscribers will be again notified, and the "subscribers" param will be [].
	    See subscribeToStore for notifications about entries being added or removed
	  
	  inputs:
	    modelName: string
	    key: string
	  
	    subscriber: (fluxRecord, previousFluxRecord) -> null
	      IN:
	        fluxRecord: plain object; the current value for the fluxRecord
	        previousFluxRecord: plain object; the last value for the fluxRecord
	      GUARANTEES:
	        1. !propsEq fluxRecord, previousFluxRecord
	        2. only called once per change
	  
	    initialFluxRecord: if set, and the key is not in the store, this is used
	      as the initial value instead of the calling "load" on the model.
	  
	  side effects:
	    vivifies a new entry with fluxRecord = {status: pending} if one isn't present
	    calls ModelRegistry[modelName].load key if vivification occured
	    Notifies all subscribers.
	  
	  returns: current fluxRecord for the entry
	   */

	  FluxStore.prototype.subscribe = function(modelName, key, subscriber, initialFluxRecord) {
	    this._queueChange({
	      modelName: modelName,
	      key: key,
	      addSubscriber: subscriber
	    });
	    return this._vivifyAndLoadEntry(modelName, key, initialFluxRecord).fluxRecord;
	  };


	  /*
	  inputs:
	    modelName: string
	    key: string
	    subscriber: the exact same function (including closure) used to subscribe
	  
	  side effects:
	    Notifies all subscribers.
	  
	  returns: null
	   */

	  FluxStore.prototype.unsubscribe = function(modelName, key, subscriber) {
	    return this._queueChange({
	      modelName: modelName,
	      key: key,
	      removeSubscriber: subscriber
	    });
	  };


	  /*
	  put updates or creates the record
	  updateFunctionOrNewFluxRecord: can be:
	    1) an arbitrary function: (oldRecord) -> newRecord
	      oldRecord will be null/undefined only if the record has not been created.
	      do not alter oldRecord
	      must return a new Object or null/undefined (in which case an empty Object is created)
	    2) a new Object to replace the existing object
	  
	  Notifies all subscribers.
	  returns: updateFunctionOrNewFluxRecord
	   */

	  FluxStore.prototype.update = function(modelName, key, updateFunctionOrNewFluxRecord) {
	    if (!isString(key)) {
	      throw new Error("key must be a string. got: " + (inspect(key)));
	    }
	    this._queueChange({
	      modelName: modelName,
	      key: key,
	      updateFunction: isFunction(updateFunctionOrNewFluxRecord) ? updateFunctionOrNewFluxRecord : function(oldRecord) {
	        return updateFunctionOrNewFluxRecord;
	      }
	    });
	    return updateFunctionOrNewFluxRecord;
	  };

	  FluxStore.getter({
	    status: function() {
	      var entries, entry, entrySubscribers, key, model, modelCount, ref;
	      entrySubscribers = 0;
	      modelCount = 0;
	      ref = this._entriesByModelName;
	      for (model in ref) {
	        entries = ref[model];
	        modelCount++;
	        for (key in entries) {
	          entry = entries[key];
	          entrySubscribers += entry.subscriberCount;
	        }
	      }
	      return {
	        entries: this._length,
	        entrySubscribers: entrySubscribers,
	        models: modelCount
	      };
	    }
	  });

	  FluxStore.prototype._reset = function() {
	    this._length = 0;
	    this._entriesByModelName = {};
	    return this._addedEntries = [];
	  };

	  FluxStore.prototype._getEntriesForModelName = function(modelName) {
	    var base;
	    return (base = this._entriesByModelName)[modelName] || (base[modelName] = {});
	  };

	  FluxStore.prototype._getEntry = function(modelName, key) {
	    if (!isString(modelName)) {
	      throw new Error("Expected 'modelName' to be a String. Got: " + (inspect(modelName)));
	    }
	    if (!isString(key)) {
	      throw new Error("Expected 'key' to be a String. Got: " + (inspect(key)));
	    }
	    return this._getEntriesForModelName(modelName)[key];
	  };

	  FluxStore.prototype._addEntry = function(modelName, key) {
	    var entry;
	    this._length++;
	    entry = this._getEntriesForModelName(modelName)[key] = new FluxEntry(modelName, key);
	    pushIfNotPresent(this._addedEntries, entry);
	    return entry;
	  };

	  FluxStore.prototype._removeEntry = function(entry) {
	    this._length--;
	    return delete this._getEntriesForModelName(entry.fluxRecord.modelName)[entry.fluxRecord.key];
	  };


	  /*
	  Returns existing entry if there is one, otherwise it vivifies a "defaultFluxRecord" and starts the model.load.
	  
	  _vivifyAndLoadEntry solves the problem of two or more subscriptions starting in the same epoch
	  on a new entry. Without this, we'd try to call "load" on the same model+key more than once.
	  Ex: if we are loading remote images, loading the same remote image multiple times is a huge waste.
	  
	  returns: entry
	   */

	  FluxStore.prototype._vivifyAndLoadEntry = function(modelName, key, initialFluxRecord) {
	    var entry;
	    entry = this._getEntry(modelName, key);
	    if (!entry) {
	      entry = this._addEntry(modelName, key);
	      if (initialFluxRecord) {
	        entry.setFluxRecord(initialFluxRecord);
	      } else {
	        this._loadKeyWithRetriesWithExponentalFalloff(modelName, key, entry);
	      }
	    }
	    return entry;
	  };

	  FluxStore.prototype._loadKeyWithRetriesWithExponentalFalloff = function(modelName, key, entry) {
	    var e, fluxRecord, loadRetryCallback, message, model, retryDelay;
	    retryDelay = 250;
	    if (model = ModelRegistry.models[modelName]) {
	      loadRetryCallback = (function(_this) {
	        return function(loadInfo) {
	          if (loadInfo.status !== pending && loadInfo.status !== success && loadInfo.status !== missing) {
	            if (_this._getEntry(modelName, key)) {
	              if (retryDelay < 60 * 1000) {
	                retryDelay *= 2;
	              }
	              return console.warn("FluxStore retry is disabled");
	            } else {
	              return log({
	                FluxStore_get_retry: {
	                  model: modelName,
	                  key: key,
	                  status: loadInfo.status,
	                  aborting: "no longer have subscribers"
	                }
	              });
	            }
	          }
	        };
	      })(this);
	      try {
	        if (fluxRecord = model.load(key, loadRetryCallback)) {
	          return entry.setFluxRecord(fluxRecord);
	        }
	      } catch (error) {
	        e = error;
	        message = "Error loading record from model '" + modelName + "' for key '" + key + "'. Error: " + e;
	        console.error(message, e.stack);
	        return entry.setFluxRecord({
	          status: failure,
	          errorObject: e,
	          message: message
	        });
	      }
	    } else {
	      return console.warn("ArtFlux: there is no model registered with the name: " + modelName + ". FluxEntry for " + modelName + ":" + key + " will forever be status: pending.");
	    }
	  };

	  FluxStore.prototype._vivifyEntry = function(modelName, key) {
	    return this._getEntry(modelName, key) || this._addEntry(modelName, key);
	  };

	  FluxStore.prototype._queueChange = function(change) {
	    var key, modelName;
	    modelName = change.modelName, key = change.key;
	    if (!isString(modelName)) {
	      throw new Error("Expected 'modelName' to be a String. Got: " + (inspect(modelName)));
	    }
	    if (!isString(key)) {
	      throw new Error("Expected 'key' to be a String. Got: " + (inspect(key)));
	    }
	    this.queueItem(change);
	    return null;
	  };

	  FluxStore.prototype.processEpochItems = function(changes) {
	    var addSubscriber, entry, i, j, k, key, l, len, len1, len2, len3, modelName, models, ref, ref1, ref2, ref3, ref4, removeEntry, removeSubscriber, removedEntries, updateFunction, updatedEntries;
	    updatedEntries = [];
	    removedEntries = [];
	    for (i = 0, len = changes.length; i < len; i++) {
	      ref = changes[i], modelName = ref.modelName, key = ref.key, removeEntry = ref.removeEntry, addSubscriber = ref.addSubscriber, removeSubscriber = ref.removeSubscriber, updateFunction = ref.updateFunction;
	      entry = this._vivifyEntry(modelName, key);
	      if (updateFunction) {
	        entry._updateFluxRecord(updateFunction);
	      } else if (addSubscriber) {
	        entry._subscribe(addSubscriber);
	      } else if (removeSubscriber) {
	        entry._unsubscribe(removeSubscriber);
	      }
	      pushIfNotPresent(updatedEntries, entry);
	    }
	    models = ModelRegistry.models;
	    for (j = 0, len1 = updatedEntries.length; j < len1; j++) {
	      entry = updatedEntries[j];
	      if ((ref1 = models[entry.getModelName()]) != null) {
	        ref1.fluxStoreEntryUpdated(entry);
	      }
	      entry._notifySubscribers();
	      if (entry.subscribers.length === 0) {
	        pushIfNotPresent(removedEntries, entry);
	        this._removeEntry(entry);
	      }
	    }
	    ref2 = this._addedEntries;
	    for (k = 0, len2 = ref2.length; k < len2; k++) {
	      entry = ref2[k];
	      if ((ref3 = models[entry.getModelName()]) != null) {
	        ref3.fluxStoreEntryAdded(entry);
	      }
	    }
	    for (l = 0, len3 = removedEntries.length; l < len3; l++) {
	      entry = removedEntries[l];
	      if ((ref4 = models[entry.getModelName()]) != null) {
	        ref4.fluxStoreEntryRemoved(entry);
	      }
	    }
	    this._addedEntries = [];
	    return null;
	  };

	  return FluxStore;

	})(Epoch));

	if (GlobalEpochCycle = (ref = Neptune.Art.Engine) != null ? (ref1 = ref.Core) != null ? ref1.GlobalEpochCycle : void 0 : void 0) {
	  GlobalEpochCycle.singleton.includeFlux(FluxStore.singleton);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, ModelRegistry, decapitalize, defineModule, inspect, isClass, log, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(19), log = ref.log, BaseObject = ref.BaseObject, decapitalize = ref.decapitalize, isClass = ref.isClass, inspect = ref.inspect, defineModule = ref.defineModule;

	defineModule(module, ModelRegistry = (function(superClass) {
	  var models;

	  extend(ModelRegistry, superClass);

	  function ModelRegistry() {
	    return ModelRegistry.__super__.constructor.apply(this, arguments);
	  }

	  ModelRegistry.models = models = {};

	  ModelRegistry.register = function(modelClassOrInstance) {
	    var _aliases, alias, newSingleton, ref1;
	    newSingleton = isClass(modelClassOrInstance) ? (console.warn("ModelRegistry.register Class (not instance) is DEPRICATED"), (_aliases = modelClassOrInstance._aliases, modelClassOrInstance), new modelClassOrInstance) : ((ref1 = modelClassOrInstance["class"], _aliases = ref1._aliases, ref1), modelClassOrInstance);
	    _aliases && (function() {
	      var i, len, results;
	      results = [];
	      for (i = 0, len = _aliases.length; i < len; i++) {
	        alias = _aliases[i];
	        results.push(models[alias] = newSingleton);
	      }
	      return results;
	    })();
	    return models[newSingleton.name] = newSingleton;
	  };

	  ModelRegistry._singletonName = function(model) {
	    return decapitalize(model.name);
	  };

	  ModelRegistry._reset = function() {
	    var i, k, len, ref1, results;
	    ref1 = Object.keys(models);
	    results = [];
	    for (i = 0, len = ref1.length; i < len; i++) {
	      k = ref1[i];
	      results.push(delete models[k]);
	    }
	    return results;
	  };

	  return ModelRegistry;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, ModelRegistry, capitalize, defineModule, fluxStore, globalCount, isString, log, mergeInfo, nextTick, ref, time,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(19), isString = ref.isString, defineModule = ref.defineModule, log = ref.log, BaseObject = ref.BaseObject, nextTick = ref.nextTick, mergeInfo = ref.mergeInfo, capitalize = ref.capitalize, globalCount = ref.globalCount, time = ref.time;

	fluxStore = __webpack_require__(311).fluxStore;

	ModelRegistry = __webpack_require__(312);

	defineModule(module, function() {
	  return function(superClass) {
	    var FluxSubscriptionsMixin;
	    return FluxSubscriptionsMixin = (function(superClass1) {
	      var combinedKey;

	      extend(FluxSubscriptionsMixin, superClass1);

	      function FluxSubscriptionsMixin() {
	        FluxSubscriptionsMixin.__super__.constructor.apply(this, arguments);
	        this._subscriptions = {};
	      }

	      FluxSubscriptionsMixin.getter({
	        models: function() {
	          return ModelRegistry.models;
	        }
	      });

	      FluxSubscriptionsMixin.prototype.getSubscriptions = function() {
	        return this._subscriptions;
	      };

	      FluxSubscriptionsMixin._combinedKey = combinedKey = function(model, fluxKey, stateField) {
	        return model.name + "/" + stateField + "/" + fluxKey;
	      };

	      FluxSubscriptionsMixin.prototype.subscribe = function(model, fluxKey, stateField, arg) {
	        var ckey, initialFluxRecord, modelName, ref1, subscriptionFunction, updatesCallback;
	        ref1 = arg != null ? arg : {}, initialFluxRecord = ref1.initialFluxRecord, updatesCallback = ref1.updatesCallback;
	        if (isString(modelName = model)) {
	          model = this.models[modelName];
	          if (!model) {
	            throw new Error("No model registered with the name: " + modelName + ". Models:\n  " + (Object.keys(this.models).join("\n  ")));
	          }
	        }
	        ckey = combinedKey(model, fluxKey, stateField);
	        return this.setStateFromFluxRecord(stateField, this._subscriptions[ckey] ? (console.error("already subscribed"), fluxStore.get(model.name, fluxKey)) : (this._subscriptions[ckey] = {
	          fluxKey: fluxKey,
	          model: model,
	          subscriptionFunction: subscriptionFunction = (function(_this) {
	            return function(fluxRecord, subscribers) {
	              if (typeof updatesCallback === "function") {
	                updatesCallback(fluxRecord);
	              }
	              return _this.setStateFromFluxRecord(stateField, fluxRecord);
	            };
	          })(this)
	        }, fluxStore.subscribe(model.name, fluxKey, subscriptionFunction, initialFluxRecord)));
	      };

	      FluxSubscriptionsMixin.prototype.unsubscribe = function(model, fluxKey, stateField) {
	        var ckey, subscription;
	        ckey = combinedKey(model, fluxKey, stateField);
	        if (subscription = this._subscriptions[ckey]) {
	          fluxStore.unsubscribe(model.name, fluxKey, subscription.subscriptionFunction);
	          return delete this._subscriptions[ckey];
	        }
	      };

	      FluxSubscriptionsMixin.prototype.setStateFromFluxRecord = function(baseField, fluxRecord) {
	        this.setState(baseField, fluxRecord != null ? fluxRecord.data : void 0);
	        if (fluxRecord.status) {
	          this.setState(baseField + "Status", fluxRecord.status);
	        }
	        if (fluxRecord.progress != null) {
	          this.setState(baseField + "Progress", fluxRecord.progress);
	        }
	        return this.setState(baseField + "FluxRecord", fluxRecord);
	      };

	      FluxSubscriptionsMixin.prototype.unsubscribeAll = function() {
	        var ckey, fluxKey, model, ref1, ref2, subscriptionFunction;
	        ref1 = this._subscriptions;
	        for (ckey in ref1) {
	          ref2 = ref1[ckey], model = ref2.model, fluxKey = ref2.fluxKey, subscriptionFunction = ref2.subscriptionFunction;
	          fluxStore.unsubscribe(model.name, fluxKey, subscriptionFunction);
	        }
	        return this._subscriptions = {};
	      };

	      return FluxSubscriptionsMixin;

	    })(superClass);
	  };
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(315).addModules({
	  FluxComponent: __webpack_require__(316)
	});


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	var Flux, React,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Flux = __webpack_require__(304);

	module.exports = Flux.React || Flux.addNamespace('React', React = (function(superClass) {
	  extend(React, superClass);

	  function React() {
	    return React.__super__.constructor.apply(this, arguments);
	  }

	  return React;

	})(Neptune.Base));


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Component, FluxComponent, FluxCore, FluxSubscriptionsMixin, Foundation, ModelRegistry, Validator, compactFlatten, createComponentFactory, defineModule, globalCount, inspect, isFunction, isPlainObject, isString, log, mergeInfo, nextTick, pending, ref, rubyFalse, rubyTrue, success, time,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	FluxCore = __webpack_require__(307);

	ref = Neptune.Art.React, Component = ref.Component, createComponentFactory = ref.createComponentFactory;

	defineModule = Foundation.defineModule, BaseObject = Foundation.BaseObject, nextTick = Foundation.nextTick, mergeInfo = Foundation.mergeInfo, log = Foundation.log, isPlainObject = Foundation.isPlainObject, isString = Foundation.isString, isFunction = Foundation.isFunction, inspect = Foundation.inspect, time = Foundation.time, globalCount = Foundation.globalCount, rubyTrue = Foundation.rubyTrue, rubyFalse = Foundation.rubyFalse, compactFlatten = Foundation.compactFlatten, Validator = Foundation.Validator, defineModule = Foundation.defineModule, CommunicationStatus = Foundation.CommunicationStatus;

	ModelRegistry = FluxCore.ModelRegistry, FluxSubscriptionsMixin = FluxCore.FluxSubscriptionsMixin;

	pending = CommunicationStatus.pending, success = CommunicationStatus.success;


	/*
	FluxComponent

	Declarative (automatic) Flux Subscription support:
	- @subscriptions declaration method

	TODO: _prepareSubscription should be triggered via createWithPostCreate rather than with each component creation
	 */

	defineModule(module, FluxComponent = (function(superClass) {
	  var normalizeSubscriptionOptions, subscriptionValidator;

	  extend(FluxComponent, superClass);

	  FluxComponent.abstractClass();

	  FluxComponent.createFluxComponentFactory = function(spec) {
	    return createComponentFactory(spec, FluxComponent);
	  };

	  function FluxComponent() {
	    FluxComponent.__super__.constructor.apply(this, arguments);
	    this._autoMaintainedSubscriptions = {};
	    this["class"]._prepareSubscriptions();
	  }


	  /*
	  @subscriptions takes an object as input with each entry describing one subscription.
	  A subscription consists of 3 parts:
	    stateField:   the field in @state which will be set with the subscribed-to data
	    model:        the subscribed-to model (from the ModelRegistry)
	    key:          key for the specific, subscribed-to data in the model
	  
	  There are three different ways to define the subscription. Each entry in subscriptionMap
	  can take any of the three patterns:
	  
	  FluxEntry-pattern 1: Fully Explicit
	  
	    @subscriptions
	      stateField:
	        model: "modelName", model-instance or (props) -> "modelName"
	        key:   "key",       key-object     or (props) -> "key" or key-object
	  
	  FluxEntry-pattern 2: Implicit-key-from-stateField, Explicit-model
	  
	    DEPRICATED: See FluxEntry-pattern 5.
	  
	    @subscriptions
	      stateField:
	        model: "modelName", model-instance or (props) -> "modelName"
	  
	    In this pattern, the key is the set to the same name as stateField. This is useful when
	    subscribing to a known singleton value.
	  
	    For example, when using the ApplicationState model, you might to something like this:
	  
	      @subscriptions
	        currentUser: model: "applicationState"
	  
	  FluxEntry-pattern 3: Implicit-model, Explicit-key
	  
	    @subscriptions
	      stateField: "key" or (props) -> "key" or key-object
	  
	    In this pattern the name of the model is the same as the stateField. This is the most common
	    pattern. Example:
	  
	      @subscriptions
	        user: (props) -> props.userId
	  
	    Or, using coffeescript shorthand:
	  
	      @subscriptions
	        user: ({userId}) -> userId
	  
	    NOTE: If the key is not a function, it must be a string. Otherwise the subscription initialization
	    will detect one of the other patterns. To use this pattern with a non-string key, do this:
	  
	      @subscriptions
	        following: (props) -> userId: props.userId, feedId: props.feedId
	  
	  FluxEntry-pattern 4: Implicit-key-from-props, implicit-model
	  
	    @subscriptions "myField"
	  
	    is equivelent to:
	  
	    @subscriptions
	      myField:
	        model:  myField
	        key:    ({myField, myFieldId}) -> myField?.id || myFieldId
	  
	    Example:
	  
	      this:
	  
	        @subscriptions "post"
	  
	      is short for:
	  
	        @subscriptions
	          post:
	            model:  "post"
	            key:    ({post, postId}) -> post?.id || postId
	  
	    TODO: What about a subscription to another post in the same component?
	  
	      Ex: @subscriptions "post", "chapterPost"
	  
	      I think the answer may be to declare model aliases. If there was a model
	      named "chapterPost" declared, FluxComponent wouldn't need any changes. The
	      trick is we want the chapterPost model to actually be the "post" model - i.e.
	      if both a post and chapterPost subscription had the same key, they should share
	      they same FluxStore entry.
	  
	      I think we can do this fairly well via that FluxModel. Something like this:
	  
	        class Post extends FluxModel
	          @aliases "chapterPost"
	  
	      In fact... couldn't we just make @register assign the model instance to both .posts and .chapterPost?
	  
	      I think that's all we need!
	  
	  FluxEntry-pattern 5: Implicit-key-from-fieldName, implicit-model
	  
	    @subscriptions "modelName.fieldName"
	  
	    is equivelent to:
	  
	    @subscriptions
	      fieldName:
	        key: fieldName
	        model: modelName
	  
	  Key and Model functions:
	  
	    If the key or model is a function, the function:
	  
	      is executed without @ set
	      inputs: (props)
	      outputs: key or modelName respectively
	  
	  Key functions:
	  
	    Key-functions are called initially during getInitialState to set up initial
	    subscriptions.
	  
	    If the key-function returns null, all depenendent state fields will be set to
	    null. No other action will be taken.
	  
	    Whenever @props changes (e.g. when componentWillReceiveProps is called), these
	    key-functions are re-evaluated. If the return value changes, subscriptions are
	    updated and new data is requested where needed.
	   */

	  FluxComponent.subscriptions = function() {
	    var arg, fn, fn1, i, j, len, len1, ref1, ref2, stateField, subscriptionMap, subscriptionName, subscriptionNames, value;
	    ref1 = compactFlatten(arguments);
	    for (i = 0, len = ref1.length; i < len; i++) {
	      arg = ref1[i];
	      if (isPlainObject(subscriptionMap = arg)) {
	        fn = (function(_this) {
	          return function(stateField, value) {
	            return _this._addSubscription(stateField, value);
	          };
	        })(this);
	        for (stateField in subscriptionMap) {
	          value = subscriptionMap[stateField];
	          fn(stateField, value);
	        }
	      } else if (isString(subscriptionNames = arg)) {
	        ref2 = subscriptionNames.match(/[_a-z][._a-z0-9]*/gi);
	        fn1 = (function(_this) {
	          return function(subscriptionName) {
	            var _, matches, modelName, subscriptionNameId;
	            if (matches = subscriptionName.match(/([_a-z0-9]+)\.([_a-z0-9]+)/i)) {
	              _ = matches[0], modelName = matches[1], stateField = matches[2];
	              return _this._addSubscription(stateField, {
	                model: modelName
	              });
	            } else {
	              subscriptionNameId = subscriptionName + "Id";
	              return _this._addSubscription(subscriptionName, {
	                key: function(props) {
	                  var ref3;
	                  return ((ref3 = props[subscriptionName]) != null ? ref3.id : void 0) || props[subscriptionNameId];
	                }
	              });
	            }
	          };
	        })(this);
	        for (j = 0, len1 = ref2.length; j < len1; j++) {
	          subscriptionName = ref2[j];
	          fn1(subscriptionName);
	        }
	      }
	    }
	    return null;
	  };

	  subscriptionValidator = new Validator({
	    stateField: "present string",
	    model: {
	      required: {
	        validate: function(v) {
	          return isFunction(v) || isString(v);
	        }
	      }
	    },
	    key: {
	      required: {
	        validate: function(v) {
	          return v !== "undefined";
	        }
	      }
	    }
	  });

	  FluxComponent._normalizeSubscriptionOptions = normalizeSubscriptionOptions = function(stateField, subscriptionOptions) {
	    var key, model;
	    if (isPlainObject(subscriptionOptions)) {
	      key = subscriptionOptions.key, model = subscriptionOptions.model;
	      return {
	        stateField: stateField,
	        model: model || stateField,
	        key: subscriptionOptions.hasOwnProperty("key") ? key : stateField
	      };
	    } else {
	      return {
	        stateField: stateField,
	        model: stateField,
	        key: subscriptionOptions
	      };
	    }
	  };

	  FluxComponent._addSubscription = function(stateField, subscriptionOptions) {
	    subscriptionOptions = normalizeSubscriptionOptions(stateField, subscriptionOptions);
	    subscriptionValidator.validateSync(subscriptionOptions);
	    if (this.getSubscriptionProperties()[stateField]) {
	      throw new Error("stateField subscription already defined");
	    }
	    this.extendSubscriptionProperties(stateField, subscriptionOptions);
	    return this.addGetter(stateField, function() {
	      return this.state[stateField];
	    });
	  };

	  FluxComponent.prototype.preprocessProps = function(newProps) {
	    this._updateAllSubscriptions(newProps = FluxComponent.__super__.preprocessProps.apply(this, arguments));
	    return newProps;
	  };

	  FluxComponent.prototype.componentWillUnmount = function() {
	    FluxComponent.__super__.componentWillUnmount.apply(this, arguments);
	    return this.unsubscribeAll();
	  };

	  FluxComponent.extendableProperty({
	    subscriptionProperties: {}
	  });

	  FluxComponent._prepareSubscription = function(subscription) {
	    var error, key, model, modelName, stateField;
	    stateField = subscription.stateField, model = subscription.model, key = subscription.key;
	    if (!model) {
	      throw new Error("no model specified in subscription: " + (inspect({
	        stateField: stateField,
	        model: model,
	        "class": this.name,
	        subscription: subscription
	      })));
	    }
	    if (isString(model)) {
	      modelName = model;
	      model = ModelRegistry.models[modelName];
	      if (!model) {
	        console.error(error = (this.getName()) + "::subscriptions() model '" + modelName + "' not registered (component = " + (this.getNamespacePath()) + ")");
	        throw new Error(error);
	      }
	    }
	    subscription.model = model;
	    return subscription.keyFunction = isFunction(key) ? key : function() {
	      return key;
	    };
	  };

	  FluxComponent.postCreateConcreteClass = function() {
	    if (this.prototype.subscriptions) {
	      this.subscriptions(this.prototype.subscriptions);
	    }
	    this._subscriptionsPrepared = false;
	    return FluxComponent.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
	  };

	  FluxComponent._prepareSubscriptions = function() {
	    var ref1, results, stateField, subscription;
	    if (this._subscriptionsPrepared) {
	      return;
	    }
	    this._subscriptionsPrepared = true;
	    ref1 = this.getSubscriptionProperties();
	    results = [];
	    for (stateField in ref1) {
	      subscription = ref1[stateField];
	      results.push(this._prepareSubscription(subscription));
	    }
	    return results;
	  };

	  FluxComponent.prototype._toFluxKey = function(stateField, key, model, props) {
	    var ref1;
	    if (rubyFalse(key)) {
	      key = (ref1 = props[stateField]) != null ? ref1.id : void 0;
	    }
	    if (rubyTrue(key)) {
	      return model.toFluxKey(key);
	    } else {
	      return null;
	    }
	  };

	  FluxComponent.prototype._updateSubscription = function(stateField, key, model, props) {
	    var existingSubscriptionFluxKey, fluxKey, initialData;
	    fluxKey = this._toFluxKey(stateField, key, model, props);
	    if (!this.state[stateField]) {
	      this.state[stateField] = initialData = props[stateField];
	    }
	    if (!rubyTrue(existingSubscriptionFluxKey = this._autoMaintainedSubscriptions[stateField])) {
	      existingSubscriptionFluxKey = null;
	    }
	    if (model && (fluxKey !== null || fluxKey !== existingSubscriptionFluxKey)) {
	      if (existingSubscriptionFluxKey !== null) {
	        this.unsubscribe(model, existingSubscriptionFluxKey, stateField);
	      }
	      this._autoMaintainedSubscriptions[stateField] = fluxKey;
	      if (rubyTrue(fluxKey)) {
	        this.subscribe(model, fluxKey, stateField, {
	          initialFluxRecord: initialData ? {
	            status: success,
	            data: initialData
	          } : void 0
	        });
	      } else {
	        this.setStateFromFluxRecord(stateField, {
	          status: success
	        });
	      }
	      return true;
	    }
	  };

	  FluxComponent.prototype._updateAllSubscriptions = function(props) {
	    var keyFunction, model, ref1, stateField, subscriptionProps;
	    if (props == null) {
	      props = this.props;
	    }
	    ref1 = this["class"].getSubscriptionProperties();
	    for (stateField in ref1) {
	      subscriptionProps = ref1[stateField];
	      keyFunction = subscriptionProps.keyFunction, model = subscriptionProps.model;
	      if (isFunction(model)) {
	        model = model(props);
	      }
	      if (isString(model)) {
	        if (!(model = this.models[model])) {
	          console.error("Could not find model named " + (inspect(model)) + " for subscription in component " + this.inspectedName);
	        }
	      }
	      if (model) {
	        this._updateSubscription(stateField, keyFunction(props), model, props);
	      }
	    }
	    return null;
	  };

	  return FluxComponent;

	})(FluxSubscriptionsMixin(Component)));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var ApplicationState, BaseObject, CommunicationStatus, FluxCore, FluxModel, FluxStore, Foundation, Unique, clone, defineModule, failure, fluxStore, isPlainObject, isString, log, merge, mergeInto, missing, objectWithout, pending, propsEq, success,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	FluxCore = __webpack_require__(307);

	clone = Foundation.clone, objectWithout = Foundation.objectWithout, BaseObject = Foundation.BaseObject, log = Foundation.log, isString = Foundation.isString, isPlainObject = Foundation.isPlainObject, merge = Foundation.merge, propsEq = Foundation.propsEq, mergeInto = Foundation.mergeInto, Unique = Foundation.Unique, defineModule = Foundation.defineModule, CommunicationStatus = Foundation.CommunicationStatus;

	FluxStore = FluxCore.FluxStore, FluxModel = FluxCore.FluxModel;

	fluxStore = FluxStore.fluxStore;

	pending = CommunicationStatus.pending, success = CommunicationStatus.success, failure = CommunicationStatus.failure, missing = CommunicationStatus.missing;


	/*
	A state-store with the same state API as React Components:
	  setState: (map) -> or (key, value) -> # => null
	  getInitialState: -> # => {}
	  @state: {} # the current State

	NOTE: Components should never access @state. Instead, they should subscribe to state changes:
	Example:
	  createComponentFactory class Top extends FluxComponent
	    @subscriptions
	      showingWelcome: model: "ozAppState"

	  showWelcome: ->
	    @model.ozAppState.showWelcome()

	Usage:
	  Inherit, register and optionally override getInitalState.
	  Note: Each time you inherit creates a new model and a different collection state
	  NOTE: @register immeidately instantiates the OzAppState singleton - which will
	    immediately call getInitialState.
	    Therefor, call @register AFTER defining getInitialState.

	Example:
	  class OzAppState extends ApplicationState

	    getInitialState: ->
	      showingWelcome: true

	    @register()

	    showWelcome: -> @setState "showingWelcome", true
	    hideWelcome: -> @setState "showingWelcome", false

	NEW:
	  You can how subscribe to the entire state of the model by subscribing to its own name:

	  Example:
	     * using the model above, you can subscribe to its entire state as follows:

	    class MyComponent extends FluxComponent
	      @subscriptions "ozAppState.ozAppState"

	      render: ->
	        TextElement text: "showingWelcome: #{@ozAppState.showingWelcome}"
	 */

	defineModule(module, ApplicationState = (function(superClass) {
	  extend(ApplicationState, superClass);

	  ApplicationState.abstractClass();

	  ApplicationState.persistant = function() {
	    return this._persistant = true;
	  };

	  ApplicationState.postCreateConcreteClass = function(arg) {
	    var classModuleState, currentState, hotReloaded, hotUpdatedFromClass, k, liveClass, liveInstance, newDefaultState, ret, tempInstance, v;
	    hotReloaded = arg.hotReloaded, classModuleState = arg.classModuleState;
	    ret = ApplicationState.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
	    if (hotReloaded) {
	      liveClass = classModuleState.liveClass, hotUpdatedFromClass = classModuleState.hotUpdatedFromClass;
	      tempInstance = new hotUpdatedFromClass;
	      liveInstance = liveClass.getSingleton();
	      newDefaultState = tempInstance.state;
	      currentState = liveInstance.state;
	      log({
	        "Flux.ApplicationState: model hot-reloaded": {
	          model: liveInstance.name
	        }
	      });
	      for (k in newDefaultState) {
	        v = newDefaultState[k];
	        if (!(!currentState.hasOwnProperty(k))) {
	          continue;
	        }
	        liveInstance.setState(k, v);
	        log({
	          "new state field added": {
	            field: k,
	            value: v
	          }
	        });
	      }
	    }
	    return ret;
	  };


	  /*
	  Declare state fields you intend to use.
	  IN: fields
	    map from field names to initial values
	  
	  EFFECTS:
	    initializes @state
	    declares @getters and @setters for each field
	   */

	  ApplicationState.stateFields = function(fields) {
	    var field, initialValue, results;
	    this._stateFields = mergeInto(this._stateFields, fields);
	    results = [];
	    for (field in fields) {
	      initialValue = fields[field];
	      results.push((function(_this) {
	        return function(field) {
	          _this._addSetter(_this.prototype, field, function(v) {
	            return this.setState(field, v);
	          });
	          return _this._addGetter(_this.prototype, field, function() {
	            return this.state[field];
	          });
	        };
	      })(this)(field));
	    }
	    return results;
	  };

	  function ApplicationState() {
	    ApplicationState.__super__.constructor.apply(this, arguments);
	    this.state = this._getInitialState();
	  }


	  /*
	  provided for consistency with React Components
	  To use: override
	  But, using @stateFields works just as well and also declares field getter / setters.
	   */

	  ApplicationState.prototype.getInitialState = function() {
	    return {};
	  };


	  /*
	  option 1:
	    IN: plainObject state-map
	    AFFECT: set many states
	    OUT: state-map
	  
	  option 2:
	    IN: key, value
	    AFFECT: set one state
	    OUT: key
	   */

	  ApplicationState.prototype.setState = function(key, value) {
	    var k, map, v;
	    if (isPlainObject(map = key)) {
	      for (k in map) {
	        v = map[k];
	        if (!(!propsEq(this.state[k], v))) {
	          continue;
	        }
	        this.state[k] = v;
	        this.load(k);
	      }
	    } else if (isString(key) && !propsEq(this.state[key], value)) {
	      this.state[key] = value;
	      this.load(key);
	    }
	    this._updateAllState();
	    this._saveToLocalStorage();
	    return key;
	  };

	  ApplicationState.prototype.removeState = function(key) {
	    var ret;
	    this._removeFromFluxStore(key);
	    ret = this.state[key];
	    delete this.state[key];
	    return ret;
	  };


	  /*
	  Removes all values in @state.
	  All entries currently in FluxStore become: state: missing
	   */

	  ApplicationState.prototype.clearState = function() {
	    var k, ref, v;
	    ref = this.state;
	    for (k in ref) {
	      v = ref[k];
	      this._removeFromFluxStore(k);
	    }
	    return this.state = {};
	  };

	  ApplicationState.prototype.resetState = function() {
	    return this.replaceState(this._getInitialState());
	  };


	  /*
	  Replace all state with newState.
	  Logically equivelent to:
	    @clearState()
	    @setState newState
	   */

	  ApplicationState.prototype.replaceState = function(newState) {
	    var k, ref, v;
	    ref = this.state;
	    for (k in ref) {
	      v = ref[k];
	      if (!(!newState.hasOwnProperty(k))) {
	        continue;
	      }
	      this._removeFromFluxStore(k);
	      delete this.state[k];
	    }
	    return this.setState(newState);
	  };

	  ApplicationState.prototype.load = function(key, callback) {
	    var fluxRecord;
	    fluxRecord = this.state.hasOwnProperty(key) ? {
	      status: success,
	      data: this.state[key]
	    } : {
	      status: missing
	    };
	    this.updateFluxStore(key, fluxRecord);
	    callback && fluxStore.onNextReady(function() {
	      return callback(fluxRecord);
	    });
	    return fluxRecord;
	  };

	  ApplicationState.prototype._removeFromFluxStore = function(key) {
	    return this.updateFluxStore(key, {
	      status: missing
	    });
	  };

	  ApplicationState.prototype._loadFromLocalStorage = function() {
	    var data, v;
	    if (this["class"]._persistant) {
	      data = localStorage.getItem(this.name);
	      if (data) {
	        v = JSON.parse(data);
	      }
	      log({
	        _loadFromLocalStorage: v
	      });
	      return v;
	    }
	  };

	  ApplicationState.prototype._updateAllState = function(state) {
	    var newState, obj, oldState;
	    oldState = state || this.state;
	    newState = merge(oldState, (
	      obj = {},
	      obj["" + this.name] = objectWithout(oldState, this.name),
	      obj
	    ));
	    if (!state) {
	      this.state = newState;
	      this.load(this.name);
	    }
	    return newState;
	  };

	  ApplicationState.getter({
	    savableState: function() {
	      return objectWithout(this.state, this.name);
	    }
	  });

	  ApplicationState.prototype._saveToLocalStorage = function(state) {
	    var v;
	    if (state == null) {
	      state = this.state;
	    }
	    if (this["class"]._persistant) {
	      return localStorage.setItem(this.name, v = JSON.stringify(this.savableState));
	    }
	  };

	  ApplicationState.prototype._getInitialState = function() {
	    return this._updateAllState(merge(this.getInitialState(), this["class"]._stateFields, (function() {
	      try {
	        return this._loadFromLocalStorage();
	      } catch (error) {}
	    }).call(this)));
	  };

	  return ApplicationState;

	})(FluxModel));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 318 */
/***/ function(module, exports) {

	module.exports = {
		"author": "Shane Brinkman-Davis Delamore, Imikimi LLC",
		"dependencies": {
			"art-foundation": "git://github.com/imikimi/art-foundation.git",
			"art-react": "git://github.com/imikimi/art-react.git",
			"chai": "^3.5.0",
			"coffee-loader": "^0.7.2",
			"coffee-script": "^1.11.1",
			"css-loader": "^0.23.1",
			"json-loader": "^0.5.4",
			"mocha": "^2.5.3",
			"neptune-namespaces": "^1.4.0",
			"script-loader": "^0.7.0",
			"sourcemapped-stacktrace": "^1.1.3",
			"style-loader": "^0.13.1",
			"webpack": "^1.13.2",
			"webpack-dev-server": "^1.16.2"
		},
		"license": "ISC",
		"name": "art-flux",
		"scripts": {
			"dev": "neptune-namespaces --std; webpack-dev-server -d --progress",
			"hot": "neptune-namespaces --std; webpack-dev-server --hot --inline --progress",
			"nn": "neptune-namespaces --std",
			"nodeTest": "neptune-namespaces --std;mocha -u tdd --compilers coffee:coffee-script/register",
			"test": "neptune-namespaces --std; webpack-dev-server -d --progress"
		},
		"version": "1.2.2"
	};

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(320).addModules({
	  FluxDbModelBase: __webpack_require__(321),
	  FluxDbModel: __webpack_require__(322),
	  FluxDbQueryModel: __webpack_require__(323)
	});


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	var Db, Flux,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Flux = __webpack_require__(304);

	module.exports = Flux.Db || Flux.addNamespace('Db', Db = (function(superClass) {
	  extend(Db, superClass);

	  function Db() {
	    return Db.__super__.constructor.apply(this, arguments);
	  }

	  return Db;

	})(Neptune.Base));


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, FluxCore, FluxDbModelBase, FluxModel, FluxStore, Foundation, ModelRegistry, capitalize, decapitalize, defineModule, emailRegexp, failure, fluxStore, globalCount, idRegExpStr, inspect, isFunction, isHexColor, isId, isNumber, isString, log, merge, missing, nextTick, objectWithout, pending, pluralize, pureMerge, shallowClone, success, time, urlRegexp,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	FluxCore = __webpack_require__(307);

	log = Foundation.log, BaseObject = Foundation.BaseObject, decapitalize = Foundation.decapitalize, pluralize = Foundation.pluralize, pureMerge = Foundation.pureMerge, shallowClone = Foundation.shallowClone, isString = Foundation.isString, emailRegexp = Foundation.emailRegexp, urlRegexp = Foundation.urlRegexp, isNumber = Foundation.isNumber, nextTick = Foundation.nextTick, capitalize = Foundation.capitalize, inspect = Foundation.inspect, isFunction = Foundation.isFunction, merge = Foundation.merge, objectWithout = Foundation.objectWithout, shallowClone = Foundation.shallowClone, time = Foundation.time, globalCount = Foundation.globalCount, defineModule = Foundation.defineModule, CommunicationStatus = Foundation.CommunicationStatus;

	FluxStore = FluxCore.FluxStore, ModelRegistry = FluxCore.ModelRegistry, FluxModel = FluxCore.FluxModel;

	fluxStore = FluxStore.fluxStore;

	pending = CommunicationStatus.pending, success = CommunicationStatus.success, failure = CommunicationStatus.failure, missing = CommunicationStatus.missing;

	idRegExpStr = "[a-z0-9]+";

	isId = function(v) {
	  return isString(v) && v.match(RegExp("^" + idRegExpStr + "$", "i"));
	};

	isHexColor = function(v) {
	  return isString(v) && v.match(/^#([a-f0-9]{3})|([a-f0-9]{6})/i);
	};


	/*
	FluxDbModelBase

	Basic functionality for DB-like models (CRUD).
	To use: inherit and override at least _storeGet and possibly other overrides.
	 */

	defineModule(module, FluxDbModelBase = (function(superClass) {
	  extend(FluxDbModelBase, superClass);

	  function FluxDbModelBase() {
	    return FluxDbModelBase.__super__.constructor.apply(this, arguments);
	  }

	  FluxDbModelBase.abstractClass();

	  FluxDbModelBase.localStoreCacheEnabled = false;

	  FluxDbModelBase.prototype.get = function(key) {
	    return fluxStore.get(this._name, key);
	  };

	  FluxDbModelBase.prototype.getOrLoad = function(key, callback) {
	    var fluxRecord;
	    if (fluxRecord = this.get(key)) {
	      callback && fluxStore.onNextReady(function() {
	        return callback(fluxRecord);
	      });
	    } else {
	      this.load(key, callback);
	    }
	    return fluxRecord;
	  };

	  FluxDbModelBase.prototype.load = function(key, callback) {
	    var data;
	    this._storeGet(key, (function(_this) {
	      return function(fluxRecord) {
	        if (data) {
	          fluxRecord.data || (fluxRecord.data = data);
	        }
	        fluxStore.update(_this._name, key, fluxRecord);
	        if (fluxRecord.data && FluxDbModelBase.localStoreCacheEnabled) {
	          _this._localStoreSet(key, fluxRecord.data);
	        }
	        return callback && fluxStore.onNextReady(function() {
	          return callback(fluxRecord);
	        });
	      };
	    })(this));
	    if (FluxDbModelBase.localStoreCacheEnabled && (data = this._localStoreGet(key))) {
	      return {
	        data: data,
	        status: success
	      };
	    }
	  };


	  /*
	  calls _storePut (must be overriden by inheriting class)
	  
	  updates fluxRecord as progress is made:
	    start: sets fluxRecord.pendingData to expected result
	    success: sets data to most up-to-date value
	    success or failure: removes fluxRecord.pendingData
	  
	  callback:
	    signature: (fluxRecord) => null
	    invoked on:
	      fluxRecord.status changes
	      success or failure
	  
	  sets additional fields on the fluxStore fluxRecord:
	    putPendingCount: 0 or more. if more, then there is a pending put
	    data: is set to what we think the updated data will be for immediate user viz
	    oldData: what the data was before the put
	    retry: if set, this is a function you can call to retry a failed put. signature: (fluxRecord) -> null
	      NOTE: retry will also call the original callback which may still be waiting for a success.
	        Most the time you'll just call retry() and let the original callback do the work.
	      Note: If there were multiple posts that failed, retry will retry them all.
	   */

	  FluxDbModelBase.prototype.put = function(id, fields, callback) {
	    var ourOldData, ourRetry;
	    ourOldData = null;
	    ourRetry = null;
	    if (id === null || id === void 0 || id === false) {
	      throw new Error("invalid id: " + (inspect(id)));
	    }
	    fluxStore.update(this.name, id, (function(_this) {
	      return function(oldFields) {
	        var res;
	        res = merge(oldFields, {
	          putPendingCount: (oldFields.putPendingCount || 0) + 1,
	          data: merge((oldFields != null ? oldFields.pendingData : void 0) || (oldFields != null ? oldFields.data : void 0), fields),
	          oldData: ourOldData = shallowClone((oldFields != null ? oldFields.oldData : void 0) || (oldFields != null ? oldFields.data : void 0))
	        });
	        return res;
	      };
	    })(this));
	    this._storePut(id, fields, (function(_this) {
	      return function(putStatus) {
	        callback && fluxStore.onNextReady(function() {
	          return callback(putStatus);
	        });
	        if (putStatus.status === pending) {
	          return;
	        }
	        if (putStatus.status === success) {
	          return fluxStore.update(_this.name, id, function(oldFields) {
	            var putPendingCount, res, updatedData;
	            if (oldFields.status !== pending && oldFields.status !== success) {
	              _this.load(id);
	            }
	            updatedData = merge(oldFields.data, fields);
	            fluxStore.onNextReady(function() {
	              return _this._updateQueries(updatedData);
	            });
	            putPendingCount = (oldFields.putPendingCount || 0) - 1;
	            res = merge(oldFields, {
	              data: merge(oldFields.data, fields)
	            });
	            if (putPendingCount <= 0) {
	              delete res.putPendingCount;
	            }
	            if (res.retry === oldFields.retry) {
	              delete res.retry;
	            }
	            if (ourOldData === res.oldData) {
	              delete res.oldData;
	            }
	            return res;
	          });
	        } else {
	          return fluxStore.update(_this.name, id, function(oldFields) {
	            return merge(oldFields, {
	              data: ourOldData === oldFields.oldData ? ourOldData : oldFields.data,
	              putPendingCount: (oldFields.putPendingCount || 0) - 1,
	              retry: ourRetry = function(newCallback) {
	                var otherRetry;
	                ourRetry = (function(_this) {
	                  return function() {
	                    return _this.put(id, fields, function(fluxRecord) {
	                      if (typeof newCallback === "function") {
	                        newCallback(fluxRecord);
	                      }
	                      return typeof callback === "function" ? callback(fluxRecord) : void 0;
	                    });
	                  };
	                })(this);
	                if (otherRetry = oldFields.retry) {
	                  return otherRetry((function(_this) {
	                    return function(fluxRecord) {
	                      if (fluxRecord.status === success) {
	                        return ourRetry();
	                        if (typeof newCallback === "function") {
	                          newCallback(fluxRecord);
	                        }
	                        return typeof callback === "function" ? callback(fluxRecord) : void 0;
	                      }
	                    };
	                  })(this));
	                } else {
	                  return ourRetry();
	                }
	              }
	            });
	          });
	        }
	      };
	    })(this));
	    return null;
	  };


	  /*
	  Updates fluxStore on success, otherwise is a passthrough for _storePost
	  SBD TODO: fluxStore will purge entries with no subscribers, won't POST fluxStore updates always result in a no-op
	    since, by definition, there can be no subscribers yet?
	   */

	  FluxDbModelBase.prototype.post = function(fields, callback) {
	    this._storePost(fields, (function(_this) {
	      return function(fluxRecord) {
	        if (fluxRecord.status === success) {
	          _this._updateQueries(fluxRecord.data);
	          fluxStore.update(_this.name, fluxRecord.data.id, fluxRecord);
	        }
	        return callback && fluxStore.onNextReady(function() {
	          return callback(fluxRecord);
	        });
	      };
	    })(this));
	    return null;
	  };

	  FluxDbModelBase.prototype.keyFromData = function(data) {
	    return data.id;
	  };

	  FluxDbModelBase.prototype._updateQueries = function(updatedRecordData) {};

	  FluxDbModelBase.prototype._storeGet = function(id, callback) {
	    throw new Error("must override. Class: " + this.className);
	  };

	  FluxDbModelBase.prototype._storePut = function(id, fields, callback) {
	    throw new Error("must override. Class: " + this.className);
	  };

	  FluxDbModelBase.prototype._storePost = function(fields, callback) {
	    throw new Error("must override. Class: " + this.className);
	  };

	  return FluxDbModelBase;

	})(FluxModel));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, FluxCore, FluxDbModel, FluxDbModelBase, FluxModel, FluxStore, Foundation, ModelRegistry, capitalize, compact, decapitalize, defineModule, emailRegexp, failure, fluxStore, idRegExpStr, inspect, isFunction, isHexColor, isId, isNumber, isPlainArray, isPlainObject, isString, log, merge, missing, nextTick, objectWithout, pending, pluralize, pureMerge, shallowClone, success, urlRegexp,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	FluxCore = __webpack_require__(307);

	FluxDbModelBase = __webpack_require__(321);

	log = Foundation.log, BaseObject = Foundation.BaseObject, decapitalize = Foundation.decapitalize, pluralize = Foundation.pluralize, pureMerge = Foundation.pureMerge, shallowClone = Foundation.shallowClone, isString = Foundation.isString, emailRegexp = Foundation.emailRegexp, urlRegexp = Foundation.urlRegexp, isNumber = Foundation.isNumber, nextTick = Foundation.nextTick, capitalize = Foundation.capitalize, inspect = Foundation.inspect, isFunction = Foundation.isFunction, merge = Foundation.merge, objectWithout = Foundation.objectWithout, isPlainObject = Foundation.isPlainObject, isPlainArray = Foundation.isPlainArray, compact = Foundation.compact, defineModule = Foundation.defineModule, CommunicationStatus = Foundation.CommunicationStatus;

	FluxStore = FluxCore.FluxStore, ModelRegistry = FluxCore.ModelRegistry, FluxModel = FluxCore.FluxModel;

	missing = CommunicationStatus.missing, failure = CommunicationStatus.failure, success = CommunicationStatus.success, pending = CommunicationStatus.pending;

	fluxStore = FluxStore.fluxStore;

	idRegExpStr = "[a-z0-9]+";

	isId = function(v) {
	  return isString(v) && v.match(RegExp("^" + idRegExpStr + "$", "i"));
	};

	isHexColor = function(v) {
	  return isString(v) && v.match(/^#([a-f0-9]{3})|([a-f0-9]{6})/i);
	};


	/*
	FluxDbModel

	Adds declarative API:
	  @fields - with validation and preprocessing support
	  @query - declare/create a model for each query
	 */

	defineModule(module, FluxDbModel = (function(superClass) {
	  var fieldTypes, i, key, len, normalizeUrl, ref, requiredKey;

	  extend(FluxDbModel, superClass);

	  FluxDbModel.abstractClass();

	  FluxDbModel.normalizeUrl = normalizeUrl = function(url) {
	    var match;
	    match = url.match(urlRegexp);
	    return "" + (match[1].toLowerCase()) + match[2] + (match[3].toLowerCase()) + (match.slice(4).join(''));
	  };

	  FluxDbModel.fieldTypes = fieldTypes = {
	    id: {
	      validate: function(v) {
	        return isId(v);
	      }
	    },
	    color: {
	      validate: function(v) {
	        return isHexColor(v);
	      }
	    },
	    number: {
	      validate: function(v) {
	        return isNumber(v);
	      }
	    },
	    date: {
	      validate: function(v) {
	        return isString(v) || (v instanceof Date);
	      },
	      preprocess: function(v) {
	        if (isString(v)) {
	          return new Date(v);
	        } else {
	          return v;
	        }
	      }
	    },
	    email: {
	      validate: function(v) {
	        return isString(v) && v.trim().match(emailRegexp);
	      },
	      preprocess: function(v) {
	        return v.trim().toLowerCase();
	      }
	    },
	    url: {
	      validate: function(v) {
	        return isString(v) && v.match(urlRegexp);
	      },
	      preprocess: function(v) {
	        return normalizeUrl(v);
	      }
	    },
	    boolean: {
	      validate: function(v) {
	        return v === true || v === false;
	      }
	    },
	    count: {
	      validate: function(v) {
	        return isNumber(v);
	      }
	    },
	    object: {
	      validate: function(v) {
	        return isPlainObject(v);
	      }
	    },
	    string: {
	      validate: function(v) {
	        return isString(v);
	      }
	    },
	    array: {
	      validate: function(v) {
	        return isPlainArray(v);
	      }
	    },
	    trimmedString: {
	      validate: function(v) {
	        return isString(v);
	      },
	      preprocess: function(v) {
	        return v.trim();
	      }
	    }
	  };

	  ref = Object.keys(FluxDbModel.fieldTypes);
	  for (i = 0, len = ref.length; i < len; i++) {
	    key = ref[i];
	    requiredKey = "required" + capitalize(key);
	    FluxDbModel.fieldTypes[requiredKey] = merge(FluxDbModel.fieldTypes[key], {
	      required: true
	    });
	  }


	  /*
	  fieldDeclarationMap is a map from field-names to fieldOptions
	  
	  fieldOptions: (all optional)
	    validate: ->
	    preprocess: ->
	    required: t/f
	      note: for internal use only, this can also be a string specifying an alternatite field-name
	        meaning: 'either this field or the alternate must be set'
	    linkTo: "modelName"
	   */

	  FluxDbModel.fields = function(fieldDeclarationMap) {
	    var field, idFieldOptions, linkTo, results, subOptions;
	    this.register();
	    results = [];
	    for (field in fieldDeclarationMap) {
	      subOptions = fieldDeclarationMap[field];
	      if (subOptions.type) {
	        throw new Error(this.namespacePath + ": @fields declarations using 'type' no longer supported");
	      }
	      if (linkTo = subOptions.linkTo) {
	        if (field.match(/.*Id$/)) {
	          console.warn("FluxDbModel " + this.name + ": linkTo field '" + field + "' should not end in 'Id'");
	        }
	        this._addField(field + "Id", idFieldOptions = merge(this.fieldTypes.id, objectWithout(subOptions, "linkTo")));
	        subOptions = merge(this.fieldTypes.plainObject, subOptions);
	        if (subOptions.required) {
	          delete subOptions.required;
	          idFieldOptions.required = field;
	        }
	      }
	      results.push(this._addField(field, subOptions));
	    }
	    return results;
	  };

	  FluxDbModel.getter({
	    relations: function() {
	      var field, linkTo, ref1;
	      if (!this._relations) {
	        this._relations = {};
	        ref1 = this.fieldProperties;
	        for (field in ref1) {
	          linkTo = ref1[field].linkTo;
	          if (linkTo) {
	            this._relations[field] = {
	              model: this.models[linkTo],
	              idField: field + "Id"
	            };
	          }
	        }
	      }
	      return this._relations;
	    }
	  });


	  /*
	  @query defines and registers a new model for returning sets of records.
	  Example
	    definition:
	      class Post extends FluxModel
	        @query "feed"
	  
	    creates and registers new model class: PostsByFeed
	  
	    example use:
	      class MyComponent extends RestComponent
	        getInitialState: ->
	          posts: models.postsByFeed.get "feedId"
	  
	    example use:
	      class MyComponent extends RestComponent
	        @restSubscriptions
	          postsByFeed: -> "feedId"
	  
	  NOTE: the @queryModel class member MUST be set by an inheriting class before this works.
	  options:
	    keyFromData: (data) -> key
	   */

	  FluxDbModel.query = function(parameterizedField, options) {
	    var ref1, rm, rqm;
	    if (options == null) {
	      options = {};
	    }
	    ModelRegistry.register(rqm = new this.queryModel(rm = this.register(), parameterizedField, options));
	    rm.queryModels.push(rqm);
	    return (ref1 = rm._queriesToUpdate) != null ? ref1.push(function(fields) {
	      return rm._updateQuery(rqm, fields[parameterizedField]);
	    }) : void 0;
	  };

	  function FluxDbModel() {
	    FluxDbModel.__super__.constructor.apply(this, arguments);
	    this.queryModels = [];
	  }

	  FluxDbModel.prototype.put = function(id, fields, callback) {
	    if (this._presentFieldsValid(fields)) {
	      FluxDbModel.__super__.put.call(this, id, this._preprocessFields(fields), callback);
	    } else {
	      callback && fluxStore.onNextReady((function(_this) {
	        return function() {
	          return callback({
	            status: failure,
	            model: _this.name,
	            id: id,
	            pendingData: fields,
	            invalidFields: _this._invalidFields(fields)
	          });
	        };
	      })(this));
	    }
	    return null;
	  };

	  FluxDbModel.prototype.post = function(fields, callback) {
	    if (this._requiredFieldsPresent(fields) && this._presentFieldsValid(fields)) {
	      FluxDbModel.__super__.post.call(this, this._preprocessFields(fields), callback);
	    } else {
	      callback && fluxStore.onNextReady((function(_this) {
	        return function() {
	          return callback({
	            status: failure,
	            pendingData: fields,
	            missingFields: _this._missingFields(fields),
	            invalidFields: _this._invalidFields(fields)
	          });
	        };
	      })(this));
	    }
	    return null;
	  };

	  FluxDbModel.prototype.validatePostFields = function(fields) {
	    if (this._requiredFieldsPresent(fields) && this._presentFieldsValid(fields)) {
	      return null;
	    }
	    return {
	      invalidFields: this._invalidFields(fields),
	      missingFields: this._missingFields(fields)
	    };
	  };

	  FluxDbModel.extendableProperty({
	    fieldProperties: {}
	  });

	  FluxDbModel._addField = function(field, options) {
	    return this.extendFieldProperties(field, options);
	  };

	  FluxDbModel.prototype._missingFields = function(fields) {
	    var fieldName, ref1, required, results;
	    ref1 = this.fieldProperties;
	    results = [];
	    for (fieldName in ref1) {
	      required = ref1[fieldName].required;
	      if (required && !((fields[fieldName] != null) || (fields[required] != null))) {
	        results.push(fieldName);
	      }
	    }
	    return results;
	  };

	  FluxDbModel.prototype._requiredFieldsPresent = function(fields) {
	    var fieldName, ref1, required;
	    ref1 = this.fieldProperties;
	    for (fieldName in ref1) {
	      required = ref1[fieldName].required;
	      if (required && !((fields[fieldName] != null) || (fields[required] != null))) {
	        return false;
	      }
	    }
	    return true;
	  };

	  FluxDbModel.prototype._preprocessFields = function(fields) {
	    var fieldName, oldV, preprocess, processedFields, ref1, v, value;
	    processedFields = null;
	    ref1 = this.fieldProperties;
	    for (fieldName in ref1) {
	      preprocess = ref1[fieldName].preprocess;
	      if (preprocess && ((value = fields[fieldName]) != null)) {
	        if ((v = preprocess(oldV = fields[fieldName])) !== oldV) {
	          processedFields || (processedFields = shallowClone(fields));
	          processedFields[fieldName] = v;
	        }
	      }
	    }
	    return processedFields || fields;
	  };

	  FluxDbModel.prototype._presentFieldsValid = function(fields) {
	    var fieldName, ref1, validate, value;
	    ref1 = this.fieldProperties;
	    for (fieldName in ref1) {
	      validate = ref1[fieldName].validate;
	      if (validate && ((value = fields[fieldName]) != null) && !validate(value)) {
	        return false;
	      }
	    }
	    return true;
	  };

	  FluxDbModel.prototype._invalidFields = function(fields) {
	    var fieldName, ref1, results, validate, value;
	    ref1 = this.fieldProperties;
	    results = [];
	    for (fieldName in ref1) {
	      validate = ref1[fieldName].validate;
	      if (validate && ((value = fields[fieldName]) != null) && !validate(value)) {
	        results.push(fieldName);
	      }
	    }
	    return results;
	  };

	  return FluxDbModel;

	})(FluxDbModelBase));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, FluxDbModelBase, FluxDbQueryModel, Foundation, capitalize, decapitalize, defineModule, emailRegexp, inspect, isFunction, isNumber, isString, log, nextTick, objectWithout, pluralize, pureMerge, shallowClone, urlRegexp,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	FluxDbModelBase = __webpack_require__(321);

	defineModule = Foundation.defineModule, log = Foundation.log, BaseObject = Foundation.BaseObject, decapitalize = Foundation.decapitalize, pluralize = Foundation.pluralize, pureMerge = Foundation.pureMerge, shallowClone = Foundation.shallowClone, isString = Foundation.isString, emailRegexp = Foundation.emailRegexp, urlRegexp = Foundation.urlRegexp, isNumber = Foundation.isNumber, nextTick = Foundation.nextTick, capitalize = Foundation.capitalize, inspect = Foundation.inspect, isFunction = Foundation.isFunction, objectWithout = Foundation.objectWithout;


	/*
	FluxDbQueryModel

	Foundation for auto-created query models.

	Currently only supports differentiating query model names based on a single field-name.

	To use: inherit and override _storeGet (required)

	options:
	  keyFromData: (singleRecordData) -> key # override the default keyFromData method
	    should return the key used by this model to fetch the list, aggregate or derrivative "data"
	    that contains the singleRecordData

	  modelName: "string"
	    Normally the model name is generated from the singlesModel name and the parameterized field.
	    This allows you to set an arbitrary alternative model name.
	    Capitalization of the first letter is automatically handled correctly no matter what you pass in.
	 */

	defineModule(module, FluxDbQueryModel = (function(superClass) {
	  extend(FluxDbQueryModel, superClass);

	  FluxDbQueryModel.abstractClass();

	  function FluxDbQueryModel(singlesModel, parameterizedField, options) {
	    FluxDbQueryModel.__super__.constructor.call(this, (options != null ? options.modelName : void 0) ? decapitalize(options != null ? options.modelName : void 0) : pluralize(singlesModel.name) + "By" + capitalize(parameterizedField));
	    this._singlesModel = singlesModel;
	    this._parameterizedField = parameterizedField;
	    this.keyFromData = options.keyFromData || options.toFluxKey || eval("(function(data) {return data['" + parameterizedField + "'];})");
	    this._options = options;
	    if (options.toFluxKey) {
	      this.toFluxKey = options.toFluxKey;
	    }
	  }

	  return FluxDbQueryModel;

	})(FluxDbModelBase));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(325).addModules({
	  ApplicationState: __webpack_require__(317),
	  VolatileModel: __webpack_require__(326),
	  VolatileQueryModel: __webpack_require__(328),
	  VolatileStore: __webpack_require__(327)
	});


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	var Flux, Models,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Flux = __webpack_require__(304);

	module.exports = Flux.Models || Flux.addNamespace('Models', Models = (function(superClass) {
	  extend(Models, superClass);

	  function Models() {
	    return Models.__super__.constructor.apply(this, arguments);
	  }

	  return Models;

	})(Neptune.Base));


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, FluxCore, FluxDb, FluxDbModel, FluxModel, FluxStore, Foundation, ModelRegistry, VolatileModel, VolatileQueryModel, VolatileStore, decapitalize, defineModule, fluxStore, log, pluralize, volatileStore,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	FluxCore = __webpack_require__(307);

	VolatileStore = __webpack_require__(327);

	VolatileQueryModel = __webpack_require__(328);

	FluxDb = __webpack_require__(319);

	defineModule = Foundation.defineModule, log = Foundation.log, BaseObject = Foundation.BaseObject, decapitalize = Foundation.decapitalize, pluralize = Foundation.pluralize, defineModule = Foundation.defineModule;

	FluxStore = FluxCore.FluxStore, FluxModel = FluxCore.FluxModel, ModelRegistry = FluxCore.ModelRegistry;

	volatileStore = VolatileStore.volatileStore;

	fluxStore = FluxStore.fluxStore;

	FluxDbModel = FluxDb.FluxDbModel;

	defineModule(module, VolatileModel = (function(superClass) {
	  extend(VolatileModel, superClass);

	  VolatileModel.queryModel = VolatileQueryModel;

	  function VolatileModel() {
	    VolatileModel.__super__.constructor.apply(this, arguments);
	    this._queriesToUpdate = [
	      (function(_this) {
	        return function(fields) {
	          return _this._updateQuery(_this, "");
	        };
	      })(this)
	    ];
	    volatileStore.init(this.name);
	  }

	  VolatileModel.prototype._storeGet = function(id, callback) {
	    return volatileStore.get(this.name, id, callback);
	  };

	  VolatileModel.prototype._storePut = function(id, fields, callback) {
	    return volatileStore.put(this.name, id, fields, callback);
	  };

	  VolatileModel.prototype._storePost = function(fields, callback) {
	    return volatileStore.post(this.name, fields, callback);
	  };

	  VolatileModel.prototype._updateQueries = function(fields) {
	    return fluxStore.onNextReady((function(_this) {
	      return function() {
	        var f, i, len, ref, results;
	        ref = _this._queriesToUpdate;
	        results = [];
	        for (i = 0, len = ref.length; i < len; i++) {
	          f = ref[i];
	          results.push(f(fields));
	        }
	        return results;
	      };
	    })(this));
	  };

	  VolatileModel.prototype._updateQuery = function(model, id) {
	    if (fluxStore.get(model.name, id)) {
	      return model.load(id);
	    }
	  };

	  return VolatileModel;

	})(FluxDbModel));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, FluxCore, FluxStore, Foundation, VolatileStore, arrayWithOne, clone, defineModule, fluxStore, log, merge, mergeInfo, missing, simulateAsyncRequest, slice, success,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	FluxCore = __webpack_require__(307);

	FluxStore = FluxCore.FluxStore;

	BaseObject = Foundation.BaseObject, mergeInfo = Foundation.mergeInfo, log = Foundation.log, clone = Foundation.clone, slice = Foundation.slice, merge = Foundation.merge, arrayWithOne = Foundation.arrayWithOne, defineModule = Foundation.defineModule, CommunicationStatus = Foundation.CommunicationStatus;

	success = CommunicationStatus.success, missing = CommunicationStatus.missing;

	fluxStore = FluxStore.fluxStore;

	simulateAsyncRequest = function(asyncCallback) {
	  fluxStore.onNextReady(asyncCallback);
	  return null;
	};

	defineModule(module, VolatileStore = (function(superClass) {
	  var getDbKey;

	  extend(VolatileStore, superClass);

	  VolatileStore.singletonClass();

	  function VolatileStore() {
	    VolatileStore.__super__.constructor.apply(this, arguments);
	    this._reset();
	  }

	  VolatileStore.prototype._reset = function() {
	    this._nextId = 0;
	    return this._db = {};
	  };

	  VolatileStore.prototype.init = function(listUri) {
	    return this._list(listUri);
	  };

	  VolatileStore.prototype.get = function(modelPrefix, id, requestStatusCallback) {
	    return simulateAsyncRequest((function(_this) {
	      return function() {
	        var dbKey, res;
	        dbKey = getDbKey(modelPrefix, id);
	        return requestStatusCallback((res = clone(_this._db[dbKey])) ? {
	          status: success,
	          data: res
	        } : {
	          status: missing
	        });
	      };
	    })(this));
	  };

	  VolatileStore.prototype.put = function(modelPrefix, id, fields, requestStatusCallback) {
	    return simulateAsyncRequest((function(_this) {
	      return function() {
	        var dbKey;
	        dbKey = getDbKey(modelPrefix, id);
	        return requestStatusCallback({
	          status: success,
	          data: clone(_this._setSingle(modelPrefix, id, dbKey, merge(_this._db[dbKey], fields)))
	        });
	      };
	    })(this));
	  };

	  VolatileStore.prototype.post = function(modelPrefix, fields, requestStatusCallback) {
	    return simulateAsyncRequest((function(_this) {
	      return function() {
	        var dbKey, id;
	        id = (_this._nextId++).toString();
	        dbKey = getDbKey(modelPrefix, id);
	        return requestStatusCallback({
	          status: success,
	          data: clone(_this._setSingle(modelPrefix, id, dbKey, fields))
	        });
	      };
	    })(this));
	  };

	  VolatileStore._getDbKey = getDbKey = function(modelPrefix, id) {
	    if (id && id.length > 0) {
	      return modelPrefix + "/" + id;
	    } else {
	      return modelPrefix;
	    }
	  };

	  VolatileStore.prototype._setSingle = function(modelPrefix, id, dbKey, fields) {
	    return this._list(modelPrefix)[id] = this._db[dbKey] = merge(fields, {
	      id: id
	    });
	  };

	  VolatileStore.prototype._list = function(modelPrefix) {
	    var base;
	    return (base = this._db)[modelPrefix] || (base[modelPrefix] = {});
	  };

	  return VolatileStore;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var FluxDbQueryModel, Foundation, VolatileQueryModel, defineModule, failure, log, missing, objectWithout, pending, ref, success,
	  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	FluxDbQueryModel = __webpack_require__(323);

	ref = Foundation.CommunicationStatus, success = ref.success, failure = ref.failure, pending = ref.pending, missing = ref.missing, defineModule = ref.defineModule;

	log = Foundation.log, objectWithout = Foundation.objectWithout, defineModule = Foundation.defineModule;

	defineModule(module, VolatileQueryModel = (function(superClass) {
	  extend(VolatileQueryModel, superClass);

	  function VolatileQueryModel() {
	    this._storeGet = bind(this._storeGet, this);
	    return VolatileQueryModel.__super__.constructor.apply(this, arguments);
	  }

	  VolatileQueryModel.abstractClass();

	  VolatileQueryModel.prototype._storeGet = function(queryParam, callback) {
	    return this._singlesModel._storeGet("", (function(_this) {
	      return function(allRequestStatus) {
	        var fields, k;
	        if (allRequestStatus.status !== success) {
	          return callback(objectWithout(allRequestStatus, "fluxKey"));
	        } else {
	          return callback({
	            status: allRequestStatus.status,
	            data: (function() {
	              var ref1, results;
	              ref1 = allRequestStatus.data;
	              results = [];
	              for (k in ref1) {
	                fields = ref1[k];
	                if (fields[this._parameterizedField] === queryParam) {
	                  results.push(fields);
	                }
	              }
	              return results;
	            }).call(_this)
	          });
	        }
	      };
	    })(this), true);
	  };

	  return VolatileQueryModel;

	})(FluxDbQueryModel));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(330);


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(331).includeInNamespace(__webpack_require__(333)).addModules({
	  ArtEryBaseObject: __webpack_require__(336),
	  Config: __webpack_require__(337),
	  Filter: __webpack_require__(338),
	  Pipeline: __webpack_require__(342),
	  PipelineRegistry: __webpack_require__(334),
	  Request: __webpack_require__(339),
	  RequestResponseBase: __webpack_require__(340),
	  Response: __webpack_require__(341),
	  Session: __webpack_require__(335)
	});


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Ery,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Art = __webpack_require__(332);

	module.exports = Art.Ery || Art.addNamespace('Ery', Ery = (function(superClass) {
	  extend(Ery, superClass);

	  function Ery() {
	    return Ery.__super__.constructor.apply(this, arguments);
	  }

	  return Ery;

	})(Neptune.Base));


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	var Art, Neptune,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Neptune = __webpack_require__(4);

	module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
	  extend(Art, superClass);

	  function Art() {
	    return Art.__super__.constructor.apply(this, arguments);
	  }

	  return Art;

	})(Neptune.Base));


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = [
	  {
	    pipelines: (__webpack_require__(334)).pipelines,
	    session: (__webpack_require__(335)).singleton
	  }, __webpack_require__(337)
	];


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, PipelineRegistry, decapitalize, defineModule, inspect, isClass, log, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(19), defineModule = ref.defineModule, log = ref.log, BaseObject = ref.BaseObject, decapitalize = ref.decapitalize, isClass = ref.isClass, inspect = ref.inspect;

	defineModule(module, PipelineRegistry = (function(superClass) {
	  var pipelines;

	  extend(PipelineRegistry, superClass);

	  function PipelineRegistry() {
	    return PipelineRegistry.__super__.constructor.apply(this, arguments);
	  }

	  PipelineRegistry.pipelines = pipelines = {};

	  PipelineRegistry.register = function(PipelineClass) {
	    var _aliases, alias, singleton;
	    singleton = PipelineClass.singleton, _aliases = PipelineClass._aliases;
	    _aliases && (function() {
	      var i, len, results;
	      results = [];
	      for (i = 0, len = _aliases.length; i < len; i++) {
	        alias = _aliases[i];
	        results.push(pipelines[alias] = singleton);
	      }
	      return results;
	    })();
	    return pipelines[singleton.name] = singleton;
	  };

	  PipelineRegistry._reset = function() {
	    var i, k, len, ref1, results;
	    ref1 = Object.keys(pipelines);
	    results = [];
	    for (i = 0, len = ref1.length; i < len; i++) {
	      k = ref1[i];
	      results.push(delete pipelines[k]);
	    }
	    return results;
	  };

	  return PipelineRegistry;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, EventedMixin, Foundation, JsonStore, Session, Validator, inspect, isObject, isString, log, merge, plainObjectsDeepEq,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	EventedMixin = __webpack_require__(168).EventedMixin;

	BaseObject = Foundation.BaseObject, merge = Foundation.merge, inspect = Foundation.inspect, isString = Foundation.isString, isObject = Foundation.isObject, log = Foundation.log, Validator = Foundation.Validator, plainObjectsDeepEq = Foundation.plainObjectsDeepEq, JsonStore = Foundation.JsonStore;

	module.exports = Session = (function(superClass) {
	  var jsonStore, jsonStoreKey;

	  extend(Session, superClass);

	  jsonStore = new JsonStore;

	  jsonStoreKey = "Art.Ery.Session.data";


	  /*
	  A global singleton Session is provided and used by default.
	  Or multiple instances can be created and passed to the
	  constructor of each Pipeline for per-pipeline custom sessions.
	   */

	  Session.singletonClass();

	  Session.property("data signature");

	  function Session(_data) {
	    this._data = _data != null ? _data : {};
	    Session.__super__.constructor.apply(this, arguments);
	    this._signature = "";
	  }

	  Session.prototype.loadSession = function() {
	    return this._sessionLoadPromise = jsonStore.getItem(jsonStoreKey).then((function(_this) {
	      return function(data) {
	        log({
	          jsonStoreItem: {
	            key: jsonStoreKey,
	            data: data
	          }
	        });
	        if (data) {
	          return _this.data = data;
	        }
	      };
	    })(this));
	  };

	  Session.getter("sessionLoadPromise", {
	    inspectedObjects: function() {
	      return this._data;
	    }
	  });

	  Session.setter({
	    data: function(v) {
	      if (!plainObjectsDeepEq(v, this._data)) {
	        this.queueEvent("change", {
	          data: v
	        });
	      }
	      return jsonStore.setItem(jsonStoreKey, this._data = v);
	    }
	  });

	  Session.prototype.reset = function() {
	    return this.data = {};
	  };

	  return Session;

	})(EventedMixin(__webpack_require__(336)));


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryBaseObject, BaseObject, defineModule, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(19), BaseObject = ref.BaseObject, defineModule = ref.defineModule;

	ArtEry = __webpack_require__(331);

	defineModule(module, ArtEryBaseObject = (function(superClass) {
	  extend(ArtEryBaseObject, superClass);

	  function ArtEryBaseObject() {
	    return ArtEryBaseObject.__super__.constructor.apply(this, arguments);
	  }

	  ArtEryBaseObject.abstractClass();

	  ArtEryBaseObject.getter({
	    productionEnvironment: function() {
	      return false;
	    },
	    pipelines: function() {
	      return ArtEry.pipelines;
	    }
	  });

	  return ArtEryBaseObject;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, Config, defineModule, mergeInto, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(19), defineModule = ref.defineModule, mergeInto = ref.mergeInto, BaseObject = ref.BaseObject;

	defineModule(module, Config = (function(superClass) {
	  extend(Config, superClass);

	  function Config() {
	    return Config.__super__.constructor.apply(this, arguments);
	  }

	  Config.classProperty({
	    tableNamePrefix: ""
	  });

	  Config.getPrefixedTableName = function(tableName) {
	    return "" + (this.getTableNamePrefix()) + tableName;
	  };

	  Config.configure = function(config) {
	    if (config == null) {
	      config = {};
	    }
	    return Config.tableNamePrefix = config.tableNamePrefix || Config.getTableNamePrefix();
	  };

	  return Config;

	})(BaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Filter, Foundation, Promise, Request, Response, defineModule, failure, getInspectedObjects, isPlainObject, log, merge, mergeInto, shallowClone, success,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Request = __webpack_require__(339);

	Response = __webpack_require__(341);

	getInspectedObjects = Foundation.getInspectedObjects, defineModule = Foundation.defineModule, BaseObject = Foundation.BaseObject, Promise = Foundation.Promise, log = Foundation.log, isPlainObject = Foundation.isPlainObject, mergeInto = Foundation.mergeInto, merge = Foundation.merge, shallowClone = Foundation.shallowClone, CommunicationStatus = Foundation.CommunicationStatus;

	success = CommunicationStatus.success, failure = CommunicationStatus.failure;

	defineModule(module, Filter = (function(superClass) {
	  extend(Filter, superClass);

	  Filter.filterLocation = "server";

	  Filter.extendableProperty({
	    beforeFilters: {},
	    afterFilters: {},
	    fields: {}
	  });

	  Filter.fields = Filter.extendFields;


	  /*
	  IN: requestType, requestFilter
	  IN: map from requestTypes to requestFilters
	  
	  requestFilter: (request) ->
	    IN: Request instance
	    OUT: return a Promise returning one of the list below OR just return one of the list below:
	      Request instance
	      Response instance
	      anythingElse -> toResponse anythingElse
	  
	    To reject a request:
	    - throw an error
	    - return a rejected promise
	    - or create a Response object with the appropriate fields
	   */

	  Filter.before = function(a, b) {
	    if (a) {
	      return this.extendBeforeFilters(a, b);
	    }
	  };

	  Filter.prototype.before = function(a, b) {
	    if (a) {
	      return this.extendBeforeFilters(a, b);
	    }
	  };


	  /*
	  IN: requestType, responseFilter
	  IN: map from requestTypes to responseFilter
	  
	  responseFilter: (response) ->
	    IN: Response instance
	    OUT: return a Promise returning one of the list below OR just return one of the list below:
	      Response instance
	      anythingElse -> toResponse anythingElse
	  
	    To reject a request:
	    - throw an error
	    - return a rejected promise
	    - or create a Response object with the appropriate fields
	   */

	  Filter.after = function(a, b) {
	    if (a) {
	      return this.extendAfterFilters(a, b);
	    }
	  };

	  Filter.prototype.after = function(a, b) {
	    if (a) {
	      return this.extendAfterFilters(a, b);
	    }
	  };

	  function Filter(options) {
	    if (options == null) {
	      options = {};
	    }
	    Filter.__super__.constructor.apply(this, arguments);
	    this.serverSideOnly = options.serverSideOnly, this.clientSideOnly = options.clientSideOnly, this.name = options.name;
	    this.name || (this.name = this["class"].getName());
	    this.after(options.after);
	    this.before(options.before);
	  }

	  Filter.property("name", {
	    serverSideOnly: false,
	    clientSideOnly: false
	  });

	  Filter.prototype.toString = function() {
	    return this.getName();
	  };

	  Filter.prototype.getBeforeFilter = function(requestType) {
	    return this.beforeFilters[requestType] || this.beforeFilters.all;
	  };

	  Filter.prototype.getAfterFilter = function(requestType) {
	    return this.afterFilters[requestType] || this.afterFilters.all;
	  };

	  Filter.prototype.processBefore = function(request) {
	    return this._processFilter(request, this.getBeforeFilter(request.type));
	  };

	  Filter.prototype.processAfter = function(response) {
	    return this._processFilter(response, this.getAfterFilter(response.type));
	  };


	  /*
	  OUT:
	    promise.then (successful Request or Response instance) ->
	    .catch (failingResponse) ->
	   */

	  Filter.prototype._processFilter = function(responseOrRequest, filterFunction) {
	    return Promise.then((function(_this) {
	      return function() {
	        if (filterFunction) {
	          responseOrRequest.addFilterLog(_this);
	          return filterFunction.call(_this, responseOrRequest);
	        } else {
	          return responseOrRequest;
	        }
	      };
	    })(this)).then((function(_this) {
	      return function(result) {
	        return responseOrRequest.next(result);
	      };
	    })(this))["catch"]((function(_this) {
	      return function(error) {
	        var ref;
	        log.error("Error Applying Filter", {
	          filter: _this,
	          pipeline: (ref = responseOrRequest.pipeline) != null ? ref.name : void 0,
	          responseOrRequest: responseOrRequest,
	          error: error
	        });
	        return responseOrRequest.next(error, failure);
	      };
	    })(this));
	  };

	  return Filter;

	})(__webpack_require__(336)));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	var ArtEry, BaseObject, CommunicationStatus, Foundation, Request, RestClient, Validator, arrayWith, failure, inspect, isObject, isString, log, merge, missing, present, success, validStatus, validator, w,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	present = Foundation.present, BaseObject = Foundation.BaseObject, RestClient = Foundation.RestClient, merge = Foundation.merge, inspect = Foundation.inspect, isString = Foundation.isString, isObject = Foundation.isObject, log = Foundation.log, Validator = Foundation.Validator, CommunicationStatus = Foundation.CommunicationStatus, arrayWith = Foundation.arrayWith, w = Foundation.w;

	ArtEry = __webpack_require__(331);

	success = CommunicationStatus.success, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure, validStatus = CommunicationStatus.validStatus;

	validator = new Validator({
	  type: w("required string"),
	  pipeline: {
	    required: {
	      "instanceof": Neptune.Art.Ery.Pipeline
	    }
	  },
	  session: w("required object"),
	  data: "object",
	  key: "string",
	  originatedOnServer: "boolean"
	});

	module.exports = Request = (function(superClass) {
	  var getRestClientParamsForArtEryRequest, restMap;

	  extend(Request, superClass);

	  function Request(options) {
	    Request.__super__.constructor.apply(this, arguments);
	    validator.preCreateSync(options, {
	      context: "Request options"
	    });
	    this.type = options.type, this.key = options.key, this.pipeline = options.pipeline, this.session = options.session, this.data = options.data, this.originatedOnServer = options.originatedOnServer, this.originatedOnClient = options.originatedOnClient, this.sessionSignature = options.sessionSignature;
	  }

	  Request.property("type key pipeline session data originatedOnServer sessionSignature");

	  Request.prototype.toString = function() {
	    return "ArtEry.Request(" + this.type + " key: " + this.key + ", hasData: " + (!!this.data) + ")";
	  };

	  Request.prototype.requireServerOrigin = function(message) {
	    if (message == null) {
	      message = "(no further explanation)";
	    }
	    if (!this.originatedOnServer) {
	      throw this.failure({
	        data: {
	          message: this.type + "-request: originatedOnServer required " + (message || "")
	        }
	      });
	    }
	    return this;
	  };

	  Request.getter({
	    request: function() {
	      return this;
	    },
	    props: function() {
	      return {
	        pipeline: this.pipeline,
	        type: this.type,
	        key: this.key,
	        session: this.session,
	        data: this.data,
	        filterLog: this.filterLog,
	        originatedOnServer: this.originatedOnServer
	      };
	    },
	    urlKeyClause: function() {
	      if (present(this.key)) {
	        return "/" + this.key;
	      } else {
	        return "";
	      }
	    }
	  });

	  Request.prototype.getRestRequestUrl = function(server) {
	    return server + "/" + this.pipeline.name + this.urlKeyClause;
	  };

	  Request.prototype.getNonRestRequestUrl = function(server) {
	    return server + "/" + this.pipeline.name + "-" + this.type + this.urlKeyClause;
	  };

	  restMap = {
	    get: "get",
	    create: "post",
	    update: "put",
	    "delete": "delete"
	  };

	  Request.getRestClientParamsForArtEryRequest = getRestClientParamsForArtEryRequest = function(arg) {
	    var data, key, method, restPath, server, type, url, urlKeyClause;
	    server = arg.server, restPath = arg.restPath, type = arg.type, key = arg.key, data = arg.data;
	    urlKeyClause = present(key) ? "/" + key : "";
	    server || (server = "");
	    url = (method = restMap[type]) ? "" + server + restPath + urlKeyClause : (method = "post", "" + server + restPath + "-" + type + urlKeyClause);
	    return {
	      method: method,
	      url: url,
	      data: data
	    };
	  };

	  Request.prototype.sendRemoteRequest = function() {
	    var remoteRequestOptions;
	    remoteRequestOptions = getRestClientParamsForArtEryRequest({
	      restPath: this.pipeline.restPath,
	      server: this.pipeline.remoteServer,
	      type: this.type,
	      key: this.key,
	      data: {
	        data: this.data,
	        session: this.session,
	        sessionSignature: this.sessionSignature
	      }
	    });
	    return RestClient.restJsonRequest(remoteRequestOptions)["catch"]((function(_this) {
	      return function(error) {
	        return _this.failure({
	          error: error
	        });
	      };
	    })(this)).then((function(_this) {
	      return function(remoteResponseOptions) {
	        var data, filterLog, session, sessionSignature, status;
	        data = remoteResponseOptions.data, status = remoteResponseOptions.status, filterLog = remoteResponseOptions.filterLog, session = remoteResponseOptions.session, sessionSignature = remoteResponseOptions.sessionSignature;
	        return _this._toResponse(status, {
	          data: data,
	          filterLog: filterLog,
	          session: session,
	          sessionSignature: sessionSignature,
	          remoteRequest: remoteRequestOptions,
	          remoteResponse: remoteResponseOptions
	        });
	      };
	    })(this));
	  };

	  return Request;

	})(__webpack_require__(340));


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryBaseObject, BaseObject, CommunicationStatus, RequestResponseBase, arrayWith, defineModule, failure, inspect, inspectedObjectLiteral, isJsonType, isPlainObject, isString, log, merge, missing, ref, success, toInspectedObjects,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(19), BaseObject = ref.BaseObject, CommunicationStatus = ref.CommunicationStatus, log = ref.log, arrayWith = ref.arrayWith, defineModule = ref.defineModule, merge = ref.merge, isJsonType = ref.isJsonType, isString = ref.isString, isPlainObject = ref.isPlainObject, inspect = ref.inspect, inspectedObjectLiteral = ref.inspectedObjectLiteral, toInspectedObjects = ref.toInspectedObjects;

	ArtEry = __webpack_require__(331);

	ArtEryBaseObject = __webpack_require__(336);

	success = CommunicationStatus.success, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure;

	defineModule(module, RequestResponseBase = (function(superClass) {
	  extend(RequestResponseBase, superClass);

	  function RequestResponseBase(options) {
	    RequestResponseBase.__super__.constructor.apply(this, arguments);
	    this.filterLog = options.filterLog;
	  }

	  RequestResponseBase.property("filterLog");

	  RequestResponseBase.prototype.addFilterLog = function(filter) {
	    return this._filterLog = arrayWith(this._filterLog, filter);
	  };

	  RequestResponseBase.getter({
	    inspectedObjects: function() {
	      var obj;
	      return (
	        obj = {},
	        obj["" + this["class"].namespacePath] = toInspectedObjects(this.props),
	        obj
	      );
	    }
	  });


	  /*
	  IN: data can be a plainObject or a promise returning a plainObject
	  OUT: promise.then (newRequestWithNewData) ->
	   */

	  RequestResponseBase.prototype.withData = function(data) {
	    return Promise.resolve(data).then((function(_this) {
	      return function(resolvedData) {
	        return new _this["class"](merge(_this.props, {
	          data: resolvedData
	        }));
	      };
	    })(this));
	  };


	  /*
	  IN: data can be a plainObject or a promise returning a plainObject
	  OUT: promise.then (newRequestWithNewData) ->
	   */

	  RequestResponseBase.prototype.withMergedData = function(data) {
	    return Promise.resolve(data).then((function(_this) {
	      return function(resolvedData) {
	        return new _this["class"](merge(_this.props, {
	          data: merge(_this.data, resolvedData)
	        }));
	      };
	    })(this));
	  };

	  RequestResponseBase.prototype.next = function(data, status) {
	    if (status == null) {
	      status = success;
	    }
	    return Promise.resolve(data).then((function(_this) {
	      return function(data) {
	        var responseProps;
	        responseProps = !data ? (status = missing, {
	          data: {
	            message: "missing response"
	          }
	        }) : isJsonType(data) ? {
	          data: data
	        } : data;
	        return _this._toResponse(status, responseProps);
	      };
	    })(this));
	  };

	  RequestResponseBase.prototype.success = function(responseProps) {
	    return this._toResponse(success, responseProps);
	  };

	  RequestResponseBase.prototype.missing = function(responseProps) {
	    return this._toResponse(missing, responseProps);
	  };

	  RequestResponseBase.prototype.failure = function(responseProps) {
	    return this._toResponse(failure, responseProps);
	  };


	  /*
	  IN:
	    responseProps: (optionally Promise returning:)
	      an object which is directly passed into the Response constructor
	      OR instanceof RequestResponseBase
	      OR anything else:
	        considered internal error, but it will create a valid, failing Response object
	  OUT:
	    promise.then (response) ->
	    .catch -> # should never happen
	   */

	  RequestResponseBase.prototype._toResponse = function(status, responseProps) {
	    return Promise.resolve(responseProps)["catch"]((function(_this) {
	      return function(e) {
	        status = failure;
	        return e;
	      };
	    })(this)).then((function(_this) {
	      return function(responseProps) {
	        var message, response;
	        if (responseProps == null) {
	          responseProps = {};
	        }
	        if (responseProps instanceof RequestResponseBase) {
	          return responseProps;
	        }
	        if (isString(responseProps)) {
	          responseProps = {
	            message: responseProps
	          };
	        }
	        if (!isPlainObject(responseProps)) {
	          status = failure;
	          message = null;
	          responseProps = {
	            data: {
	              message: responseProps instanceof Error ? (log.error(message = "Internal Error: ArtEry.RequestResponseBase#_toResponse received Error instance", _this, responseProps), message) : log.error("Internal Error: ArtEry.RequestResponseBase#_toResponse expecting responseProps or error", responseProps)
	            }
	          };
	        }
	        response = new ArtEry.Response(merge({
	          request: _this.request,
	          status: status
	        }, responseProps));
	        if (status === success) {
	          return Promise.resolve(response);
	        } else {
	          return Promise.reject(response);
	        }
	      };
	    })(this));
	  };

	  return RequestResponseBase;

	})(ArtEryBaseObject));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	var BaseObject, CommunicationStatus, Foundation, Request, Response, Validator, arrayWith, failure, formattedInspect, inspect, isJsonType, isPlainObject, log, merge, missing, responseValidator, success, w,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Request = __webpack_require__(339);

	BaseObject = Foundation.BaseObject, arrayWith = Foundation.arrayWith, inspect = Foundation.inspect, isPlainObject = Foundation.isPlainObject, log = Foundation.log, CommunicationStatus = Foundation.CommunicationStatus, Validator = Foundation.Validator, merge = Foundation.merge, isJsonType = Foundation.isJsonType, formattedInspect = Foundation.formattedInspect, w = Foundation.w;

	success = CommunicationStatus.success, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure;

	responseValidator = new Validator({
	  request: w("required", {
	    "instanceof": Request
	  }),
	  status: w("required communicationStatus"),
	  data: {
	    validate: function(a) {
	      return a === void 0 || isJsonType(a);
	    }
	  },
	  session: "object"
	});

	module.exports = Response = (function(superClass) {
	  extend(Response, superClass);

	  function Response(options) {
	    var ref;
	    Response.__super__.constructor.apply(this, arguments);
	    responseValidator.preCreateSync(options, {
	      context: "Response options"
	    });
	    this.request = options.request, this.status = options.status, this.data = (ref = options.data) != null ? ref : {}, this.session = options.session, this.sessionSignature = options.sessionSignature, this.error = options.error, this.remoteRequest = options.remoteRequest, this.remoteResponse = options.remoteResponse;
	    this.session || (this.session = this.request.session);
	  }

	  Response.prototype.isResponse = true;

	  Response.prototype.toString = function() {
	    return "ArtEry.Response(" + this.type + ": " + this.status + "): " + this.message;
	  };

	  Response.property("request status data session sessionSignature error remoteResponse remoteRequest");

	  Response.getter({
	    type: function() {
	      return this.request.type;
	    },
	    originatedOnServer: function() {
	      return this.request.originatedOnServer;
	    },
	    beforeFilterLog: function() {
	      return this.request.filterLog;
	    },
	    afterFilterLog: function() {
	      return this.filterLog;
	    },
	    message: function() {
	      var ref;
	      return (ref = this.data) != null ? ref.message : void 0;
	    },
	    isSuccessful: function() {
	      return this._status === success;
	    },
	    notSuccessful: function() {
	      return this._status !== success;
	    },
	    props: function() {
	      return {
	        request: this.request,
	        status: this.status,
	        data: this.data,
	        session: this.session,
	        filterLog: this.filterLog,
	        remoteRequest: this.remoteRequest,
	        remoteResponse: this.remoteResponse
	      };
	    },
	    plainObjectsResponse: function() {
	      var out, ref;
	      out = {
	        status: this.status,
	        data: this.data,
	        session: this.session
	      };
	      if (((ref = this.filterLog) != null ? ref.length : void 0) > 0) {
	        out.filterLog = this.filterLog;
	      }
	      return out;
	    }
	  });

	  return Response;

	})(__webpack_require__(340));


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Config, Filter, Foundation, Pipeline, PipelineRegistry, Promise, Request, Response, Session, Validator, arrayToTruthMap, compactFlatten, decapitalize, defineModule, escapeRegExp, failure, inspect, inspectedObjectLiteral, isClass, isFunction, isPlainArray, isPlainObject, isString, log, lowerCamelCase, merge, mergeInto, missing, newObjectFromEach, normalizeFieldProps, peek, reverseForEach, success,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	Foundation = __webpack_require__(19);

	Response = __webpack_require__(341);

	Request = __webpack_require__(339);

	Filter = __webpack_require__(338);

	Session = __webpack_require__(335);

	Config = __webpack_require__(337);

	PipelineRegistry = __webpack_require__(334);

	newObjectFromEach = Foundation.newObjectFromEach, compactFlatten = Foundation.compactFlatten, BaseObject = Foundation.BaseObject, reverseForEach = Foundation.reverseForEach, Promise = Foundation.Promise, log = Foundation.log, isPlainObject = Foundation.isPlainObject, inspect = Foundation.inspect, isString = Foundation.isString, isClass = Foundation.isClass, isFunction = Foundation.isFunction, inspect = Foundation.inspect, CommunicationStatus = Foundation.CommunicationStatus, merge = Foundation.merge, isPlainArray = Foundation.isPlainArray, decapitalize = Foundation.decapitalize, defineModule = Foundation.defineModule, Validator = Foundation.Validator, mergeInto = Foundation.mergeInto, arrayToTruthMap = Foundation.arrayToTruthMap, lowerCamelCase = Foundation.lowerCamelCase, peek = Foundation.peek, inspectedObjectLiteral = Foundation.inspectedObjectLiteral, escapeRegExp = Foundation.escapeRegExp;

	normalizeFieldProps = Validator.normalizeFieldProps;

	success = CommunicationStatus.success, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure;

	defineModule(module, Pipeline = (function(superClass) {
	  var instantiateFilter, noOptions, preprocessFilter;

	  extend(Pipeline, superClass);

	  Pipeline.register = function() {
	    this.singletonClass();
	    return PipelineRegistry.register(this);
	  };

	  Pipeline.abstractClass();

	  Pipeline.postCreateConcreteClass = function(arg) {
	    var hotReloaded;
	    hotReloaded = arg.hotReloaded;
	    if (!hotReloaded) {
	      this.register();
	    }
	    this._defineQueryHandlers();
	    this._initClientApiRequest();
	    this._initFields();
	    return Pipeline.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
	  };

	  Pipeline.instantiateFilter = instantiateFilter = function(filter) {
	    if (isClass(filter)) {
	      return new filter;
	    } else if (isFunction(filter)) {
	      return filter(this);
	    } else if (filter instanceof Filter) {
	      return filter;
	    } else if (isPlainObject(filter)) {
	      return new Filter(filter);
	    } else {
	      throw "invalid filter: " + (inspect(filter)) + " " + (filter instanceof Filter);
	    }
	  };

	  Pipeline.extendableProperty({
	    queries: {},
	    filters: [],
	    handlers: {},
	    clientApiMethodList: [],
	    fields: {}
	  });

	  Pipeline.getAliases = function() {
	    return this._aliases || {};
	  };


	  /*
	  INPUT: zero or more strings or arrays of strings
	    - arbitrary nesting of arrays is OK
	    - nulls are OK, they are ignored
	  OUTPUT: null
	  
	  NOTE: @aliases can only be called once
	  
	  example:
	    class Post extends Pipeline
	      @aliases "chapterPost"
	  
	  purpose:
	    - used by ArtEryFluxComponent to make model aliases
	      (see FluxModel.aliases)
	   */

	  Pipeline.aliases = function() {
	    this._aliases = newObjectFromEach(arguments, function(map, k, v) {
	      return map[lowerCamelCase(v)] = true;
	    });
	    return this;
	  };

	  preprocessFilter = function(filter) {
	    var f, i, len, results;
	    if (isPlainArray(filter)) {
	      results = [];
	      for (i = 0, len = filter.length; i < len; i++) {
	        f = filter[i];
	        if (f) {
	          results.push(instantiateFilter(f));
	        }
	      }
	      return results;
	    } else {
	      return instantiateFilter(filter);
	    }
	  };

	  Pipeline.query = function(queries) {
	    return this.extendQueries(queries);
	  };

	  Pipeline.handler = function(handlers) {
	    return this.extendHandlers(handlers);
	  };

	  Pipeline.filter = function(filter) {
	    return this.extendFilters(preprocessFilter(filter));
	  };

	  Pipeline.getter({
	    aliases: function() {
	      return Object.keys(this["class"].getAliases());
	    },
	    inspectedObjects: function() {
	      return inspectedObjectLiteral(this.name);
	    },
	    isRemoteClient: function() {
	      return this.remoteServer;
	    },
	    remoteServer: function() {
	      var apiRoot, domain, port, protocol, ref, ret;
	      if (!this.remoteServerInfo) {
	        return;
	      }
	      ref = this.remoteServerInfo, domain = ref.domain, port = ref.port, apiRoot = ref.apiRoot, protocol = ref.protocol;
	      protocol || (protocol = "http");
	      ret = protocol + "://" + domain;
	      if (port) {
	        ret += ":" + port;
	      }
	      return ret;
	    },
	    apiRoot: function() {
	      var r, ref;
	      if (r = (ref = this.remoteServerInfo) != null ? ref.apiRoot : void 0) {
	        return "/" + r;
	      } else {
	        return "";
	      }
	    },
	    restPath: function() {
	      return this._restPath || (this._restPath = this.apiRoot + "/" + this.name);
	    },
	    restPathRegex: function() {
	      return this._restPathRegex || (this._restPathRegex = RegExp("^" + (escapeRegExp(this.restPath)) + "(?:-([a-z0-9_]+))?(?:\\/([-_.a-z0-9]+))?", "i"));
	    }
	  });

	  function Pipeline(_options) {
	    this._options = _options != null ? _options : {};
	    Pipeline.__super__.constructor.apply(this, arguments);
	  }

	  Pipeline.getter("options", {
	    tableName: function() {
	      return Config.getPrefixedTableName(this.name);
	    },
	    normalizedFields: function() {
	      var k, nf, ref, v;
	      nf = {};
	      ref = this.fields;
	      for (k in ref) {
	        v = ref[k];
	        nf[k] = normalizeFieldProps(v);
	      }
	      return nf;
	    }
	  });

	  Pipeline.getter({
	    name: function() {
	      return this._name || (this._name = this._options.name || decapitalize(this["class"].getName()));
	    },
	    session: function() {
	      return this._session || (this._session = this._options.session || Session.singleton);
	    },
	    handlerRequestTypesMap: function(into) {
	      if (into == null) {
	        into = {};
	      }
	      mergeInto(into, this.handlers);
	      return into;
	    },
	    filterRequestTypesMap: function(into) {
	      var filter, i, len, ref;
	      if (into == null) {
	        into = {};
	      }
	      ref = this.filters;
	      for (i = 0, len = ref.length; i < len; i++) {
	        filter = ref[i];
	        mergeInto(into, filter.beforeFilters);
	      }
	      return into;
	    },
	    requestTypesMap: function(into) {
	      if (into == null) {
	        into = {};
	      }
	      return this.getHandlerRequestTypesMap(this.getFilterRequestTypesMap(into));
	    },
	    requestTypes: function() {
	      return Object.keys(this.requestTypesMap);
	    },
	    beforeFilters: function() {
	      return this._beforeFilters || (this._beforeFilters = this.filters.slice().reverse());
	    },
	    afterFilters: function() {
	      return this.filters;
	    }
	  });

	  Pipeline.prototype.getBeforeFiltersFor = function(type) {
	    var filter, i, len, ref, results;
	    ref = this.beforeFilters;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      filter = ref[i];
	      if (filter.getBeforeFilter(type)) {
	        results.push(filter);
	      }
	    }
	    return results;
	  };

	  Pipeline.prototype.getAfterFiltersFor = function(type) {
	    var filter, i, len, ref, results;
	    ref = this.afterFilters;
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      filter = ref[i];
	      if (filter.getAfterFilter(type)) {
	        results.push(filter);
	      }
	    }
	    return results;
	  };


	  /*
	  OVERRIDE
	  OUT: queryModelName:
	    query: (queryKey, pipeline) -> array of plain objects
	   */

	  Pipeline.prototype.getAutoDefinedQueries = function() {
	    return {};
	  };

	  Pipeline.prototype.getPipelineReport = function() {
	    return {
	      tableName: this.tableName,
	      fields: newObjectFromEach(this.fields, function(fieldProps) {
	        return newObjectFromEach(Object.keys(fieldProps).sort(), function(out, index, k) {
	          var v;
	          v = fieldProps[k];
	          if (!(k === "preprocess" || k === "validate" || k === "fieldType")) {
	            return out[k] = v;
	          }
	        });
	      }),
	      requests: newObjectFromEach(this.requestTypes, (function(_this) {
	        return function(type) {
	          var filter;
	          return inspectedObjectLiteral(compactFlatten([
	            (function() {
	              var i, len, ref, results;
	              ref = this.getBeforeFiltersFor(type);
	              results = [];
	              for (i = 0, len = ref.length; i < len; i++) {
	                filter = ref[i];
	                results.push(filter.getName());
	              }
	              return results;
	            }).call(_this), _this.handlers[type] ? "[" + type + "-handler]" : void 0, (function() {
	              var i, len, ref, results;
	              ref = this.getAfterFiltersFor(type);
	              results = [];
	              for (i = 0, len = ref.length; i < len; i++) {
	                filter = ref[i];
	                results.push(filter.getName());
	              }
	              return results;
	            }).call(_this)
	          ]).join(' > '));
	        };
	      })(this))
	    };
	  };

	  Pipeline.prototype.getApiReport = function(options) {
	    var server;
	    if (options == null) {
	      options = {};
	    }
	    server = options.server;
	    return newObjectFromEach(this.requestTypes, (function(_this) {
	      return function(type) {
	        var method, obj, ref, url;
	        ref = Request.getRestClientParamsForArtEryRequest({
	          server: _this.remoteServer || server,
	          type: type,
	          restPath: _this.restPath
	        }), method = ref.method, url = ref.url;
	        return (
	          obj = {},
	          obj["" + (method.toLocaleUpperCase())] = url,
	          obj
	        );
	      };
	    })(this));
	  };


	  /*
	  handlers are merely the "pearl" filter - the action that happens
	   - after all before-filters and
	   - before all after-filters
	  
	  IN: map from request-types to request handlers:
	    (request) -> request OR response OR result which will be converted to a response
	   */

	  Pipeline.handlers = Pipeline.extendHandlers;

	  Pipeline._defineQueryHandlers = function() {
	    var k, ref, results, v;
	    ref = this.getQueries();
	    results = [];
	    for (k in ref) {
	      v = ref[k];
	      results.push(this.extendHandlers(k, (function() {
	        if (isFunction(v)) {
	          return v;
	        } else {
	          v = v.query;
	          if (!isFunction(v)) {
	            throw new Error("query delaration must be a function or have a 'query' property that is a function");
	          }
	          return v;
	        }
	      })()));
	    }
	    return results;
	  };

	  Pipeline.prototype._applyBeforeFilters = function(request) {
	    var applyNextFilter, filterIndex, filters;
	    filters = this.getBeforeFiltersFor(request.type);
	    filterIndex = 0;
	    applyNextFilter = function(partiallyBeforeFilteredRequest) {
	      if (partiallyBeforeFilteredRequest.isResponse || filterIndex >= filters.length) {
	        return Promise.resolve(partiallyBeforeFilteredRequest);
	      } else {
	        return filters[filterIndex++].processBefore(partiallyBeforeFilteredRequest).then(function(result) {
	          return applyNextFilter(result);
	        });
	      }
	    };
	    return applyNextFilter(request);
	  };

	  Pipeline.prototype._applyHandler = function(request) {
	    var handler, message;
	    if (request.isResponse) {
	      return request;
	    }
	    if (this.isRemoteClient && !request.originatedOnClient) {
	      return request.sendRemoteRequest(this.remoteServer);
	    } else if (handler = this.handlers[request.type]) {
	      request.addFilterLog(request.type + "-handler");
	      return request.next(handler.call(this, request));
	    } else {
	      message = "no Handler for request type: " + request.type;
	      log.error(message, {
	        request: request
	      });
	      return request.missing({
	        data: {
	          message: message
	        }
	      });
	    }
	  };

	  Pipeline.prototype._applyAfterFilters = function(response) {
	    var applyNextFilter, filterIndex, filters;
	    filters = this.getAfterFiltersFor(response.type);
	    filterIndex = 0;
	    applyNextFilter = function(partiallyAfterFilteredReponse) {
	      if (partiallyAfterFilteredReponse.notSuccessful || filterIndex >= filters.length) {
	        return Promise.resolve(partiallyAfterFilteredReponse);
	      } else {
	        return filters[filterIndex++].processAfter(partiallyAfterFilteredReponse).then(function(result) {
	          return applyNextFilter(result);
	        });
	      }
	    };
	    return applyNextFilter(response);
	  };

	  Pipeline.prototype._processRequest = function(request) {
	    if (isPlainObject(request)) {
	      request = new Request(merge(request, {
	        pipeline: this
	      }));
	    }
	    return this._applyBeforeFilters(request).then((function(_this) {
	      return function(request) {
	        return _this._applyHandler(request);
	      };
	    })(this)).then((function(_this) {
	      return function(response) {
	        return _this._applyAfterFilters(response);
	      };
	    })(this))["catch"]((function(_this) {
	      return function(error) {
	        log.error({
	          Pipeline_processRequest: {
	            error: error
	          }
	        });
	        return request.next(error);
	      };
	    })(this));
	  };


	  /*
	  options
	    all the Request options are valid here
	    returnResponseObject: true [default: false]
	      if true, the response object is returned, otherwise, just the data field is returned.
	   */

	  noOptions = {};

	  Pipeline.prototype._processClientRequest = function(type, options) {
	    var returnResponseObject;
	    if (options == null) {
	      options = noOptions;
	    }
	    returnResponseObject = options.returnResponseObject;
	    if (isString(options)) {
	      options = {
	        key: options
	      };
	    }
	    return this._processRequest(new Request(merge(options, {
	      type: type,
	      pipeline: this,
	      session: this.session.data,
	      sessionSignature: this.session.signature
	    }))).then((function(_this) {
	      return function(response) {
	        var data, session, sessionSignature, status;
	        status = response.status, data = response.data, session = response.session, sessionSignature = response.sessionSignature;
	        if (status === success) {
	          if (session) {
	            _this.session.data = session;
	            _this.session.signature = sessionSignature;
	          }
	          if (returnResponseObject) {
	            return response;
	          } else {
	            return data;
	          }
	        } else {
	          throw response;
	        }
	      };
	    })(this));
	  };

	  Pipeline._clientApiRequest = function(requestType) {
	    var base;
	    if (indexOf.call(this.getClientApiMethodList(), requestType) < 0) {
	      this.extendClientApiMethodList(requestType);
	    }
	    return (base = this.prototype)[requestType] || (base[requestType] = function(options) {
	      return this._processClientRequest(requestType, options);
	    });
	  };

	  Pipeline._initClientApiRequest = function() {
	    var handler, name, ref, results;
	    ref = this.getHandlers();
	    results = [];
	    for (name in ref) {
	      handler = ref[name];
	      results.push(this._clientApiRequest(name));
	    }
	    return results;
	  };

	  Pipeline._initFields = function() {
	    var filter, i, len, ref, results;
	    ref = this.getFilters();
	    results = [];
	    for (i = 0, len = ref.length; i < len; i++) {
	      filter = ref[i];
	      results.push(this.extendFields(filter.fields));
	    }
	    return results;
	  };

	  return Pipeline;

	})(__webpack_require__(336)));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(344);


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(345).addModules({
	  ArtEryFluxModel: __webpack_require__(346),
	  ArtEryQueryFluxModel: __webpack_require__(347)
	});


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	var Ery, Flux,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Ery = __webpack_require__(331);

	module.exports = Ery.Flux || Ery.addNamespace('Flux', Flux = (function(superClass) {
	  extend(Flux, superClass);

	  function Flux() {
	    return Flux.__super__.constructor.apply(this, arguments);
	  }

	  return Flux;

	})(Neptune.Base));


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryFluxModel, ArtEryQueryFluxModel, CommunicationStatus, Flux, FluxModel, Foundation, Promise, arrayWith, arrayWithElementReplaced, createWithPostCreate, decapitalize, defineModule, eq, failure, fastBind, formattedInspect, inspect, isFunction, isString, log, merge, missing, models, pending, select, success, upperCamelCase,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Flux = Neptune.Art.Flux;

	if (!Flux) {
	  throw new Error("Neptune.Art.Flux not loaded. Please pre-require Flux or Flux/web_worker.");
	}

	ArtEry = __webpack_require__(329);

	ArtEryQueryFluxModel = __webpack_require__(347);

	log = Foundation.log, CommunicationStatus = Foundation.CommunicationStatus, select = Foundation.select, isString = Foundation.isString, isFunction = Foundation.isFunction, fastBind = Foundation.fastBind, decapitalize = Foundation.decapitalize, merge = Foundation.merge, Promise = Foundation.Promise, eq = Foundation.eq, upperCamelCase = Foundation.upperCamelCase, arrayWith = Foundation.arrayWith, arrayWithElementReplaced = Foundation.arrayWithElementReplaced, formattedInspect = Foundation.formattedInspect, defineModule = Foundation.defineModule, createWithPostCreate = Foundation.createWithPostCreate, inspect = Foundation.inspect;

	missing = CommunicationStatus.missing, failure = CommunicationStatus.failure, success = CommunicationStatus.success, pending = CommunicationStatus.pending;

	FluxModel = Flux.FluxModel, models = Flux.models;

	defineModule(module, ArtEryFluxModel = (function(superClass) {
	  var createModel;

	  extend(ArtEryFluxModel, superClass);

	  ArtEryFluxModel.abstractClass();

	  createModel = function(name, pipeline, aliases) {
	    var AnonymouseArtErtFluxModel, klass;
	    klass = createWithPostCreate(AnonymouseArtErtFluxModel = (function(superClass1) {
	      extend(AnonymouseArtErtFluxModel, superClass1);

	      function AnonymouseArtErtFluxModel() {
	        return AnonymouseArtErtFluxModel.__super__.constructor.apply(this, arguments);
	      }

	      AnonymouseArtErtFluxModel._name = upperCamelCase(name);

	      AnonymouseArtErtFluxModel.pipeline(pipeline);

	      if (aliases) {
	        AnonymouseArtErtFluxModel.aliases(aliases);
	      }

	      return AnonymouseArtErtFluxModel;

	    })(ArtEryFluxModel));
	    return klass.singleton;
	  };

	  ArtEryFluxModel.defineModelsForAllPipelines = function() {
	    var aliases, name, pipeline, ref, results;
	    ref = ArtEry.pipelines;
	    results = [];
	    for (name in ref) {
	      pipeline = ref[name];
	      if (aliases = pipeline.aliases) {
	        name = pipeline.getName();
	        if (!models[name]) {
	          results.push(createModel(name, pipeline, aliases));
	        } else {
	          results.push(void 0);
	        }
	      } else {
	        results.push(createModel(name, pipeline));
	      }
	    }
	    return results;
	  };

	  ArtEryFluxModel.pipeline = function(_pipeline1) {
	    this._pipeline = _pipeline1;
	    return this._pipeline;
	  };

	  function ArtEryFluxModel() {
	    ArtEryFluxModel.__super__.constructor.apply(this, arguments);
	    this._updateSerializers = {};
	    this._pipeline = this["class"]._pipeline;
	    this._queryModels = {};
	    this.queries(this._pipeline.queries);
	    this._bindPipelineMethods();
	  }

	  ArtEryFluxModel.prototype._bindPipelineMethods = function() {
	    var abstractPrototype, k, ref, results, v;
	    abstractPrototype = this._pipeline["class"].getAbstractPrototype();
	    ref = this._pipeline;
	    results = [];
	    for (k in ref) {
	      v = ref[k];
	      if (!this[k] && !abstractPrototype[k] && isFunction(v)) {
	        results.push(this[k] = fastBind(v, this));
	      }
	    }
	    return results;
	  };

	  ArtEryFluxModel.prototype.keyFromData = function(data) {
	    var base, ret;
	    ret = (typeof (base = this._pipeline).keyFromData === "function" ? base.keyFromData(data) : void 0) || data.id;
	    if (!ret) {
	      throw new Error("keyFromData: failed to generate a key from: @_pipeline.keyFromData?(data) || data.id)");
	    }
	    return ret;
	  };

	  ArtEryFluxModel.prototype.keysEqual = function(a, b) {
	    return eq(this.keyFromData(a), this.keyFromData(b));
	  };


	  /*
	  TODO:
	  queries need to go through an ArtEry pipeline.
	  queries should be invoked with that ArtEry pipeline as @
	  every record returned should get sent through the after-pipeline
	  as-if it were a "get" request
	   */

	  ArtEryFluxModel.prototype.queries = function(map, ignoreAlreadyDefinedWarning) {
	    var modelName, options, results;
	    results = [];
	    for (modelName in map) {
	      options = map[modelName];
	      results.push(this.defineQuery(modelName, options, ignoreAlreadyDefinedWarning));
	    }
	    return results;
	  };

	  ArtEryFluxModel.prototype.defineQuery = function(modelName, options, ignoreAlreadyDefinedWarning) {
	    var ArtEryQueryFluxModelChild, _pipeline, recordsModel;
	    if (this._queryModels[modelName]) {
	      if (!ignoreAlreadyDefinedWarning) {
	        console.warn("query already defined! " + (this.getName()) + ": " + modelName);
	      }
	      return;
	    }
	    _pipeline = this._pipeline;
	    recordsModel = this;
	    if (isFunction(options)) {
	      options = {
	        query: options
	      };
	    }
	    if (!isFunction(options.query)) {
	      throw new Error("query required");
	    }
	    return this._queryModels[modelName] = new (ArtEryQueryFluxModelChild = (function(superClass1) {
	      var k, v;

	      extend(ArtEryQueryFluxModelChild, superClass1);

	      function ArtEryQueryFluxModelChild() {
	        return ArtEryQueryFluxModelChild.__super__.constructor.apply(this, arguments);
	      }

	      ArtEryQueryFluxModelChild._name = upperCamelCase(modelName);

	      for (k in options) {
	        v = options[k];
	        ArtEryQueryFluxModelChild.prototype[k] = v;
	      }

	      ArtEryQueryFluxModelChild.prototype._pipeline = _pipeline;

	      ArtEryQueryFluxModelChild.prototype._recordsModel = recordsModel;

	      ArtEryQueryFluxModelChild.prototype.query = function(key) {
	        return this._pipeline[modelName]({
	          key: key
	        });
	      };

	      return ArtEryQueryFluxModelChild;

	    })(ArtEryQueryFluxModel));
	  };


	  /*
	  IN: key: string
	  OUT:
	    promise.then (data) ->
	    promise.catch (response with .status and .error) ->
	   */

	  ArtEryFluxModel.prototype.load = function(key) {
	    if (!isString(key)) {
	      throw new Error("invalid key: " + (inspect(key)));
	    }
	    this._getUpdateSerializer(key).updateFluxStore((function(_this) {
	      return function() {
	        return _this._pipeline.get({
	          key: key
	        });
	      };
	    })(this));
	    return false;
	  };

	  ArtEryFluxModel.prototype.create = function(data) {
	    return this._pipeline.create({
	      data: data
	    }).then((function(_this) {
	      return function(data) {
	        _this.updateFluxStore(_this.keyFromData(data), {
	          status: success,
	          data: data
	        });
	        return data;
	      };
	    })(this));
	  };


	  /*
	  Purpose:
	    Allows multiple in-flight updates to update the flux-store with every success or failure
	    to the current-best-known state of the remote record.
	  Usage:
	    updateSerializer = @_getUpdateSerializer key
	    updateSerializer.updateFluxStore (accumulatedSuccessfulUpdatesToData) =>
	      return updated data
	    Effects:
	      - after the returned, updated data is resolved, @updateFluxStore is called
	      - calls to updateFluxStore are serialized:
	        - each is executed and fluxStore is updated before the next
	  
	  Internal Notes:
	    - auto vivifies
	    When allDone:
	    - removed from @_updateSerializers
	   */

	  ArtEryFluxModel.prototype._getUpdateSerializer = function(key) {
	    var updateSerializer;
	    if (!(updateSerializer = this._updateSerializers[key])) {
	      updateSerializer = new Promise.Serializer;
	      updateSerializer.then((function(_this) {
	        return function() {
	          var ref;
	          return (ref = _this.fluxStoreGet(key)) != null ? ref.data : void 0;
	        };
	      })(this));
	      updateSerializer.updateFluxStore = (function(_this) {
	        return function(updateFunction) {
	          updateSerializer.then(function(data) {
	            return Promise.then(function() {
	              return updateFunction(data);
	            }).then(function(data) {
	              return {
	                status: success,
	                data: data
	              };
	            })["catch"](function(e) {
	              if (data) {
	                return {
	                  status: success,
	                  data: data
	                };
	              } else {
	                return {
	                  status: e.status
	                };
	              }
	            }).then(function(fluxRecord) {
	              _this.updateFluxStore(key, fluxRecord);
	              return data;
	            });
	          });
	          return updateSerializer;
	        };
	      })(this);
	    }
	    updateSerializer.allDonePromise().then((function(_this) {
	      return function(accumulatedSuccessfulUpdatesToData) {
	        return delete _this._updateSerializers[key];
	      };
	    })(this));
	    return updateSerializer;
	  };

	  ArtEryFluxModel.prototype._updateQueries = function(updatedRecord) {
	    var modelName, queryModel, ref;
	    ref = this._queryModels;
	    for (modelName in ref) {
	      queryModel = ref[modelName];
	      queryModel.localUpdate(updatedRecord);
	    }
	    return null;
	  };

	  ArtEryFluxModel.prototype.fluxStoreEntryUpdated = function(arg) {
	    var dataChanged, fluxRecord, key, previousFluxRecord;
	    key = arg.key, fluxRecord = arg.fluxRecord, previousFluxRecord = arg.previousFluxRecord, dataChanged = arg.dataChanged;
	    if (dataChanged && fluxRecord.status === success) {
	      return this._updateQueries(fluxRecord.data);
	    }
	  };

	  ArtEryFluxModel.prototype._optimisticallyUpdateFluxStore = function(key, fieldsToUpdate) {
	    return this.updateFluxStore(key, (function(_this) {
	      return function(oldFluxRecord) {
	        return merge(oldFluxRecord, {
	          data: merge(oldFluxRecord != null ? oldFluxRecord.data : void 0, fieldsToUpdate)
	        });
	      };
	    })(this));
	  };

	  ArtEryFluxModel.prototype.update = function(key, updatedFields) {
	    if (!isString(key)) {
	      throw new Error("invalid key: " + (inspect(key)));
	    }

	    /*
	    creating a Promise here because we have two promise paths
	    path 1: the caller of this update wants to know when this specific update
	      succeeds or fails.
	    path 2: the updateSerializer must continue whether or not
	     */
	    return new Promise((function(_this) {
	      return function(resolve, reject) {
	        return _this._getUpdateSerializer(key).updateFluxStore(function(accumulatedSuccessfulUpdatesToData) {

	          /*
	          NOTE if this update fails:
	          
	            The FluxStore record gets rolled back to the version just before this
	            update was called. All pending updates after this one will be 'lost'
	            in the fluxStore UNTIL, and if, those pending updates succeed. As they
	            succeed, the fluxStore will be updated.
	          
	            So, technically, it isn't the MOST accurate representation if a
	            previous update failed, but it will be resolved to the most accurate
	            representation once all updates have completed or failed.
	           */
	          var ret;
	          ret = _this._pipeline.update({
	            key: key,
	            data: updatedFields
	          }).then(function() {
	            return merge(accumulatedSuccessfulUpdatesToData, updatedFields);
	          });
	          ret.then(resolve, reject);
	          return ret;

	          /*
	          NOTE: this could be done more cleanly with tapThen (see Art.Foundation.Promise)
	          
	          @_pipeline.update key, updatedFields
	          .then -> merge accumulatedSuccessfulUpdatesToData, updatedFields
	          .tapThen resolve, reject
	           */
	        });
	      };
	    })(this));
	  };

	  return ArtEryFluxModel;

	})(FluxModel));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryQueryFluxModel, CommunicationStatus, Flux, FluxModel, Foundation, Promise, arrayWith, arrayWithElementReplaced, decapitalize, defineModule, eq, failure, formattedInspect, isFunction, isString, log, merge, missing, pending, propsEq, select, success, upperCamelCase,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	Flux = Neptune.Art.Flux;

	ArtEry = __webpack_require__(329);

	log = Foundation.log, CommunicationStatus = Foundation.CommunicationStatus, select = Foundation.select, isString = Foundation.isString, isFunction = Foundation.isFunction, decapitalize = Foundation.decapitalize, merge = Foundation.merge, Promise = Foundation.Promise, eq = Foundation.eq, upperCamelCase = Foundation.upperCamelCase, arrayWith = Foundation.arrayWith, arrayWithElementReplaced = Foundation.arrayWithElementReplaced, formattedInspect = Foundation.formattedInspect, propsEq = Foundation.propsEq, defineModule = Foundation.defineModule;

	missing = CommunicationStatus.missing, failure = CommunicationStatus.failure, success = CommunicationStatus.success, pending = CommunicationStatus.pending;

	FluxModel = Flux.FluxModel;

	defineModule(module, ArtEryQueryFluxModel = (function(superClass) {
	  extend(ArtEryQueryFluxModel, superClass);

	  ArtEryQueryFluxModel.abstractClass();


	  /*
	  This class is designed to be extended with overrides:
	   */

	  function ArtEryQueryFluxModel() {
	    ArtEryQueryFluxModel.__super__.constructor.call(this, null);
	    this.register();
	  }

	  ArtEryQueryFluxModel.prototype.loadData = function(key) {
	    return Promise.resolve(this.query(key, this.pipeline)).then((function(_this) {
	      return function(data) {
	        return _this.localSort(data);
	      };
	    })(this));
	  };

	  ArtEryQueryFluxModel.setter("recordsModel pipeline");

	  ArtEryQueryFluxModel.getter("recordsModel pipeline");


	  /*
	  OVERRIDE
	  IN: will be the key (returned from fromFluxKey)
	  OUT: array of singleModel records
	    OR promise.then (arrayOfRecords) ->
	  TODO:
	    In the future we may wish to return other things beyond the array of records.
	    Example:
	      DynamoDb returns data for "getting the next page of records" in addition to the records.
	      DynamoDb also returns other interesting stats about the query.
	  
	    If an array is returned, it will always be records. However, if an object is
	    returned, then one of the fields will be records - and will go through the return
	    pipeline, but the rest will be left untouched and placed in the FluxRecord's data field.
	    Or should they be put in an auxiliary field???
	   */

	  ArtEryQueryFluxModel.prototype.query = function(key) {
	    return [];
	  };


	  /*
	  OVERRIDE
	  IN: single record
	  OUT: string key for the query results that should contain this record
	   */

	  ArtEryQueryFluxModel.prototype.queryKeyFromRecord = function(record) {
	    return "";
	  };


	  /*
	  OVERRIDE
	  override for to sort records when updating local query data in response to local record changes
	   */

	  ArtEryQueryFluxModel.prototype.localSort = function(queryData) {
	    return queryData;
	  };


	  /*
	  OVERRIDE
	  override for custom merge
	  This implementation is a streight-up merge using @recordsModel.keysEqual
	  
	  IN:
	    previousQueryData: array of records or null
	    updatedRecordData: single record or null
	  OUT: return preciousQueryData if nothing changed, else return a new array
	   */

	  ArtEryQueryFluxModel.prototype.localMerge = function(previousQueryData, updatedRecordData) {
	    var currentRecordData, i, j, len;
	    if (!updatedRecordData) {
	      return previousQueryData;
	    }
	    if (!((previousQueryData != null ? previousQueryData.length : void 0) > 0)) {
	      return [updatedRecordData];
	    }
	    for (i = j = 0, len = previousQueryData.length; j < len; i = ++j) {
	      currentRecordData = previousQueryData[i];
	      if (this.recordsModel.keysEqual(currentRecordData, updatedRecordData)) {
	        if (propsEq(currentRecordData, updatedRecordData)) {
	          return null;
	        }
	        return arrayWithElementReplaced(previousQueryData, updatedRecordData, i);
	      }
	    }
	    return arrayWith(previousQueryData, updatedRecordData);
	  };


	  /*
	  OVERRIDE
	  localUpdate gets called whenever whenever a fluxStore entry is created or updated for the recordsModel.
	  
	  Can override for custom behavior!
	  
	  This implementation assumes there is only one possible query any particular record will belong to,
	  and it assumes the queryKey can be computed via @queryKeyFromRecord.
	  
	  NOTE: @queryKeyFromRecord must be implemented!
	   */

	  ArtEryQueryFluxModel.prototype.localUpdate = function(updatedRecordData) {
	    var fluxRecord, mergeResult, queryKey;
	    if (!updatedRecordData) {
	      return;
	    }
	    queryKey = typeof this.queryKeyFromRecord === "function" ? this.queryKeyFromRecord(updatedRecordData) : void 0;
	    if (!isString(queryKey)) {
	      throw new Error("invalid queryKey from " + (formattedInspect(updatedRecordData)));
	    }
	    if (!(fluxRecord = this.fluxStoreGet(queryKey))) {
	      return;
	    }
	    if (mergeResult = this.localMerge(fluxRecord.data, updatedRecordData)) {
	      return this.updateFluxStore(queryKey, {
	        data: this.localSort(mergeResult)
	      });
	    }
	  };

	  return ArtEryQueryFluxModel;

	})(FluxModel));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(349).addModules({
	  Selected: __webpack_require__(350)
	});


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var App, Models,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	App = __webpack_require__(115);

	module.exports = App.Models || App.addNamespace('Models', Models = (function(superClass) {
	  extend(Models, superClass);

	  function Models() {
	    return Models.__super__.constructor.apply(this, arguments);
	  }

	  return Models;

	})(Neptune.Base));


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var A, ApplicationState, Selected, arrayWith, compactFlatten, defineModule, log, merge, newObjectFromEach, ref, sendEmail, timeout,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(120), log = ref.log, defineModule = ref.defineModule, arrayWith = ref.arrayWith, ApplicationState = ref.ApplicationState, compactFlatten = ref.compactFlatten, newObjectFromEach = ref.newObjectFromEach, merge = ref.merge, timeout = ref.timeout;

	A = __webpack_require__(19).Browser.DomElementFactories.A;

	sendEmail = function(arg) {
	  var address, body, link, params, subject;
	  address = arg.address, subject = arg.subject, body = arg.body;
	  link = "mailto:" + (address || "");
	  params = compactFlatten([subject && ("subject=" + (encodeURIComponent(subject))), body && ("body=" + (encodeURIComponent(body)))]);
	  if (params.length > 0) {
	    link += "?" + (params.join('&'));
	  }
	  return A({
	    href: link,
	    target: "black"
	  }).click();
	};

	defineModule(module, Selected = (function(superClass) {
	  extend(Selected, superClass);

	  function Selected() {
	    return Selected.__super__.constructor.apply(this, arguments);
	  }

	  Selected.persistant();

	  Selected.prototype.toggle = function(key) {
	    var obj;
	    return this.replaceState(log(this.state[key] ? newObjectFromEach(this.state, function(out, k, v) {
	      if (v && k !== key) {
	        return out[k] = true;
	      }
	    }) : merge((
	      obj = {},
	      obj["" + key] = true,
	      obj
	    ), this.state)));
	  };

	  Selected.prototype.email = function() {
	    return sendEmail({
	      subject: "Needs and Emotions",
	      body: Object.keys(this.savableState).sort().join('\n')
	    });
	  };

	  return Selected;

	})(ApplicationState));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(352).addModules({
	  App: __webpack_require__(353),
	  Button: __webpack_require__(363),
	  CategoryButton: __webpack_require__(358),
	  LeafButton: __webpack_require__(364),
	  ShowMap: __webpack_require__(354)
	});


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	var App, Components,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	App = __webpack_require__(115);

	module.exports = App.Components || App.addNamespace('Components', Components = (function(superClass) {
	  extend(Components, superClass);

	  function Components() {
	    return Components.__super__.constructor.apply(this, arguments);
	  }

	  return Components;

	})(Neptune.Base));


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var App, CanvasElement, Component, Element, FluxComponent, Foundation, Namespace, Nvc, PagingScrollElement, React, RectangleElement, ShowMap, TextElement, defineModule, inspect, log, merge, ref, textStyle, version, w,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	React = __webpack_require__(281);

	Namespace = __webpack_require__(352);

	ShowMap = __webpack_require__(354);

	Nvc = __webpack_require__(355).Nvc;

	version = __webpack_require__(113).version;

	ref = __webpack_require__(120), w = ref.w, log = ref.log, inspect = ref.inspect, defineModule = ref.defineModule, merge = ref.merge, CanvasElement = ref.CanvasElement, RectangleElement = ref.RectangleElement, PagingScrollElement = ref.PagingScrollElement, TextElement = ref.TextElement, Element = ref.Element, Component = ref.Component, FluxComponent = ref.FluxComponent;

	textStyle = Neptune.Nvc.App.Styles.StyleProps.textStyle;

	defineModule(module, App = (function(superClass) {
	  extend(App, superClass);

	  function App() {
	    return App.__super__.constructor.apply(this, arguments);
	  }

	  App.subscriptions("selected.selected");

	  App.stateFields({
	    canvasSize: null,
	    initialContentSize: null
	  });

	  App.prototype.ready = function(arg) {
	    var target;
	    target = arg.target;
	    return this.canvasSize = target.currentSize;
	  };

	  App.prototype.initialContentReady = function(arg) {
	    var target;
	    target = arg.target;
	    return this.initialContentSize || (this.initialContentSize = target.currentSize);
	  };

	  App.prototype.render = function() {
	    var canvasSize, initialContentSize, name, ref1, selected, selectedNames;
	    ref1 = this.state, canvasSize = ref1.canvasSize, initialContentSize = ref1.initialContentSize;
	    selectedNames = (function() {
	      var ref2, results;
	      ref2 = this.selected || {};
	      results = [];
	      for (name in ref2) {
	        selected = ref2[name];
	        if (selected) {
	          results.push(name);
	        }
	      }
	      return results;
	    }).call(this);
	    return CanvasElement({
	      canvasId: "artCanvas",
	      childrenLayout: "column"
	    }, RectangleElement({
	      inFlow: false,
	      color: "#f9f9f9"
	    }), PagingScrollElement({
	      startAtEnd: true
	    }, Element({
	      size: {
	        ww: 1,
	        hch: 1
	      },
	      padding: 5,
	      childrenLayout: "column"
	    }, TextElement({
	      size: {
	        ww: 1,
	        hch: 1
	      },
	      align: "center",
	      fontFamily: "arial",
	      color: "#0004",
	      padding: 10,
	      text: "Needs and Emotions v" + version + " by Shane Brinkman-Davis Delamore"
	    }), ShowMap({
	      path: [],
	      map: merge(Nvc.core, (selectedNames.length > 0) && {
	        selected: selectedNames
	      })
	    }))));
	  };

	  return App;

	})(FluxComponent));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Atomic, Button, CanvasElement, CategoryButton, Component, Element, FillElement, FluxComponent, Foundation, LeafButton, Nvc, OutlineElement, React, RectangleElement, StyleProps, TextElement, arrayWith, capitalize, createComponentFactory, createFluxComponentFactory, createWithPostCreate, defineModule, eq, inspect, isPlainObject, log, peek, point, ref, textStyle,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	React = __webpack_require__(281);

	Atomic = __webpack_require__(125);

	Nvc = __webpack_require__(355).Nvc;

	ref = __webpack_require__(302), createFluxComponentFactory = ref.createFluxComponentFactory, FluxComponent = ref.FluxComponent;

	point = Atomic.point;

	arrayWith = Foundation.arrayWith, defineModule = Foundation.defineModule, log = Foundation.log, inspect = Foundation.inspect, isPlainObject = Foundation.isPlainObject, capitalize = Foundation.capitalize, peek = Foundation.peek, arrayWith = Foundation.arrayWith, eq = Foundation.eq, createWithPostCreate = Foundation.createWithPostCreate;

	createComponentFactory = React.createComponentFactory, Component = React.Component, Element = React.Element, CanvasElement = React.CanvasElement, RectangleElement = React.RectangleElement, TextElement = React.TextElement, OutlineElement = React.OutlineElement, FillElement = React.FillElement;

	CategoryButton = __webpack_require__(358);

	LeafButton = __webpack_require__(364);

	Button = __webpack_require__(363);

	StyleProps = Neptune.Nvc.App.Styles.StyleProps;

	textStyle = StyleProps.textStyle;

	Nvc = __webpack_require__(355).Nvc;

	defineModule(module, function() {
	  var SubMap, SubMapFactory;
	  return SubMapFactory = createWithPostCreate(SubMap = (function(superClass) {
	    extend(SubMap, superClass);

	    function SubMap() {
	      return SubMap.__super__.constructor.apply(this, arguments);
	    }

	    SubMap.stateFields({
	      subKey: null
	    });

	    SubMap.prototype.drillIn = function(subKey1) {
	      this.subKey = subKey1;
	    };

	    SubMap.prototype.render = function() {
	      var axisTypes, k, key, map, name, path, ref1, subKey, subMap, v;
	      ref1 = this.props, map = ref1.map, key = ref1.key, path = ref1.path;
	      subKey = this.subKey;
	      subMap = map[subKey];
	      axisTypes = {
	        left: point(1, 0),
	        right: point(-1, 0)
	      };
	      return Element({
	        size: {
	          ww: 1,
	          hch: 1
	        },
	        clip: true,
	        childrenLayout: "column",
	        animators: {
	          size: {
	            voidValue: {
	              ww: 1,
	              h: 0
	            }
	          }
	        }
	      }, Element({
	        size: {
	          ww: 1,
	          hch: 1
	        },
	        cacheDraw: true,
	        childrenLayout: "column",
	        margin: 10
	      }, path.length >= 1 && RectangleElement({
	        color: "#0001",
	        margin: 10,
	        size: {
	          ww: 1,
	          h: 2
	        }
	      }), Element({
	        size: {
	          ww: 1,
	          hch: 1
	        },
	        childrenAlignment: "bottomCenter",
	        childrenLayout: "flow"
	      }, (function() {
	        var i, len, ref2, results;
	        if (isPlainObject(map)) {
	          ref2 = Object.keys(map).sort();
	          results = [];
	          for (i = 0, len = ref2.length; i < len; i++) {
	            k = ref2[i];
	            v = map[k];
	            results.push(CategoryButton({
	              key: k,
	              category: k,
	              subMap: v,
	              selected: k === subKey,
	              drillIn: this.drillIn
	            }));
	          }
	          return results;
	        } else {
	          log({
	            key: key
	          });
	          return [
	            key.match(/selected/) ? Element({
	              size: {
	                ww: 1,
	                hch: 1
	              },
	              childrenLayout: "row",
	              childrenAlignment: "center"
	            }, Button({
	              text: "email list",
	              action: this.models.selected.email,
	              size: {
	                ww: 1,
	                hch: 1
	              }
	            })) : void 0, (function() {
	              var j, len1, ref3, results1;
	              ref3 = map.sort();
	              results1 = [];
	              for (j = 0, len1 = ref3.length; j < len1; j++) {
	                name = ref3[j];
	                results1.push(LeafButton({
	                  key: name,
	                  name: name,
	                  parentName: key,
	                  path: path
	                }));
	              }
	              return results1;
	            })()
	          ];
	        }
	      }).call(this))), subMap && SubMapFactory({
	        key: "subMap:" + subKey,
	        map: subMap,
	        path: arrayWith(path, subKey)
	      }));
	    };

	    return SubMap;

	  })(FluxComponent));
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(356).addModules({
	  Nvc: __webpack_require__(357)
	});


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var App, Data,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	App = __webpack_require__(115);

	module.exports = App.Data || App.addNamespace('Data', Data = (function(superClass) {
	  extend(Data, superClass);

	  function Data() {
	    return Data.__super__.constructor.apply(this, arguments);
	  }

	  return Data;

	})(Neptune.Base));


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Foundation, HotStyleProps, Nvc, arrayToFalseMap, deepMap, defineModule, log, sbdNeedsList, splitOnLines, wordsArray,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	Foundation = __webpack_require__(19);

	HotStyleProps = __webpack_require__(281).HotStyleProps;

	defineModule = Foundation.defineModule, log = Foundation.log, arrayToFalseMap = Foundation.arrayToFalseMap, wordsArray = Foundation.wordsArray, deepMap = Foundation.deepMap;

	splitOnLines = function(str) {
	  return str.split("\n");
	};


	/*
	 unsorted needs:

	   quality
	   mourning
	 */

	sbdNeedsList = {
	  surviving: {
	    body: {
	      sustanence: "air, food, water",
	      health: "wellbeing, wellness, healing, regeneration, rejuvenation",
	      energy: "rest, restoration, sleep, vitality"
	    },
	    environment: "temperature, humidity, atmosphere, clothing, shelter",
	    "physical-safety": "violence, accidents, illness, disasters",
	    security: "stability predictability sustainability",
	    procreation: "sexual-release children"
	  },
	  thriving: {
	    pleasure: {
	      senses: "sight-beauty smell-fragrance touch-texture sound-music taste-food-drink",
	      body: "eroticisim, exercise, fitness, movement, dance, sex",
	      variety: "newness, novelty",
	      comfort: "quiet, space, sanctuary, ergonomics, leisure, time"
	    },
	    play: "adventure, excitement, fantasy, fun, humor, joy, laughter",
	    social: {
	      bonding: {
	        sharing: "experiences, interests, values",
	        physical: "embracing touch hug sexual-connection",
	        closeness: "openness communication, communion, companionship, friendship, intimacy, free-to-be-oneself",
	        mutuality: "partnership, balance"
	      },
	      community: {
	        belonging: "accepted, acknowledged, included, equal",
	        participation: "collaboration, cooperation, service, sharing",
	        appriciation: "valued, recognized, wanted"
	      },
	      reciprocity: {
	        nurturing: "care, feedback, help, kindness, support, affection",
	        understanding: "listening, empathy, knowing, seeing, respect",
	        compassion: "attention, consideration, forgiveness, presence, respect, tenderness, vulnerability, love"
	      },
	      "social-safety": "consistency, honesty, justice, reassurance, trust privacy"
	    }
	  },
	  transcending: {
	    "self-acceptance": "allowing, approval, empathy, love, compassion, caring honesty, trust",
	    "self-awareness": "consciousness, discovery, knowledge",
	    "self-growth": "evolution, integration, development, improvement",
	    "self-expression": "creativity, creation, imagination, invention, innovation, actualization, realization",
	    "self-respect": "responsiblity, authenticity, courageousness, dignity, honorablity, honesty, integrity, worthiness",
	    autonomy: "challenge, choice, empowerment, enablement, flexibility, freedom, intention, liberty, limitless, possibility, potential, responsibility",
	    engagement: "flow, gratitude, practice, mindfulness",
	    mastery: "competent, effective, efficient, skillfull, masterful, improving",
	    meaning: "perspective, learning, awareness, celebration, depth, discovery, exploration, legacy, spirituality",
	    peace: "ease, balance, clarity, faith, grace, harmony, hope, order, structure, tranquility, beauty, unity, oneness",
	    purpose: "contribution, dedication, dreams, enrichment, impact, importance, inspiration, to-matter, passion, significance, vision"
	  }
	};

	defineModule(module, Nvc = (function(superClass) {
	  extend(Nvc, superClass);

	  function Nvc() {
	    return Nvc.__super__.constructor.apply(this, arguments);
	  }

	  Nvc.categories = ["needs", "posEmotions", "negEmotions"];

	  Nvc.needs = deepMap(sbdNeedsList, function(el) {
	    return el.match(/[-_0-9a-z]+/gi);
	  });

	  Nvc.nvcNeeds = {
	    "connection a-h": wordsArray("acceptance\naffection\nappreciation\nbelonging\ncooperation\ncommunication\ncloseness\ncommunity\ncompanionship\ncompassion\nconsideration\nconsistency\nempathy"),
	    "connection i-z": wordsArray("inclusion\nintimacy\nlove\nmutuality\nnurturing\nrespect\nself-respect\nsafety\nsecurity\nstability\nsupport\nto know\nto be known\nto see\nto be seen\nto understand\nto be understood\ntrust\nwarmth"),
	    "physical well being": wordsArray("air\nfood\nmovement/exercise\nrest/sleep\nsexual expression\nsafety\nshelter\ntouch\nwater"),
	    honesty: wordsArray("authenticity\nintegrity\npresence"),
	    play: wordsArray("joy\nhumor"),
	    peace: wordsArray("beauty\ncommunion\nease\nequality\nharmony\ninspiration\norder"),
	    autonomy: wordsArray("choice\nfreedom\nindependence\nspace\nspontaneity"),
	    meaning: wordsArray("awareness\ncelebration of life\nchallenge\nclarity\ncompetence\nconsciousness\ncontribution\ncreativity\ndiscovery\nefficacy\neffectiveness\ngrowth\nhope\nlearning\nmourning\nparticipation\npurpose\nself-expression\nstimulation\nto matter\nunderstanding")
	  };

	  Nvc.posEmotions = {
	    affectionate: wordsArray("compassionate\nfriendly\nloving\nopen-hearted\nsympathetic\ntender\nwarm"),
	    engaged: wordsArray("absorbed\nalert\ncurious\nengrossed\nenchanted\nentranced\nfascinated\ninterested\nintrigued\ninvolved\nspellbound\nstimulated"),
	    hopeful: wordsArray("expectant\nencouraged\noptimistic"),
	    confident: wordsArray("empowered\nopen\nproud\nsafe\nsecure"),
	    excited: wordsArray("amazed\nanimated\nardent\naroused\nastonished\ndazzled\neager\nenergetic\nenthusiastic\ngiddy\ninvigorated\nlively\npassionate\nsurprised\nvibrant"),
	    grateful: wordsArray("appreciative\nmoved\nthankful\ntouched"),
	    inspired: wordsArray("amazed\nawed\nwonder"),
	    joyful: wordsArray("amused\ndelighted\nglad\nhappy\njubilant\npleased\ntickled"),
	    exhilarated: wordsArray("blissful\necstatic\nelated\nenthralled\nexuberant\nradiant\nrapturous\nthrilled"),
	    peaceful: wordsArray("calm\nclear-headed\ncomfortable\ncentered\ncontent\nequanimous\nfulfilled\nmellow\nquiet\nrelaxed\nrelieved\nsatisfied\nserene\nstill\ntranquil\ntrusting")
	  };

	  Nvc.negEmotions = {
	    afraid: wordsArray("apprehensive\ndread\nforeboding\nfrightened\nmistrustful\npanicked\npetrified\nscared\nsuspicious\nterrified\nwary\nworried"),
	    annoyed: wordsArray("aggravated\ndismayed\ndisgruntled\ndispleased\nexasperated\nfrustrated\nimpatient\nirritated\nirked"),
	    angry: wordsArray("enraged\nfurious\nincensed\nindignant\nirate\nlivid\noutraged\nresentful"),
	    aversion: wordsArray("animosity\nappalled\ncontempt\ndisgusted\ndislike\nhate\nhorrified\nhostile\nrepulsed"),
	    confused: wordsArray("ambivalent\nbaffled\nbewildered\ndazed\nhesitant\nlost\nmystified\nperplexed\npuzzled\ntorn"),
	    disconnected: wordsArray("alienated\naloof\napathetic\nbored\ncold\ndetached\ndistant\ndistracted\nindifferent\nnumb\nremoved\nuninterested\nwithdrawn"),
	    disquiet: wordsArray("agitated\nalarmed\ndiscombobulated\ndisconcerted\ndisturbed\nperturbed\nrattled\nrestless\nshocked\nstartled\nsurprised\ntroubled\nturbulent\nturmoil\nuncomfortable\nuneasy\nunnerved\nunsettled\nupset"),
	    embarrassed: wordsArray("ashamed\nchagrined\nflustered\nguilty\nmortified\nself-conscious"),
	    fatigue: wordsArray("beat\nburnt-out\ndepleted\nexhausted\nlethargic\nlistless\nsleepy\ntired\nweary\nworn-out"),
	    pain: wordsArray("agony\nanguished\nbereaved\ndevastated\ngrief\nheartbroken\nhurt\nlonely\nmiserable\nregretful\nremorseful"),
	    sad: wordsArray("depressed\ndejected\ndespair\ndespondent\ndisappointed\ndiscouraged\ndisheartened\nforlorn\ngloomy\nheavy-hearted\nhopeless\nmelancholy\nunhappy\nwretched"),
	    tense: wordsArray("anxious\ncranky\ndistressed\ndistraught\nedgy\nfidgety\nfrazzled\nirritable\njittery\nnervous\noverwhelmed\nrestless\nstressed out"),
	    vulnerable: wordsArray("fragile\nguarded\nhelpless\ninsecure\nleery\nreserved\nsensitive\nshaky"),
	    yearning: wordsArray("envious\njealous\nlonging\nnostalgic\npining\nwistful")
	  };

	  Nvc.core = {
	    needs: Nvc.needs,
	    posEmotions: Nvc.posEmotions,
	    negEmotions: Nvc.negEmotions
	  };

	  return Nvc;

	})(HotStyleProps));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Button, Component, Element, FillElement, PointerActionsMixin, RectangleElement, StyleProps, TextElement, defineModule, log, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(120), defineModule = ref.defineModule, Component = ref.Component, Element = ref.Element, TextElement = ref.TextElement, FillElement = ref.FillElement, RectangleElement = ref.RectangleElement, log = ref.log;

	StyleProps = Neptune.Nvc.App.Styles.StyleProps;

	PointerActionsMixin = __webpack_require__(359).PointerActionsMixin;

	Button = __webpack_require__(363);

	defineModule(module, function() {
	  var CategoryButton, emojiMap, subtextMap;
	  emojiMap = {
	    needs: "",
	    negEmotions: "",
	    posEmotions: "",
	    selected: ""
	  };
	  subtextMap = {
	    needs: "needs",
	    negEmotions: "emotions",
	    posEmotions: "emotions",
	    surviving: "animal",
	    thriving: "mamal",
	    transcending: "human",
	    selected: "my selection"
	  };
	  return CategoryButton = (function(superClass) {
	    extend(CategoryButton, superClass);

	    function CategoryButton() {
	      return CategoryButton.__super__.constructor.apply(this, arguments);
	    }

	    CategoryButton.prototype.doAction = function() {
	      var category, drillIn, ref1, subMap;
	      ref1 = this.props, category = ref1.category, subMap = ref1.subMap, drillIn = ref1.drillIn;
	      if (subMap) {
	        return drillIn(category, subMap);
	      }
	    };

	    CategoryButton.prototype.render = function() {
	      var category, ref1, selected;
	      ref1 = this.props, category = ref1.category, selected = ref1.selected;
	      return Button({
	        selected: selected,
	        color: StyleProps.primaryColor,
	        emoji: emojiMap[category],
	        text: category,
	        subtext: subtextMap[category],
	        action: this.doAction
	      });
	    };

	    return CategoryButton;

	  })(Component);
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(360);


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(361).addModules({
	  PointerActionsMixin: __webpack_require__(362)
	});


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	var Mixins, React,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	React = __webpack_require__(284);

	module.exports = React.Mixins || React.addNamespace('Mixins', Mixins = (function(superClass) {
	  extend(Mixins, superClass);

	  function Mixins() {
	    return Mixins.__super__.constructor.apply(this, arguments);
	  }

	  return Mixins;

	})(Neptune.Base));


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var defineModule,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	defineModule = __webpack_require__(19).defineModule;

	defineModule(module, function() {
	  return function(superClass) {
	    var PointerActionsMixin;
	    return PointerActionsMixin = (function(superClass1) {
	      extend(PointerActionsMixin, superClass1);

	      function PointerActionsMixin() {
	        return PointerActionsMixin.__super__.constructor.apply(this, arguments);
	      }

	      PointerActionsMixin.stateFields({
	        hover: false,
	        pointerIsDown: false
	      });

	      PointerActionsMixin.prototype.mouseIn = function() {
	        return this.setState({
	          hover: true
	        });
	      };

	      PointerActionsMixin.prototype.mouseOut = function() {
	        return this.setState({
	          hover: false
	        });
	      };

	      PointerActionsMixin.prototype.pointerDown = function() {
	        return this.setState({
	          pointerIsDown: true
	        });
	      };

	      PointerActionsMixin.prototype.pointerUp = function() {
	        return this.setState({
	          pointerIsDown: false
	        });
	      };

	      PointerActionsMixin.getter({
	        buttonHandlers: function() {
	          return {

	            /*
	              CafScript could do: {}
	                @mouseIn
	                @mouseOut
	            
	                pointerDown:
	                pointerIn:      @pointerDown
	            
	                pointerUp:
	                pointerOut:
	                pointerCancel:  @pointerUp
	             */
	            mouseIn: this.mouseIn,
	            mouseOut: this.mouseOut,
	            pointerDown: this.pointerDown,
	            pointerIn: this.pointerDown,
	            pointerUp: this.pointerUp,
	            pointerCancel: this.pointerUp,
	            pointerOut: this.pointerUp,
	            pointerUpInside: this.doAction
	          };
	        },
	        hoverHandlers: function() {
	          return {
	            mouseIn: this.mouseIn,
	            mouseOut: this.mouseOut
	          };
	        }
	      });

	      return PointerActionsMixin;

	    })(superClass);
	  };
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Component, Element, FillElement, PointerActionsMixin, RectangleElement, StyleProps, TextElement, defineModule, log, ref, rgbColor,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;

	ref = __webpack_require__(120), defineModule = ref.defineModule, Component = ref.Component, Element = ref.Element, TextElement = ref.TextElement, FillElement = ref.FillElement, RectangleElement = ref.RectangleElement, log = ref.log, rgbColor = ref.rgbColor;

	PointerActionsMixin = __webpack_require__(359).PointerActionsMixin;

	StyleProps = Neptune.Nvc.App.Styles.StyleProps;

	defineModule(module, function() {
	  var Button;
	  return Button = (function(superClass) {
	    extend(Button, superClass);

	    function Button() {
	      return Button.__super__.constructor.apply(this, arguments);
	    }

	    Button.prototype.doAction = function() {
	      var ref1;
	      return (ref1 = this.props) != null ? ref1.action() : void 0;
	    };

	    Button.prototype.render = function() {
	      var color, emoji, ref1, selected, small, subtext, text;
	      ref1 = this.props, text = ref1.text, subtext = ref1.subtext, emoji = ref1.emoji, selected = ref1.selected, color = ref1.color, small = ref1.small;
	      color = rgbColor(color);
	      color = (function() {
	        switch (false) {
	          case !selected:
	            return color;
	          case !this.pointerIsDown:
	            return color.blend("white", .5);
	          default:
	            return "white";
	        }
	      }).call(this);
	      return Element({
	        size: {
	          wcw: 1,
	          hch: 1
	        },
	        cursor: "pointer",
	        on: this.buttonHandlers,
	        animators: {
	          size: {
	            toFrom: {
	              hch: 1,
	              w: 0
	            }
	          }
	        },
	        clip: true
	      }, RectangleElement({
	        inFlow: false,
	        color: color,
	        animators: {
	          color: {},
	          shadow: {
	            duration: .3
	          }
	        },
	        padding: 3,
	        radius: small ? 100 : 2,
	        shadow: this.pointerIsDown || (selected && !this.hover) ? {
	          blur: 4,
	          color: "#0002",
	          offset: {
	            y: 1
	          }
	        } : this.hover ? {
	          blur: 12,
	          color: "#0004",
	          offset: {
	            y: 2
	          }
	        } : {
	          blur: 8,
	          color: "#0002",
	          offset: {
	            y: 2
	          }
	        }
	      }), emoji ? Element({
	        size: 100,
	        padding: 18
	      }, TextElement({
	        text: emoji,
	        location: {
	          ps: .5
	        },
	        axis: "centerCenter",
	        scale: function(ps, cs) {
	          return ps.div(cs).min();
	        },
	        layoutMode: "tight",
	        fontSize: 64
	      })) : TextElement(StyleProps.textStyle, {
	        size: {
	          cs: 1
	        },
	        align: "centerCenter",
	        text: text,
	        padding: small ? 15 : 20
	      }), subtext && TextElement(StyleProps.textStyle, {
	        fontSize: 10,
	        location: {
	          ww: .5,
	          yh: 1,
	          y: -8
	        },
	        size: {
	          cs: 1
	        },
	        axis: "bottomCenter",
	        text: subtext
	      }));
	    };

	    return Button;

	  })(PointerActionsMixin(Component));
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {var Button, Element, FillElement, FluxComponent, PointerActionsMixin, RectangleElement, StyleProps, TextElement, defineModule, log, ref,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty,
	  slice = [].slice;

	ref = __webpack_require__(120), defineModule = ref.defineModule, FluxComponent = ref.FluxComponent, Element = ref.Element, TextElement = ref.TextElement, FillElement = ref.FillElement, RectangleElement = ref.RectangleElement, log = ref.log;

	StyleProps = Neptune.Nvc.App.Styles.StyleProps;

	PointerActionsMixin = __webpack_require__(359).PointerActionsMixin;

	Button = __webpack_require__(363);

	defineModule(module, function() {
	  var LeafButton;
	  return LeafButton = (function(superClass) {
	    var getSelectedKey;

	    extend(LeafButton, superClass);

	    function LeafButton() {
	      return LeafButton.__super__.constructor.apply(this, arguments);
	    }

	    LeafButton.subscriptions({
	      selected: getSelectedKey = function(arg) {
	        var name, path;
	        name = arg.name, path = arg.path;
	        if (path[0] !== "selected") {
	          return (path.join(' > ')) + " > " + name;
	        } else {
	          return name;
	        }
	      }
	    });

	    LeafButton.prototype.action = function() {
	      return this.models.selected.toggle(getSelectedKey(this.props));
	    };

	    LeafButton.prototype.render = function() {
	      var first, i, last, middle, name, parentName, ref1, ref2, secondToLast;
	      ref1 = this.props, name = ref1.name, parentName = ref1.parentName;
	      if (name.match(/\ >\ /)) {
	        ref2 = name.split(" > "), first = ref2[0], middle = 4 <= ref2.length ? slice.call(ref2, 1, i = ref2.length - 2) : (i = 1, []), secondToLast = ref2[i++], last = ref2[i++];
	        first = (function() {
	          switch (first) {
	            case "needs":
	              return "";
	            case "negEmotions":
	              return "";
	            case "posEmotions":
	              return "";
	            default:
	              return first;
	          }
	        })();
	        name = first + " " + secondToLast + " > " + last;
	      }
	      return Button({
	        color: StyleProps.leafColor,
	        text: name,
	        small: true,
	        selected: this.selected,
	        action: this.action
	      });
	    };

	    return LeafButton;

	  })(PointerActionsMixin(FluxComponent));
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(93)(module)))

/***/ }
/******/ ]);
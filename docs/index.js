/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 545);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var ref, ref1;

module.exports = (ref = typeof Neptune !== "undefined" && Neptune !== null ? (ref1 = Neptune.Art) != null ? ref1.StandardLib : void 0 : void 0) != null ? ref : __webpack_require__(521);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(487);


/***/ }),
/* 3 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(387);


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(374)
var ieee754 = __webpack_require__(582)
var isArray = __webpack_require__(327)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(401);


/***/ }),
/* 7 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(539);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(540);


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = __webpack_require__(633).Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(397);


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var Core, Types, isFunction, isJsonAtomicType, isObject, isPlainArray, isPlainObject, isString, mergeInto, ref;

ref = Core = __webpack_require__(16), isPlainObject = ref.isPlainObject, mergeInto = ref.mergeInto, isString = ref.isString, isFunction = ref.isFunction, isObject = ref.isObject, isPlainArray = ref.isPlainArray, isJsonAtomicType = ref.isJsonAtomicType;

module.exports = Types = (function() {
  var cloneObjectUpToKey, deepEach, deepEachAll, deepMap, deepMapArray, deepMapObject, functionName, noopMapper, objectName, tEq, throwInequalityError, toJsonStructure, toPostMessageStructure;

  function Types() {}

  mergeInto(Types, Core.Types);

  throwInequalityError = function(a, b) {
    throw new Error("Value types are not compatible for inequality tests. a: " + (a != null ? a.constructor.name : void 0) + ", b: " + (b != null ? b.constructor.name : void 0));
  };


  /*
   * simplified - as simple as I can make it
   * sacrifices some semantics
  gt = (a, b)->
    if (o = a > b) || a <= b
      return o
    a.gt b
  
   * just a tad more complex and only sacrifices clear errors
  gt = (a, b)->
    if typeof a == typeof b
      if (o = a > b) || a <= b
        return o
    a.gt b
   */

  tEq = function(a, b) {
    return typeof a === typeof b;
  };

  Types.gt = function(a, b) {
    var s;
    if ((a != null) && (b != null)) {
      s = tEq(a, b);
      return (s && a > b) || ((s && a <= b) ? false : a.gt(b));
    } else {
      return throwInequalityError(a, b);
    }
  };

  Types.lt = function(a, b) {
    var s;
    if ((a != null) && (b != null)) {
      s = tEq(a, b);
      return (s && a < b) || ((s && a >= b) ? false : a.lt(b));
    } else {
      return throwInequalityError(a, b);
    }
  };

  Types.gte = function(a, b) {
    var s;
    if ((a != null) && (b != null)) {
      s = tEq(a, b);
      return (s && a >= b) || ((s && a < b) ? false : a.gte(b));
    } else {
      return throwInequalityError(a, b);
    }
  };

  Types.lte = function(a, b) {
    var s;
    if ((a != null) && (b != null)) {
      s = tEq(a, b);
      return (s && a <= b) || ((s && a > b) ? false : a.lte(b));
    } else {
      return throwInequalityError(a, b);
    }
  };


  /*
  like RubyOnRails#present:
    "An object is present if it's not blank."
  
  basic:
    present null, undefined or "" returns false (or whatever returnIfNotPresent is set to)
    all other values return something truish - generally themselves
  
  custom:
    for bar where isFunction bar.present
      present bar returns bar.present()
  
  special-case truish results:
    present 0 or false returns true
  
  for any other value foo,
    present foo returns foo
  
  IN:
    obj:
      object tested for presence
    returnIfNotPresent: [false]
      what to return if not present
  
  OUT:
    returnIfNotPresent, true, or the value passed in
  
  If 'obj' has method: obj.present() => obj.present()
   */

  Types.present = function(obj, returnIfNotPresent) {
    var present;
    if (returnIfNotPresent == null) {
      returnIfNotPresent = false;
    }
    present = isFunction(obj != null ? obj.getPresent : void 0) ? obj.getPresent() : isFunction(obj != null ? obj.present : void 0) ? obj.present() : isString(obj) ? !obj.match(/^\s*$/) : obj !== void 0 && obj !== null;
    if (present) {
      return obj || true;
    } else {
      return returnIfNotPresent;
    }
  };

  Types.functionName = functionName = function(f) {
    var matched;
    return f.name || ((matched = ("" + f).match(/function ([a-zA-Z]+)\(/)) && matched[1]) || "function";
  };

  Types.objectName = objectName = function(obj) {
    var a, name, ref1;
    if (!obj) {
      return "" + obj;
    } else if (a = typeof obj.getNamespacePath === "function" ? obj.getNamespacePath() : void 0) {
      return a;
    } else if (a = obj.classPathName) {
      return a;
    } else if (obj.constructor === Object) {
      return "Object";
    } else if (isFunction(obj)) {
      return functionName(obj);
    } else if (isString(name = (ref1 = obj.constructor) != null ? ref1.name : void 0) && name.length > 0) {
      return name;
    } else if (obj instanceof Object) {
      return "(anonymous instanceof Object)";
    } else {
      return "(objectName unknown)";
    }
  };

  Types.isBrowserObject = function(obj) {
    var name;
    if (!Types.isObject(obj)) {
      return false;
    }
    name = Types.objectName(obj);
    return name.slice(0, 4) === "HTML" || name.slice(0, 22) === "CanvasRenderingContext";
  };


  /*
  IN:
    f: (value, [key]) ->
      f is called on every non-plainObject and non-plainArray reachable by traversing
      the plainObject/plainArray structure
      If f is called on a propery of a plainObject, the key for that property is also passed in.
  OUT: value
   */

  Types.deepEach = deepEach = function(v, f, key) {
    var j, k, len, subV;
    if (isPlainArray(v)) {
      for (j = 0, len = v.length; j < len; j++) {
        subV = v[j];
        deepEach(subV, f);
      }
    } else if (isPlainObject(v)) {
      for (k in v) {
        subV = v[k];
        deepEach(subV, f, k);
      }
    } else {
      f(v, key);
    }
    return v;
  };


  /*
  deepEachAll: just like deepEach except 'f' gets called on every value found including the initial value.
   */

  Types.deepEachAll = deepEachAll = function(v, f, key) {
    var j, k, len, subV;
    f(v, key);
    if (isPlainArray(v)) {
      for (j = 0, len = v.length; j < len; j++) {
        subV = v[j];
        deepEachAll(subV, f);
      }
    } else if (isPlainObject(v)) {
      for (k in v) {
        subV = v[k];
        deepEachAll(subV, f, k);
      }
    } else {

    }
    return v;
  };


  /*
  only creates a new array if the children changed
   */

  deepMapArray = function(array, mapper, options) {
    var i, j, len, p, r, res, v;
    res = null;
    for (i = j = 0, len = array.length; j < len; i = ++j) {
      v = array[i];
      r = deepMap(v, mapper, options);
      if (r !== v) {
        res || (res = array.slice());
        res[i] = r;
      }
    }
    res || (res = array);
    if (p = options != null ? options.postprocessArray : void 0) {
      return p(res);
    } else {
      return res;
    }
  };

  cloneObjectUpToKey = function(obj, k) {
    var k2, res, v;
    res = {};
    for (k2 in obj) {
      v = obj[k2];
      if (k2 === k) {
        break;
      }
      res[k2] = v;
    }
    return res;
  };

  deepMapObject = function(obj, mapper, options) {
    var k, p, r, res, v;
    res = null;
    for (k in obj) {
      v = obj[k];
      r = deepMap(v, mapper, options);
      if (r !== v || res) {
        res || (res = cloneObjectUpToKey(obj, k));
        res[k] = r;
      }
    }
    res || (res = obj);
    if (p = options != null ? options.postprocessObject : void 0) {
      return p(res);
    } else {
      return res;
    }
  };

  noopMapper = function(v) {
    return v;
  };


  /*
  Applies "f" to every -value- in a nested structure of plain arrays and objects.
  Pure functional efficient:
    If an array or object, and all its sub values, didn't change, the original array/object is reused.
  
  NOTE: deepMap only yields values to 'mapper' which are NOT plain arrays nor plain objects.
   */

  Types.deepMap = deepMap = function(v, mapper, options) {
    var arrayMapper, objectMapper;
    arrayMapper = (options != null ? options.arrays : void 0) || noopMapper;
    objectMapper = (options != null ? options.objects : void 0) || noopMapper;
    mapper || (mapper = noopMapper);
    if (isPlainArray(v)) {
      return deepMapArray(arrayMapper(v), mapper, options);
    } else if (isPlainObject(v)) {
      return deepMapObject(objectMapper(v), mapper, options);
    } else {
      return mapper(v);
    }
  };

  Types.toPlainStructure = function(o) {
    return deepMap(o, function(o) {
      if (isObject(o)) {
        if (o.toPlainStructure) {
          return o.toPlainStructure();
        } else {
          return objectName(o);
        }
      } else {
        return o;
      }
    });
  };


  /*
  similar to toPlainStructure, except all non-JSON types are converted to strings
   */

  Types.toJsonStructure = toJsonStructure = function(o) {
    return deepMap(o, function(o) {
      if (isObject(o)) {
        if (o.toJsonStructure) {
          return o.toJsonStructure();
        } else {
          return toJsonStructure(o.toPlainStructure ? o.toPlainStructure() : "" + o);
        }
      } else if (isJsonAtomicType(o)) {
        return o;
      } else {
        return "" + o;
      }
    });
  };

  Types.toPostMessageStructure = toPostMessageStructure = function(o) {
    return deepMap(o, function(o) {
      switch (o.constructor) {
        case ArrayBuffer:
        case Date:
        case RegExp:
        case Blob:
        case File:
        case FileList:
        case ImageData:
        case Boolean:
        case String:
          return o;
        default:
          if (isObject(o)) {
            if (o.toPostMessageStructure) {
              return o.toPostMessageStructure();
            } else {
              if (o.toPlainStructure) {
                return toPostMessageStructure(o.toPlainStructure());
              } else {
                return "" + o;
              }
            }
          } else {
            return "" + o;
          }
      }
    });
  };

  return Types;

})();


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = exports;

elliptic.version = __webpack_require__(603).version;
elliptic.utils = __webpack_require__(572);
elliptic.rand = __webpack_require__(182);
elliptic.curve = __webpack_require__(100);
elliptic.curves = __webpack_require__(564);

// Protocols
elliptic.ec = __webpack_require__(565);
elliptic.eddsa = __webpack_require__(568);


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(455);


/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(290);

module.exports.includeInNamespace(__webpack_require__(511)).addModules({
  ArrayCompactFlatten: __webpack_require__(90),
  Merge: __webpack_require__(288),
  StringCase: __webpack_require__(289),
  Types: __webpack_require__(43)
});


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(523);


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return __webpack_require__(17).merge(
    __webpack_require__(17),
    __webpack_require__(166),
    __webpack_require__(24),
    { StyleProps: __webpack_require__(173) }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var ref, ref1;

module.exports = (ref = typeof Neptune !== "undefined" && Neptune !== null ? (ref1 = Neptune.Art) != null ? ref1.CommunicationStatus : void 0 : void 0) != null ? ref : __webpack_require__(404);


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var Engine,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(439)).addNamespace('Engine', Engine = (function(superClass) {
  extend(Engine, superClass);

  function Engine() {
    return Engine.__super__.constructor.apply(this, arguments);
  }

  Engine.version = __webpack_require__(329).version;

  return Engine;

})(Neptune.PackageNamespace));

__webpack_require__(211);

__webpack_require__(54);

__webpack_require__(224);

__webpack_require__(39);

__webpack_require__(236);

__webpack_require__(238);

__webpack_require__(241);

__webpack_require__(242);


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Filter, Foundation, Promise, Request, Response, Validator, config, defineModule, getInspectedObjects, isPlainObject, log, merge, mergeInto, normalizeFields, shallowClone, success, toInspectedObjects, toPlainObjects,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Request = __webpack_require__(81);

Response = __webpack_require__(132);

config = __webpack_require__(27).config;

toPlainObjects = Foundation.toPlainObjects, Validator = Foundation.Validator, toInspectedObjects = Foundation.toInspectedObjects, getInspectedObjects = Foundation.getInspectedObjects, defineModule = Foundation.defineModule, BaseObject = Foundation.BaseObject, Promise = Foundation.Promise, log = Foundation.log, isPlainObject = Foundation.isPlainObject, mergeInto = Foundation.mergeInto, merge = Foundation.merge, shallowClone = Foundation.shallowClone, CommunicationStatus = Foundation.CommunicationStatus;

success = CommunicationStatus.success;

normalizeFields = Validator.normalizeFields;


/*
TODO

Filters should be able to detect if they are being run server-side or client-side.
  This is a simple global value, since the entire code-base is either running in Node or in the Browser.
  It doesn't change at runtime - duh!
  So, I think we should have a value like: Art.Ery.location, which is set at init-time
  to the code-base's running location.

  WHY do we need this? Filters may want to run on both AND run a little differently on both.

    LinkFieldsFilter, for example, would translate a linked field {foo: id: 123} to {fooId: 123} and not need
    to transmit the whole foo-record over the wire. BUT, if the data was {foo: username: "hi"}, that indicates
    a new foo-record should be created, and that should be done server-side.

    IT's a little thing right now, so I'm not implementing it... yet

  WHY PART 2

    This may be the solution to Filters which are not symmetrical. It's possible the before-part should be
    client-side-only, but the after-part should be server-side-only (for example).

    We could add @beforeLocation and @afterLocation props, but maybe this one solution is "good enough" for everything.
    The only down-side is it isn't as clear in the ArtEry-Pipeline report, but that may be OK since it doesn't seem like
    it'll be used that much.

Art.Ery.location values:
  "server"
  "client"
  "both" - this is the "serverless" mode, it's all run client-side, but it includes both client-side and server-side filters.

SBD:
  location: 'client' filters WILL run server-side for server-initiated requests.
  Maybe 'client' should be 'requester' instead of 'client'? 'requester' and 'server'?
 */

defineModule(module, Filter = (function(superClass) {
  var locationNames, locationPriorityBoost;

  extend(Filter, superClass);

  Filter.extendableProperty({

    /*
    @after: foo: (request) ->
      IN: Request instance
      OUT: return a Promise returning one of the list below OR just return one of the list below:
        Request instance
        Response instance
        anythingElse -> toResponse anythingElse
    
      To reject a request:
      - throw an error
      - return a rejected promise
      - or create a Response object with the appropriate fields
     */
    before: {},

    /*
    @before: foo: (response) ->
      IN: Request instance
      OUT: return a Promise returning one of the list below OR just return one of the list below:
        Request instance
        Response instance
        anythingElse -> toResponse anythingElse
    
      To reject a request:
      - throw an error
      - return a rejected promise
      - or create a Response object with the appropriate fields
     */
    after: {}
  });


  /*
  fields
   */

  Filter.extendableProperty({
    fields: {}
  }, {
    extend: function(oldFields, addFields) {
      return merge(oldFields, normalizeFields(addFields));
    }
  });

  Filter.extendableProperty({
    filterFailures: false

    /*
    location: determine if the filter will run on the 'server', 'client' or 'both'.
     */
  });

  Filter.locationNames = locationNames = {
    server: true,
    client: true,
    both: true
  };

  Filter.extendableProperty({
    location: "server"
  }, {
    extend: function(__, v) {
      if (!locationNames[v]) {
        throw new Error("invalid location: " + v);
      }
      return v;
    }

    /*
    Filter Groups: default: "middle"
    
    Filter sequence, based on groups:
      loggers beforeFilter
        outter beforeFilter
          middle beforeFilter
            inner beforeFilter
              handler
            inner afterFilter
          middle afterFilter
        outter afterFilter
      loggers afterFilter
     */
  });

  Filter.groupNames = {
    loggers: 2,
    outter: 1,
    middle: 0,
    inner: -1
  };

  Filter.extendableProperty({
    group: Filter.groupNames.middle
  }, {
    extend: function(__, v) {
      var value;
      if (v != null) {
        if ((value = Filter.groupNames[v]) == null) {
          throw new Error("invalid Filter group: " + v);
        }
        return value;
      } else {
        return 0;
      }
    }

    /*
      2018-04-19 SBD: I still think 'both' should be 1000, but it breaks Zo.
    
      Why? Because the ValidationFilter sets default fields and the UserOwnedFilter
      throws errors if the user attempts to set fields they aren't allowed to manually
      set. Well, this means the UserOwnedFilter needs to fire BEFORE ValidationFilter.
    
      The real problem here is ValidationFilter actually acts differently client-side vs
      server-side. I'm beginning to think the "both" mode for a Filter actually doesn't
      make much sense. I think we DO want to have a client-side validator which is
      initialized with the exact same constraint as the server-side validator. However,
      I'm beginning to think it just makes more sense if they are actually different filters.
    
      Right now I'm overloading what "Validation" means - and overloading usually (always?)
      creates unecessary complexity.
    
      And guess what? Validation, and only as a pre-filter, is STILL the only example I've
      found where a "both" filter kind-of makes sense.
    
      If we split Validator into separate Client and Server, we can drop the whole "both"
      concept - which probably simplifies A LOT of code! ooo!
     */
  });

  locationPriorityBoost = {
    client: 2000,
    both: 0,
    server: 0
  };

  Filter.getter({
    priority: function() {
      return this.group + locationPriorityBoost[this.location];
    }
  });

  function Filter(options) {
    var ref;
    if (options == null) {
      options = {};
    }
    Filter.__super__.constructor.apply(this, arguments);
    this.serverSideOnly = options.serverSideOnly, this.clientSideOnly = options.clientSideOnly, this.name = (ref = options.name) != null ? ref : this["class"].getName(), this.location = options.location, this.fields = options.fields, this.group = options.group, this.filterFailures = options.filterFailures, this.after = options.after, this.before = options.before;
  }

  Filter.property("name");

  Filter.setter({
    nextHandler: function(v) {
      throw new Error("depricated");
    }
  });

  Filter.prototype.shouldFilter = function(processingLocation) {
    switch (this.location) {
      case "server":
        return processingLocation !== "client";
      case "client":
        return processingLocation !== "server";
      case "both":
        return true;
      default:
        throw new Error("Filter " + (this.getName()) + ": invalid filter location: " + location);
    }
  };

  Filter.prototype.toString = function() {
    return this.getName();
  };

  Filter.prototype.getBeforeFilter = function(arg) {
    var location, requestType;
    requestType = arg.requestType, location = arg.location;
    return this.shouldFilter(location) && (this.before[requestType] || this.before.all);
  };

  Filter.prototype.getAfterFilter = function(arg) {
    var location, requestType;
    requestType = arg.requestType, location = arg.location;
    return this.shouldFilter(location) && (this.after[requestType] || this.after.all);
  };

  Filter.prototype.processBefore = function(request) {
    return this.applyHandler(request, this.getBeforeFilter(request));
  };

  Filter.prototype.processAfter = function(request) {
    return this.applyHandler(request, this.getAfterFilter(request));
  };

  Filter.prototype.handleRequest = function(request, filterChain, currentFilterChainIndex) {
    return this.processBefore(request).then((function(_this) {
      return function(request) {
        var nextHandler, nextIndex;
        if (request.isResponse) {
          return request;
        } else {
          return ((nextHandler = filterChain[nextIndex = currentFilterChainIndex + 1]) ? nextHandler.handleRequest(request, filterChain, nextIndex) : request.missing("no Handler for request type: " + request.type)).then(function(response) {
            if (response.isSuccessful || _this.filterFailures) {
              return _this.processAfter(response);
            } else {
              return response;
            }
          });
        }
      };
    })(this));
  };

  Filter.getter({
    logName: function() {
      return this.getName();
    },
    inspectedObjects: function() {
      var obj;
      return (
        obj = {},
        obj[(this.getNamespacePath()) + "(" + this.name + ")"] = toInspectedObjects(this.props),
        obj
      );
    },
    props: function() {
      return {
        location: this.location
      };
    }
  });

  return Filter;

})(__webpack_require__(131)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(15);
var inherits = __webpack_require__(7);

exports.inherits = inherits;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),
/* 23 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(317);

module.exports.includeInNamespace(__webpack_require__(361)).addModules({
  EmojiMap: __webpack_require__(362),
  Needs: __webpack_require__(174),
  NegativeEmotions: __webpack_require__(175),
  PositiveEmotions: __webpack_require__(176),
  Tools: __webpack_require__(177)
});


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(47).Buffer
var Transform = __webpack_require__(163).Transform
var StringDecoder = __webpack_require__(164).StringDecoder
var inherits = __webpack_require__(7)

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DrawEpoch, DummyEpoch, Epoch, EventEpoch, Foundation, GlobalEpochCycle, IdleEpoch, StateEpoch, arrayWithout, currentSecond, drawEpoch, dummyEpoch, durationString, eventEpoch, fastBind, fluxEpoch, globalCount, idleEpoch, isPlainObject, log, miniInspect, reactEpoch, requestAnimationFrame, stateEpoch, time, toMs,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

EventEpoch = __webpack_require__(14).EventEpoch;

StateEpoch = __webpack_require__(37);

DrawEpoch = __webpack_require__(214);

IdleEpoch = __webpack_require__(223);

log = Foundation.log, requestAnimationFrame = Foundation.requestAnimationFrame, miniInspect = Foundation.miniInspect, time = Foundation.time, arrayWithout = Foundation.arrayWithout, currentSecond = Foundation.currentSecond, Epoch = Foundation.Epoch, globalCount = Foundation.globalCount, isPlainObject = Foundation.isPlainObject, durationString = Foundation.durationString, fastBind = Foundation.fastBind;

toMs = function(s) {
  return (s * 1000).toFixed(1) + "ms";
};

eventEpoch = EventEpoch.eventEpoch;

drawEpoch = DrawEpoch.drawEpoch;

stateEpoch = StateEpoch.stateEpoch;

idleEpoch = IdleEpoch.idleEpoch;

DummyEpoch = (function(superClass) {
  extend(DummyEpoch, superClass);

  function DummyEpoch() {
    return DummyEpoch.__super__.constructor.apply(this, arguments);
  }

  DummyEpoch.singletonClass();

  return DummyEpoch;

})(Epoch);

dummyEpoch = DummyEpoch.dummyEpoch;

fluxEpoch = reactEpoch = dummyEpoch;

module.exports = GlobalEpochCycle = (function(superClass) {
  var timerStack;

  extend(GlobalEpochCycle, superClass);

  GlobalEpochCycle.singletonClass();

  GlobalEpochCycle.classGetter({
    activeCanvasElements: function() {
      return this.globalEpochCycle.activeCanvasElements;
    }
  });

  function GlobalEpochCycle() {
    var boundQueueNextEpoch;
    GlobalEpochCycle.__super__.constructor.apply(this, arguments);
    this.cycleQueued = false;
    this.processingCycle = false;
    this.activeCanvasElements = [];
    this._fluxOnIdleOkUntil = currentSecond();
    this._resetThisCyclesStats();
    boundQueueNextEpoch = fastBind(this.queueNextEpoch, this);
    idleEpoch.queueNextEpoch = stateEpoch.queueNextEpoch = drawEpoch.queueNextEpoch = eventEpoch.queueNextEpoch = boundQueueNextEpoch;
    eventEpoch.logEvent = (function(_this) {
      return function(name, id) {
        var ref;
        return (ref = _this.globalEpochStats) != null ? ref.logEvent(name, id) : void 0;
      };
    })(this);
  }

  GlobalEpochCycle.prototype.allowFluxOnIdle = function(nextNSeconds) {
    return this._fluxOnIdleOkUntil = currentSecond() + nextNSeconds;
  };

  GlobalEpochCycle.prototype._resetThisCyclesStats = function() {
    return this.performanceSamples = {};
  };

  GlobalEpochCycle.prototype.addPerformanceSample = function(name, value) {
    if (!this.performanceSamples) {
      throw new Error("@performanceSamples not set");
    }
    return this.performanceSamples[name] = (this.performanceSamples[name] || 0) + value;
  };

  timerStack = [];

  GlobalEpochCycle.prototype.timePerformance = function(name, f) {
    var start, subTimeTotal, timeResult, tsl;
    start = currentSecond();
    timerStack.push(0);
    f();
    subTimeTotal = timerStack.pop();
    timeResult = currentSecond() - start;
    if ((tsl = timerStack.length) > 0) {
      timerStack[tsl - 1] += timeResult;
    }
    return this.addPerformanceSample(name, timeResult - subTimeTotal);
  };

  GlobalEpochCycle.prototype.startTimePerformance = function() {
    var start;
    start = currentSecond();
    timerStack.push(0);
    return start;
  };

  GlobalEpochCycle.prototype.endTimePerformance = function(name, start) {
    var subTimeTotal, timeResult, tsl;
    subTimeTotal = timerStack.pop();
    timeResult = currentSecond() - start;
    if ((tsl = timerStack.length) > 0) {
      timerStack[tsl - 1] += timeResult;
    }
    return this.addPerformanceSample(name, timeResult - subTimeTotal);
  };

  GlobalEpochCycle.getter({
    numActivePointers: function() {
      var canvasElement, count, i, len, ref;
      count = 0;
      ref = this.activeCanvasElements;
      for (i = 0, len = ref.length; i < len; i++) {
        canvasElement = ref[i];
        count += canvasElement.getNumActivePointers();
      }
      return count;
    },
    idle: function() {
      return reactEpoch.getEpochLength() === 0 && stateEpoch.getEpochLength() === 0 && eventEpoch.getEpochLength() === 0;
    },
    epochLength: function() {
      return idleEpoch.getEpochLength() + eventEpoch.getEpochLength() + stateEpoch.getEpochLength() + reactEpoch.getEpochLength() + fluxEpoch.getEpochLength();
    }
  });

  GlobalEpochCycle.getter({
    idleEpoch: function() {
      return idleEpoch;
    },
    eventEpoch: function() {
      return eventEpoch;
    },
    stateEpoch: function() {
      return stateEpoch;
    },
    drawEpoch: function() {
      return drawEpoch;
    },
    reactEpoch: function() {
      return reactEpoch;
    },
    fluxEpoch: function() {
      return fluxEpoch;
    }
  });

  GlobalEpochCycle.prototype.includeReact = function(epoch) {
    return (reactEpoch = epoch).queueNextEpoch = (function(_this) {
      return function() {
        return _this.queueNextEpoch();
      };
    })(this);
  };

  GlobalEpochCycle.prototype.includeFlux = function(epoch) {
    return (fluxEpoch = epoch).queueNextEpoch = (function(_this) {
      return function() {
        return _this.queueNextEpoch();
      };
    })(this);
  };

  GlobalEpochCycle.prototype.logEvent = function(name, id) {
    var ref;
    return (ref = this.globalEpochStats) != null ? ref.logEvent(name, id) : void 0;
  };

  GlobalEpochCycle.prototype.detachCanvasElement = function(toRemoveCe) {
    return this.activeCanvasElements = arrayWithout(this.activeCanvasElements, toRemoveCe);
  };

  GlobalEpochCycle.prototype.attachCanvasElement = function(toAddCe) {
    return this.activeCanvasElements.push(toAddCe);
  };

  GlobalEpochCycle.prototype.processFluxEpoch = function() {
    var start;
    start = this.startTimePerformance();
    fluxEpoch.processEpoch();
    return this.endTimePerformance("flux", start);
  };

  GlobalEpochCycle.prototype.processIdleEpoch = function() {
    var start;
    start = this.startTimePerformance();
    if (idleEpoch != null) {
      idleEpoch.processEpoch();
    }
    return this.endTimePerformance("idle", start);
  };

  GlobalEpochCycle.prototype.processEventEpoch = function() {
    var start;
    start = this.startTimePerformance();
    eventEpoch.processEpoch();
    return this.endTimePerformance("event", start);
  };

  GlobalEpochCycle.prototype.processReactEpoch = function() {
    var start;
    start = this.startTimePerformance();
    reactEpoch.processEpoch();
    return this.endTimePerformance("react", start);
  };

  GlobalEpochCycle.prototype.processStateEpoch = function() {
    var start;
    start = this.startTimePerformance();
    stateEpoch.processEpoch();
    return this.endTimePerformance("aim", start);
  };

  GlobalEpochCycle.prototype.processDrawEpoch = function() {
    var start;
    start = this.startTimePerformance();
    drawEpoch.processEpoch();
    return this.endTimePerformance("draw", start);
  };

  GlobalEpochCycle.prototype.flushEpochNow = function() {
    if (this.processingCycle) {
      return;
    }
    this.processingCycle = true;
    this._processCycleExceptDraw();
    return this.processingCycle = false;
  };

  GlobalEpochCycle.prototype._processCycleExceptDraw = function() {
    this.processEventEpoch();
    this.processFluxEpoch();
    if (this.getIdle()) {
      this.processIdleEpoch();
    }
    reactEpoch.updateGlobalCounts();
    this.processReactEpoch();
    globalCount("reactEpochAfter", reactEpoch.getEpochLength());
    stateEpoch.updateGlobalCounts();
    this.processStateEpoch();
    return globalCount("stateEpochAfter", stateEpoch.getEpochLength());
  };

  GlobalEpochCycle.prototype.processEpochItems = function(items) {
    var drawCount, gc, globalEpochFrameTime, i, k, k2, keys, len, reactWastedWork, reactWork, ref, sorted, startTime, v, v2;
    fluxEpoch._frameSecond = idleEpoch._frameSecond = eventEpoch._frameSecond = reactEpoch._frameSecond = stateEpoch._frameSecond = drawEpoch._frameSecond = this._frameSecond;
    Foundation.resetGlobalCounts();
    startTime = currentSecond();
    this._resetThisCyclesStats();
    this.processingCycle = true;
    this._processCycleExceptDraw();
    if (stateEpoch.getEpochLength() > 0) {
      this.processStateEpoch();
    }
    drawCount = drawEpoch.epochLength;
    this.processDrawEpoch();
    this.processingCycle = false;
    if (this.getEpochLength() > 0) {
      this.queueNextEpoch();
    }
    if (drawCount > 0) {
      globalEpochFrameTime = currentSecond() - startTime;
      gc = Foundation.globalCounts;
      if (false) {
        keys = Object.keys(gc).sort();
        sorted = {};
        for (i = 0, len = keys.length; i < len; i++) {
          k = keys[i];
          v = gc[k];
          if (v > 0 && v < 1) {
            v = toMs(v);
          }
          if (isPlainObject(v)) {
            for (k2 in v) {
              v2 = v[k2];
              if (v2 > 0 && v2 < 1) {
                v[k2] = toMs(v2);
              }
            }
          }
          sorted[k] = v;
        }
        log({
          globalCounts: sorted,
          fps: (1 / globalEpochFrameTime).toFixed(1)
        });
        reactWork = (gc["ReactComponent_Created"] || 0) + (gc["ReactVirtualElement_Created"] || 0);
        reactWastedWork = (gc["ReactComponent_UpdateFromTemporaryComponent_NoChange"] || 0) + (gc["ReactVirtualElement_UpdateFromTemporaryVirtualElement_NoChange"] || 0);
        if (reactWork > 0) {
          log({
            reactWork: reactWork,
            reactWastedWork: reactWastedWork,
            reactEfficiency: 1 - reactWastedWork / reactWork
          });
        }
      }
      return (ref = this.globalEpochStats) != null ? ref.add(startTime, globalEpochFrameTime, this.performanceSamples) : void 0;
    }
  };

  return GlobalEpochCycle;

})(Epoch);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, Config, Configurable, Validator, defineModule, mergeInto, ref, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), w = ref.w, Validator = ref.Validator, defineModule = ref.defineModule, mergeInto = ref.mergeInto, BaseObject = ref.BaseObject, Configurable = ref.Configurable;

defineModule(module, Config = (function(superClass) {
  extend(Config, superClass);

  function Config() {
    return Config.__super__.constructor.apply(this, arguments);
  }

  Config.defaults({
    tableNamePrefix: "",
    location: "both",
    apiRoot: "api",

    /*
    remoteServer examples:
      "http://localhost:8085"
      "http://domain.com"
      "https://domain.com"
      "//domain.com"  # this ensures the request stays HTTP or HTTPS based on the original html request
      true
    
    If remoteServer is true
      requests will still go to the remote server
      The remote URL, though, will just be "#{apiRoot}/..."
    
      This is a good setting for apps loaded from an HTML page on the same
      server as the remote-API.
     */
    remoteServer: null,
    verbose: false,
    returnProcessingInfoToClient: false,

    /*
      generating a secury HMAC privateSessionKey:
    
      in short, run: openssl rand -base64 16
    
      http://security.stackexchange.com/questions/95972/what-are-requirements-for-hmac-secret-key
      Recommends 128bit string generated with a "cryptographically
      secure pseudo random number generator (CSPRNG)."
    
      http://osxdaily.com/2011/05/10/generate-random-passwords-command-line/
       * 128 bits:
      > openssl rand -base64 16
    
       * 256 bits:
      > openssl rand -base64 32
     */
    server: {
      privateSessionKey: "todo+generate+your+one+unique+key"
    }
  });

  Config.getPrefixedTableName = function(tableName) {
    return "" + Config.config.tableNamePrefix + tableName;
  };

  return Config;

})(Configurable));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, global) {var BaseObject, Binary, BinaryString, ClassSystem, InspectedObjectLiteral, Promise, StandardLib, Utf8, compactFlatten, encodings, inspect, isFunction, isNode, isPlainArray, isString, log, merge, min, pad, readFileAsArrayBuffer, readFileAsDataUrl,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Binary = __webpack_require__(111);

Utf8 = __webpack_require__(197);

StandardLib = __webpack_require__(1);

ClassSystem = __webpack_require__(6);

merge = StandardLib.merge, isString = StandardLib.isString, isFunction = StandardLib.isFunction, isPlainArray = StandardLib.isPlainArray, log = StandardLib.log, min = StandardLib.min, inspect = StandardLib.inspect, readFileAsDataUrl = StandardLib.readFileAsDataUrl, readFileAsArrayBuffer = StandardLib.readFileAsArrayBuffer, compactFlatten = StandardLib.compactFlatten, pad = StandardLib.pad, InspectedObjectLiteral = StandardLib.InspectedObjectLiteral, Promise = StandardLib.Promise, isNode = StandardLib.isNode;

BaseObject = ClassSystem.BaseObject, inspect = ClassSystem.inspect;

encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

module.exports = BinaryString = (function(superClass) {
  var binary;

  extend(BinaryString, superClass);

  BinaryString.isBinary = function(arg) {
    var ref;
    return arg && ((arg instanceof BinaryString) || arg.constructor === ArrayBuffer || ((ref = arg.buffer) != null ? ref.constructor : void 0) === ArrayBuffer);
  };

  BinaryString.binary = binary = function(arg) {
    if (arg instanceof BinaryString) {
      return arg;
    } else {
      return new BinaryString(arg);
    }
  };

  BinaryString.binaryFromBlob = function(blob) {
    return readFileAsArrayBuffer(blob).then(function(ab) {
      return binary(ab);
    });
  };

  BinaryString.cloneUint8Array = function(srcU8A) {
    var dstU8A;
    dstU8A = new Uint8Array(new ArrayBuffer(src.length));
    dstU8A.set(srcU8A);
    return dstU8A;
  };

  function BinaryString(arg) {
    this.bytes = (function() {
      if (arg == null) {
        return new Uint8Array;
      } else if (arg instanceof BinaryString) {
        return BinaryString.cloneUint8Array(arg.bytes);
      } else if (isFunction(arg != null ? arg.uint8Array : void 0)) {
        return arg.uint8Array();
      } else if (isPlainArray(arg)) {
        return new Uint8Array(arg);
      } else if (arg instanceof ArrayBuffer) {
        return new Uint8Array(arg);
      } else if (arg instanceof Uint8Array) {
        return arg;
      } else if (isString(arg)) {
        return Utf8.toBuffer(arg);
      } else if (isFunction(arg.toString)) {
        return Utf8.toBuffer(arg.toString());
      } else {
        throw new Error("invalid Binary string constructor argument: " + (inspect(arg)));
      }
    })();
    this.length = this.bytes.length;
  }

  BinaryString.prototype.slice = function(a, b) {
    return new BinaryString(this.bytes.slice(a, b));
  };

  BinaryString.fromBase64 = function(base64encoding) {
    var byteString, i, j, len, ref, uint8Array;
    byteString = atob(base64encoding);
    len = byteString.length;
    uint8Array = new Uint8Array(new ArrayBuffer(len));
    for (i = j = 0, ref = len; j < ref; i = j += 1) {
      uint8Array[i] = byteString.charCodeAt(i);
    }
    return new BinaryString(uint8Array);
  };

  BinaryString.prototype.toDataUri = function(mimeType, sync) {
    var v;
    if (isNode) {
      v = "data:" + (mimeType != null ? mimeType : '') + ";base64," + (this.toBase64(true));
      if (sync) {
        return v;
      } else {
        return Promise.resolve(v);
      }
    } else {
      return readFileAsDataUrl(this.toBlob(mimeType));
    }
  };

  BinaryString.fromDataUri = function(dataURI) {
    var base64encoding, splitDataURI;
    splitDataURI = dataURI.split(',');
    base64encoding = splitDataURI[1];
    return this.fromBase64(base64encoding);
  };

  BinaryString.prototype.toString = function() {
    return Utf8.toString(this.bytes);
  };

  BinaryString.prototype.getString = function() {
    return this.toString();
  };

  BinaryString.prototype.toArrayBuffer = function() {
    return this.bytes.buffer;
  };

  BinaryString.prototype.toBlob = function(mimeType) {
    return new Blob([this.bytes], merge({
      type: mimeType
    }));
  };

  BinaryString.prototype.eq = function(b) {
    return this.compare(b) === 0;
  };

  BinaryString.prototype.compare = function(b) {
    var bytesA, bytesB, diff, i, j, ref;
    bytesA = this.bytes;
    bytesB = b.bytes;
    for (i = j = 0, ref = min(this.length, b.length); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (0 !== (diff = bytesA[i] - bytesB[i])) {
        return diff;
      }
    }
    return this.length - b.length;
  };

  BinaryString.prototype.inspect = function() {
    return this.getInspectedString();
  };

  BinaryString.getter({
    uint8Array: function() {
      return this.bytes;
    },
    arrayBuffer: function() {
      return this.bytes.buffer;
    },
    nodeBuffer: function() {
      return new Buffer(this.bytes);
    },
    blob: function() {
      return new Blob([this.bytes]);
    },
    plainArray: function() {
      var b, j, len1, ref, results;
      ref = this.bytes;
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        b = ref[j];
        results.push(b);
      }
      return results;
    },
    byteLength: function() {
      return this.length;
    },
    inspectedObjects: function() {
      var lenStr;
      lenStr = this.length >= 10 * 1024 * 1024 ? (Math.floor(this.length / 1024 * 1024)) + "m" : this.length >= 10 * 1024 ? (Math.floor(this.length / 1024)) + "k" : this.length + "b";
      return new InspectedObjectLiteral("<BinaryString length: " + lenStr + ">");
    },
    inspectedString: function(stride, maxBytes) {
      var characters, count, line, offset;
      if (stride == null) {
        stride = 8;
      }
      if (maxBytes == null) {
        maxBytes = 64;
      }
      count = 0;
      characters = [];
      if (this.length < maxBytes) {
        maxBytes = this.length;
      }
      line = new Array(stride);
      return compactFlatten([
        "BinaryString length: " + this.length + " bytes", maxBytes < this.length ? "First " + maxBytes + " bytes:" : void 0, (function() {
          var j, ref, ref1, results;
          results = [];
          for (offset = j = 0, ref = maxBytes, ref1 = stride; ref1 > 0 ? j < ref : j > ref; offset = j += ref1) {
            results.push(this._inspectLine(offset, stride, maxBytes));
          }
          return results;
        }).call(this)
      ]).join('\n');
    }
  });

  BinaryString.prototype._inspectLine = function(offset, length, maxBytes) {
    var b, characters, end, hexCharacters, i, y;
    end = min(this.length, offset + length);
    if (maxBytes >= 0) {
      end = min(end, maxBytes);
    }
    characters = (function() {
      var j, ref, ref1, results;
      results = [];
      for (i = j = ref = offset, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
        b = this.bytes[i];
        if (b >= 31 && b <= 127) {
          results.push(String.fromCharCode(b));
        } else {
          results.push('');
        }
      }
      return results;
    }).call(this);
    hexCharacters = (function() {
      var j, ref, ref1, results;
      results = [];
      for (i = j = ref = offset, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
        b = this.bytes[i];
        y = b.toString(16);
        if (y.length < 2) {
          y = "0" + y;
        }
        results.push(y);
      }
      return results;
    }).call(this);
    return (pad(hexCharacters.join(' '), length * 3)) + " '" + (characters.join('')) + "'";
  };


  /*
  toBase64 performance
  see: http://localhost:8080/webpack-dev-server/perf?grep=BinaryString
  as-of 2016-02-14, the manual string manipulation version is surprisingly the best on average for FF, Chrome and Safari
    For shorter lengths, toBase64Custom is by far the fastest, but
    toBase64ToDataUri starts to be faster at longer lengths.
   */

  BinaryString.prototype.toBase64 = function(sync) {
    var v;
    if (sync == null) {
      sync = false;
    }
    if (isNode) {
      v = new Buffer(this.bytes).toString('base64');
      if (sync) {
        return v;
      } else {
        return Promise.resolve(v);
      }
    } else if (this.length > 16 * 1024) {
      return this.toBase64ToDataUri();
    } else {
      return this.toBase64Custom();
    }
  };

  BinaryString.prototype.toBase64ToDataUri = function() {
    return this.toDataUri().then(function(dataUri) {
      return dataUri.split(',')[1];
    });
  };

  BinaryString.prototype.toBase64Custom = function() {
    var a, b, base64, byteLength, byteRemainder, bytes, c, chunk, d, i, j, mainLength, ref;
    bytes = this.bytes;
    base64 = '';
    byteLength = bytes.byteLength;
    byteRemainder = byteLength % 3;
    mainLength = byteLength - byteRemainder;
    for (i = j = 0, ref = mainLength - 1; j <= ref; i = j += 3) {
      chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
      a = (chunk & 16515072) >> 18;
      b = (chunk & 258048) >> 12;
      c = (chunk & 4032) >> 6;
      d = chunk & 63;
      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
    }
    return Promise.resolve((function() {
      switch (byteRemainder) {
        case 0:
          return base64;
        case 1:
          chunk = bytes[mainLength];
          a = (chunk & 252) >> 2;
          b = (chunk & 3) << 4;
          return base64 + encodings[a] + encodings[b] + '==';
        case 2:
          chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
          a = (chunk & 64512) >> 10;
          b = (chunk & 1008) >> 4;
          c = (chunk & 15) << 2;
          return base64 + encodings[a] + encodings[b] + encodings[c] + '=';
      }
    })());
  };

  BinaryString.downloadBinaryData = function(filename, binaryData, mimeType) {
    var blob;
    binaryData = binary(binaryData);
    if (global.navigator.msSaveOrOpenBlob != null) {
      blob = binaryData.toBlob(mimeType);
      return window.navigator.msSaveOrOpenBlob(blob, filename);
    } else {
      return binaryData.toDataUri(mimeType).then(function(uri) {
        var e;
        e = document.createElement('a');
        e.setAttribute('href', uri);
        e.setAttribute('download', filename);
        document.body.appendChild(e);
        e.click();
        return document.body.removeChild(e);
      });
    }
  };

  return BinaryString;

})(BaseObject);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer, __webpack_require__(3)))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var AtomElement, Atomic, Canvas, Color, Foundation, GradientFillStyle, Matrix, Point, PointLayout, PointLayoutBase, Rectangle, ShadowableElement, createWithPostCreate, isNumber, isPlainObject, log, matrix, max, merge, min, point, point0, point1, rect, ref, rgbColor,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Canvas = __webpack_require__(11);

AtomElement = __webpack_require__(121);

ref = __webpack_require__(40), PointLayout = ref.PointLayout, PointLayoutBase = ref.PointLayoutBase;

log = Foundation.log, isPlainObject = Foundation.isPlainObject, min = Foundation.min, max = Foundation.max, createWithPostCreate = Foundation.createWithPostCreate, isNumber = Foundation.isNumber, merge = Foundation.merge;

rgbColor = Atomic.rgbColor, Color = Atomic.Color, point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix, point0 = Atomic.point0, point1 = Atomic.point1;

GradientFillStyle = Canvas.GradientFillStyle;

module.exports = createWithPostCreate(ShadowableElement = (function(superClass) {
  var defaultOffset, noShadow;

  extend(ShadowableElement, superClass);

  function ShadowableElement() {
    return ShadowableElement.__super__.constructor.apply(this, arguments);
  }

  ShadowableElement.registerWithElementFactory = function() {
    return this !== ShadowableElement;
  };

  ShadowableElement.getter({
    cacheable: function() {
      return this.getHasChildren();
    }
  });

  defaultOffset = new PointLayout({
    y: 2
  });

  noShadow = {
    color: rgbColor(0, 0, 0, 0),
    blur: 0,
    offset: new PointLayout(0)
  };

  ShadowableElement.drawLayoutProperty({
    shadow: {
      "default": null,
      validate: function(v) {
        return !v || v === true || isPlainObject(v);
      },
      preprocess: function(v) {
        var blur, color, offset;
        if (!v) {
          return null;
        }
        color = v.color, offset = v.offset, blur = v.blur;
        color = rgbColor(color || "#0007");
        if (color.a < 1 / 255) {
          return null;
        }
        offset = offset != null ? offset instanceof PointLayoutBase ? offset : new PointLayout(offset) : defaultOffset;
        if (blur == null) {
          blur = 4;
        }
        return {
          blur: blur,
          offset: offset,
          color: color
        };
      }
    }
  });

  ShadowableElement.getter({
    normalizedShadow: function(pending) {
      var offset, shadow, x, y;
      shadow = this.getShadow(pending);
      if (!shadow || shadow === noShadow) {
        return null;
      }
      offset = shadow.offset;
      x = offset.layoutX(this._currentSize);
      y = offset.layoutY(this._currentSize);
      return merge(shadow, {
        offsetX: x,
        offsetY: y
      });
    }
  });

  ShadowableElement.prototype._expandRectangleByShadow = function(r, pending, normalizedShadow) {
    var blur, expandBottom, expandLeft, expandRight, expandTop, h, offsetX, offsetY, w, x, y;
    if (!normalizedShadow) {
      return r;
    }
    x = r.x, y = r.y, w = r.w, h = r.h;
    blur = normalizedShadow.blur, offsetX = normalizedShadow.offsetX, offsetY = normalizedShadow.offsetY;
    offsetX || (offsetX = 0);
    offsetY || (offsetY = 0);
    blur || (blur = 0);
    expandLeft = max(0, blur - offsetX);
    expandTop = max(0, blur - offsetY);
    expandRight = max(0, blur + offsetX);
    expandBottom = max(0, blur + offsetY);
    return r["with"](x - expandLeft, y - expandTop, w + expandLeft + expandRight, h + expandTop + expandBottom);
  };

  ShadowableElement.virtualProperty({
    drawAreaPadding: function(pending) {
      return 0;
    },
    baseDrawArea: function(pending) {
      return this._expandRectangleByShadow(this.getPreFilteredBaseDrawArea(pending), pending, this.getNormalizedShadow(pending));
    }
  });

  ShadowableElement.prototype._prepareDrawOptions = function(drawOptions, compositeMode, opacity) {
    ShadowableElement.__super__._prepareDrawOptions.apply(this, arguments);
    return drawOptions.shadow = this.normalizedShadow;
  };

  return ShadowableElement;

})(AtomElement));


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(92);

module.exports.includeInNamespace(__webpack_require__(512)).addModules({
  FormattedInspect: __webpack_require__(293),
  InspectedObjectLiteral: __webpack_require__(91),
  InspectedObjects: __webpack_require__(147),
  Inspector: __webpack_require__(148),
  Inspector2: __webpack_require__(517),
  PlainObjects: __webpack_require__(296)
});

__webpack_require__(294);


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var MinimalBaseObject, capitalize, isFunction, isPlainObject, isString, ref;

capitalize = __webpack_require__(16).capitalize;

ref = __webpack_require__(12), isFunction = ref.isFunction, isString = ref.isString, isPlainObject = ref.isPlainObject;

module.exports = MinimalBaseObject = (function() {
  var addGetter, addGetters, addProperties, addSetter, addSetters, defProperties, defProperty, propGetterName, propInternalName, propListStringToArray, propSetterName;

  function MinimalBaseObject() {}

  MinimalBaseObject.propInternalName = propInternalName = function(prop) {
    return "_" + prop;
  };


  /*
  IN: arguments is a list of strings or objects
    strings: are just the names of the properties
    objects: map from prop names to getter/setter functions
   */

  MinimalBaseObject.getter = function() {
    return defProperties(this.prototype, arguments, true, false);
  };

  MinimalBaseObject.setter = function() {
    return defProperties(this.prototype, arguments, false, true);
  };

  MinimalBaseObject.addGetter = function(prop, getter) {
    return this._addGetter(this.prototype, prop, getter);
  };

  MinimalBaseObject.addSetter = function(prop, setter) {
    return this._addSetter(this.prototype, prop, setter);
  };

  MinimalBaseObject.addClassGetter = function(prop, getter) {
    return this._addGetter(this, prop, getter);
  };

  MinimalBaseObject.addClassSetter = function(prop, setter) {
    return this._addSetter(this, prop, setter);
  };


  /*
  IN: arguments is a list of strings or objects
    strings: are just the names of the properties
    objects: map from prop names to initializers
   */

  MinimalBaseObject.property = function() {
    return defProperties(this.prototype, arguments, true, true);
  };

  MinimalBaseObject.classGetter = function() {
    return defProperties(this, arguments, true, false);
  };

  MinimalBaseObject.classSetter = function() {
    return defProperties(this, arguments, false, true);
  };

  MinimalBaseObject.classProperty = function() {
    return defProperties(this, arguments, true, true);
  };

  MinimalBaseObject._propGetterName = propGetterName = function(prop) {
    return "get" + capitalize(prop);
  };

  MinimalBaseObject._propSetterName = propSetterName = function(prop) {
    return "set" + capitalize(prop);
  };

  MinimalBaseObject._addGetter = addGetter = function(obj, prop, getter) {
    obj[propGetterName(prop)] = getter;
    if (!isFunction(getter)) {
      getter = (function() {
        return getter;
      });
    }
    Object.defineProperty(obj, prop, {
      get: getter,
      configurable: true
    });
    return prop;
  };

  MinimalBaseObject._addSetter = addSetter = function(obj, prop, setter) {
    obj[propSetterName(prop)] = setter;
    Object.defineProperty(obj, prop, {
      set: setter,
      configurable: true
    });
    return prop;
  };

  MinimalBaseObject._addGetters = addGetters = function(obj, map) {
    var getter, prop;
    for (prop in map) {
      getter = map[prop];
      addGetter(obj, prop, getter);
    }
    return map;
  };

  MinimalBaseObject._addSetters = addSetters = function(obj, map) {
    var prop, setter;
    for (prop in map) {
      setter = map[prop];
      addSetter(obj, prop, setter);
    }
    return map;
  };

  MinimalBaseObject._addProperties = addProperties = function(obj, map) {
    var initializer, prop;
    for (prop in map) {
      initializer = map[prop];
      defProperty(obj, prop, true, true, initializer);
    }
    return map;
  };

  MinimalBaseObject._defProperty = defProperty = function(obj, prop, defineGetter, defineSetter, initializer) {
    var propName;
    propName = propInternalName(prop);
    if (defineGetter) {
      addGetter(obj, prop, obj[propGetterName(prop)] = isFunction(initializer) ? function() {
        if (this[propName] != null) {
          return this[propName];
        } else {
          return this[propName] = initializer();
        }
      } : initializer != null ? function() {
        if (this[propName] != null) {
          return this[propName];
        } else {
          return this[propName] = initializer;
        }
      } : function() {
        return this[propName];
      });
    }
    if (defineSetter) {
      return addSetter(obj, prop, function(v) {
        return this[propName] = v;
      });
    }
  };

  MinimalBaseObject._defProperties = defProperties = function(obj, props, defineGetter, defineSetter) {
    var i, len, prop, propFromString, propMap, results;
    results = [];
    for (i = 0, len = props.length; i < len; i++) {
      prop = props[i];
      if (isPlainObject(propMap = prop)) {
        if (defineGetter && defineSetter) {
          results.push(addProperties(obj, propMap));
        } else if (defineGetter) {
          results.push(addGetters(obj, propMap));
        } else {
          results.push(addSetters(obj, propMap));
        }
      } else if (isString(prop)) {
        results.push((function() {
          var j, len1, ref1, results1;
          ref1 = propListStringToArray(prop);
          results1 = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            propFromString = ref1[j];
            results1.push(defProperty(obj, propFromString, defineGetter, defineSetter, null));
          }
          return results1;
        })());
      } else {
        throw new Error("invalid value. Expected string or plain-object:", prop);
      }
    }
    return results;
  };

  MinimalBaseObject._propListStringToArray = propListStringToArray = function(propList) {
    return propList.match(/[_a-z][_a-z0-9]*/gi);
  };

  return MinimalBaseObject;

})();


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var FoundationMath, StringExtensions, Types, compactFlatten, escapedDoubleQuoteRegex, floor, intRand, isArray, isBrowser, isNumber, isPlainObject, isString, wordsRegex;

FoundationMath = __webpack_require__(44);

Types = __webpack_require__(12);

wordsRegex = __webpack_require__(46).wordsRegex;

intRand = FoundationMath.intRand;

isString = Types.isString, isNumber = Types.isNumber, isPlainObject = Types.isPlainObject, isArray = Types.isArray;

compactFlatten = __webpack_require__(16).compactFlatten;

isBrowser = __webpack_require__(58).isBrowser;

escapedDoubleQuoteRegex = /[\\]["]/g;

floor = Math.floor;

module.exports = StringExtensions = (function() {
  var base62Characters, consistentJsonStringify, crypto, escapeDoubleQuoteJavascriptString, escapeJavascriptString, getPadding, jsStringifyR, pluralize, randomString, repeat, standardIndent;

  function StringExtensions() {}


  /*
  IN: an array and optionally a string, in any order
    joiner: the string
    array-to-flatten-and-join: the array
  
  OUT:
    compactFlatten(array).join joiner || ""
  
  NOTE: this uses Ruby's default value for joining - the empty array, not ',' which is JavaScripts
   */

  StringExtensions.compactFlattenJoin = function(a, b) {
    var array, joiner;
    array = null;
    joiner = isString(a) ? (array = b, a) : (array = a, b || "");
    return compactFlatten(array).join(joiner);
  };

  StringExtensions.base62Characters = base62Characters = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

  StringExtensions.randomString = randomString = function(length, chars, randomNumbers) {
    var charsLength, i, result;
    if (length == null) {
      length = 32;
    }
    if (chars == null) {
      chars = base62Characters;
    }
    result = '';
    charsLength = chars.length;
    if (randomNumbers) {
      return ((function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = length; j < ref; i = j += 1) {
          results.push(chars[randomNumbers[i] % charsLength]);
        }
        return results;
      })()).join('');
    } else {
      return ((function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = length; j < ref; i = j += 1) {
          results.push(chars[intRand(charsLength)]);
        }
        return results;
      })()).join('');
    }
  };

  StringExtensions.cryptoRandomString = isBrowser ? ((crypto = global.crypto, global), crypto ? function(l, c) {
    return randomString(l, c, crypto.getRandomValues(new Uint8Array(l)));
  } : (console.warn("window.crypto not available, using standard random for cryptoRandomString"), function(l, c) {
    return randomString(l, c);
  })) : (crypto = __webpack_require__(337), function(l, c) {
    return randomString(l, c, crypto.randomBytes(l));
  });

  StringExtensions.randomBase62Character = function() {
    return base62Characters[intRand(62)];
  };


  /*
  should really use: https://www.npmjs.org/package/pluralize
    pluralize "food" >> "foods"
    pluralize 1, "food" -> "1 food"
    pluralize 0, "food" -> "0 foods"
    pluralize 2, "food" -> "2 foods"
    pluralize 3, "person", people" -> "2 people"
   */

  StringExtensions.pluralize = pluralize = function(a, b, pluralForm) {
    if (isNumber(a)) {
      return a + " " + (a === 1 ? b : pluralForm || pluralize(b));
    } else if (isString(a || (a = b))) {
      return a + "s";
    }
  };

  StringExtensions.replaceLast = function(str, find, replaceWith) {
    var index;
    index = str.lastIndexOf(find);
    if (index >= 0) {
      return str.substring(0, index) + replaceWith + str.substring(index + find.length);
    } else {
      return str.toString();
    }
  };

  StringExtensions.getPadding = getPadding = function(length, padding) {
    var i, j, out, ref;
    if (padding == null) {
      padding = " ";
    }
    out = "";
    for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      out += padding;
    }
    return out;
  };

  StringExtensions.pad = function(str, length, padding, alignRight) {
    var exactPadding;
    str = String(str);
    if (str.length >= length) {
      return str;
    }
    exactPadding = getPadding(Math.max(length - str.length, 0), padding);
    if (alignRight) {
      return exactPadding + str;
    } else {
      return str + exactPadding;
    }
  };

  StringExtensions.escapeDoubleQuoteJavascriptString = escapeDoubleQuoteJavascriptString = function(str) {
    var s;
    s = String(str).replace(/[\\"]/g, "\\$&").replace(/[\0\b\f\n\r\t\v\u2028\u2029]/g, function(x) {
      switch (x) {
        case '\0':
          return "\\0";
        case '\b':
          return "\\b";
        case '\f':
          return "\\f";
        case '\n':
          return "\\n";
        case '\r':
          return "\\r";
        case '\t':
          return "\\t";
        case '\v':
          return "\\v";
        case '\u2028':
          return "\\u2028";
        case '\u2029':
          return "\\u2029";
      }
    });
    return s = '"' + s + '"';
  };


  /*
  SBD for a while I only had JSON.stringify here, but I hate seeing: "I said, \"hello.\""
  when I could be seeing: 'I said, "hello."'
  
  Is this going to break anything? I figure if you really need "" only, just use stringify.
   */

  StringExtensions.escapeJavascriptString = escapeJavascriptString = function(str) {
    var s;
    s = JSON.stringify(str);
    if (s.match(escapedDoubleQuoteRegex)) {
      return "'" + (s.replace(escapedDoubleQuoteRegex, '"').replace(/'/g, "\\'").slice(1, -1)) + "'";
    } else {
      return s;
    }
  };

  StringExtensions.allIndexes = function(str, regex) {
    var indexes, lastIndex, result;
    indexes = [];
    if (!((regex instanceof RegExp) && regex.global)) {
      throw new Error("regex must be a global RegExp");
    }
    regex.lastIndex = 0;
    while (result = regex.exec(str)) {
      indexes.push(result.index);
      lastIndex = result;
    }
    return indexes;
  };

  StringExtensions.repeat = repeat = " ".repeat ? function(str, times) {
    return str.repeat(times);
  } : function(str, count) {
    var result;
    count === floor(count);
    result = '';
    if (count > 0 && str.length > 0) {
      while (true) {
        if ((count & 1) === 1) {
          result += str;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        str += str;
      }
    }
    return result;
  };

  StringExtensions.rightAlign = function(str, width) {
    if (str.length >= width) {
      return str;
    } else {
      return repeat(" ", width - str.length) + str;
    }
  };

  StringExtensions.eachMatch = function(str, regex, f) {
    var result;
    regex.lastIndex = 0;
    while (result = regex.exec(str)) {
      f(result);
    }
    return null;
  };

  standardIndent = {
    joiner: ', ',
    openObject: '{',
    openArray: '[',
    closeObject: "}",
    closeArray: "]"
  };

  StringExtensions.jsStringify = function(obj) {
    return jsStringifyR(obj, "");
  };

  jsStringifyR = function(o, s) {
    var el, first, j, k, len, v;
    if (isPlainObject(o)) {
      s += "{";
      first = true;
      for (k in o) {
        v = o[k];
        if (first) {
          first = false;
        } else {
          s += ",";
        }
        if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(k)) {
          s += k;
        } else {
          s += JSON.stringify(k);
        }
        s += ":";
        s = jsStringifyR(v, s);
      }
      return s + "}";
    } else if (isArray(o)) {
      s += "[";
      first = true;
      for (j = 0, len = o.length; j < len; j++) {
        el = o[j];
        if (first) {
          first = false;
        } else {
          s += ",";
        }
        s = jsStringifyR(el, s);
      }
      return s + "]";
    } else {
      return s + JSON.stringify(o);
    }
  };

  StringExtensions.consistentJsonStringify = consistentJsonStringify = function(object, indent) {
    var closeArray, closeObject, error, indentObject, joiner, k, lastTotalIndent, openArray, openObject, out, totalIndent, v;
    return out = (function() {
      var ref;
      if (object === false || object === true || object === null || isNumber(object)) {
        return "" + object;
      } else if (isString(object)) {
        return JSON.stringify(object);
      } else {
        indentObject = indent ? typeof indent === "string" ? {
          joiner: ",\n" + indent,
          openObject: "{\n" + indent,
          openArray: "[\n" + indent,
          closeObject: "\n}",
          closeArray: "\n]",
          totalIndent: indent,
          indent: indent
        } : {
          totalIndent: totalIndent = indent.indent + (lastTotalIndent = indent.totalIndent),
          joiner: ",\n" + totalIndent,
          openObject: "{\n" + totalIndent,
          openArray: "[\n" + totalIndent,
          closeObject: "\n" + lastTotalIndent + "}",
          closeArray: "\n" + lastTotalIndent + "]",
          indent: indent.indent
        } : void 0;
        ref = indentObject || standardIndent, joiner = ref.joiner, openObject = ref.openObject, openArray = ref.openArray, closeObject = ref.closeObject, closeArray = ref.closeArray;
        if (isPlainObject(object)) {
          return openObject + ((function() {
            var j, len, ref1, results;
            ref1 = (Object.keys(object)).sort();
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              k = ref1[j];
              if (object[k] !== void 0) {
                results.push(JSON.stringify(k) + ": " + consistentJsonStringify(object[k], indentObject));
              }
            }
            return results;
          })()).join(joiner) + closeObject;
        } else if (isArray(object)) {
          return openArray + ((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = object.length; j < len; j++) {
              v = object[j];
              results.push(consistentJsonStringify(v, indentObject));
            }
            return results;
          })()).join(joiner) + closeArray;
        } else {
          Neptine.Art.StandardLib.log.error(error = "invalid object type for Json. Expecting: null, false, true, number, string, plain-object or array", object);
          throw new Error(error);
        }
      }
    })();
  };

  StringExtensions.splitRuns = function(str) {
    var ch, chCount, i, j, lastCh, ref, result;
    if (str.length === 0) {
      return [];
    }
    lastCh = str[0];
    chCount = 1;
    result = [];
    for (i = j = 1, ref = str.length; j < ref; i = j += 1) {
      ch = str[i];
      if (ch === lastCh) {
        chCount++;
      } else {
        result.push([lastCh, chCount]);
        chCount = 1;
      }
      lastCh = ch;
    }
    result.push([lastCh, chCount]);
    return result;
  };

  StringExtensions.eachRunAsCharCodes = function(str, f) {
    var ch, chCount, i, j, lastCh, ref;
    lastCh = str.charCodeAt(0);
    chCount = 1;
    for (i = j = 1, ref = str.length; j < ref; i = j += 1) {
      ch = str.charCodeAt(i);
      if (ch === lastCh) {
        chCount++;
      } else {
        f(lastCh, chCount);
        chCount = 1;
      }
      lastCh = ch;
    }
    f(lastCh, chCount);
    return null;
  };


  /*
  TODO: I think this can be generalized to cover most all ellipsies and word-wrap scenarios:
    a) have an options object with options:
      maxLength: number         # similar to current maxLength
      minLength: number         # currently implied to be maxLength / 2, in additional customizable, it would also be optional
      brokenWordEllipsis: ""   # used when only part of a word is included
      moreWordsEllipsis: ""    # used when there are more words, but the last word is whole
      wordLengthFunction: (string) -> string.length
         * can be replaced with, say, the font pixel-width for a string
         * in this way, this function can be used by text-layout
         * minLength and maxLength would then be in pixels
      breakWords: false         # currently, this is effectively true - will break the last word on line in most situations
      breakOnlyWord: true       # even if breakWords is false, if this is the only word on the line and it doesn't fit, should we break it?
                                 * should this even be an option?
       * future:
      wordBreakFunction: (word, maxLength) -> shorterWord
         * given a word and the maximum length of that word, returns
         * a word <= maxLength according to wordLengthFunction
  
    b) Use cases
      - TextLayout - uses pixels for length rather than characters
      - Art.Engine.Element 'flow' layout
        - if the input was an array of "words" and
        - wordLengthFunction returns the Element's width...
        I think this works. We'd need a way to handle margins though. I think this works:
          spaceLength: (leftWord, rightWord) -> 1
      - Shortend user display names:
        Options:
          wordBreakFunction: (word, maxLength) -> word[0]
          brokenWordEllipsis: "." or ""
        Example Output:
          "Shane Delamore", 10 > "Shane D." or
          "Shane Delamore", 10 > "Shane D"
        Or, just leave breakwords: false and get:
          "Shane Delamore", 10 > "Shane"
  
    c) returns both the output string and the "string remaining" - everything not included
    d) alternate input: an array of strings already broken up by words - the "remainging" return value would then also be an array of "words"
      (this would be for efficiency when doing multi-line layout)
  
  Right now, it works as follows:
  The output string is guaranteed to be:
    <= maxLength
    >= maxLength / 2 in almost all secenarios as long as inputString is >= maxLength / 2
   */

  StringExtensions.humanFriendlyShorten = function(inputString, maxLength) {
    var j, len, minLength, part, string, stringParts;
    if (!(maxLength > 0)) {
      throw new error("maxLength must be > 0");
    }
    inputString = inputString.trim();
    if (!(inputString.length > maxLength)) {
      return inputString;
    }
    minLength = maxLength / 2;
    stringParts = inputString.split(/\s+/);
    string = "";
    for (j = 0, len = stringParts.length; j < len; j++) {
      part = stringParts[j];
      if (string.length === 0) {
        string = part;
      } else if ((string.length < minLength) || string.length + part.length + 2 <= maxLength) {
        string += " " + part;
      } else {
        break;
      }
    }
    if (string.length > maxLength) {
      string = string.slice(0, maxLength - 1).trim();
    }
    return string + "";
  };

  StringExtensions.stripTrailingWhitespace = function(a) {
    return a.split(/[ ]*\n/).join("\n").split(/[ ]*$/)[0].replace(/\n+$/, '');
  };

  return StringExtensions;

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(531);


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var processNextTick = __webpack_require__(104);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(60);
util.inherits = __webpack_require__(7);
/*</replacement>*/

var Readable = __webpack_require__(345);
var Writable = __webpack_require__(158);

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var Base, BaseObject, floatEq, inspect, inspectedObjectLiteral, isFunction, isNumber, isPlainArray, isPlainObject, isString, log, lowerCamelCase, object, ref, stringToNumberArray, upperCamelCase, wordsArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), inspect = ref.inspect, log = ref.log, isNumber = ref.isNumber, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isString = ref.isString, isFunction = ref.isFunction, stringToNumberArray = ref.stringToNumberArray, BaseObject = ref.BaseObject, lowerCamelCase = ref.lowerCamelCase, upperCamelCase = ref.upperCamelCase, inspectedObjectLiteral = ref.inspectedObjectLiteral, floatEq = ref.floatEq, wordsArray = ref.wordsArray, inspect = ref.inspect, object = ref.object;

module.exports = Base = (function(superClass) {
  var letterFieldNames, reservedWords;

  extend(Base, superClass);


  /*
  TODO
  
  All Atomics follow the same pattern:
  
    A fixed, ordered set of fields
    with fixed names
    and fixed defaults
  
  Most functions could be automatically defined given:
  
    An array of field-names
    An array of default values
    NOTE: I wish we could just use an object to specifiy those, but
      the order is not guaranteed, and we need a fixed order.
  
  The field-names could be defined with a string.
  Zero (0) can be the default default-value
  
  Point:      @defineAtomic fieldNames: "x y"
  Matrix:     @defineAtomic fieldNames: "sx shy tx shx sy ty", defaults: [1, 1]
  Rectangle:  @defineAtomic fieldNames: "x y w h"
  Perimeter:  @defineAtomic fieldNames: "left right top bottom"
  
  nonStandardInitializes
    Initializing with 1 arg or fields.length args is usually the same for all atomics
    But, intializing with a number of args in between tends to vary.
    I suggest overrides:
    _init0: -> defaults
    _init1: (a) -> all fields = a
    _init2:
    _init3:
    _init4:
    _init#{n}: -> each field gets set individually
  
  @defineAtomicClass: ({fieldNames, defaults, aliases}) ->
    fields = wordsArray fields if isString fields
    @defineSetAll()           # uses fieldNames
    @defineInit0()            # uses fieldNames and defaults
    @defineInit1()            # uses fieldNames
    @defineInterpolate()      # uses fieldNames
    @defineComparisonOperators()  # uses fieldNames, defines: eq, gt, lt, gte, lte
    @defineMathOperators()        # uses fieldNames, defines: add, sub, mul, div
    @defineToArray()          # uses fieldNames
    @defineInitFromObject()   # uses fieldNames and aliases
    @defineToObject()         # uses fieldNames
    @defineGetters()          # uses fieldNames and aliases
    @defineInto()             # uses fieldNames
    @defineToString()
    @defineInspect()
    @defineToInspectedObjects()
   */

  Base.prototype._initFromString = function(string) {
    return this._init.apply(this, stringToNumberArray(string));
  };

  function Base(a, b, c, d, e, f, g) {
    Base.__super__.constructor.apply(this, arguments);
    if (isPlainArray(a)) {
      this._init.apply(this, a);
    } else if (isString(a)) {
      this._initFromString(a);
    } else if (isPlainObject(a)) {
      this._initFromObject(a);
    } else if ((a != null) && !isNumber(a) && !(a instanceof Base) && isFunction(a.toString)) {
      this._initFromString(a.toString());
    } else {
      this._init(a, b, c, d, e, f, g);
    }
  }

  Base.prototype.compare = function(b) {
    if (this.eq(b)) {
      return 0;
    }
    if (this.lte(b)) {
      return -1;
    }
    if (this.gte(b)) {
      return 1;
    }
    return 0/0;
  };

  Base.getConstructorFunctionName = function() {
    return this.constructorFunctionName || (this.constructorFunctionName = lowerCamelCase(this.getName()));
  };

  Base.getter({
    plainObjects: function() {
      return this.toObject();
    },
    inspectedObjects: function() {
      return inspectedObjectLiteral(this.inspectedObjectString);
    },
    inspectedObjectString: function() {
      var ref1, value;
      value = this.inspectedObjectStringRaw;
      return (ref1 = this["class"].getNamedValuesByValue()[value]) != null ? ref1 : value;
    },
    inspectedObjectStringRaw: function() {
      return this["class"].getConstructorFunctionName() + ("(" + this.inspectedObjectInitializer + ")");
    },
    inspectedObjectInitializer: function() {
      return this.toArray().join(', ');
    },
    array: function() {
      return this.toArray();
    }
  });

  Base.namedValues = {};

  Base.getNamedValuesByValue = function() {
    return this._namedValuesByValue != null ? this._namedValuesByValue : this._namedValuesByValue = object(this.namedValues, {
      key: function(v) {
        return v.inspectedObjectStringRaw;
      },
      "with": function(v, k) {
        return k;
      }
    });
  };

  Base.prototype.toPlainStructure = function() {
    return this.getPlainObjects();
  };

  Base.prototype.toPlainEvalString = function() {
    return inspect(this.getPlainObjects());
  };

  Base.prototype.inspect = function() {
    return (this["class"].getConstructorFunctionName()) + "(" + (this.toArray().join(', ')) + ")";
  };

  Base.prototype.toJson = function() {
    return this.toString();
  };

  Base.prototype.toString = function(precision) {
    var a;
    if (precision) {
      return "[" + (((function() {
        var j, len, ref1, results;
        ref1 = this.toArray();
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          a = ref1[j];
          results.push(a.toPrecision(precision));
        }
        return results;
      }).call(this)).join(', ')) + "]";
    } else {
      return "[" + (this.toArray().join(', ')) + "]";
    }
  };

  Base.prototype.neq = function(b) {
    return !this.eq(b);
  };

  Base.prototype.between = function(a, b) {
    return this.gte(a) && this.lte(b);
  };

  Base.prototype.floatEq = floatEq;

  Base.prototype.isNumber = isNumber;


  /*
  for use by extending children classes
   */

  Base.defineAtomicClass = function(arg) {
    this.fieldNames = arg.fieldNames, this.constructorFunctionName = arg.constructorFunctionName;
    if (isString(this.fieldNames)) {
      this.fieldNames = wordsArray(this.fieldNames);
    }
    this.getConstructorFunctionName();
    this._defineCore(this.fieldNames);
    this._defineComparisonOperators(this.fieldNames);
    return this._defineMathOperators(this.fieldNames);

    /*
    TODO: more standard methods to add:
    
     * most init can be standardized
    _init*
    
     * more math methods
    min max floor ceil average bound round
    
     * class methods
    @isPoint
     */
  };

  reservedWords = {
    "with": true
  };

  Base._definePrototypeMethodViaEval = function(name, paramsList, body) {
    var nameInEval;
    nameInEval = reservedWords[name] ? "" : name;
    return this.prototype[name] = eval(body = "(\nfunction " + nameInEval + "(" + paramsList + ") {\n" + body + "\n}\n)");
  };


  /*
  define: eq, lt, gt, lte, gt
  With these signatures:
  
     * provide numbers for all fields to compare
    myColor.eq r, g, b, a
  
     * provide another instance of @class to compare against
    myColor.eq myOtherColor
   */

  letterFieldNames = wordsArray("a b c d e f");

  Base._defineComparisonOperators = function(fieldNames) {
    var comparisonOperators, f, functionName, i, operator, params, paramsList, results;
    params = letterFieldNames.slice(0, fieldNames.length);
    paramsList = params.join(', ');
    this._definePrototypeMethodViaEval("eq", paramsList, "if (this === a) return true;\nif (this.isNumber(a)) {\n  return\n  " + (((function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
        f = fieldNames[i];
        results.push("this.floatEq(this." + f + ", " + params[i] + ")");
      }
      return results;
    })()).join(" &&\n  ")) + ";\n} else {\n  return a &&\n  " + (((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = fieldNames.length; j < len; j++) {
        f = fieldNames[j];
        results.push("this.floatEq(this." + f + ", a." + f + ")");
      }
      return results;
    })()).join(" &&\n  ")) + ";\n}");
    comparisonOperators = {
      lt: "<",
      gt: ">",
      lte: "<=",
      gte: ">="
    };
    results = [];
    for (functionName in comparisonOperators) {
      operator = comparisonOperators[functionName];
      results.push(this._definePrototypeMethodViaEval(functionName, paramsList, "if (this.isNumber(a)) {\n  return\n  " + (((function() {
        var j, len, results1;
        results1 = [];
        for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
          f = fieldNames[i];
          results1.push("this." + f + " " + operator + " " + params[i]);
        }
        return results1;
      })()).join(" &&\n  ")) + ";\n} else {\n  return a &&\n  " + (((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = fieldNames.length; j < len; j++) {
          f = fieldNames[j];
          results1.push("this." + f + " " + operator + " a." + f);
        }
        return results1;
      })()).join(" &&\n  ")) + ";\n}"));
    }
    return results;
  };


  /*
  define: add, sub, mul and div
  With these signatures:
  
    myColor.add r, g, b, a   # 4 numbers
  
    myColor.add myOtherColor, into # add by component
    myColor.add v, into            # one number to add to all
  
    into is optional. if set:
      it should be an instance of @class
      into is what is returned; a new instance of @class is not created
      into's field are set to the result
      NOTE: Atomic classes are designed to be used Pure-Functionally!
        SO, only use this if you created 'into' and you are not using it ANYWHERE else.
   */

  Base._defineMathOperators = function(fieldNames) {
    var f, functionName, i, mathOperators, operator, params, results;
    mathOperators = {
      add: "+",
      sub: "-",
      mul: "*",
      div: "/"
    };
    params = letterFieldNames.slice(0, fieldNames.length);
    results = [];
    for (functionName in mathOperators) {
      operator = mathOperators[functionName];
      results.push(this._definePrototypeMethodViaEval(functionName, params.join(', '), "if (this.isNumber(b)) {\n  return this._into(\n  null,\n  " + (((function() {
        var j, len, results1;
        results1 = [];
        for (i = j = 0, len = fieldNames.length; j < len; i = ++j) {
          f = fieldNames[i];
          results1.push("this." + f + " " + operator + " " + params[i]);
        }
        return results1;
      })()).join(",\n  ")) + "\n  );\n} else if (this.isNumber(a)) {\n  return this._into(\n  b,\n  " + (((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = fieldNames.length; j < len; j++) {
          f = fieldNames[j];
          results1.push("this." + f + " " + operator + " a");
        }
        return results1;
      })()).join(",\n  ")) + "\n  );\n} else {\n  return this._into(\n  b,\n  " + (((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = fieldNames.length; j < len; j++) {
          f = fieldNames[j];
          results1.push("this." + f + " " + operator + " a." + f);
        }
        return results1;
      })()).join(",\n  ")) + "\n  );\n}"));
    }
    return results;
  };

  Base._defineCore = function(fields) {
    var f, field, fieldList, j, len;
    fieldList = fields.join(', ');
    this._definePrototypeMethodViaEval("_into", "into, " + fieldList, "if (into === true)\n  into = this;\nelse\n  into = into || new this.class;\nreturn into._setAll(" + fieldList + ");");
    this._definePrototypeMethodViaEval("_setAll", fieldList, (((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = fields.length; j < len; j++) {
        f = fields[j];
        results.push("this." + f + " = " + f);
      }
      return results;
    })()).join(";\n")) + ";\nreturn this;");
    this._definePrototypeMethodViaEval("with", fieldList, "if (this.eq(" + fieldList + "))\n  return this;\nelse\n  return new this.class(" + fieldList + ");");
    this._definePrototypeMethodViaEval("clone", '', "return new this.class(" + (((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = fields.length; j < len; j++) {
        field = fields[j];
        results.push("this." + field);
      }
      return results;
    })()).join(',')) + ");");
    for (j = 0, len = fields.length; j < len; j++) {
      field = fields[j];
      this._definePrototypeMethodViaEval("with" + (upperCamelCase(field)), field, "return this.with(\n  " + (((function() {
        var l, len1, results;
        results = [];
        for (l = 0, len1 = fields.length; l < len1; l++) {
          f = fields[l];
          results.push(f === field ? f : "this." + f);
        }
        return results;
      })()).join(",\n  ")) + "\n);");
    }
    this._definePrototypeMethodViaEval("interpolate", "b, p, into", "var oneMinusP = 1 - p;\nreturn this._into(\ninto,\n" + (((function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = fields.length; l < len1; l++) {
        f = fields[l];
        results.push("b." + f + " * p + this." + f + " * oneMinusP");
      }
      return results;
    })()).join(",\n")) + "\n);");
    this._definePrototypeMethodViaEval("toArray", "", "return [" + (((function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = fields.length; l < len1; l++) {
        f = fields[l];
        results.push("this." + f);
      }
      return results;
    })()).join(", ")) + "];");
    return this._definePrototypeMethodViaEval("toObject", "", "return {" + (((function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = fields.length; l < len1; l++) {
        f = fields[l];
        results.push(f + ": this." + f);
      }
      return results;
    })()).join(", ")) + "};");
  };

  return Base;

})(BaseObject);


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
var Animator, Atomic, Canvas, DrawCacheManager, Element, ElementBase, ElementDrawAreaMixin, ElementDrawMixin, Foundation, GlobalEpochCycle, Join, Layout, Matrix, Point, PointLayout, Promise, Rectangle, StateEpoch, Unique, arrayWithout, arrayWithoutValue, ceil, clone, compact, compactFlatten, config, createWithPostCreate, currentSecond, defaultSize, defineModule, drawCacheManager, each, find, floatEq, floatEq0, floor, formattedInspect, globalEpochCycle, identityMatrix, insert, inspect, inspectLean, inspectedObjectLiteral, isArray, isFunction, isInfiniteResult, isNumber, isPlainArray, isPlainObject, isPoint, isString, keepIfRubyTrue, log, matrix, max, merge, mergeInto, min, minimumOrderedOverlappingMerge, modulo, namedPoints, neq, nonStatePropertyKeyTest, object, perimeter, perimeter0, plainObjectsDeepEq, point, point0, point1, pointLayout, present, rect, ref, ref1, remove, repeat, rgbColor, rubyTrue, shallowEq, stateEpoch, stats, time, toInspectedObjects, zeroedStats,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Atomic = __webpack_require__(4);

Foundation = __webpack_require__(2);

Canvas = __webpack_require__(11);

Animator = __webpack_require__(210);

Layout = __webpack_require__(40);

ElementBase = __webpack_require__(215);

StateEpoch = __webpack_require__(37);

GlobalEpochCycle = __webpack_require__(26);

ref = __webpack_require__(74), ElementDrawMixin = ref.ElementDrawMixin, DrawCacheManager = ref.DrawCacheManager, ElementDrawAreaMixin = ref.ElementDrawAreaMixin;

config = __webpack_require__(73).config;

isInfiniteResult = __webpack_require__(75).isInfiniteResult;

rgbColor = Atomic.rgbColor, point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, Matrix = Atomic.Matrix, matrix = Atomic.matrix, identityMatrix = Atomic.identityMatrix, point0 = Atomic.point0, point1 = Atomic.point1, perimeter0 = Atomic.perimeter0, isPoint = Atomic.isPoint, perimeter = Atomic.perimeter;

namedPoints = Point.namedPoints;

floor = Math.floor, ceil = Math.ceil;

globalEpochCycle = GlobalEpochCycle.globalEpochCycle;

drawCacheManager = DrawCacheManager.drawCacheManager;

PointLayout = Layout.PointLayout;

pointLayout = PointLayout.pointLayout;

ref1 = __webpack_require__(77), each = ref1.each, find = ref1.find, arrayWithout = ref1.arrayWithout, neq = ref1.neq, inspect = ref1.inspect, inspectLean = ref1.inspectLean, clone = ref1.clone, time = ref1.time, plainObjectsDeepEq = ref1.plainObjectsDeepEq, shallowEq = ref1.shallowEq, Unique = ref1.Unique, compact = ref1.compact, compactFlatten = ref1.compactFlatten, keepIfRubyTrue = ref1.keepIfRubyTrue, log = ref1.log, insert = ref1.insert, remove = ref1.remove, merge = ref1.merge, max = ref1.max, min = ref1.min, arrayWithoutValue = ref1.arrayWithoutValue, minimumOrderedOverlappingMerge = ref1.minimumOrderedOverlappingMerge, isPlainObject = ref1.isPlainObject, isPlainArray = ref1.isPlainArray, isNumber = ref1.isNumber, isString = ref1.isString, isFunction = ref1.isFunction, mergeInto = ref1.mergeInto, floatEq = ref1.floatEq, floatEq0 = ref1.floatEq0, Join = ref1.Join, rubyTrue = ref1.rubyTrue, createWithPostCreate = ref1.createWithPostCreate, currentSecond = ref1.currentSecond, repeat = ref1.repeat, present = ref1.present, Promise = ref1.Promise, modulo = ref1.modulo, inspectedObjectLiteral = ref1.inspectedObjectLiteral, defineModule = ref1.defineModule, isArray = ref1.isArray, formattedInspect = ref1.formattedInspect, object = ref1.object, toInspectedObjects = ref1.toInspectedObjects;

stats = clone(zeroedStats = {
  stagingBitmapsCreated: 0,
  lastStagingBitmapSize: null,
  elementsDrawn: 0
});

defaultSize = point(100);

stateEpoch = StateEpoch.stateEpoch;

nonStatePropertyKeyTest = ElementBase.nonStatePropertyKeyTest;

defineModule(module, Element = (function(superClass) {
  var childrenWithout, defaultLocationLayout, defaultSizeLayout, getLocationPointLayout, getSizePointLayout, namedChildrenSizeFunctions, namedLocationLayouts, namedLocationLayoutsRaw, namedSizeLayouts, namedSizeLayoutsRaw, noChildren;

  extend(Element, superClass);

  Element.registerWithElementFactory = function() {
    return true;
  };

  Element.stats = stats;

  Element.resetStats = function() {
    return mergeInto(stats, zeroedStats);
  };

  Element.created = 0;

  Element.createdByType = {};

  Element.resetCreated = function() {
    Element.created = 0;
    return Element.createdByType = {};
  };

  function Element(options, children) {
    var childrenArray, i, j, ref2;
    Element.created++;
    Element.__super__.constructor.call(this, options);
    this._propertiesInitialized = false;
    if (arguments.length === 2 && children && children.constructor === Array) {
      if (children.length > 0) {
        this.setChildren(children);
      }
    } else if (arguments.length > 1) {
      childrenArray = new Array(arguments.length - 1);
      for (i = j = 1, ref2 = arguments.length; j < ref2; i = j += 1) {
        childrenArray[i - 1] = arguments[i];
      }
      this.setChildren(childrenArray);
    }
    this._propertiesInitialized = true;
  }

  Element.prototype._initFields = function() {
    Element.__super__._initFields.apply(this, arguments);
    this._resetDrawCache();
    this._initTemporaryFields();
    this._initComputedFields();
    this._activeAnimator = null;
    this._toVoidAnimationStatus = false;
    return this._locationLayoutDisabled = false;
  };

  Element.prototype._initTemporaryFields = function() {
    this._currentDrawTarget = null;
    this._currentToTargetMatrix = null;
    this._lastParentSize = null;
    return this._bitmapFactory = null;
  };

  Element.prototype._initComputedFields = function() {
    this._elementSpaceDrawArea = null;
    this._filterChildren = [];
    this._rootElement = this;
    this._elementToAbsMatrix = null;
    this._absToElementMatrix = null;
    return this._parentToElementMatrix = null;
  };

  Element.getter({
    absToElementMatrix: function() {
      return this._absToElementMatrix || (this._absToElementMatrix = this._parent ? this._parent.getAbsToElementMatrix().mul(this.getParentToElementMatrix()) : this.getParentToElementMatrix());
    },
    parentToElementMatrix: function() {
      return this._parentToElementMatrix || (this._parentToElementMatrix = this._elementToParentMatrix.inv);
    },
    elementToDocumentMatrix: function() {
      return this.getElementToAbsMatrix().mul(this.getCanvasElement()._absToDocumentMatrix);
    },
    documentToElementMatrix: function() {
      return this.getCanvasElement()._documentToAbsMatrix.mul(this.getAbsToElementMatrix());
    },
    absOpacity: function() {
      var opacity, parent;
      opacity = this.getVisible() ? this.getOpacity() : 0;
      if (parent = this.getParent()) {
        opacity *= parent.getAbsOpacity();
      }
      return opacity;
    },
    isChanging: function() {
      return this.__stateChangeQueued;
    },
    isFilter: function() {
      return false;
    },
    rootElement: function() {
      return this._rootElement || (this._rootElement = this._parent ? this._parent.getRootElement() : this);
    },
    bitmapFactory: function() {
      var ref2;
      return this._bitmapFactory || ((ref2 = this.getCanvasElement()) != null ? ref2.bitmapFactory : void 0) || Canvas.Bitmap;
    },
    devicePixelsPerPoint: function() {
      return this.getRootElement()._devicePixelsPerPoint || 1;
    },
    canvasElement: function() {
      var re;
      re = this.getRootElement();
      if (re !== this) {
        return re.getCanvasElement();
      } else {
        return null;
      }
    }
  });

  Element.prototype.transformToParentSpace = function(p) {
    return this._elementToParentMatrix.transform(p);
  };

  Element.prototype.transformFromParentSpace = function(p) {
    return this._elementToParentMatrix.inverseTransform(p);
  };

  Element.prototype._clearRootElement = function() {
    var child, j, len, oldRootElement, ref2, results1;
    if (oldRootElement = this._rootElement) {
      this._rootElement = null;
      this.queueEvent("rootElementChanged", (function(_this) {
        return function() {
          return {
            oldRootElement: oldRootElement,
            rootElement: _this.getRootElement()
          };
        };
      })(this));
      ref2 = this._children;
      results1 = [];
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        results1.push(child._clearRootElement());
      }
      return results1;
    }
  };

  Element.prototype.preprocessEventHandlers = function(handlerMap) {
    var k, v;
    for (k in handlerMap) {
      v = handlerMap[k];
      if (k === "rootElementChanged") {
        this.getRootElement();
      }
    }
    return handlerMap;
  };

  Element.setter({
    absToElementMatrix: function(aToE) {
      return this.setElementToAbsMatrix(aToE.invert());
    },
    parentToElementMatrix: function(pToE) {
      return this.setElementToParentMatrix(pToE.invert());
    }
  });

  defaultSizeLayout = new PointLayout({
    ps: 1
  });

  defaultLocationLayout = new PointLayout(0);

  namedSizeLayoutsRaw = {
    parentSize: {
      ps: 1
    },
    childrenSize: {
      cs: 1
    },
    parentHeightSquare: {
      hh: 1,
      wh: 1
    },
    parentWidthSquare: {
      hw: 1,
      ww: 1
    },
    childrenSizeMaxParentWidth: {
      cs: 1,
      max: {
        ww: 1
      }
    },
    parentHeightChildrenWidth: {
      hh: 1,
      wcw: 1
    },
    parentWidthChildrenHeight: {
      ww: 1,
      hch: 1
    },
    parentHeightChildrenWidthMaxParentWidth: {
      wcw: 1,
      hh: 1,
      max: {
        ww: 1
      }
    }
  };

  namedSizeLayouts = object(namedSizeLayoutsRaw, function(v) {
    return pointLayout(v);
  });

  Element.getSizePointLayout = getSizePointLayout = function(v, previousValue) {
    var l;
    if (isString(v)) {
      if (!(l = namedSizeLayouts[v])) {
        throw new Error("invalid named size layout: " + v);
      }
      if (previousValue) {
        return pointLayout(namedSizeLayoutsRaw[v], previousValue);
      } else {
        return l;
      }
    } else {
      return pointLayout(v, previousValue || defaultSizeLayout);
    }
  };

  namedLocationLayoutsRaw = object(namedPoints, function(ps) {
    return {
      ps: ps
    };
  });

  namedLocationLayoutsRaw[0] = 0;

  namedLocationLayouts = object(namedLocationLayoutsRaw, function(v) {
    return pointLayout(v);
  });

  Element.getLocationPointLayout = getLocationPointLayout = function(v, previousValue) {
    var l;
    if (v === 0 || isString(v)) {
      if (!(l = namedLocationLayouts[v])) {
        throw new Error("invalid named location layout: " + v);
      }
      if (previousValue) {
        return pointLayout(namedLocationLayoutsRaw[v], previousValue);
      } else {
        return l;
      }
    } else {
      return pointLayout(v, previousValue || defaultLocationLayout);
    }
  };

  Element.drawLayoutProperty({
    size: {
      "default": "parentSize",
      validate: function(v) {
        if (isString(v)) {
          return !!namedSizeLayouts[v];
        } else {
          return true;
        }
      },
      preprocess: getSizePointLayout
    }
  });

  Element.layoutProperty({

    /*
    TODO: Update StateEpochLayout to use: childrenSizePreprocessor
    
    How do we want to handle currentPadding?
      - is it always set; gut: yes
      - should childrenSizePreprocessor be responsible for including padding?
      - should we check before calling childrenSizePreprocessor? If it is length 4,
        then padding is added after?
    
      - I kinda want to NOT include currentPadding, at least not most the time.
        99% of the time it is going to be the exact same calulation:
    
        if currentPadding
          right += currentPadding.getWidth()
          bottom += currentPadding.getHeight()
    
        which, if applied after, would look like this:
    
          childrenSizePreprocessor(...).add currentPadding.getWidth(), currentPadding.getHeight()
           * note, this only creates a second point if there is non-zero padding.
    
    childrenSizePreprocessor:
      default: (left, top, right, bottom) -> point right, bottom
      validate: (v) -> isFunction v
     */
    location: {
      "default": 0,
      validate: function(v) {
        if (isString(v)) {
          return !!namedLocationLayouts[v];
        } else {
          return true;
        }
      },
      preprocess: getLocationPointLayout,
      postSetter: function() {
        return this._locationLayoutDisabled = false;
      }
    },
    scale: {
      "default": 1,
      preprocess: function(s) {
        if (isFunction(s)) {
          return s;
        } else {
          return point(s);
        }
      },
      postSetter: function() {
        return this._locationLayoutDisabled = false;
      }
    },
    angle: {
      "default": 0,
      postSetter: function() {
        return this._locationLayoutDisabled = false;
      }
    },
    childrenLayout: {
      "default": null,
      validate: function(v) {
        return v === null || v === "flow" || v === "column" || v === "row";
      }
    },
    childrenAlignment: {
      "default": point0,
      preprocess: function(v) {
        return point(v);
      }
    },
    axis: {
      "default": point0,
      preprocess: function(v) {
        return point(v);
      }
    },
    inFlow: {
      "default": true,
      preprocess: function(v) {
        return !!v;
      }
    },
    layoutWeight: {
      "default": 1,
      validate: function(v) {
        return isNumber(v);
      }
    },
    padding: {
      "default": 0,
      drawAreaProperty: true,
      preprocess: function(v) {
        if (isFunction(v)) {
          return v;
        } else if (v === false || v === void 0 || v === null) {
          return null;
        } else {
          return perimeter(v);
        }
      }
    },
    margin: {
      "default": null,
      preprocess: function(v) {
        if (isFunction(v)) {
          return v;
        } else if (v === false || v === void 0 || v === null) {
          return null;
        } else {
          return perimeter(v);
        }
      }
    },
    childrenMargins: {
      "default": null,
      preprocess: function(v) {
        if (isFunction(v)) {
          return v;
        } else if (v === false || v === void 0 || v === null) {
          return null;
        } else {
          return perimeter(v);
        }
      }
    }
  });

  namedChildrenSizeFunctions = {
    ignoreTransforms: function(child) {
      return child.getPendingCurrentSize();
    },
    totalArea: function(child, into) {
      return child.getAreaInParentSpace(true, into);
    },
    logicalArea: function(child, into) {
      return child.getLogicalAreaInParentSpace(true, into);
    }
  };

  Element.layoutProperty({

    /*
    childArea returns the area for a single child
    as part of the childrenSize computation for layout.
    
    Legal values:
      A string matching one of the namedChildrenSizeFunctions (Above)
      customChildAreaFunction
        IN:
          child (Element)
          intoRectangle
            For efficiency, you can optionally write your result into "intoRectangle"
            and return intoRectangle.
            This avoids creating new objects.
        OUT: area expressed as a point or rect
          if a point, top == left == 0, right == x, bottom == y
    
    Note: This happens during layout, so if providing a custom
      function, you should use getPending* functions to
      inspect the child element to get current values.
    
    Note: Currently, childArea is ignored if childrenLayout is set.
     */
    childArea: {
      "default": null,
      preprocess: function(v) {
        if (isFunction(v)) {
          return v;
        } else {
          return namedChildrenSizeFunctions[v];
        }
      },
      validate: function(v) {
        return (v == null) || isFunction(v) || namedChildrenSizeFunctions[v];
      }
    }
  });

  Element.concreteProperty({
    currentSize: {
      "default": defaultSize,
      setter: function(_new, _old) {
        return _old;
      }
    },
    currentPadding: {
      "default": perimeter0,
      setter: function(_new, _old) {
        return _old;
      }
    },
    currentMargin: {
      "default": perimeter0,
      setter: function(_new, _old) {
        return _old;
      }
    }
  });

  Element.virtualProperty({
    currentLocationX: function(pending, customAxis) {
      var a, p, s, state;
      state = this.getState(pending);
      s = state._currentSize;
      a = customAxis || state._axis;
      p = state._currentPadding;
      return state._elementToParentMatrix.transformX(s.x * a.x - p.left, s.y * a.y - p.top);
    },
    currentLocationY: function(pending, customAxis) {
      var a, p, s, state;
      state = this.getState(pending);
      s = state._currentSize;
      a = customAxis || state._axis;
      p = state._currentPadding;
      return state._elementToParentMatrix.transformY(s.x * a.x - p.left, s.y * a.y - p.top);
    },
    currentLocation: function(pending, elementToParentMatrix) {
      var a, p, s, state;
      state = this.getState(pending);
      s = state._currentSize;
      a = state._axis;
      p = state._currentPadding;
      elementToParentMatrix || (elementToParentMatrix = state._elementToParentMatrix);
      return elementToParentMatrix.transformXY(s.x * a.x - p.left, s.y * a.y - p.top);
    },
    currentAngle: function(pending) {
      var state;
      state = this.getState(pending);
      return state._elementToParentMatrix.angle;
    },
    currentScale: function(pending) {
      var state;
      state = this.getState(pending);
      return state._elementToParentMatrix.getExactScale();
    },
    elementToAbsMatrix: {
      getter: function(pending) {
        var state;
        state = this.getState(pending);
        return state._elementToAbsMatrix || (state._elementToAbsMatrix = state._parent ? state._elementToParentMatrix.mul(state._parent.getElementToAbsMatrix()) : state._elementToParentMatrix);
      },
      setter: function(eToA) {
        return this.setElementToParentMatrix(this._parent ? eToA.mul(this._parent.getAbsToElementMatrix()) : eToA);
      }
    }
  });

  Element.getter({
    currentElementToParentMatrix: function(pending, withLocation, withScale) {
      if (withLocation || withScale) {
        withLocation || (withLocation = this.getCurrentLocation(pending));
        return this._getElementToParentMatrixForXY(pending, withLocation.x, withLocation.y, withScale);
      } else {
        return this.getState(pending)._elementToParentMatrix;
      }
    }
  });

  Element.concreteProperty({
    cursor: {
      "default": null,
      validate: function(v) {
        return !v || typeof v === "string";
      }
    },
    elementToParentMatrix: {
      "default": Matrix.identityMatrix,
      preprocess: function(v) {
        return matrix(v);
      },
      setter: function(v) {
        this._locationLayoutDisabled = true;
        return matrix(v);
      }
    },
    parent: {
      "default": null,
      setter: function(p) {
        if (p) {
          p.addChild(this);
        } else {
          this.removeFromParent();
        }
        return p;
      }
    },
    children: {
      "default": noChildren = [],
      setter: function(newChildren, oldChildren) {
        var child, childrenHaveRemovedAnimations, firstTimeSettingChildren, j, keepOldChildren, len, len1, len2, len3, n, oldParent, q, r;
        this.__drawPropertiesChanged = true;
        newChildren = compactFlatten(newChildren, keepIfRubyTrue);
        firstTimeSettingChildren = oldChildren === noChildren;
        this._filterChildren = null;
        for (j = 0, len = oldChildren.length; j < len; j++) {
          child = oldChildren[j];
          if (!(child.getPendingHasToVoidAnimators())) {
            continue;
          }
          childrenHaveRemovedAnimations = true;
          break;
        }
        if (childrenHaveRemovedAnimations) {
          keepOldChildren = [];
          for (n = 0, len1 = oldChildren.length; n < len1; n++) {
            child = oldChildren[n];
            if (child._toVoidAnimationStatus === "done") {
              child._toVoidAnimationStatus = false;
            } else if (indexOf.call(newChildren, child) >= 0) {
              keepOldChildren.push(child);
            } else if (child.getPendingHasToVoidAnimators()) {
              child._activateToVoidAnimators();
              keepOldChildren.push(child);
            }
          }
          newChildren = minimumOrderedOverlappingMerge(keepOldChildren, newChildren);
        }
        for (q = 0, len2 = oldChildren.length; q < len2; q++) {
          child = oldChildren[q];
          if (indexOf.call(newChildren, child) < 0) {
            child._setParentOnly(null);
          }
        }
        for (r = 0, len3 = newChildren.length; r < len3; r++) {
          child = newChildren[r];
          if (child.getIsFilter()) {
            (this._filterChildren || (this._filterChildren = [])).push(child);
          }
          if ((oldParent = child.getPendingParent()) !== this) {
            if (oldParent != null) {
              oldParent._setChildrenOnly(oldParent.pendingChildrenWithout(child));
            }
            child._setParentOnly(this);
          }
        }
        this._filterChildren || (this._filterChildren = noChildren);
        return newChildren;
      }
    }
  });


  /*
  Apply f to each child
  return: this
  
  SBD NOTE: 2015-11-5 We should start using this for all child iteration.
    It will allow us to implement Spans in the future.
  
     * basic span sketch:
    for child in @_children
      if isSpan child
        child.eachChild f
      else
        f child
  
     * span sketch with span-properties:
    class ElementBase
      eachChild: (f, spanProps) ->
        for child in @_children
          if isSpan child
            child.eachChild f, spanProps
          else
            f child, spanProps
  
    class Span extends ElementBase
      eachChild: (f, spanProps) ->
        if @props
          spanProps = if spanProps
            merge spanProps, @props
          else
            @props
        super f, spanProps
   */

  Element.prototype.eachChild = function(f) {
    var child, j, len, ref2;
    ref2 = this._children;
    for (j = 0, len = ref2.length; j < len; j++) {
      child = ref2[j];
      f(child);
    }
    return this;
  };

  Element.prototype._toVoidAnimationDone = function() {
    var animator, prop, ref2;
    ref2 = this.animators;
    for (prop in ref2) {
      animator = ref2[prop];
      if ((animator.toVoid != null) && (animator.active != null)) {
        return;
      }
    }
    this._toVoidAnimationStatus = "done";
    return this.removeFromParent();
  };

  Element.prototype._activateToVoidAnimators = function() {
    var animator, prop, ref2, results1;
    if (!(!this._toVoidAnimationStatus && this.getPendingHasToVoidAnimators())) {
      return;
    }
    this._toVoidAnimationStatus = "active";
    ref2 = this.getPendingAnimators();
    results1 = [];
    for (prop in ref2) {
      animator = ref2[prop];
      if (animator.getHasToVoidAnimation()) {
        results1.push(animator.startToVoidAnimation(this).then((function(_this) {
          return function() {
            return _this._toVoidAnimationDone();
          };
        })(this)));
      }
    }
    return results1;
  };

  Element.getter({
    logicalArea: function() {
      var left, ref2, ref3, top, x, y;
      ref2 = this.getCurrentPadding(), left = ref2.left, top = ref2.top;
      ref3 = this._currentSize, x = ref3.x, y = ref3.y;
      return new Rectangle(-left, -top, x, y);
    },
    paddedWidth: function() {
      return this._currentSize.x - this.getCurrentPadding().getWidth();
    },
    paddedHeight: function() {
      return this._currentSize.y - this.getCurrentPadding().getHeight();
    },
    paddedSize: function() {
      var p, ref2, x, y;
      p = this.getCurrentPadding();
      ref2 = this._currentSize, x = ref2.x, y = ref2.y;
      return point(x - p.getWidth(), y - p.getHeight());
    },
    paddedArea: function() {
      var p, size;
      p = this.getCurrentPadding();
      size = this._currentSize;
      return new Rectangle(0, 0, max(0, size.x - p.getWidth()), max(0, size.y - p.getHeight()));
    }
  });

  Element.drawAreaProperty({
    clip: {
      "default": false,
      preprocess: function(v) {
        return !!v;
      }
    }
  });

  Element.drawLayoutProperty({
    visible: {
      "default": true,
      preprocess: function(v) {
        return !!v;
      }
    }
  });

  Element.concreteProperty({
    opacity: {
      "default": 1,
      validate: function(v) {
        return typeof v === "number";
      }
    },
    compositeMode: {
      "default": "normal",
      validate: function(v) {
        return typeof v === "string";
      }
    },
    pointerEventPriority: {
      "default": 0,
      preprocess: function(v) {
        return v | 0;
      }
    },
    userProps: {
      "default": null,
      validate: function(v) {
        return (v == null) || isPlainObject(v);
      }

      /*
        Can be:
          (pointInElementSpace, thisElement, pointInParentSpace) -> true / false
        OR:
          'never' == -> false
          'inLogicalArea'   == (pointInElementSpace, thisElement) -> thisElement.logicalAreaInElementSpace.contains pointInElementSpace
          'inPaddedArea'    == (pointInElementSpace, thisElement) -> thisElement.paddedAreaInElementSpace.contains pointInElementSpace
          'passToChildren'  == calls pointerInside for every child, returns true if any return true
       */
    },
    receivePointerEvents: {
      "default": "inLogicalArea",
      validate: function(v) {
        return isFunction(v) || v === "never" || v === "inLogicalArea" || v === "inPaddedArea" || v === "passToChildren";
      }
    },
    pointInsideTest: {
      "default": null,
      validate: function(v) {
        return !v || isFunction(v);
      }
    }
  });

  Element.virtualProperty({
    invisible: {
      getter: function(pending) {
        return this.getState(pending)._visible;
      },
      setter: function(v) {
        return this.setVisible(!v);
      }
    },
    hasToVoidAnimators: {
      getter: function(pending) {
        var animator, animators, prop;
        if (animators = this.getState(pending)._animators) {
          for (prop in animators) {
            animator = animators[prop];
            if (animator.hasToVoidAnimation) {
              return true;
            }
          }
        }
        return false;
      }
    },
    isMask: {
      getter: function(pending) {
        return this.getState(pending)._compositeMode === "alphaMask";
      },
      setter: function(v) {
        return this.setCompositeMode(v ? "alphaMask" : "normal");
      }
    },
    opacityPercent: function(pending) {
      var state;
      state = this.getState(pending);
      return state._opacity * 100 | 0;
    },
    hasMask: function(pending) {
      var child, j, len, ref2, state;
      state = this.getState(pending);
      ref2 = state._children;
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        if (child.isMask) {
          return true;
        }
      }
      return false;
    },
    firstMask: function(pending) {
      var child, j, len, ref2, state;
      state = this.getState(pending);
      ref2 = state._children;
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        if (child.isMask) {
          return child;
        }
      }
    },
    sizeAffectsLocation: function(pending) {
      var state;
      state = this.getState(pending);
      return state._axis.x !== 0 || state._axis.y !== 0;
    },
    absoluteAxis: function(pending) {
      var state;
      state = this.getState(pending);
      return state._currentSize.mul(state._axis);
    },
    sizeForChildren: function(pending, customParentSize) {
      var _currentPadding, _currentSize, ref2;
      ref2 = this.getState(pending), _currentPadding = ref2._currentPadding, _currentSize = ref2._currentSize;
      return _currentPadding.subtractedFromSize(customParentSize || _currentSize);
    },
    parentSizeForChildren: function(pending) {
      var ref2;
      return ((ref2 = this.getState(pending)._parent) != null ? ref2.getSizeForChildren(pending) : void 0) || defaultSize;
    },
    nextSibling: {
      getter: function(pending) {
        var parent;
        parent = this.getState(pending)._parent;
        return [parent, (parent != null ? parent.getChildren(pending)[parent.getChildIndex(this, pending) + 1] : void 0) || null];
      },
      setter: function(siblingOrPair) {
        return this.placeRelativeToSibling(siblingOrPair, 0);
      }
    },
    prevSibling: {
      getter: function(pending) {
        var parent;
        parent = this.getState(pending)._parent;
        return [parent, (parent != null ? parent.getChildren(pending)[parent.getChildIndex(this, pending) - 1] : void 0) || null];
      },
      setter: function(siblingOrPair) {
        return this.placeRelativeToSibling(siblingOrPair, 1);
      }
    },
    maxXInParentSpace: function(pending) {
      var _currentPadding, _currentSize, _elementToParentMatrix, bottom, left, ref2, right, top;
      ref2 = this.getState(pending), _currentPadding = ref2._currentPadding, _currentSize = ref2._currentSize, _elementToParentMatrix = ref2._elementToParentMatrix;
      right = _currentSize.x + (left = -_currentPadding.left);
      bottom = _currentSize.y + (top = -_currentPadding.top);
      return max((_elementToParentMatrix.transformX(left, top), _elementToParentMatrix.transformX(left, bottom), _elementToParentMatrix.transformX(right, top), _elementToParentMatrix.transformX(right, bottom)));
    },
    maxYInParentSpace: function(pending) {
      var _currentPadding, _currentSize, _elementToParentMatrix, bottom, left, ref2, right, top;
      ref2 = this.getState(pending), _currentPadding = ref2._currentPadding, _currentSize = ref2._currentSize, _elementToParentMatrix = ref2._elementToParentMatrix;
      right = _currentSize.x + (left = -_currentPadding.left);
      bottom = _currentSize.y + (top = -_currentPadding.top);
      return max((_elementToParentMatrix.transformY(left, top), _elementToParentMatrix.transformY(left, bottom), _elementToParentMatrix.transformY(right, top), _elementToParentMatrix.transformY(right, bottom)));
    },
    areaInParentSpace: function(pending, into) {
      var _currentPadding, _currentSize, _elementToParentMatrix, bottom, left, ref2, right, top, x, x1, x2, x3, x4, y, y1, y2, y3, y4;
      ref2 = this.getState(pending), _currentPadding = ref2._currentPadding, _currentSize = ref2._currentSize, _elementToParentMatrix = ref2._elementToParentMatrix;
      into || (into = new Rectangle);
      right = _currentSize.x + (left = -_currentPadding.left);
      bottom = _currentSize.y + (top = -_currentPadding.top);
      into.x = x = min(x1 = _elementToParentMatrix.transformX(left, top), x2 = _elementToParentMatrix.transformX(left, bottom), x3 = _elementToParentMatrix.transformX(right, top), x4 = _elementToParentMatrix.transformX(right, bottom));
      into.y = y = min(y1 = _elementToParentMatrix.transformY(left, top), y2 = _elementToParentMatrix.transformY(left, bottom), y3 = _elementToParentMatrix.transformY(right, top), y4 = _elementToParentMatrix.transformY(right, bottom));
      into.w = max(x1, x2, x3, x4) - x;
      into.h = max(y1, y2, y3, y4) - y;
      return into;
    },
    logicalAreaInParentSpace: function(pending, into) {
      var _axis, _currentSize, ref2;
      ref2 = this.getState(pending), _axis = ref2._axis, _currentSize = ref2._currentSize;
      into || (into = new Rectangle);
      into.x = this.getCurrentLocationX(pending) - _currentSize.x * _axis.x;
      into.y = this.getCurrentLocationY(pending) - _currentSize.y * _axis.y;
      into.w = _currentSize.x;
      into.h = _currentSize.y;
      return into;
    },
    widthInParentSpace: function(pending) {
      var a, b, bottom, c, d, left, padding, right, state, top;
      state = this.getState(pending);
      padding = state._currentPadding;
      left = -padding.left;
      top = -padding.top;
      right = state._currentSize.x + left;
      bottom = state._currentSize.y + top;
      a = state._elementToParentMatrix.transformX(left, top);
      b = state._elementToParentMatrix.transformX(left, bottom);
      c = state._elementToParentMatrix.transformX(right, top);
      d = state._elementToParentMatrix.transformX(right, bottom);
      return max(a, b, c, d) - min(a, b, c, d);
    },
    heightInParentSpace: function(pending) {
      var a, b, bottom, c, d, left, padding, right, state, top;
      state = this.getState(pending);
      padding = state._currentPadding;
      left = -padding.left;
      top = -padding.top;
      right = state._currentSize.x + left;
      bottom = state._currentSize.y + top;
      a = state._elementToParentMatrix.transformY(left, top);
      b = state._elementToParentMatrix.transformY(left, bottom);
      c = state._elementToParentMatrix.transformY(right, top);
      d = state._elementToParentMatrix.transformY(right, bottom);
      return max(a, b, c, d) - min(a, b, c, d);
    },
    layoutLocationParentCircular: function(pending) {
      var ref2, state;
      state = this.getState(pending);
      return !!state._location.layoutIsCircular((ref2 = state._parent) != null ? ref2.getState(pending)._size : void 0);
    },
    layoutSizeParentCircular: function(pending) {
      var ref2, state;
      state = this.getState(pending);
      return !!state._size.layoutIsCircular((ref2 = state._parent) != null ? ref2.getState(pending)._size : void 0);
    },
    layoutMovesChildren: function(pending) {
      return !!(this.getState(pending))._childrenLayout;
    }
  });

  Element.getter({
    allChildrenAreUpLayout: function() {
      return false;
    }
  });


  /*
  INFO
   */

  Element.getter({
    coreProps: function() {
      var j, len, prop, properties, ret;
      properties = [this._axis && !this.axis.eq(point()) ? "axis" : void 0, !this.location.eq(point0) ? "location" : void 0, this._currentSize ? "size" : void 0, !floatEq0(this.angle) ? "angle" : void 0, !this.scale.eq(point(1, 1)) ? "scale" : void 0, this._compositeMode && this._compositeMode !== "normal" ? "compositeMode" : void 0, (this._opacity != null) && this._opacity < 1 ? "opacity" : void 0, this._invisible ? "invisible" : void 0, this._layout ? "layout" : void 0];
      ret = {};
      for (j = 0, len = properties.length; j < len; j++) {
        prop = properties[j];
        if (prop) {
          ret[prop] = this[prop];
        }
      }
      return ret;
    },
    requiresParentStagingBitmap: function() {
      return this._compositeMode !== "normal";
    },
    firstChildRequiringParentStagingBitmap: function() {
      var child, j, len, ref2;
      ref2 = this._children;
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        if (child.getRequiresParentStagingBitmap()) {
          return child;
        }
      }
    },
    childRequiresParentStagingBitmap: function() {
      return !!this.getFirstChildRequiringParentStagingBitmap();
    }
  });

  Element.prototype.inspectParentStructure = function(elementPath) {
    if (elementPath == null) {
      elementPath = this.elementPath;
    }
    if (elementPath.length === 1) {
      return [elementPath[0].inspectedName, elementPath[0].coreProps];
    } else {
      return [elementPath[0].inspectedName, elementPath[0].coreProps, this.inspectParentStructure(elementPath.slice(1))];
    }
  };

  Element.prototype.inspectChildrenStructure = function() {
    var child;
    return [this.inspectedName, this.coreProps].concat((function() {
      var j, len, ref2, results1;
      ref2 = this._children;
      results1 = [];
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        results1.push(child.inspectChildrenStructure());
      }
      return results1;
    }).call(this));
  };

  Element.prototype.inspectRender = function(toBitmapOptions, callback) {
    var childArea;
    childArea = toBitmapOptions.area || "parentLogicalArea";
    return this.onNextReady((function(_this) {
      return function() {
        var child, fn, i, j, joiner, len, ref2;
        joiner = new Join;
        joiner["do"](function(done) {
          return _this.toBitmapWithInfo(merge(toBitmapOptions, {
            area: "logicalArea"
          }), function(bitmap) {
            var outPut;
            outPut = {};
            outPut[_this.inspectedName] = [_this.inspectedName, bitmap];
            return done(outPut);
          });
        });
        ref2 = _this.children;
        fn = function(child, i) {
          return joiner["do"](function(done) {
            return child.toBitmapWithInfo(merge(toBitmapOptions, {
              area: childArea
            }), function(bitmap) {
              var ret;
              ret = {};
              ret["child" + i] = [child.inspectedName, bitmap];
              return done(ret);
            });
          });
        };
        for (i = j = 0, len = ref2.length; j < len; i = ++j) {
          child = ref2[i];
          fn(child, i);
        }
        return joiner.join(function(results) {
          return callback(merge(results));
        });
      };
    })(this));
  };

  Element.prototype.logInspectRender = function(toBitmapOptions) {
    if (toBitmapOptions == null) {
      toBitmapOptions = {};
    }
    toBitmapOptions.pixelsPerPoint || (toBitmapOptions.pixelsPerPoint = this.devicePixelsPerPoint);
    return this.inspectRender(toBitmapOptions, (function(_this) {
      return function(results) {
        return _this.log(results);
      };
    })(this));
  };

  Element.prototype.abortAnimations = function() {
    if (this._activeAnimator) {
      return this._activeAnimator.abort();
    }
  };

  Element.prototype.finishAnimations = function() {
    if (this._activeAnimator) {
      return this._activeAnimator.finish();
    }
  };

  Element.prototype.startChildAddedAnimation = function(child) {
    var animation;
    if (animation = child.getPendingAddedAnimation() || (this._propertiesInitialized && this.getPendingChildAddedAnimation())) {
      return child.animate = animation;
    }
  };

  Element.getter({
    hasCustomClipping: function() {
      return false;
    }
  });

  Element.prototype._elementToParentMatrixChanged = function(oldElementToParentMatrix) {};


  /*
  Creates and returns an bitmap with the current element drawn on it
  IN:
    options: plain object
      backgroundColor: [transparent]  #
      area: DEFAULT: "drawArea"
        "logicalArea"         means => drawArea: @logicalArea,                  elementToDrawAreaMatrix: identityMatrix
        "paddedArea"          means => drawArea: @paddedArea,                   elementToDrawAreaMatrix: identityMatrix
        "drawArea"            means => drawArea: @elementSpaceDrawArea,         elementToDrawAreaMatrix: identityMatrix
        "parentLogicalArea"   means => drawArea: @parent.logicalArea,           elementToDrawAreaMatrix: @elementToParentMatrix
        "parentPaddedArea"    means => drawArea: @parent.paddedArea,            elementToDrawAreaMatrix: @elementToParentMatrix
        "parentDrawArea"      means => drawArea: @parent.elementSpaceDrawArea,  elementToDrawAreaMatrix: @elementToParentMatrix
        "targetDrawArea"    to be used with custom elementToDrawAreaMatrix - sets drawArea to include @elementSpaceDrawArea in the specificed target-space
      size: [drawArea.size]     # Bitmap size. Will be multiplied by pixelsPerPoint for the final size.
      mode: ["fit"], "zoom"     # determines how the requested drawArea is scaled to fit the bitmap size
        "fit" - scaled so requested area is <= size
          final size adjusted to have the same aspect ratio as the requested area
        "zoom" - scaled so reqeusted area is >= size
          size is not altered
      pixelsPerPoint: [1]       # Ex: set to "2" for "retina" images [default = 1]
      elementToDrawAreaMatrix:  # the draw matrix [see area's defaults]
      drawArea: [see area]      # the area to capture in drawArea-space (overrides area's drawArea)
      bitmapFactory: [null]     # overrides default bitmapFactory
    OR
    size: anything that point() accepts
  
  OUT promise.then ({bitmap, elementToBitmapMatrix}) ->
   */

  Element.prototype.toBitmapWithInfo = function(optionsOrSize) {
    var options;
    if (optionsOrSize == null) {
      optionsOrSize = {};
    }
    if (!isPlainObject(options = optionsOrSize)) {
      options = {
        size: point(optionsOrSize)
      };
    }
    return new Promise((function(_this) {
      return function(resolve) {
        return stateEpoch.onNextReady(function() {
          var results;
          resolve(results = _this.toBitmapSync(options));
          return typeof callback === "function" ? callback(results.bitmap, results.elementToBitmapMatrix) : void 0;
        });
      };
    })(this));
  };

  Element.prototype.toBitmap = function(options) {
    log.error("DEPRICATED: ArtEngine.Element.toBitmap use toBitmapBasic of toBitmapWithInfo");
    return this.toBitmapWithInfo(options);
  };

  Element.prototype.toBitmapBasic = function(options) {
    if (this.key === "child") {
      throw new Error("GOTCHA!");
    }
    return this.toBitmapWithInfo(options).then(function(arg) {
      var bitmap;
      bitmap = arg.bitmap;
      return bitmap;
    });
  };

  Element.prototype.toBitmapSync = function(options) {
    var areaOptions, backgroundColor, bitmap, bitmapFactory, drawArea, elementToBitmapMatrix, elementToDrawAreaMatrix, mode, oldBitmapFactory, pixelsPerPoint, ratio, scale, size;
    if (options == null) {
      options = {};
    }
    if (options.elementToDrawAreaMatrix && !options.area) {
      options.area = "targetDrawArea";
    }
    areaOptions = (function() {
      switch (options.area || "drawArea") {
        case "logicalArea":
          return {
            drawArea: this.logicalArea,
            elementToDrawAreaMatrix: identityMatrix
          };
        case "paddedArea":
          return {
            drawArea: this.paddedArea,
            elementToDrawAreaMatrix: identityMatrix
          };
        case "drawArea":
          return {
            drawArea: this.elementSpaceDrawArea,
            elementToDrawAreaMatrix: identityMatrix
          };
        case "parentLogicalArea":
          return {
            drawArea: this.parent.logicalArea,
            elementToDrawAreaMatrix: this.elementToParentMatrix
          };
        case "parentPaddedArea":
          return {
            drawArea: this.parent.paddedArea,
            elementToDrawAreaMatrix: this.elementToParentMatrix
          };
        case "parentDrawArea":
          return {
            drawArea: this.parent.elementSpaceDrawArea,
            elementToDrawAreaMatrix: this.elementToParentMatrix
          };
        case "targetDrawArea":
          return {
            drawArea: this.drawAreaIn(options.elementToDrawAreaMatrix || identityMatrix),
            elementToDrawAreaMatrix: identityMatrix
          };
        default:
          throw new Error("invalid area option: " + options.area);
      }
    }).call(this);
    options = merge(areaOptions, options);
    drawArea = options.drawArea, elementToDrawAreaMatrix = options.elementToDrawAreaMatrix, size = options.size, mode = options.mode, bitmapFactory = options.bitmapFactory, pixelsPerPoint = options.pixelsPerPoint, backgroundColor = options.backgroundColor;
    pixelsPerPoint || (pixelsPerPoint = 1);
    mode || (mode = "fit");
    size = point(size || drawArea.size).mul(pixelsPerPoint).ceil();
    ratio = size.div(drawArea.size.max(point1));
    if (mode === "zoom") {
      scale = ratio.max();
    } else {
      scale = ratio.min();
      size = drawArea.size.mul(scale).ceil();
    }
    elementToBitmapMatrix = elementToDrawAreaMatrix.mul(Matrix.translate(drawArea.cc.neg).scale(scale).translate(size.cc));
    oldBitmapFactory = this._bitmapFactory;
    this._bitmapFactory = bitmapFactory || this.bitmapFactory;
    bitmap = this.bitmapFactory.newBitmap(size.max(point1));
    bitmap.pixelsPerPoint = pixelsPerPoint;
    if (backgroundColor) {
      bitmap.clear(backgroundColor);
    }
    this.drawOnBitmap(bitmap, elementToBitmapMatrix);
    this._bitmapFactory = oldBitmapFactory;
    return {
      bitmap: bitmap,
      elementToBitmapMatrix: elementToBitmapMatrix
    };
  };

  Element.prototype.logBitmap = function(options) {
    if (options == null) {
      options = {};
    }
    options.pixelsPerPoint || (options.pixelsPerPoint = this.devicePixelsPerPoint);
    return this.toBitmapBasic(options).then((function(_this) {
      return function(bitmap) {
        return _this.log({
          currentSize: _this.currentSize,
          currentLocation: _this.currentLocation,
          size: _this.size,
          location: _this.location,
          elementToParentMatrix: _this.elementToParentMatrix,
          bitmap: bitmap
        });
      };
    })(this));
  };

  Element.prototype.fillShape = function(target, elementToTargetMatrix, options) {
    if (options == null) {
      options = {};
    }
  };

  Element.prototype.strokeShape = function(target, elementToTargetMatrix, options) {
    if (options == null) {
      options = {};
    }
  };

  Element.prototype.compositingChanged = function() {
    return this.getOpacityChanged() || this.getCompositeModeChanged();
  };

  Element.getter({
    redrawRequired: function() {
      var _pendingState;
      _pendingState = this._pendingState;
      return this.__drawPropertiesChanged || (this._opacity !== _pendingState._opacity) || (this._compositeMode !== _pendingState._compositeMode) || (this._parent !== _pendingState._parent) || (!this._currentSize.eq(_pendingState._currentSize)) || (!this._elementToParentMatrix.eq(_pendingState._elementToParentMatrix));
    }
  });

  Element.prototype._setChildrenOnly = function(c) {
    this._pendingState._children = c;
    this._elementChanged();
    return c;
  };

  Element.prototype._setParentOnly = function(p) {
    this._pendingState._parent = p;
    this._elementChanged();
    return p;
  };

  Element.prototype._getElementToParentMatrixForXY = function(pending, x, y, withScale, withParentSize) {
    var _angle, _axis, _currentPadding, _currentSize, _elementToParentMatrix, _parent, _scale, axis, axisXInElementSpace, axisYInElementSpace, currentX, currentY, left, parentSize, ref2, size, state, top;
    ref2 = state = this.getState(pending), _currentPadding = ref2._currentPadding, _currentSize = ref2._currentSize, _axis = ref2._axis, _scale = ref2._scale, _angle = ref2._angle, _elementToParentMatrix = ref2._elementToParentMatrix;
    if (withScale != null) {
      _scale = withScale;
    }
    if (isFunction(_scale)) {
      _parent = state._parent;
      parentSize = withParentSize || _parent.getState(pending)._currentSize;
      _scale = _scale(parentSize, _currentSize);
    }
    _scale = point(_scale);
    left = _currentPadding.left, top = _currentPadding.top;
    size = _currentSize;
    axis = _axis;
    axisXInElementSpace = axis.x * size.x - left;
    axisYInElementSpace = axis.y * size.y - top;
    if (this._locationLayoutDisabled) {
      currentX = _elementToParentMatrix.transformX(axisXInElementSpace, axisYInElementSpace);
      currentY = _elementToParentMatrix.transformY(axisXInElementSpace, axisYInElementSpace);
      return _elementToParentMatrix.translate(x - currentX, y - currentY);
    } else {
      return (new Matrix).translateXY(-axisXInElementSpace, -axisYInElementSpace, true).scale(_scale, true).rotate(_angle, true).translateXY(x, y, true);
    }
  };

  Element.prototype._setElementToParentMatrixFromLayout = function(l, parentSize) {
    return this._setElementToParentMatrixFromLayoutXY(l.x, l.y, parentSize);
  };

  Element.prototype._setElementToParentMatrixFromLayoutXY = function(x, y, parentSize) {
    var e2p;
    if (this._locationLayoutDisabled) {
      return;
    }
    e2p = this._getElementToParentMatrixForXY(true, x, y, null, parentSize);
    if (!this._pendingState._elementToParentMatrix.eq(e2p)) {
      this._pendingState._elementToParentMatrix = e2p;
      this._elementChanged();
    }
    return this;
  };

  Element.prototype._translateLocationXY = function(x, y) {
    this._pendingState._elementToParentMatrix = this._pendingState._elementToParentMatrix.translateXY(x, y);
    return this._elementChanged();
  };

  Element.prototype._sizeDirectlyEffectsDrawing = function() {
    var c;
    return ((c = this.getPendingChildren()) && c.length === 0) || this.getPendingClip();
  };

  Element.prototype._setSizeFromLayout = function(s) {
    var x, y;
    x = s.x, y = s.y;
    if (!s.eq(this.getPendingCurrentSize())) {
      this._pendingState._currentSize = s;
      if (this._sizeDirectlyEffectsDrawing()) {
        this.__drawPropertiesChanged = true;
      }
      this._elementChanged();
      return s;
    }
  };

  Element.prototype._setPaddingFromLayout = function(p) {
    this._pendingState._currentPadding = p;
    this._elementChanged();
    return p;
  };

  Element.prototype._setMarginFromLayout = function(m) {
    this._pendingState._currentMargin = m;
    this._elementChanged();
    return m;
  };

  Element.prototype._setElementToParentMatrixWithoutChangingLocation = function(m) {
    var ax, axis, ay, o, size, x1, x2, y1, y2;
    o = this._pendingState;
    size = o._currentSize;
    axis = o._axis;
    ax = size.x * axis.x;
    ay = size.y * axis.y;
    x1 = o._elementToParentMatrix.transformX(ax, ay);
    y1 = o._elementToParentMatrix.transformY(ax, ay);
    x2 = m.transformX(ax, ay);
    y2 = m.transformY(ax, ay);
    return this.setElementToParentMatrix(m.translateXY(x1 - x2, y1 - y2));
  };

  Element.prototype.getElementToElementMatrix = function(o) {
    if (o == null) {
      o = this.getRootElement();
    }
    if (o === this) {
      return matrix();
    } else {
      return this.getElementToAbsMatrix().mul(o.getAbsToElementMatrix());
    }
  };

  Element.prototype.getElementToTargetMatrix = function(parentToTargetMatrix) {
    return this._elementToParentMatrix.mul(parentToTargetMatrix);
  };


  /*
  returns:
    if ancestor is not an actual ancestor to v
      @elementToAbsMatrix.transform v
    else
      ancestor.absToElementMatrix.transform @elementToAbsMatrix.transform v
  performance:
    only creates one object, the returned point, no matter how far away the ancestor is.
   */

  Element.prototype.transformToAncestorSpace = function(v, ancestor) {
    var element, x, x1, y, y1;
    x = v.x, y = v.y;
    element = this;
    while (element) {
      x1 = element._elementToParentMatrix.transformX(x, y);
      y1 = element._elementToParentMatrix.transformY(x, y);
      x = x1;
      y = y1;
      element = element.parent;
      if (element === ancestor) {
        return point(x, y);
      }
    }
    return null;
  };

  Element.prototype.transformToAncestorSpaceX = function(v, ancestor) {
    var element, x, y;
    if (isPoint(v)) {
      x = v.x, y = v.y;
    } else {
      x = v;
      y = 0;
    }
    element = this;
    while (element) {
      x = element._elementToParentMatrix.transformX(x, y);
      y = element._elementToParentMatrix.transformY(x, y);
      element = element.parent;
      if (element === ancestor) {
        return x;
      }
    }
    return null;
  };

  Element.prototype.transformToAncestorSpaceY = function(v, ancestor) {
    var element, x, y;
    if (isPoint(v)) {
      x = v.x, y = v.y;
    } else {
      x = 0;
      y = v;
    }
    element = this;
    while (element) {
      x = element._elementToParentMatrix.transformX(x, y);
      y = element._elementToParentMatrix.transformY(x, y);
      element = element.parent;
      if (element === ancestor) {
        return y;
      }
    }
    return null;
  };

  Element.prototype.pointInsideChildren = function(p) {
    return !!(this._visible && !!this.childUnderPoint(this.getParentToElementMatrix().transform(p)));
  };

  Element.prototype.pointInside = function(p) {
    var h, p2EM, padding, size, w, x, y;
    return this._visible && !this.getIsMask() && (function() {
      if (isFunction(this._receivePointerEvents)) {
        return this._receivePointerEvents(this.getParentToElementMatrix().transform(p), this, p);
      } else {
        switch (this._receivePointerEvents) {
          case "never":
            return false;
          case "passToChildren":
            return this.pointInsideChildren(p);
          case "inPaddedArea":
            p2EM = this.getParentToElementMatrix();
            size = this._currentSize;
            padding = this._currentPadding;
            x = p2EM.transformX(p.x, p.y);
            y = p2EM.transformY(p.x, p.y);
            w = size.x - padding.getWidth();
            h = size.y - padding.getHeight();
            return x >= 0 && y >= 0 && x < w && y < h;
          case "inLogicalArea":
            p2EM = this.getParentToElementMatrix();
            size = this._currentSize;
            padding = this._currentPadding;
            x = p2EM.transformX(p.x, p.y);
            y = p2EM.transformY(p.x, p.y);
            x += padding.left;
            y += padding.top;
            w = size.x;
            h = size.y;
            return x >= 0 && y >= 0 && x < w && y < h;
        }
      }
    }).call(this);
  };

  Element.prototype.childUnderPoint = function(pointInElementSpace) {
    var child, j, ref2;
    ref2 = this._children;
    for (j = ref2.length - 1; j >= 0; j += -1) {
      child = ref2[j];
      if (child.pointInside(pointInElementSpace)) {
        return child;
      }
    }
    return false;
  };

  Element.prototype.getChildIndex = function(child, pending) {
    return this.getChildren(pending).indexOf(child);
  };

  Element.prototype.find = function(pattern, arg, matches) {
    var child, findAll, functionResult, j, len, matchAgainst, matchFound, ref2, ref3, usedFunction, verbose;
    ref2 = arg != null ? arg : {}, findAll = ref2.findAll, verbose = ref2.verbose;
    if (matches == null) {
      matches = [];
    }
    matchFound = (usedFunction = isFunction(pattern)) ? !!(functionResult = pattern(this)) : (matchAgainst = "" + this.pathStringWithNames + (this.key ? ":" + this.key : "") + ":" + this.objectId, matchAgainst.match(pattern));
    if (matchFound) {
      if (verbose) {
        this.log(usedFunction ? {
          found: this.inspectedNameWithoutIds,
          functionResult: functionResult
        } : {
          found: this.inspectedNameWithoutIds,
          pattern: pattern,
          matched: matchAgainst
        });
      }
      matches.push(this);
    }
    if (!matchFound || findAll) {
      ref3 = this._children;
      for (j = 0, len = ref3.length; j < len; j++) {
        child = ref3[j];
        child.find(pattern, arguments[1], matches);
      }
    }
    return matches;
  };

  Element.prototype.findElementsWithKey = function(key) {
    return this.find(function(e) {
      return e.key === key;
    });
  };

  Element.prototype.findElementWithKey = function(key) {
    var first;
    first = this.findElementsWithKey(key)[0];
    return first;
  };

  Element.getter({
    elementPathWithoutIds: function() {
      if (this.parent) {
        return this.parent.elementPath + " > " + this.classPathNameAndId;
      } else {
        return this.classPathNameAndId;
      }
    },
    topMostParent: function() {
      if (this._parent) {
        return this._parent.topMostParent || this._parent;
      } else {
        return null;
      }
    },
    hasChildren: function() {
      return this._children.length > 0;
    },
    reverseChildren: function() {
      return this._children.slice().reverse();
    },
    elementPath: function() {
      var elementPath;
      if (this.parent) {
        elementPath = this.parent.elementPath;
        elementPath.push(this);
        return elementPath;
      } else {
        return [this];
      }
    },
    pathIdString: function() {
      var p;
      return ((function() {
        var j, len, ref2, results1;
        ref2 = this.elementPath;
        results1 = [];
        for (j = 0, len = ref2.length; j < len; j++) {
          p = ref2[j];
          results1.push(p.className + p.objectId);
        }
        return results1;
      }).call(this)).join('/');
    },
    pathString: function() {
      var p;
      return ((function() {
        var j, len, ref2, results1;
        ref2 = this.elementPath;
        results1 = [];
        for (j = 0, len = ref2.length; j < len; j++) {
          p = ref2[j];
          results1.push(p.className);
        }
        return results1;
      }).call(this)).join('/');
    },
    pathStringWithNames: function() {
      var p;
      return ((function() {
        var j, len, ref2, results1;
        ref2 = this.elementPath;
        results1 = [];
        for (j = 0, len = ref2.length; j < len; j++) {
          p = ref2[j];
          results1.push(p.inspectedNameWithoutIds);
        }
        return results1;
      }).call(this)).join('/');
    },
    fullPathString: function() {
      var p;
      return ((function() {
        var j, len, ref2, results1;
        ref2 = this.elementPath;
        results1 = [];
        for (j = 0, len = ref2.length; j < len; j++) {
          p = ref2[j];
          results1.push(p.classPathNameAndId);
        }
        return results1;
      }).call(this)).join('/');
    },
    childrenInspectedNames: function() {
      var c, j, len, ref2, results1;
      ref2 = this._children;
      results1 = [];
      for (j = 0, len = ref2.length; j < len; j++) {
        c = ref2[j];
        results1.push(c.inspectedName);
      }
      return results1;
    },
    inspectedObjects: function() {
      var child;
      return [inspectedObjectLiteral(this.inspectedName), toInspectedObjects(this.minimalProps)].concat((function() {
        var j, len, ref2, results1;
        ref2 = this.children;
        results1 = [];
        for (j = 0, len = ref2.length; j < len; j++) {
          child = ref2[j];
          results1.push(child.inspectedObjects);
        }
        return results1;
      }).call(this));
    }
  });

  childrenWithout = function(children, child) {
    var index;
    children = children.slice();
    if ((index = children.indexOf(child)) >= 0) {
      remove(children, index, 1);
    }
    return children;
  };

  Element.prototype.childrenWithout = function(child) {
    return childrenWithout(this._children, child);
  };

  Element.prototype.pendingChildrenWithout = function(child) {
    return childrenWithout(this.getPendingChildren(), child);
  };

  Element.prototype.insertChild = function(child, index) {
    var children;
    children = this.pendingChildrenWithout(child);
    if (index < 0) {
      index = children.length + 1 + index;
    }
    this.setChildren(insert(children, index, child));
    return child;
  };

  Element.prototype.addChild = function(child) {
    return this.insertChild(child, -1);
  };

  Element.prototype.addChildBelow = function(child, belowChild) {
    var children;
    if (!(belowChild !== child && indexOf.call(this.getPendingChildren(), belowChild) >= 0)) {
      return this.insertChild(child, 0);
    }
    children = this.pendingChildrenWithout(child);
    this.setChildren(insert(children, children.indexOf(belowChild), child));
    return child;
  };

  Element.prototype.addChildAbove = function(child, aboveChild) {
    var children;
    if (!(aboveChild !== child && indexOf.call(this.getPendingChildren(), aboveChild) >= 0)) {
      return this.insertChild(child, -1);
    }
    children = this.pendingChildrenWithout(child);
    this.setChildren(insert(children, children.indexOf(aboveChild) + 1, child));
    return child;
  };

  Element.prototype.addBelow = function(sibling) {
    return sibling.getPendingParent().addChildBelow(this, sibling);
  };

  Element.prototype.addAbove = function(sibling) {
    return sibling.getPendingParent().addChildAbove(this, sibling);
  };

  Element.prototype.addChildBelowMask = function(child) {
    return this.addChildBelow(child, this.getPendingFirstMask());
  };

  Element.prototype.placeRelativeToSibling = function(siblingOrPair, offset) {
    var children, parent, sibling;
    if (siblingOrPair && siblingOrPair.constructor === Array) {
      if (siblingOrPair.length !== 2) {
        throw new Error("If array is provided, it must be formated: [parent, sibling]");
      }
      parent = siblingOrPair[0], sibling = siblingOrPair[1];
      if (sibling && sibling.getPendingParent() !== parent) {
        throw new Error("Sibling's current parent does not match specified parent. Did the sibling move?");
      }
    } else {
      sibling = siblingOrPair;
      parent = (sibling != null ? sibling.getPendingParent() : void 0) || this.getPendingParent();
    }
    if (!parent) {
      if (!sibling) {
        return this.setParent(null);
      } else {
        throw new Error("Can't place next to sibling. Sibling is an orphan.");
      }
    }
    children = parent.pendingChildrenWithout(this);
    return parent.setChildren(insert(children, children.indexOf(sibling) + offset, this));
  };

  Element.prototype.removeChild = function(child) {
    if (!child) {
      return;
    }
    this.setChildren(this.pendingChildrenWithout(child));
    return child;
  };

  Element.prototype.releaseChildren = function() {
    return this.setChildren([]);
  };

  Element.prototype.removeFromParent = function() {
    var p, ref2;
    if ((ref2 = (p = this.getPendingParent())) != null) {
      ref2.removeChild(this);
    }
    return p;
  };

  Element.prototype.moveChildToFront = function(child) {
    return this.insertChild(child, -1);
  };

  Element.prototype.moveChildToBack = function(child) {
    return this.insertChild(child, 0);
  };

  Element.prototype.moveToFront = function() {
    var ref2;
    return (ref2 = this.getPendingParent()) != null ? ref2.insertChild(this, -1) : void 0;
  };

  Element.prototype.moveToBack = function() {
    var ref2;
    return (ref2 = this.getPendingParent()) != null ? ref2.insertChild(this, 0) : void 0;
  };

  Element.prototype.moveBelow = function(sibling) {
    var ref2;
    return sibling != null ? (ref2 = sibling.getPendingParent()) != null ? ref2.addChildBelow(this, sibling) : void 0 : void 0;
  };

  Element.prototype.moveBelowMask = function() {
    var ref2;
    return (ref2 = this.getPendingParent()) != null ? ref2.addChildBelowMask(this) : void 0;
  };

  Element.prototype._sizeChanged = function(newSize, oldSize) {
    return this.queueEvent("sizeChanged", {
      oldSize: oldSize,
      size: newSize
    });
  };

  Element.prototype._applyStateChanges = function() {
    var oldElementToParentMatrix, parentChanged, releaseCount;
    if (this.getCurrentSizeChanged()) {
      this._sizeChanged(this._pendingState._currentSize, this._currentSize);
    }
    if (this.getElementToParentMatrixChanged()) {
      oldElementToParentMatrix = this._elementToParentMatrix;
    }
    parentChanged = this.parentChanged;
    Element.__super__._applyStateChanges.apply(this, arguments);
    if (this.__drawAreaChanged) {
      this._drawAreaChanged();
    }
    if (this.__drawPropertiesChanged) {
      this._drawPropertiesChanged();
    }
    if (oldElementToParentMatrix) {
      this._elementToParentMatrixChanged(oldElementToParentMatrix);
    }
    this.__drawAreaChanged = false;
    this.__redrawRequired = false;
    this.__drawPropertiesChanged = false;
    this.__layoutPropertiesChanged = false;
    if (parentChanged && !this._parent) {
      return releaseCount = this._releaseAllCacheBitmaps();
    }
  };

  Element.prototype._layoutPropertiesChanged = function() {};

  Element.prototype._updateDrawArea = function() {};

  Element.prototype._layoutSize = function(parentSize, childrenSize) {
    return this.getPendingSize().layout(parentSize, childrenSize);
  };

  Element.prototype._layoutSizeForChildren = function(parentSize, childrenSize) {
    var out, sizeLayout, x, y;
    sizeLayout = this.getPendingSize();
    out = sizeLayout.layout(parentSize, childrenSize);
    if (sizeLayout.getChildrenRelative()) {
      x = out.x, y = out.y;
      return out["with"](isInfiniteResult(x) ? parentSize.x : x, isInfiniteResult(y) ? parentSize.y : y);
    } else {
      return out;
    }
  };

  Element.prototype._layoutLocation = function(parentSize) {
    return this.getPendingLocation().layout(parentSize);
  };

  Element.prototype._layoutLocationX = function(parentSize) {
    return this.getPendingLocation().layoutX(parentSize);
  };

  Element.prototype._layoutLocationY = function(parentSize) {
    return this.getPendingLocation().layoutY(parentSize);
  };

  Element.prototype.depth = function() {
    if (this.parent) {
      return this.parent.depth() + 1;
    } else {
      return 1;
    }
  };

  Element.getter({
    focused: function() {
      var c;
      return !!((c = this.getCanvasElement()) && c.isFocused(this));
    }
  });

  Element.prototype._focus = function() {
    var ref2;
    return (ref2 = this.getCanvasElement()) != null ? ref2.focusElement(this) : void 0;
  };

  Element.prototype._blur = function() {
    var ref2;
    if (!this.focused) {
      return;
    }
    return (ref2 = this.getCanvasElement()) != null ? ref2.focusElement(this.parent) : void 0;
  };

  Element.prototype._focusDomElement = function() {
    var ref2;
    return (ref2 = this.getCanvasElement()) != null ? ref2.focusCanvas() : void 0;
  };

  Element.prototype.focus = function() {
    return this._focus();
  };

  Element.prototype.blur = function() {
    return this._blur();
  };

  Element.prototype.capturePointerEvents = function() {
    var ref2;
    return (ref2 = this.getCanvasElement()) != null ? ref2.capturePointerEvents(this) : void 0;
  };

  Element.getter({
    pointerEventsCaptured: function() {
      var ref2;
      return (ref2 = this.getCanvasElement()) != null ? ref2.pointerEventsCapturedBy(this) : void 0;
    }
  });


  /*
  nonChildrenLayoutFirstPass: a function
    EFFECT:
      optionally sets the location and/or size of
      one or more first-pass-children
  
      Always iterate through firstPassChildren and NOT @children!
    IN:
      firstPassSizeForChildrenConstrained
        Simpler picture of layout at first-pass.
        Any nearInfinite values are replaced with the respective parentSize.
  
      firstPassSizeForChildrenUnconstrained
        More accurately captures the layout picture at the first-pass, but
          may contain nearInfinite values.
        Useful for flow/text layout.
  
        NOTE: FlexLayout (currently/2017) doesn't need this at all, so most
        layouts shouldn't need it.
  
    OUT: childrenSizeBase
    EFFECT:
      sets size and location for children
  
    childrenSizeBase is unioned with the computed area for all children
  
  nonChildrenLayoutFinalPass: a function
    IN: finalSizeForChildren
      This is the finalSize, passed through @getSizeForChildren()
  
    OUT: ignored
   */

  Element.prototype.nonChildrenLayoutFirstPass = null;

  Element.prototype.nonChildrenLayoutFinalPass = null;

  Element.prototype.postFlexLayout = function(mainCoordinate, inFlowChildren) {};

  return Element;

})(ElementDrawMixin(ElementDrawAreaMixin(ElementBase))));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
var Atomic, Epoch, Foundation, Point, StateEpoch, StateEpochLayout, childrenDrawChanged, childrenDrawUnchanged, defineModule, globalCount, inspect, isMobileBrowser, log, longestCommonSubsequence, point, requestAnimationFrame, select,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

StateEpochLayout = __webpack_require__(219);

point = Atomic.point, Point = Atomic.Point;

log = Foundation.log, requestAnimationFrame = Foundation.requestAnimationFrame, longestCommonSubsequence = Foundation.longestCommonSubsequence, select = Foundation.select, inspect = Foundation.inspect, Epoch = Foundation.Epoch, globalCount = Foundation.globalCount, defineModule = Foundation.defineModule;

isMobileBrowser = Foundation.Browser.isMobileBrowser();

childrenDrawUnchanged = function(before, after) {
  return window.lcs = longestCommonSubsequence(before, after);
};

childrenDrawChanged = function(before, after) {
  var child, i, len, results;
  if (before) {
    results = [];
    for (i = 0, len = before.length; i < len; i++) {
      child = before[i];
      if (indexOf.call(childrenDrawUnchanged(before, after), child) < 0) {
        results.push(child);
      }
    }
    return results;
  } else {
    return after;
  }
};

defineModule(module, StateEpoch = (function(superClass) {
  var epochCount, markChildrenRedrawRequired;

  extend(StateEpoch, superClass);

  StateEpoch.singletonClass();

  StateEpoch._stateEpochLayoutInProgress = false;

  function StateEpoch() {
    StateEpoch.__super__.constructor.call(this, {
      emptyQueueAfterProcessing: true
    });
  }

  StateEpoch.prototype._addChangingElement = function(element) {
    return this.queueItem(element);
  };

  StateEpoch.prototype._isChangingElement = function(element) {
    return this.isItemQueued(element);
  };

  StateEpoch.prototype.computeDepth = function(element) {
    if (!element) {
      return 0;
    }
    return element.__depth = 1 + this.computeDepth(element.getPendingParent());
  };

  StateEpoch.prototype.computeDepths = function(changingElements) {
    var element, i, len;
    for (i = 0, len = changingElements.length; i < len; i++) {
      element = changingElements[i];
      this.computeDepth(element);
    }
    return null;
  };

  StateEpoch.prototype.sortChangingElementsDepthsAscending = function(changingElements) {
    return changingElements.sort(function(a, b) {
      return a.__depth - b.__depth;
    });
  };

  StateEpoch.prototype.notifyLayoutPropertiesChanged = function(changingElements) {
    var element, i, len;
    for (i = 0, len = changingElements.length; i < len; i++) {
      element = changingElements[i];
      if (element.__layoutPropertiesChanged) {
        element._layoutPropertiesChanged();
      }
    }
    return null;
  };

  StateEpoch.prototype.getDrawChangedElements = function(changingElements) {
    var el, i, len, results;
    results = [];
    for (i = 0, len = changingElements.length; i < len; i++) {
      el = changingElements[i];
      if (el.__redrawRequired) {
        results.push(el);
      }
    }
    return results;
  };

  StateEpoch.prototype.informAncestorsElementNeedsRedrawing = function(el) {
    el._needsRedrawing();
    return null;
  };

  StateEpoch.prototype.applyStateChanges = function(changingElements) {
    var el, i, len;
    for (i = 0, len = changingElements.length; i < len; i++) {
      el = changingElements[i];
      el._applyStateChanges();
    }
    return null;
  };

  markChildrenRedrawRequired = function(element) {
    var child, i, len, ref;
    if (element.getChildrenChanged()) {
      ref = childrenDrawChanged(element.children, element.getPendingChildren());
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        child.__redrawRequired = true;
      }
    }
    return null;
  };

  StateEpoch.prototype.markRedrawRequired = function(changingElements) {
    var element, i, len;
    for (i = 0, len = changingElements.length; i < len; i++) {
      element = changingElements[i];
      element.__redrawRequired = element.getRedrawRequired();
      markChildrenRedrawRequired(element);
    }
    return null;
  };

  StateEpoch.prototype.markDrawAreaChanged = function(changingElements) {
    var element, i, len, parent;
    for (i = 0, len = changingElements.length; i < len; i++) {
      element = changingElements[i];
      element.__drawAreaChanged || (element.__drawAreaChanged = element.getChildrenChanged() || (element.getCurrentSizeChanged() && (element.getPendingChildren().length === 0 || element.getPendingClip())));
      if (element.getElementToParentMatrixChanged()) {
        if (parent = element.getPendingParent()) {
          parent.__drawAreaChanged = true;
          parent._elementChanged();
        }
      }
    }
    return null;
  };

  StateEpoch.prototype.resetAbsMatriciesR = function(element) {
    var child, i, len, ref;
    if (element._elementToAbsMatrix === null && element._absToElementMatrix === null) {
      return;
    }
    element._elementToAbsMatrix = element._absToElementMatrix = null;
    element.queueEvent("absMatriciesChanged");
    ref = element.getPendingChildren();
    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      this.resetAbsMatriciesR(child);
    }
    return null;
  };

  StateEpoch.prototype.resetParentToElementMatricies = function(elements) {
    var el, i, len;
    for (i = 0, len = elements.length; i < len; i++) {
      el = elements[i];
      if (el) {
        if (el.getElementToParentMatrixChanged()) {
          el._parentToElementMatrix = null;
        }
      }
    }
    return null;
  };

  StateEpoch.prototype.getElementToAbsMatrixChangedElementsDepthAscending = function(changingElements) {
    var el, i, len, results;
    results = [];
    for (i = 0, len = changingElements.length; i < len; i++) {
      el = changingElements[i];
      if (el.getElementToParentMatrixChanged() || el.getParentChanged()) {
        results.push(el);
      }
    }
    return results;
  };

  StateEpoch.prototype.resetAbsMatricies = function(elements) {
    var el, i, len;
    for (i = 0, len = elements.length; i < len; i++) {
      el = elements[i];
      this.resetAbsMatriciesR(el);
    }
    return null;
  };

  StateEpoch.prototype.updateElementParentChangingElements = function(changingElements) {
    var el, i, len;
    for (i = 0, len = changingElements.length; i < len; i++) {
      el = changingElements[i];
      if (!(el.getParentChanged())) {
        continue;
      }
      el._clearRootElement();
      el._updateRegistryFromPendingState();
    }
    return null;
  };

  StateEpoch.prototype.recomputeMousePathAndCursor = function(changingElements) {
    var el, i, len, ref, rootElement, testedRoots;
    testedRoots = [];
    for (i = 0, len = changingElements.length; i < len; i++) {
      el = changingElements[i];
      rootElement = el.getRootElement();
      if (indexOf.call(testedRoots, rootElement) < 0) {
        testedRoots.push(rootElement);
        if ((ref = rootElement.pointerEventManager) != null) {
          ref.updateMousePath();
        }
      }
    }
    return null;
  };

  epochCount = 0;

  StateEpoch.prototype.inspectChangingElements = function(changingElements) {
    var c, ce, changing, changingKeys, key, newV, o, oldV;
    return {
      epoch: ++epochCount,
      changingElements: (function() {
        var i, j, len, len1, results;
        results = [];
        for (i = 0, len = changingElements.length; i < len; i++) {
          ce = changingElements[i];
          o = {};
          if ((changingKeys = ce._getChangingStateKeys()).length > 0) {
            o.changing = changing = {};
            for (j = 0, len1 = changingKeys.length; j < len1; j++) {
              key = changingKeys[j];
              oldV = ce[key];
              newV = ce._pendingState[key];
              switch (key) {
                case "_parent":
                  oldV = oldV != null ? oldV.inspectedName : void 0;
                  newV = newV != null ? newV.inspectedName : void 0;
                  break;
                case "_children":
                  oldV = (function() {
                    var k, len2, results1;
                    results1 = [];
                    for (k = 0, len2 = oldV.length; k < len2; k++) {
                      c = oldV[k];
                      results1.push(c.inspectedName);
                    }
                    return results1;
                  })();
                  newV = (function() {
                    var k, len2, results1;
                    results1 = [];
                    for (k = 0, len2 = newV.length; k < len2; k++) {
                      c = newV[k];
                      results1.push(c.inspectedName);
                    }
                    return results1;
                  })();
              }
              changing[key] = {
                old: oldV,
                "new": newV
              };
            }
          }
          o.__depth = ce.__depth;
          if (ce.__drawAreaChanged) {
            o.drawAreaChanged = true;
          }
          if (ce.__redrawRequired) {
            o.drawPropertiesChanged = true;
          }
          results.push([ce.inspect(), o]);
        }
        return results;
      })()
    };
  };

  StateEpoch.prototype.preprocessElementsForEpoch = function(changingElements) {
    var el, i, len;
    for (i = 0, len = changingElements.length; i < len; i++) {
      el = changingElements[i];
      el.preprocessForEpoch();
    }
    return null;
  };

  StateEpoch.prototype.processEpochItems = function(changingElements) {
    var changingElementsLength, drawChangedElements, el, elementToAbsMatrixChangedElementsDepthAscending, i, j, k, len, len1, len2, results;
    this.preprocessElementsForEpoch(changingElements);
    this.computeDepths(changingElements);
    this.notifyLayoutPropertiesChanged(changingElements);
    StateEpochLayout.markLayoutPropertiesChanged(changingElements);
    changingElementsLength = changingElements.length;
    this.sortChangingElementsDepthsAscending(changingElements);
    StateEpoch._stateEpochLayoutInProgress = true;
    StateEpochLayout.updateLayouts(changingElements);
    StateEpoch._stateEpochLayoutInProgress = false;
    this.markRedrawRequired(changingElements);
    this.markDrawAreaChanged(changingElements);
    if (changingElements.length !== changingElementsLength) {
      this.sortChangingElementsDepthsAscending(changingElements);
    }
    elementToAbsMatrixChangedElementsDepthAscending = this.getElementToAbsMatrixChangedElementsDepthAscending(changingElements);
    drawChangedElements = this.getDrawChangedElements(changingElements);
    for (i = 0, len = drawChangedElements.length; i < len; i++) {
      el = drawChangedElements[i];
      this.informAncestorsElementNeedsRedrawing(el);
    }
    this.resetParentToElementMatricies(elementToAbsMatrixChangedElementsDepthAscending);
    this.updateElementParentChangingElements(changingElements);
    this.applyStateChanges(changingElements);
    this.resetAbsMatricies(elementToAbsMatrixChangedElementsDepthAscending);
    for (j = 0, len1 = changingElements.length; j < len1; j++) {
      el = changingElements[j];
      if (el.__drawAreaChanged) {
        el._drawAreaChanged();
      }
    }
    if (!isMobileBrowser) {
      this.recomputeMousePathAndCursor(changingElements);
    }
    results = [];
    for (k = 0, len2 = drawChangedElements.length; k < len2; k++) {
      el = drawChangedElements[k];
      results.push(this.informAncestorsElementNeedsRedrawing(el));
    }
    return results;
  };

  return StateEpoch;

})(Epoch));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(54);

module.exports.includeInNamespace(__webpack_require__(412)).addModules({
  AnimatedElementMixin: __webpack_require__(212),
  CanvasElement: __webpack_require__(411),
  Element: __webpack_require__(36),
  ElementBase: __webpack_require__(215),
  ElementFactory: __webpack_require__(119),
  EngineStat: __webpack_require__(216),
  EpochedElementMixin: __webpack_require__(221),
  EventedElementMixin: __webpack_require__(222),
  GlobalEpochCycle: __webpack_require__(26),
  IdleEpoch: __webpack_require__(223),
  Lib: __webpack_require__(120),
  StandardImport: __webpack_require__(77),
  StateEpoch: __webpack_require__(37)
});

__webpack_require__(74);

__webpack_require__(415);


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var Elements,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(20)).addNamespace('Elements', Elements = (function(superClass) {
  extend(Elements, superClass);

  function Elements() {
    return Elements.__super__.constructor.apply(this, arguments);
  }

  return Elements;

})(Neptune.PackageNamespace));

__webpack_require__(226);

__webpack_require__(228);

__webpack_require__(230);

__webpack_require__(232);


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(242);

module.exports.addModules({
  InterpolatedPointLayout: __webpack_require__(436),
  PointLayout: __webpack_require__(437),
  PointLayoutBase: __webpack_require__(125)
});


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var Ery,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.Ery', Ery = (function(superClass) {
  extend(Ery, superClass);

  function Ery() {
    return Ery.__super__.constructor.apply(this, arguments);
  }

  Ery.version = __webpack_require__(330).version;

  return Ery;

})(Neptune.PackageNamespace));

__webpack_require__(252);


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

var CommonJs, isClass, isFunction, ref;

ref = __webpack_require__(12), isClass = ref.isClass, isFunction = ref.isFunction;

module.exports = CommonJs = (function() {
  var definingModule;

  function CommonJs() {}

  definingModule = null;

  CommonJs.getModuleBeingDefined = function() {
    return definingModule;
  };


  /*
  IN:
    defineFunciton ||
   */

  CommonJs.defineModule = function(_module, a) {
    var lastModule, mod, result;
    lastModule = definingModule;
    definingModule = _module;
    mod = isFunction(a) ? isClass(a) ? a : a() : a;
    result = _module.exports = (mod != null ? typeof mod.createWithPostCreate === "function" ? mod.createWithPostCreate(mod) : void 0 : void 0) || mod;
    definingModule = lastModule;
    return result;
  };

  return CommonJs;

})();


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/*
Set: global.ArtStandardLibMultipleContextTypeSupport = true
Before the first time you require this file if you need to be able to test objects
from multiple contexts.

When do you need this?
  - when working with iFrames
  - when working with Node's 'repl' or 'vm'

What is the differences?
  With: slower, but other-wise the same
  Without: plain-arrays and plain-objects from other contexts
    are not detected with isArray, isPlainArray, isPlainObject
 */
var ArtStandardLibMultipleContextTypeSupport, Types;

ArtStandardLibMultipleContextTypeSupport = global.ArtStandardLibMultipleContextTypeSupport;

module.exports = Types = (function() {
  var _functionsPrototype, hasOwnProperties, hasProperties, isArray, isClass, isDirectPrototypeOf, isExtendedClass, isFunction, isJsonAtomicType, isNonNegativeInt, isNumber, isObject, isPlainObject, isString;

  function Types() {}

  Types.isPromise = function(obj) {
    return (obj != null) && isFunction(obj.then) && !isFunction(obj);
  };

  Types.isRegExp = ArtStandardLibMultipleContextTypeSupport ? function(obj) {
    return obj.constructor.name === "RegExp";
  } : function(obj) {
    return obj.constructor === RegExp;
  };

  Types.isNumber = isNumber = function(obj) {
    return typeof obj === "number";
  };

  Types.prototype.isNonNegativeInt = function(x) {
    return ((x | 0) === x) && x >= 0;
  };

  Types.isDate = function(obj) {
    return obj && obj.constructor === Date;
  };

  Types.isString = isString = function(obj) {
    return typeof obj === "string";
  };

  Types.isFunction = isFunction = function(obj) {
    return typeof obj === "function";
  };

  Types.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };

  Types.isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  _functionsPrototype = Object.getPrototypeOf(function() {});

  Types.isClass = isClass = function(obj) {
    var prototype;
    return !!(typeof obj === "function" && ((typeof obj.__super__ === "object") || ((typeof (prototype = Object.getPrototypeOf(obj)) === "function") && prototype !== _functionsPrototype) || (hasOwnProperties(obj)) || (obj.prototype && hasProperties(obj.prototype))));
  };

  Types.isExtendedClass = isExtendedClass = function(obj) {
    var prototype;
    return !!(typeof obj === "function" && ((typeof obj.__super__ === "object") || ((typeof (prototype = Object.getPrototypeOf(obj)) === "function") && prototype !== _functionsPrototype)));
  };

  Types.isArrayUniversal = Array.isArray;

  Types.isArray = isArray = ArtStandardLibMultipleContextTypeSupport ? Types.isArrayUniversal : function(o) {
    return (o != null) && o.constructor === Array;
  };

  Types.isPlainArray = isArray;

  Types.isNonNegativeInt = isNonNegativeInt = function(x) {
    return (x | 0 === x) && x >= 0;
  };

  Types.isArrayIterable = function(source) {
    return !!(source && isNonNegativeInt(source.length));
  };

  Types.isJsonAtomicType = isJsonAtomicType = function(a) {
    return isString(a) || isNumber(a) || a === true || a === false || a === null;
  };

  Types.isJsonType = function(a) {
    return isJsonAtomicType(a) || isPlainObject(a) || isArray(a);
  };

  Types.isObject = isObject = function(obj) {
    return !!obj && typeof obj === "object" && !isArray(obj);
  };

  Types.isDirectPrototypeOf = isDirectPrototypeOf = function(o, prototype) {
    return !isFunction(o) && prototype.constructor === o.constructor;
  };


  /*
  NOTE:
    getSuper doesn't work in CoffeeScript classes objects, but it does on ES6 classes.
    getSuper does work on CoffeeScript class instance objects.
  
  All about getSuper in ES6 land:
  
    class A {}
    class B extends A {}
    class C extends B {}
  
    a = new A
    b = new B
    c = new C
  
    getSuper(B) == A
    getSuper(C) == B
  
    getSuper(A.prototype) == Object.prototype
    getSuper(B.prototype) == A.prototype
    getSuper(C.prototype) == B.prototype
  
    getSuper(b) == A.prototype
    getSuper(c) == B.prototype
  
  prototype map:
  
  KEY:
    <->
       <-- .constructor
       --> .prototype
    ^  Object.getPrototypeOf
  
  MAP:
    A <-> aPrototype
  
    ^     ^     ^
    |     |     a
    |     |
  
    B <-> bPrototype
  
    ^     ^     ^
    |     |     b
    |     |
  
    C <-> cPrototype
  
                ^
                c
  
  Definition of super:
  
    if instance then prototype's prototype
    else prototype
   */

  Types.getSuper = function(o) {
    var _super;
    if (!((typeof o === "object") || (typeof o === "function"))) {
      throw new Error("getSuper expecting an object");
    }
    _super = Object.getPrototypeOf(o);
    if (isDirectPrototypeOf(o, _super)) {
      _super = Object.getPrototypeOf(_super);
    }
    return _super;
  };

  Types.isPlainObjectUniversal = function(v) {
    return (v != null) && null === Object.getPrototypeOf(Object.getPrototypeOf(v));
  };

  Types.isPlainObject = isPlainObject = ArtStandardLibMultipleContextTypeSupport ? Types.isPlainObjectUniversal : function(v) {
    return (v != null) && v.constructor === Object;
  };

  Types.hasProperties = hasProperties = function(o) {
    var k;
    if (o == null) {
      return false;
    }
    for (k in o) {
      return true;
    }
    return false;
  };

  Types.hasOwnProperties = hasOwnProperties = function(o) {
    var k;
    if (o == null) {
      return false;
    }
    for (k in o) {
      if (o.hasOwnProperty(k)) {
        return true;
      }
    }
    return false;
  };

  return Types;

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

var MathExtensions, RegExpExtensions, abs, ceil, float32Precision, float64Precision, floor, inverseFloat64Precision, inverstFlaot32Precision, max, min, numberRegexp, pow, random, ref, round;

RegExpExtensions = __webpack_require__(46);

numberRegexp = RegExpExtensions.numberRegexp;

float64Precision = 0.0000000001;

float32Precision = 0.0000001;

inverseFloat64Precision = 1 / float64Precision;

inverstFlaot32Precision = 1 / float32Precision;

ref = self.Math, abs = ref.abs, min = ref.min, max = ref.max, ceil = ref.ceil, floor = ref.floor, round = ref.round, random = ref.random, pow = ref.pow;

module.exports = MathExtensions = (function() {
  var bound;

  function MathExtensions() {}

  MathExtensions.nearInfinity = pow(10, 100);

  MathExtensions.nearInfinityResult = pow(10, 50);

  MathExtensions.float32Precision = float32Precision;

  MathExtensions.float64Precision = float64Precision;

  MathExtensions.modulo = function(a, b) {
    var r;
    r = a % b;
    if (r < 0) {
      return r + b;
    } else {
      return r;
    }
  };

  MathExtensions.stringToNumberArray = function(string) {
    var a, i, j, len, match, v;
    a = string.split(",");
    for (i = j = 0, len = a.length; j < len; i = ++j) {
      v = a[i];
      match = v.match(numberRegexp);
      a[i] = match != null ? match[0] - 0 : 0;
    }
    return a;
  };

  MathExtensions.minMagnitude = function(a, magnitude) {
    if (a < 0) {
      return min(a, -magnitude);
    } else {
      return max(a, magnitude);
    }
  };

  MathExtensions.maxMagnitude = function(a, magnitude) {
    return bound(-magnitude, a, magnitude);
  };

  MathExtensions.maxChange = function(newValue, oldValue, maxChangeV) {
    return bound(oldValue - maxChangeV, newValue, oldValue + maxChangeV);
  };

  MathExtensions.bound = bound = function(a, b, c) {
    if (isNaN(b)) {
      return a;
    }
    if (b < a) {
      return a;
    } else if (b > c) {
      return c;
    } else {
      return b;
    }
  };

  MathExtensions.absGt = function(a, b) {
    return abs(a) > abs(b);
  };

  MathExtensions.absLt = function(a, b) {
    return abs(a) < abs(b);
  };

  MathExtensions.absGte = function(a, b) {
    return abs(a) >= abs(b);
  };

  MathExtensions.absLte = function(a, b) {
    return abs(a) <= abs(b);
  };

  MathExtensions.abs = abs;

  MathExtensions.min = min;

  MathExtensions.max = max;

  MathExtensions.round = round;

  MathExtensions.ceil = function(v, m) {
    if (m == null) {
      m = 1;
    }
    return ceil(v / m) * m;
  };

  MathExtensions.floor = function(v, m) {
    if (m == null) {
      m = 1;
    }
    return floor(v / m) * m;
  };

  MathExtensions.round = function(v, m) {
    if (m == null) {
      m = 1;
    }
    return round(v / m) * m;
  };

  MathExtensions.simplifyNum = function(num) {
    return round(num * inverseFloat64Precision) * float64Precision;
  };

  MathExtensions.floatEq = function(n1, n2) {
    return n1 === n2 || float64Precision > abs(n1 - n2);
  };

  MathExtensions.float32Eq = function(n1, n2) {
    return n1 === n2 || float32Precision > abs(n1 - n2);
  };

  MathExtensions.floatEq0 = function(n) {
    return n === 0 || float64Precision > abs(n);
  };

  MathExtensions.float32Eq0 = function(n) {
    return n === 0 || float32Precision > abs(n);
  };

  MathExtensions.floatTrue0 = function(n) {
    if (n === 0 || float64Precision > abs(n)) {
      return 0;
    } else {
      return n;
    }
  };

  MathExtensions.float32True0 = function(n) {
    if (n === 0 || float32Precision > abs(n)) {
      return 0;
    } else {
      return n;
    }
  };

  MathExtensions.random = random;

  MathExtensions.intRand = function(max) {
    return random() * max | 0;
  };

  MathExtensions.iPart = function(v) {
    return v - (v % 1);
  };

  MathExtensions.fPart = function(v) {
    return v % 1;
  };

  MathExtensions.commaize = function(x) {
    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  };

  MathExtensions.cyclingSequenceFunction = function(sequence) {
    var sequencePos;
    sequencePos = sequence.length;
    return function() {
      sequencePos++;
      if (sequencePos >= sequence.length) {
        sequencePos = 0;
      }
      return sequence[sequencePos];
    };
  };

  return MathExtensions;

})();


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BlueBirdPromise, ErrorWithInfo, Promise, deepEach, deepMap, defineModule, getEnv, isFunction, isPlainObject, isPromise, promiseDebug, ref;

Promise = BlueBirdPromise = __webpack_require__(375);

ref = __webpack_require__(12), deepMap = ref.deepMap, deepEach = ref.deepEach, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;

defineModule = __webpack_require__(42).defineModule;

getEnv = __webpack_require__(58).getEnv;

if (promiseDebug = getEnv().artPromiseDebug) {
  console.log("Art.StandardLib.Promise: BlueBirdPromise debug ENABLED");
}

BlueBirdPromise.config({
  warnings: promiseDebug,
  longStackTraces: promiseDebug,
  cancellation: promiseDebug,
  monitoring: promiseDebug
});

isPromise = __webpack_require__(43).isPromise;

ErrorWithInfo = __webpack_require__(291);


/*
ArtPromise extends ES6 Promises in the following ways:

- constructing a promise with no parameters is allowed
- promise.resolve and promise.reject are supported as
  alternative ways to resolve or reject a promise

If native promises are supported, they are used,
otherwise a polyfill is used.

TODO:
  ES6 says Promises are designed to be extensible:
  http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects

  If I properly extend Promise, will my new methods be available on all promise objects... ???
    At least all promises chained off of one created using my Promise class... ???

  But I had problems doing that. Maybe it's how CoffeeScript extends things?

TODO:
  I want a way to do 'then' and 'catch' without effecting any following 'thens' or 'caches'

  It's easy to implement, but what to call it? Leaning towards tapThen. If I had Ruby's 'tap', then
  I could do this effectively with:

    .tap (a) -> a.then ->
    but
    .tapThen ->
    is even nicer

  Will it be available on returned promises?
    (see ES6 Promise extension above)

  tapThen: (successF, failF) ->
    @then successF, failF
    @ # return the current promise, not the one returned from the then-call above
 */

defineModule(module, function() {
  var ArtPromise, k, v;
  ArtPromise = (function() {
    var deepAll, noop;

    function ArtPromise() {}

    ArtPromise.isPromise = isPromise;

    ArtPromise.testPromise = function(promise) {
      promise.then(function(v) {
        return console.log("promise.resolve", v);
      });
      return promise["catch"](function(v) {
        return console.log("promise.reject", v);
      });
    };

    ArtPromise.mapAll = function(map) {
      var key, keys;
      keys = Object.keys(map);
      return Promise.all((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = keys.length; j < len; j++) {
          key = keys[j];
          results.push(map[key]);
        }
        return results;
      })()).then(function(values) {
        var i, j, key, len, out;
        out = {};
        for (i = j = 0, len = keys.length; j < len; i = ++j) {
          key = keys[i];
          out[key] = values[i];
        }
        return out;
      });
    };

    ArtPromise.containsPromises = function(plainStructure) {
      var containsPromises;
      containsPromises = false;
      deepEach(plainStructure, function(v) {
        return containsPromises || (containsPromises = isPromise(v));
      });
      return containsPromises;
    };


    /*
    For use with Node-style callbacks:
      IN: (error, data) ->
        error: null or set if there was an error
        data: set if error is null
    
    Example:
      Promise.withCallback (callback) ->
        doAsyncStuff -> callback()
     */

    ArtPromise.withCallback = function(startPromiseBodyFunction) {
      return new BlueBirdPromise(function(resolve, reject) {
        var callback;
        callback = function(err, data) {
          if (err) {
            return reject(new Error(err));
          }
          return resolve(data);
        };
        return startPromiseBodyFunction(callback);
      });
    };

    ArtPromise.newExternallyResolvable = function() {
      var out, p;
      out = {};
      p = new BlueBirdPromise(function(resolve, reject) {
        out.resolve = resolve;
        return out.reject = reject;
      });
      p.resolve = out.resolve;
      p.reject = out.reject;
      return p;
    };

    noop = function(a) {
      return a;
    };

    ArtPromise.deepAll = deepAll = function(plainStructure, resolvedResultPreprocessor) {
      var promises;
      if (resolvedResultPreprocessor == null) {
        resolvedResultPreprocessor = noop;
      }
      promises = [];
      deepEach(plainStructure, function(v) {
        if (isPromise(v)) {
          return promises.push(v);
        }
      });
      return Promise.all(promises).then(function(resolved) {
        var i;
        i = 0;
        return deepMap(plainStructure, function(v) {
          if (isPromise(v)) {
            return resolvedResultPreprocessor(resolved[i++]);
          } else {
            return v;
          }
        });
      });
    };

    ArtPromise.deepResolve = deepAll;


    /*
    Serializer makes it easy to ensure promise-returning functions are invoked in order, after each
    promise is resolved.
    
    USAGE:
    
       * EXAMPLE 1: Basic - not too different from normal Promise sequences
      serializer = new ArtPromise.Serializer
      serializer.then -> doA()
    
       * then execute sometime later, possbly asynchronously:
      serializer.then -> doB()
    
       * then execute sometime later, possbly asynchronously:
      serializer.then (doBResult) ->
         * doA and doB have completed and any returning promises resolved
         * the result of the last 'then' is passed in
    
       * EXAMPLE 2: apply the same async function serially to each element in list
       * - list's order is preserved
       * - each invocation waits for the previous one to complete
      serializer = new ArtPromise.Serializer
      list.forEach serializer.serialize f = (element) -> # do something with element, possibly returning a promise
      serializer.then (lastFResult) ->
         * do something after the last invocation of f completes
         * the result of the last invocation of 'f' is passed in
    
       * EXAMPLE 3: mix multiple serialized functions and manual @then invocations
       * - invocation order is perserved
      serializer = new ArtPromise.Serializer
      serializedA = serializer.serialize aFunction
      serializedB = serializer.serialize bFunction
    
      serializedB()
      serializer.then -> @cFunction()
      serializedB()
      serializedA()
      serializedB()
    
      serializer.then (lastBFunctionResult) ->
         * this is invoked AFTER:
         * evaluating, in order, waiting for any promises:
         *   bFunction, cFunction, bFunction, aFunction, bFunction
     */

    ArtPromise.Serializer = (function() {
      function Serializer() {
        this._lastPromise = BlueBirdPromise.resolve();
      }


      /*
      Returns a new function, serializedF, that acts just like 'f'
        - f is forced to be async:
          - if f doesn't return a promise, a promise wrapping f's result is returned
        - invoking serializedF queues f in this serializer instance's sequence via @then
      IN: any function with any signature
      OUT: (f's signature) -> promise.then (fResult) ->
      
      Example with Comparison:
      
         * all asyncActionReturningPromise(element)s get called immediately
         * and may complete randomly at some later event
        myArray.forEach (element) ->
          asyncActionReturningPromise element
      
         * VS
      
         * asyncActionReturningPromise(element) only gets called
         * after the previous call completes.
         * If a previous call failes, the remaining calls never happen.
        serializer = new Promise.Serializer
        myArray.forEach serializer.serialize (element) ->
          asyncActionReturningPromise element
      
         * bonus, you can do things when all the promises complete:
        serializer.then =>
      
         * or if anything fails
        serializer.catch =>
      
         * VS - shortcut
      
         * Just insert "Promise.serialize" before your forEach function to ensure serial invocations.
         * However, you don't get the full functionality of the previous example.
        myArray.forEach Promise.serialize (element) ->
          asyncActionReturningPromise element
       */

      Serializer.prototype.serialize = function(f) {
        return (function(_this) {
          return function() {
            var args;
            args = arguments;
            return _this.then(function() {
              return f.apply(null, args);
            });
          };
        })(this);
      };

      Serializer.prototype.then = function(resolved, rejected) {
        return this._lastPromise = this._lastPromise.then(resolved, rejected);
      };

      Serializer.prototype["catch"] = function(rejected) {
        return this._lastPromise = this._lastPromise["catch"](rejected);
      };

      Serializer.prototype.always = function(f) {
        return this._lastPromise = this._lastPromise["catch"]((function(_this) {
          return function() {
            return null;
          };
        })(this)).then(f);
      };


      /*
      OUT: promise that resolves / rejects only when there are no more
        pending tasks queued with the serializer.
      
        .then (lastResult) ->
        .catch (lastError) ->
      
      NOTE: allDonePromise could complete, then more tasks could be queued with the serializer.
        Promises can't be resolved/rejected twice, so when the more-tasks complete, the first
        allDonePromise won't do anything.
        However, you can call allDonePromise again once the tasks are queued and get notified
        when THEY are done.
       */

      Serializer.prototype.allDonePromise = function() {
        var currentLastPromise;
        currentLastPromise = this._lastPromise;
        return currentLastPromise.then((function(_this) {
          return function(lastResult) {
            if (currentLastPromise === _this._lastPromise) {
              return lastResult;
            } else {
              return _this.allDonePromise();
            }
          };
        })(this))["catch"]((function(_this) {
          return function(lastError) {
            if (currentLastPromise === _this._lastPromise) {
              throw lastError;
            } else {
              return _this.allDonePromise();
            }
          };
        })(this));
      };

      return Serializer;

    })();


    /*
    OUT: serializedF = -> Promise.resolve f arguments...
      IN: any arguments
      EFFECT: f is invoked with arguments passed in AFTER the last invocation of serializedF completes.
      OUT: promise.then -> results from f
    
    NOTE: 'f' can return a promise, but it doesn't have to. If it does return a promise, the next
      'f' invocation will not start until and if the previous one's promise completes.
    
    USAGE:
      serializedF = Promise.serialize f = -> # do something, possibly returning a promise
      serializedF()
      serializedF()
      serializedF()
      .then (resultOfLastF)->
         * executed after f was executed and any returned promises resolved, 3 times, sequentially
    
    OR
      serializedF = Promise.serialize f = (element) -> # do something with element, possibly returning a promise
      Promise.all (serializedF item for item in list)
      .then (results) ->
         * f was excuted list.length times sequentially
         * results contains the result values from each execution, in order
     */

    ArtPromise.serialize = function(f) {
      return new ArtPromise.Serializer().serialize(f);
    };

    ArtPromise.invert = function(promise) {
      return promise.then(function(e) {
        throw new ErrorWithInfo("" + e, e);
      }, function(v) {
        return v;
      });
    };

    ArtPromise["finally"] = function(promise, action) {
      return BlueBirdPromise.resolve(promise)["finally"](action);
    };

    ArtPromise.then = BlueBirdPromise["try"];

    return ArtPromise;

  })();
  for (k in ArtPromise) {
    v = ArtPromise[k];
    BlueBirdPromise[k] || (BlueBirdPromise[k] = v);
  }
  return BlueBirdPromise;
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 46 */
/***/ (function(module, exports) {

var RegExpExtensions;

module.exports = RegExpExtensions = (function() {
  var k, lc, ref, v;

  function RegExpExtensions() {}

  RegExpExtensions.escapeRegExp = function(string) {
    var ref;
    return (ref = string != null ? typeof string.replace === "function" ? string.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&") : void 0 : void 0) != null ? ref : '';
  };

  RegExpExtensions.findUrlProtocolRegExp = /([\w-]+)(:\/\/)/;

  RegExpExtensions.findDomainRegExp = /localhost|[\w]+(?:-[\w]+)*(?:\.[\w]+(?:-[\w]+)*)*(?:\.[a-z]{2,20})/;

  RegExpExtensions.urlQueryParamsRegExp = /(?:[-+=&*._\w]|%[a-f\d]{2})*(?!\.)(?:[-+=&*._\w]|%[a-f\d]{2})/i;

  RegExpExtensions.findLegalUrlCharacterRegExp = /[-._~!$&'()*+,;=:@\w]|%[a-f\d]{2}/;

  RegExpExtensions.findUrlPathRegExp = RegExp("(?:\\/(?:(?:" + RegExpExtensions.findLegalUrlCharacterRegExp.source + ")*(?!\\.)(?:" + RegExpExtensions.findLegalUrlCharacterRegExp.source + "))?)*");

  RegExpExtensions.findUrlPortRegExp = /(\:)(\d+)/;

  RegExpExtensions.findUrlFragmentRegExp = RegExp("(\\#)((?:(?:\\?|" + RegExpExtensions.findLegalUrlCharacterRegExp.source + ")*(?!\\.)" + RegExpExtensions.findLegalUrlCharacterRegExp.source + "|))");

  RegExpExtensions.findEmailRegExp = /((?:[^<>\s\n"\\]|\\.)+|"(?:[^"\\]|\\.)*")@([^\s\n<>]+)/i;

  RegExpExtensions.emailRegExp = RegExp("^" + RegExpExtensions.findEmailRegExp.source + "$", "i");

  RegExpExtensions.numberRegExp = /([-]?\.[0-9]+)|([-]?[0-9]+(\.[0-9]+)?)/;

  RegExpExtensions.urlProtocolRegExp = RegExp("^" + RegExpExtensions.findUrlProtocolRegExp.source + "$", "i");

  RegExpExtensions.domainRegExp = RegExp("^" + RegExpExtensions.findDomainRegExp.source + "$", "i");

  RegExpExtensions.urlPathRegExp = RegExp("^" + RegExpExtensions.findUrlPathRegExp.source + "$", "i");

  RegExpExtensions.urlQueryRegExp = RegExp("^" + RegExpExtensions.urlQueryParamsRegExp.source + "$", "i");

  RegExpExtensions.isoDateRegExp = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;

  RegExpExtensions.hex16ColorRegExp = /^#([a-f0-9])([a-f0-9])([a-f0-9])([a-f0-9])?$/i;

  RegExpExtensions.hex256ColorRegExp = /^#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})?$/i;

  RegExpExtensions.rgbColorRegExp = /rgb *\( *(\d+%?) *, *(\d+%?) *, *(\d+%?) *\)/;

  RegExpExtensions.rgbaColorRegExp = /rgba *\( *(\d+%?) *, *(\d+%?) *, *(\d+%?) *, *(\d*\.?\d*)\)/;

  RegExpExtensions.findColorRegExp = RegExp("(" + RegExpExtensions.hex16ColorRegExp.source + ")|(" + RegExpExtensions.hex256ColorRegExp.source + ")|(" + RegExpExtensions.rgbColorRegExp.source + ")|(" + RegExpExtensions.rgbaColorRegExp.source + ")", "i");

  RegExpExtensions.colorRegExp = RegExp("^" + RegExpExtensions.findColorRegExp.source + "$");

  RegExpExtensions.wordsRegExp = /[^\s]+/g;

  RegExpExtensions.exactlyOneWordRegExp = /^[^\s]+$/;

  RegExpExtensions.findUrlOrigin = RegExp("(?:" + RegExpExtensions.findUrlProtocolRegExp.source + ")(" + RegExpExtensions.findDomainRegExp.source + ")?(?:" + RegExpExtensions.findUrlPortRegExp.source + ")?", "i");


  /*
  match OUTPUT: [url, protocol, '://', domain, ':', port, path, '?', query]
  
  USAGE:
    [__, protocol, __, domain, __, port, path, __, query, __, fragment] = str.match findUrlRegExp
  
  DESIGN NOTE:
    The reason why I included the fixed strings ('://', ':' and '?') was so that
    you can take the matchResult, alter individual elements and create a value url easily by:
  
      matchResult.slice(1).join ''
   */

  RegExpExtensions.findUrlRegExp = RegExp(RegExpExtensions.findUrlOrigin.source + "(" + RegExpExtensions.findUrlPathRegExp.source + ")?(?:(\\?)(" + RegExpExtensions.urlQueryParamsRegExp.source + ")?)?(?:" + RegExpExtensions.findUrlFragmentRegExp.source + ")?", "i");

  RegExpExtensions.findUrlWithOptionalProtocolRegExp = RegExp("(?:" + RegExpExtensions.findUrlProtocolRegExp.source + ")?(" + RegExpExtensions.findDomainRegExp.source + ")(?:" + RegExpExtensions.findUrlPortRegExp.source + ")?(" + RegExpExtensions.findUrlPathRegExp.source + ")?(?:(\\?)(" + RegExpExtensions.urlQueryParamsRegExp.source + ")?)?(?:" + RegExpExtensions.findUrlFragmentRegExp.source + ")?", "i");

  RegExpExtensions.findAllUrlsRegExp = RegExp("" + RegExpExtensions.findUrlRegExp.source, "ig");

  RegExpExtensions.findAllUrlsWithOptionalProtocolRegExp = RegExp("" + RegExpExtensions.findUrlWithOptionalProtocolRegExp.source, "ig");

  RegExpExtensions.findSourceReferenceUrlRegExp = RegExp(RegExpExtensions.findUrlOrigin.source + "(" + RegExpExtensions.findUrlPathRegExp.source + ")?(?:(\\?)(" + RegExpExtensions.urlQueryParamsRegExp.source + ")?)?(?:\\:(\\d+))?(?:\\:(\\d+))?", "i");

  RegExpExtensions.urlRegExp = RegExp("^" + RegExpExtensions.findUrlRegExp.source + "$", "i");

  RegExpExtensions.urlWithOptionalProtocolRegExp = RegExp("^" + RegExpExtensions.findUrlWithOptionalProtocolRegExp.source + "$", "i");

  ref = RegExpExtensions;
  for (k in ref) {
    v = ref[k];
    if (!(/RegExp$/.test(k))) {
      continue;
    }
    RegExpExtensions[k.replace(/RegExp/, "Regexp")] = v;
    RegExpExtensions[k.replace(/RegExp/, "Regex")] = v;
  }

  lc = function(s) {
    return s.toLocaleLowerCase();
  };

  RegExpExtensions.normalizeUrl = function(url) {
    var ref1;
    url = ((ref1 = RegExpExtensions.findUrlProtocolRegExp.exec(url)) != null ? ref1.index : void 0) === 0 ? url : "http://" + url;
    return url.replace(RegExpExtensions.findDomainRegExp, lc).replace(RegExpExtensions.findUrlProtocolRegExp, lc);
  };

  return RegExpExtensions;

})();


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(5)
var Buffer = buffer.Buffer

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  Object.keys(buffer).forEach(function (prop) {
    exports[prop] = buffer[prop]
  })
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
Object.keys(Buffer).forEach(function (prop) {
  SafeBuffer[prop] = Buffer[prop]
})

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    [
      "PointerActionsMixin",
      "Component",
      "Element",
      "StyleProps",
      "TextElement"
    ],
    [global, __webpack_require__(18)],
    (PointerActionsMixin, Component, Element, StyleProps, TextElement) => {
      let TabButton;
      return (TabButton = Caf.defClass(
        class TabButton extends PointerActionsMixin(Component) {},
        function(TabButton, classSuper, instanceSuper) {
          this.prototype.render = function() {
            let subtext, emoji, selected;
            ({ subtext, emoji, selected } = this.props);
            return Element(
              {
                childrenLayout: "column",
                childrenAlignment: "centerCenter",
                childrenMargins: 5,
                size: { ps: 1 },
                cursor: "pointer",
                on: this.buttonHandlers,
                clip: true,
                animators: "draw",
                draw: {
                  radius: 10,
                  color:
                    selected || this.pointerIsDown
                      ? StyleProps.primaryColor
                      : "transparent"
                }
              },
              emoji &&
                TextElement({
                  size: "childrenSize",
                  text: emoji,
                  layoutMode: "tight",
                  fontSize: 32
                }),
              subtext &&
                TextElement(StyleProps.textStyle, {
                  fontSize: 9,
                  size: "childrenSize",
                  text: subtext
                })
            );
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = exports;

asn1.bignum = __webpack_require__(10);

asn1.define = __webpack_require__(366).define;
asn1.base = __webpack_require__(51);
asn1.constants = __webpack_require__(179);
asn1.decoders = __webpack_require__(370);
asn1.encoders = __webpack_require__(372);


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var base = exports;

base.Reporter = __webpack_require__(368).Reporter;
base.DecoderBuffer = __webpack_require__(178).DecoderBuffer;
base.EncoderBuffer = __webpack_require__(178).EncoderBuffer;
base.Node = __webpack_require__(367);


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

var AtomicBase, Foundation, Namespace, PI, Point, abs, atan, bound, ceil, floatEq, floor, inspect, inspectedObjectLiteral, isArray, isFunction, isNumber, isString, log, max, min, nearInfinity, round, sqrt, stringToNumberArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

AtomicBase = __webpack_require__(35);

Namespace = __webpack_require__(67);

inspect = Foundation.inspect, bound = Foundation.bound, floatEq = Foundation.floatEq, log = Foundation.log, isNumber = Foundation.isNumber, isArray = Foundation.isArray, isString = Foundation.isString, isFunction = Foundation.isFunction, stringToNumberArray = Foundation.stringToNumberArray, nearInfinity = Foundation.nearInfinity, inspectedObjectLiteral = Foundation.inspectedObjectLiteral;

abs = Math.abs, sqrt = Math.sqrt, atan = Math.atan, PI = Math.PI, floor = Math.floor, ceil = Math.ceil, round = Math.round, min = Math.min, max = Math.max;


/*
point() general point constructor

IN: (p:Point)
OUT: p

IN: ()
IN: ([])
OUT: point 0, 0

IN: (string)
OUT: Point.namedPoints[string] || Point.parse string

IN: (s:number)
IN: ([s:number])
OUT: new Point s, s

IN: (x:number, y:number)
IN: ([x:number, y:number])
OUT: new Point x, y

IN: ({x:number, y:number})
OUT: new Point x || 0, y || 0

IN: ({aspectRatio: number, area: number})
  aspectRatio: number representing: width / height
  area: number representing the square-area desired
OUT:
  a point, p, with:
    p.area == o.area
    p.aspectRatio == o.aspectRatio
 */

module.exports = Point = (function(superClass) {
  var bottomLeft, centerCenter, centerLeft, isPoint, k, namedPoints, point, point0, point1, pointWithAspectRatioAndArea, topCenter, topRight, v;

  extend(Point, superClass);

  function Point() {
    return Point.__super__.constructor.apply(this, arguments);
  }

  Point.defineAtomicClass({
    fieldNames: "x y"
  });

  Point.isPoint = isPoint = function(v) {
    return (v != null ? v.constructor : void 0) === Point;
  };

  pointWithAspectRatioAndArea = function(arg) {
    var area, aspectRatio, sqrtArea;
    aspectRatio = arg.aspectRatio, area = arg.area;
    sqrtArea = Math.sqrt(area / aspectRatio);
    return point(sqrtArea * aspectRatio, sqrtArea);
  };

  Point.point = point = function(a, b) {
    var p, x, y;
    if (isPoint(a)) {
      return a;
    }
    if (isString(a) && (p = namedPoints[a])) {
      return p;
    }
    if ((a != null ? a.aspectRatio : void 0) && a.area >= 0) {
      return pointWithAspectRatioAndArea(a);
    }
    x = a || 0;
    y = b != null ? b : a;
    if (point0.eq(x, y)) {
      return point0;
    }
    if (point1.eq(x, y)) {
      return point1;
    }
    return new Point(a, b);
  };

  Point.parse = function(string, existing) {
    if (existing) {
      throw new Error("existing feature is no longer supported");
    }
    return new Point(string);
  };

  Point.prototype._init = function(x, y) {
    x || (x = 0);
    if (y == null) {
      y = x;
    }
    this.x = x - 0;
    return this.y = y - 0;
  };

  Point.prototype._initFromObject = function(o) {
    this.x = o.x || 0;
    return this.y = o.y || 0;
  };

  Point.getter({
    exportedValue: function() {
      var out, ref, x, y;
      ref = this, x = ref.x, y = ref.y;
      if (x === y) {
        return x;
      } else {
        out = {};
        if (x !== 0) {
          out.x = x;
        }
        if (y !== 0) {
          out.y = y;
        }
        return out;
      }
    },
    top: function() {
      return 0;
    },
    left: function() {
      return 0;
    },
    right: function() {
      return this.x;
    },
    bottom: function() {
      return this.y;
    },
    centerX: function() {
      return this.x * .5;
    },
    centerY: function() {
      return this.y * .5;
    },
    hCenter: function() {
      return this.getCenterX();
    },
    vCenter: function() {
      return this.getCenterY();
    },
    tl: function() {
      return point0;
    },
    tc: function() {
      return this.mul(0.5, 0);
    },
    tr: function() {
      return this.mul(1, 0);
    },
    lc: function() {
      return this.mul(0, 0.5);
    },
    cc: function() {
      return this.mul(0.5, 0.5);
    },
    rc: function() {
      return this.mul(1, 0.5);
    },
    bl: function() {
      return this.mul(0, 1);
    },
    bc: function() {
      return this.mul(0.5, 1);
    },
    br: function() {
      return this;
    },
    ccNeg: function() {
      return this.mul(-0.5);
    },
    topLeft: function() {
      return point0;
    },
    topCenter: function() {
      return this.mul(0.5, 0);
    },
    topRight: function() {
      return this.mul(1, 0);
    },
    centerLeft: function() {
      return this.mul(0, 0.5);
    },
    centerCenter: function() {
      return this.mul(0.5, 0.5);
    },
    centerRight: function() {
      return this.mul(1, 0.5);
    },
    bottomLeft: function() {
      return this.mul(0, 1);
    },
    bottomCenter: function() {
      return this.mul(0.5, 1);
    },
    bottomRight: function() {
      return this;
    },
    w: function() {
      return this.x;
    },
    width: function() {
      return this.x;
    },
    h: function() {
      return this.y;
    },
    height: function() {
      return this.y;
    },
    neg: function() {
      return new Point(-this.x, -this.y);
    },
    inv: function() {
      return new Point(1.0 / this.x, 1.0 / this.y);
    },
    vector: function() {
      return [this.x, this.y];
    },
    magnitudeSquared: function() {
      return this.x * this.x + this.y * this.y;
    },
    magnitude: function() {
      return sqrt(this.x * this.x + this.y * this.y);
    },
    aspectRatio: function() {
      return this.x / this.y;
    },
    absoluteAspectRatio: function() {
      return abs(this.x / this.y);
    },
    swapped: function() {
      return point(this.y, this.x);
    },
    rounded: function() {
      return this.round();
    },
    floored: function() {
      return this.floor();
    },
    ceiled: function() {
      return this.ceil();
    },
    area: function() {
      return this.x * this.y;
    },
    sum: function() {
      return this.x + this.y;
    },
    size: function() {
      return this;
    },
    location: function() {
      return point0;
    },
    abs: function() {
      return this["with"](abs(this.x), abs(this.y));
    },
    unitVector: function() {
      var m;
      m = 1 / this.magnitude;
      return new Point(this.x * m, this.y * m);
    },
    perpendicularVector: function() {
      return new Point(this.y, -this.x);
    },
    unitPerpendicularVector: function() {
      var m;
      m = 1 / this.magnitude;
      return new Point(this.y * m, -this.x * m);
    },
    angle: function() {
      if (this.x === 0) {
        return PI * (this.y > 0 ? .5 : 1.5);
      } else {
        if (this.x > 0) {
          return atan(this.y / this.x);
        } else {
          return atan(this.y / this.x) + PI;
        }
      }
    },
    isInteger: function() {
      return floatEq(this.x, this.x | 0) && floatEq(this.y, this.y | 0);
    }
  });

  Point.prototype.distance = function(p2) {
    return sqrt(this.distanceSquared(p2));
  };

  Point.prototype.distanceSquared = function(p2) {
    var x, y;
    x = this.x - p2.x;
    y = this.y - p2.y;
    return x * x + y * y;
  };

  Point.prototype.withArea = function(newArea) {
    var area;
    area = this.area;
    if (!(area > 0 && newArea >= 0)) {
      throw new Error("area must be > 0");
    }
    return this.mul(Math.sqrt(newArea / area));
  };

  Point.prototype.vectorLength = 2;

  Point.prototype.toIndex = function(lineStride) {
    return ~~this.y * lineStride + ~~this.x;
  };

  Point.prototype.contains = function(p) {
    return p.x >= 0 && p.y >= 0 && p.x < this.x & p.y < this.y;
  };

  Point.prototype.nearestInsidePoint = function(p) {
    return this["with"](bound(0, p.x, this.x), bound(0, p.y, this.y));
  };

  Point.prototype.appendToVector = function(vector) {
    var l;
    l = vector.length;
    vector[l + 1] = this.y;
    return vector[l] = this.x;
  };

  Point.prototype.dot = function(p) {
    return this.x * p.x + this.y * p.y;
  };

  Point.prototype.cross = function(p) {
    return this.x * p.y - this.y * p.x;
  };

  Point.prototype.floor = function() {
    return this["with"](floor(this.x), floor(this.y));
  };

  Point.prototype.ceil = function() {
    return this["with"](ceil(this.x), ceil(this.y));
  };

  Point.prototype.union = function(b) {
    if (isPoint(b)) {
      return this.max(b);
    } else {
      return b.union(this);
    }
  };

  Point.prototype.intersection = function(b) {
    if (isPoint(b)) {
      return this.min(b);
    } else {
      return b.intersection(this);
    }
  };

  Point.prototype.min = function(b) {
    if (b == null) {
      b = null;
    }
    if (b) {
      return this["with"](min(this.x, b.x), min(this.y, b.y));
    } else {
      return min(this.x, this.y);
    }
  };

  Point.prototype.max = function(b) {
    if (b == null) {
      b = null;
    }
    if (b) {
      return this["with"](max(this.x, b.x), max(this.y, b.y));
    } else {
      return max(this.x, this.y);
    }
  };

  Point.prototype.average = function(b) {
    if (b == null) {
      b = null;
    }
    if (b) {
      return this["with"]((this.x + b.x) / 2, (this.y + b.y) / 2);
    } else {
      return (this.x + this.y) / 2;
    }
  };

  Point.prototype.bound = function(a, b) {
    return this["with"](bound(a.x, this.x, b.x), bound(a.y, this.y, b.y));
  };

  Point.prototype.round = function(m) {
    if (m == null) {
      m = 1;
    }
    return this["with"](round(this.x / m) * m, round(this.y / m) * m);
  };

  Point.prototype.roundOut = function() {
    return this.ceil();
  };


  /*
  OUT:
    out.aspectRatio == @aspectRatio
    out <= into
    out.x == into.x or out.y == into.y
  proposed rename: scaledJustLte
   */

  Point.prototype.fitInto = function(into) {
    var x, xr, y, yr;
    if (into == null) {
      return this;
    }
    if (isNumber(into)) {
      x = y = into;
    } else {
      x = into.x, y = into.y;
    }
    xr = x / this.x;
    yr = y / this.y;
    return this.mul(min(xr, yr));
  };


  /*
  OUT:
    out.aspectRatio == @aspectRatio
    out >= into
    out.x == into.x or out.y == into.y
  
  KEYWORD: I used to call this 'zoom'
  proposed rename: scaledJustGte
   */

  Point.prototype.fill = function(into) {
    var x, xr, y, yr;
    if (isNumber(into)) {
      x = y = into;
    } else {
      x = into.x, y = into.y;
    }
    xr = x / this.x;
    yr = y / this.y;
    return this.mul(max(xr, yr));
  };


  /*
  OUT:
    out.aspectRatio == @aspectRatio
    out.area == p.area
   */

  Point.prototype.withSameAreaAs = function(p) {
    return this.mul(Math.sqrt(p.area / this.area));
  };

  Point.prototype.withAspectRatio = function(aspectRatio) {
    if (floatEq(aspectRatio, this.aspectRatio)) {
      return this;
    }
    return point({
      aspectRatio: aspectRatio,
      area: this.area
    });
  };

  Point.prototype.withRect = function(a, b, c, d) {
    if ((d != null) && a === 0 && b === 0) {
      return this["with"](c, d);
    } else {
      return Namespace.rect(a, b, c, d);
    }
  };

  Point.prototype.minRatio = function(b) {
    return min(this.x / b.x, this.y / b.y);
  };

  Point.prototype.maxRatio = function(b) {
    return max(this.x / b.x, this.y / b.y);
  };

  point0 = Object.freeze(new Point(0));

  point1 = Object.freeze(new Point(1));

  topRight = Object.freeze(new Point(1, 0));

  topCenter = Object.freeze(new Point(0.5, 0));

  centerLeft = Object.freeze(new Point(0, 0.5));

  centerCenter = Object.freeze(new Point(0.5));

  bottomLeft = Object.freeze(new Point(0, 1));

  Point.namedPoints = namedPoints = {
    point0: point0,
    point1: point1,
    topLeft: point0,
    topCenter: topCenter,
    topRight: topRight,
    centerLeft: centerLeft,
    centerCenter: centerCenter,
    centerRight: Object.freeze(new Point(1, 0.5)),
    bottomLeft: bottomLeft,
    bottomCenter: Object.freeze(new Point(0.5, 1)),
    bottomRight: point1,
    pointNearInfinity: Object.freeze(new Point(nearInfinity)),
    left: point0,
    center: topCenter,
    right: topRight,
    top: point0,
    bottom: bottomLeft
  };

  for (k in namedPoints) {
    v = namedPoints[k];
    Point[k] = v;
  }

  Point.namedValues = namedPoints;

  return Point;

})(AtomicBase);


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var Core,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(20)).addNamespace('Core', Core = (function(superClass) {
  extend(Core, superClass);

  function Core() {
    return Core.__super__.constructor.apply(this, arguments);
  }

  return Core;

})(Neptune.PackageNamespace));

__webpack_require__(118);

__webpack_require__(220);


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(453);


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

var Flux,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(465)).addNamespace('Flux', Flux = (function(superClass) {
  extend(Flux, superClass);

  function Flux() {
    return Flux.__super__.constructor.apply(this, arguments);
  }

  Flux.version = __webpack_require__(331).version;

  return Flux;

})(Neptune.PackageNamespace));

__webpack_require__(264);

__webpack_require__(266);


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var ArrayExtensions, bound, exactlyOneWordRegex, intRand, isNumber, isString, max, modulo, ref, ref1, ref2, wordsRegex,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(44), bound = ref.bound, max = ref.max, intRand = ref.intRand, modulo = ref.modulo;

ref1 = __webpack_require__(12), isNumber = ref1.isNumber, isString = ref1.isString;

ref2 = __webpack_require__(46), wordsRegex = ref2.wordsRegex, exactlyOneWordRegex = ref2.exactlyOneWordRegex;

module.exports = ArrayExtensions = (function() {
  var _moveArrayElementLargeArray, _moveArrayElementSmallArray, a, arrayWithElementMoved, arrayWithInsertedValue, basicCompareFunction, indexOfOrLength, keepAll, keepIfRubyTrue, leftOfIndex, longestCommonSubsequence, moveArrayElement, randomElement, randomSortInPlace, rightOfIndex, w;

  function ArrayExtensions() {}


  /*
  Useful compact and compactFlatten keepTester functions
   */

  ArrayExtensions.keepAll = keepAll = function() {
    return true;
  };

  ArrayExtensions.keepIfRubyTrue = keepIfRubyTrue = function(a) {
    return a !== void 0 && a !== null && a !== false;
  };

  ArrayExtensions.reverseForEach = function(array, f) {
    var p, v;
    for (p = array.length - 1; p >= 0; p += -1) {
      v = array[p];
      f(v);
    }
    return array;
  };

  ArrayExtensions.arrayToTruthMap = function(array) {
    var a, len1, p, res;
    res = {};
    for (p = 0, len1 = array.length; p < len1; p++) {
      a = array[p];
      res[a] = true;
    }
    return res;
  };

  ArrayExtensions.arrayToFalseMap = function(array) {
    var a, len1, p, res;
    res = {};
    for (p = 0, len1 = array.length; p < len1; p++) {
      a = array[p];
      res[a] = false;
    }
    return res;
  };

  ArrayExtensions.arrayAfterEach = function(array, value) {
    var len1, out, p, v;
    out = [];
    for (p = 0, len1 = array.length; p < len1; p++) {
      v = array[p];
      out.push(v);
      out.push(value);
    }
    return out;
  };

  ArrayExtensions.arrayBeforeEach = function(array, value) {
    var len1, out, p, v;
    out = [];
    for (p = 0, len1 = array.length; p < len1; p++) {
      v = array[p];
      out.push(value);
      out.push(v);
    }
    return out;
  };

  ArrayExtensions.arrayBetweenEach = function(array, value) {
    var i, len1, out, p, v;
    out = [];
    for (i = p = 0, len1 = array.length; p < len1; i = ++p) {
      v = array[i];
      if (i > 0) {
        out.push(value);
      }
      out.push(v);
    }
    return out;
  };

  ArrayExtensions.concatInto = function(array, b) {
    return array.push.apply(array, b);
  };

  ArrayExtensions.uniqueValues = function(sortedArray, eqF) {
    var i, len1, p, results, v;
    if (eqF == null) {
      eqF = (function(a, b) {
        return a === b;
      });
    }
    results = [];
    for (i = p = 0, len1 = sortedArray.length; p < len1; i = ++p) {
      v = sortedArray[i];
      if (i === 0 || !eqF(v, sortedArray[i - 1])) {
        results.push(v);
      }
    }
    return results;
  };


  /*
  IN:
    array: an array or falsy value
    element: anything
  OUT:
    array containing element as the last element
  
  EFFECT:
    if array was falsy, a new length-1 array is returned
    else, array was mutated by pushing the current element
  
  WHY?
    Why write this when arrays alread have push?
  
    1) if array is null, this works as desired
    2) this returns array, not array.length
      Returning the array is what Ruby's push does.
      It makes chaining pushes easy.
   */

  ArrayExtensions.push = function(array, element) {
    if (array) {
      array.push(element);
      return array;
    } else {
      return [element];
    }
  };

  ArrayExtensions.peek = function(array, offset) {
    if (offset == null) {
      offset = -1;
    }
    if (array != null) {
      return array[array.length + offset];
    } else {
      return void 0;
    }
  };

  basicCompareFunction = function(a, b) {
    return a - b;
  };

  ArrayExtensions.leftOfIndex = leftOfIndex = function(array, index) {
    if (!array) {
      return array;
    }
    return array.slice(0, index);
  };

  ArrayExtensions.rightOfIndex = rightOfIndex = function(array, index) {
    if (!array) {
      return array;
    }
    if (index < 0) {
      index += array.length;
    }
    return array.slice(index + 1);
  };

  indexOfOrLength = function(array, value) {
    var i;
    if (0 > (i = array.indexOf(value))) {
      return array.length;
    } else {
      return i;
    }
  };

  ArrayExtensions.leftOf = function(array, value) {
    return leftOfIndex(array, indexOfOrLength(array, value));
  };

  ArrayExtensions.rightOf = function(array, value) {
    return rightOfIndex(array, indexOfOrLength(array, value));
  };

  ArrayExtensions.splitArray = function(array, value) {
    var index;
    index = indexOfOrLength(array, value);
    return [leftOfIndex(array, index), rightOfIndex(array, index)];
  };


  /*
  findSortedFirst
  
  Acts as-if it sorted the array and returned the first element.
  
  Details:
    tests each element in the array againts the current "smallest"
    returns the element for which tests "smaller" than every other
    element a is "smaller" than b if compareFunction(a, b) returns >0 value
  
  IN:
    array - the array to search or null
    compareFunction - (a, b) -> # standard compare function
      returns:
        0: if a and b are equal
        <0: if b is greater than a
        >0: if a is greater than b
      default: (a, b) -> a - b
  
  OUT:
    largest value in array or undefined if array is null or length 0
   */

  ArrayExtensions.findSortedFirst = function(array, compareFunction) {
    var element, i, p, ref3, returnElement;
    if (compareFunction == null) {
      compareFunction = basicCompareFunction;
    }
    if (!((array != null ? array.length : void 0) > 0)) {
      return void 0;
    }
    returnElement = array[0];
    for (i = p = 1, ref3 = array.length; p < ref3; i = p += 1) {
      if (0 < compareFunction(returnElement, element = array[i])) {
        returnElement = element;
      }
    }
    return returnElement;
  };

  ArrayExtensions.first = function(array) {
    return array[0];
  };

  ArrayExtensions.second = function(array) {
    return array[1];
  };

  ArrayExtensions.third = function(array) {
    return array[2];
  };

  ArrayExtensions.forth = function(array) {
    return array[3];
  };

  ArrayExtensions.fifth = function(array) {
    return array[4];
  };

  ArrayExtensions.last = function(array) {
    if (array) {
      return array[array.length - 1];
    } else {
      return void 0;
    }
  };

  ArrayExtensions.pushIfNotPresent = function(array, item) {
    if (indexOf.call(array, item) >= 0) {
      return false;
    } else {
      array.push(item);
      return true;
    }
  };

  ArrayExtensions.randomElement = randomElement = function(array, fromFirstN) {
    if (fromFirstN == null) {
      fromFirstN = array.length;
    }
    return array[Math.random() * fromFirstN | 0];
  };

  ArrayExtensions.randomSortInPlace = randomSortInPlace = function(array) {
    var a, i, j, len, p, ref3;
    len = array.length;
    for (i = p = ref3 = len - 1; p >= 0; i = p += -1) {
      j = intRand(i);
      a = array[i];
      array[i] = array[j];
      array[j] = a;
    }
    return array;
  };

  ArrayExtensions.arrayWithRandomSort = function(array) {
    if (array) {
      return randomSortInPlace(array.slice());
    } else {
      return [];
    }
  };

  ArrayExtensions.randomSort = ArrayExtensions.arrayWithRandomSort;

  ArrayExtensions.insert = function(array, index, item) {
    if (index < 0) {
      index = array.length + index + 1;
    }
    array.splice(index, 0, item);
    return array;
  };

  ArrayExtensions.arrayWithInsertedValue = arrayWithInsertedValue = function(array, index, item) {
    return ArrayExtensions.insert(array.slice(), index, item);
  };

  ArrayExtensions.withInserted = arrayWithInsertedValue;

  ArrayExtensions.withSort = function(array, sortFunction) {
    array = array.slice();
    return array.sort(sortFunction);
  };

  ArrayExtensions.remove = function(array, index, amount) {
    if (amount == null) {
      amount = 1;
    }
    if (index < 0) {
      index = array.length + index + 1;
    }
    array.splice(index, amount);
    return array;
  };

  ArrayExtensions.removeFirstMatch = function(array, toMatchValue) {
    var index;
    index = array.indexOf(toMatchValue);
    if (index >= 0) {
      return ArrayExtensions.remove(array, index);
    } else {
      return array;
    }
  };

  ArrayExtensions.arrayWithout = function(array, index, amount) {
    if (amount == null) {
      amount = 1;
    }
    if (index == null) {
      index = array.length - 1;
    }
    return ArrayExtensions.remove(array.slice(), index, amount);
  };

  ArrayExtensions.arrayWithoutValue = function(array, value) {
    return ArrayExtensions.remove(array.slice(), array.indexOf(value), 1);
  };

  ArrayExtensions.arrayWithoutLast = function(array, amount) {
    if (amount == null) {
      amount = 1;
    }
    if ((array != null) && amount < array.length) {
      return array.slice(0, array.length - amount);
    } else {
      return [];
    }
  };

  ArrayExtensions.arrayWith = function(array, value) {
    if (!array) {
      return [value];
    }
    array = array.slice();
    array.push(value);
    return array;
  };

  ArrayExtensions.truncatedArrayWith = function(array, length, value) {
    if (!array) {
      return [value];
    }
    array = array.slice(0, length);
    array.push(value);
    return array;
  };

  ArrayExtensions.poppedArray = function(array) {
    return array.slice(0, array.length - 1);
  };

  ArrayExtensions.arrayWithOne = function(array, value) {
    if (!array) {
      return [value];
    }
    array = array.slice();
    if (indexOf.call(array, value) < 0) {
      array.push(value);
    }
    return array;
  };

  ArrayExtensions.slice = function(a, b, c) {
    return arraySlice.call(a, b, c);
  };

  ArrayExtensions.shuffleArray = function(a) {
    var i, j, t;
    i = a.length;
    while (--i > 0) {
      j = ~~(Math.random() * (i + 1));
      t = a[j];
      a[j] = a[i];
      a[i] = t;
    }
    return a;
  };

  ArrayExtensions._moveArrayElementLargeArray = _moveArrayElementLargeArray = function(array, from, to) {
    array.splice(to, 0, array.splice(from, 1)[0]);
    return array;
  };

  ArrayExtensions._moveArrayElementSmallArray = _moveArrayElementSmallArray = function(array, from, to) {
    var i, p, q, ref3, ref4, ref5, ref6, tmp;
    from = from | 0;
    to = to | 0;
    tmp = array[from];
    if (from < to) {
      for (i = p = ref3 = from, ref4 = to - 1; p <= ref4; i = p += 1) {
        array[i] = array[i + 1];
      }
    } else {
      for (i = q = ref5 = from, ref6 = to + 1; q >= ref6; i = q += -1) {
        array[i] = array[i - 1];
      }
    }
    array[to] = tmp;
    return array;
  };

  ArrayExtensions.moveArrayElement = moveArrayElement = function(array, from, to) {
    from = modulo(from | 0, array.length);
    to = modulo(to | 0, array.length);
    if (Math.abs(from - to) > 300) {
      _moveArrayElementLargeArray(array, from, to);
    } else {
      _moveArrayElementSmallArray(array, from, to);
    }
    return array;
  };

  ArrayExtensions.arrayWithElementMoved = arrayWithElementMoved = function(array, from, to) {
    from = modulo(from | 0, array.length);
    to = modulo(to | 0, array.length);
    if (from === to) {
      return array;
    }
    array = array.slice();
    return moveArrayElement(array, from, to);
  };

  ArrayExtensions.arrayWithElementValueMoved = function(array, value, to) {
    var from;
    from = array.indexOf(value);
    if (from < 0) {
      return array;
    }
    return arrayWithElementMoved(array, from, to);
  };

  ArrayExtensions.arrayWithElementReplaced = function(array, value, index) {
    array = array.slice();
    array[index] = value;
    return array;
  };

  ArrayExtensions.arrayWithAllButLast = function(array, amount) {
    if (amount == null) {
      amount = 1;
    }
    if (array) {
      return array.slice(0, array.length - amount);
    } else {
      return [];
    }
  };

  ArrayExtensions.stableSort = function(array, compare) {
    var a, b, i, length, notSorted, p, ref3;
    compare || (compare = function(a, b) {
      return a - b;
    });
    notSorted = true;
    length = array.length;
    while (notSorted) {
      notSorted = false;
      for (i = p = 1, ref3 = length; p < ref3; i = p += 1) {
        if (compare(a = array[i - 1], b = array[i]) > 0) {
          array[i - 1] = b;
          array[i] = a;
          notSorted = true;
        }
      }
    }
    return array;
  };

  ArrayExtensions.longestCommonSubsequence = longestCommonSubsequence = function(a, b) {
    var c, diag, i, j, latch, lcs, left, m, n, p, q, r, ref3, ref4, ref5, row, s;
    lcs = [];
    row = [];
    c = [];
    if (m < n) {
      s = a;
      a = b;
      b = s;
    }
    m = a.length;
    n = b.length;
    for (j = p = 0, ref3 = n; p < ref3; j = p += 1) {
      row[j] = 0;
    }
    for (i = q = 0, ref4 = m; q < ref4; i = q += 1) {
      c[i] = row = row.slice();
      diag = 0;
      for (j = r = 0, ref5 = n - 1; r <= ref5; j = r += 1) {
        latch = row[j];
        if (a[i] === b[j]) {
          row[j] = diag + 1;
        } else {
          left = row[j - 1] || 0;
          if (left > row[j]) {
            row[j] = left;
          }
        }
        diag = latch;
      }
    }
    i--;
    j--;
    while (i > -1 && j > -1) {
      switch (c[i][j]) {
        case i && c[i - 1][j]:
          i--;
          continue;
        case j && c[i][j - 1]:
          j--;
          break;
        default:
          j--;
          lcs.unshift(a[i]);
          i--;
          continue;
      }
    }
    return lcs;
  };

  ArrayExtensions.minimumOrderedOverlappingMerge = function(a, b) {
    var ai, bj, c, ck, i, j, k, l, m, n, o, out;
    c = longestCommonSubsequence(a, b);
    m = a.length;
    n = b.length;
    o = c.length;
    out = new Array(n);
    i = 0;
    j = 0;
    k = 0;
    l = 0;
    while (i < m && j < n && k < o) {
      ai = a[i];
      bj = b[j];
      ck = c[k];
      if (ai === ck && bj === ck) {
        i++;
        j++;
        k++;
        out[l++] = ai;
      } else if (ai !== ck) {
        i++;
        if (indexOf.call(b, ai) < 0) {
          out[l++] = ai;
        }
      } else {
        j++;
        out[l++] = bj;
      }
    }
    while (i < m) {
      ai = a[i++];
      if (indexOf.call(b, ai) < 0) {
        out[l++] = ai;
      }
    }
    while (j < n) {
      out[l++] = b[j++];
    }
    return out;
  };

  ArrayExtensions.wordsArray = w = function() {
    var arg, len1, out, p;
    out = [];
    for (p = 0, len1 = arguments.length; p < len1; p++) {
      arg = arguments[p];
      if (isString(arg) && !arg.match(exactlyOneWordRegex)) {
        out = out.concat(arg.match(wordsRegex));
      } else {
        out.push(arg);
      }
    }
    return out;
  };

  ArrayExtensions.wordArray = ArrayExtensions.wordsArray;

  ArrayExtensions.w = ArrayExtensions.wordsArray;

  ArrayExtensions.a = a = function() {
    var arg, len1, out, p;
    out = [];
    for (p = 0, len1 = arguments.length; p < len1; p++) {
      arg = arguments[p];
      out.push(arg);
    }
    return out;
  };

  return ArrayExtensions;

})();


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var Environment, ParseUrl, defineModule, isNode;

defineModule = __webpack_require__(42).defineModule;

ParseUrl = __webpack_require__(95);

isNode = __webpack_require__(322);

defineModule(module, Environment = (function() {
  function Environment() {}

  Environment.getEnv = function() {
    var ref, ref1;
    return global.environment != null ? global.environment : global.environment = (((ref = global.location) != null ? ref.search : void 0) ? ParseUrl.parseQuery() : (ref1 = global.process) != null ? ref1.env : void 0) || {};
  };

  Environment.isBrowser = !!(global.window && global.navigator && global.document);

  Environment.isWebWorker = !!(!Environment.isBrowser && global.importScripts);

  Environment.isNode = !!isNode;

  return Environment;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

var ObjectExtensions, compactFlatten, deepArrayEach, isArrayOrArguments, isFunction, isObject, isPlainArray, isPlainObject, mergeInto, object, present, ref, ref1,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(16), compactFlatten = ref.compactFlatten, deepArrayEach = ref.deepArrayEach, isArrayOrArguments = ref.isArrayOrArguments, mergeInto = ref.mergeInto;

ref1 = __webpack_require__(12), isPlainObject = ref1.isPlainObject, isObject = ref1.isObject, isFunction = ref1.isFunction, isPlainArray = ref1.isPlainArray, present = ref1.present;

object = __webpack_require__(93).object;

module.exports = ObjectExtensions = (function() {
  var expandPathedProperties, objectKeyCount, propertyIsPathed, setPathedProperty, toObjectInternal, withPropertyPath;

  function ObjectExtensions() {}

  ObjectExtensions.countKeys = function(o) {
    return Object.keys(o).length;
  };

  ObjectExtensions.objectKeyCount = objectKeyCount = function(o) {
    var count, k, v;
    count = 0;
    for (k in o) {
      v = o[k];
      count++;
    }
    return count;
  };

  ObjectExtensions.objectHasKeys = function(o) {
    var b, k;
    for (k in o) {
      b = o[k];
      return true;
    }
    return false;
  };

  ObjectExtensions.objectLength = objectKeyCount;


  /*
  NOTE:
    null and undefined keys are NOT SUPPORTED
  
    They should be converted to strings, first,
    which is what they would become anyway.
  
  IN: 0 or more arguments
    out = {}
    list = arguments
  
    for element in list
      objects: merge into out
      arrays or argument lists: recurse using element as the list
      null or undefined: skip
      else out[element] = next element (or undefined if none)
  
  OUT: plain object
   */

  toObjectInternal = function(list, out) {
    var element, j, key, len;
    key = null;
    for (j = 0, len = list.length; j < len; j++) {
      element = list[j];
      if (key) {
        out[key] = element;
        key = null;
      } else if (isPlainObject(element)) {
        mergeInto(out, element);
      } else if (isArrayOrArguments(element)) {
        toObjectInternal(element, out);
      } else if (element != null) {
        key = element;
      }
    }
    if (key) {
      return out[key] = void 0;
    }
  };

  ObjectExtensions.toObject = function() {
    var out;
    out = {};
    toObjectInternal(arguments, out);
    return out;
  };


  /*
  IN:
    inputArray: any array
    transformFunction: (element) -> [key, value]
      default: transforms an array of the form: [[key1, value1], [key2, value2], etc...]
   */

  ObjectExtensions.arrayToMap = function(inputArray, transformFunction) {
    var element, j, key, len, outputMap, ref2, value;
    if (transformFunction == null) {
      transformFunction = function(element) {
        return element;
      };
    }
    outputMap = {};
    for (j = 0, len = inputArray.length; j < len; j++) {
      element = inputArray[j];
      ref2 = transformFunction(element), key = ref2[0], value = ref2[1];
      outputMap[key] = value;
    }
    return outputMap;
  };


  /*
  IN:
    obj: the object to select fields from
  
    2nd argument can be:
      selectFunction: (value, key) -> true / false
  
    OR obj can be followed by any number of strings or arrays in any nesting, possibly with null fields
   */

  ObjectExtensions.select = function(obj, a) {
    var j, k, len, prop, properties, result, v;
    if (!obj) {
      return {};
    }
    result = {};
    if (isFunction(a)) {
      if (a.length === 1) {
        for (k in obj) {
          v = obj[k];
          if (a(v)) {
            result[k] = v;
          }
        }
      } else {
        for (k in obj) {
          v = obj[k];
          if (a(k, v)) {
            result[k] = v;
          }
        }
      }
    } else {
      properties = compactFlatten(Array.prototype.slice.call(arguments, 1));
      for (j = 0, len = properties.length; j < len; j++) {
        prop = properties[j];
        if (((v = obj[prop]) != null) || obj.hasOwnProperty(prop)) {
          result[prop] = v;
        }
      }
    }
    return result;
  };

  ObjectExtensions.selectAll = function() {
    var j, len, obj, prop, properties, ref2, result;
    obj = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (!obj) {
      return {};
    }
    result = {};
    ref2 = compactFlatten(properties);
    for (j = 0, len = ref2.length; j < len; j++) {
      prop = ref2[j];
      result[prop] = obj[prop];
    }
    return result;
  };

  ObjectExtensions.objectWithDefinedValues = function(obj) {
    return object(obj, {
      when: function(v) {
        return v !== void 0;
      }
    });
  };

  ObjectExtensions.objectWithExistingValues = function(obj) {
    return object(obj, {
      when: function(v) {
        return v != null;
      }
    });
  };

  ObjectExtensions.objectWithPresentValues = function(obj) {
    return object(obj, {
      when: function(v) {
        return present(v);
      }
    });
  };

  ObjectExtensions.objectWithout = function() {
    var anythingToDo, j, len, obj, prop, properties, result, v;
    obj = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (!obj) {
      return {};
    }
    if (properties.length === 1 && !(typeof properties[0] === "string")) {
      properties = properties[0];
    }
    anythingToDo = false;
    for (j = 0, len = properties.length; j < len; j++) {
      prop = properties[j];
      if (obj.hasOwnProperty(prop)) {
        anythingToDo = true;
        break;
      }
    }
    if (anythingToDo) {
      result = {};
      for (prop in obj) {
        v = obj[prop];
        if (indexOf.call(properties, prop) < 0) {
          result[prop] = v;
        }
      }
      return result;
    } else {
      return obj;
    }
  };

  ObjectExtensions.propertyIsPathed = propertyIsPathed = function(key) {
    return !!key.match(/[\s\.\/]/);
  };

  ObjectExtensions.withPropertyPath = withPropertyPath = function(obj, propertyPath, action) {
    var i, j, key, len;
    propertyPath = propertyPath.match(/[^\s\.\/]+/g);
    for (i = j = 0, len = propertyPath.length; j < len; i = ++j) {
      key = propertyPath[i];
      if (i === propertyPath.length - 1) {
        action(obj, key);
      } else {
        obj = obj[key] || (obj[key] = {});
      }
    }
    return obj;
  };

  ObjectExtensions.setPathedProperty = setPathedProperty = function(obj, propertyPath, value) {
    withPropertyPath(obj, propertyPath, function(o, k) {
      return o[k] = value;
    });
    return obj;
  };

  ObjectExtensions.expandPathedProperties = expandPathedProperties = function(obj, into, pathExpansionEnabled) {
    var k, v;
    if (into == null) {
      into = {};
    }
    if (pathExpansionEnabled == null) {
      pathExpansionEnabled = true;
    }
    for (k in obj) {
      v = obj[k];
      if (pathExpansionEnabled && propertyIsPathed(k)) {
        withPropertyPath(into, k, function(o, finalKey) {
          if (isPlainObject(v)) {
            return expandPathedProperties(v, o[finalKey] || (o[finalKey] = {}), true);
          } else {
            return o[finalKey] = v;
          }
        });
      } else if (isPlainObject(v)) {
        expandPathedProperties(v, into[k] || (into[k] = {}), false);
      } else {
        into[k] = v;
      }
    }
    return into;
  };

  return ObjectExtensions;

})();


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var inherits = __webpack_require__(7)
var md5 = __webpack_require__(99)
var RIPEMD160 = __webpack_require__(161)
var sha = __webpack_require__(162)

var Base = __webpack_require__(25)

function HashNoConstructor (hash) {
  Base.call(this, 'digest')

  this._hash = hash
  this.buffers = []
}

inherits(HashNoConstructor, Base)

HashNoConstructor.prototype._update = function (data) {
  this.buffers.push(data)
}

HashNoConstructor.prototype._final = function () {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null

  return r
}

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new HashNoConstructor(md5)
  if (alg === 'rmd160' || alg === 'ripemd160') return new Hash(new RIPEMD160())

  return new Hash(sha(alg))
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(22);
var assert = __webpack_require__(15);

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}

var Buffer = __webpack_require__(47).Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > 65536) throw new Error('requested too many random bytes')
  // in case browserify  isn't using the Uint8Array version
  var rawBytes = new global.Uint8Array(size)

  // This will not work in older browsers.
  // See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
  if (size > 0) {  // getRandomValues fails on IE if size == 0
    crypto.getRandomValues(rawBytes)
  }

  // XXX: phantomjs doesn't like a buffer being passed here
  var bytes = Buffer.from(rawBytes.buffer)

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(23)))

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function scrub_vec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
  return false
}

function Global () {
  this.SBOX = []
  this.INV_SBOX = []
  this.SUB_MIX = [[], [], [], []]
  this.INV_SUB_MIX = [[], [], [], []]
  this.init()
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
}

Global.prototype.init = function () {
  var d, i, sx, t, x, x2, x4, x8, xi, _i
  d = (function () {
    var _i, _results
    _results = []
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1)
      } else {
        _results.push((i << 1) ^ 0x11b)
      }
    }
    return _results
  })()
  x = 0
  xi = 0
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    this.SBOX[x] = sx
    this.INV_SBOX[sx] = x
    x2 = d[x]
    x4 = d[x2]
    x8 = d[x4]
    t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    this.SUB_MIX[3][x] = t
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    this.INV_SUB_MIX[3][sx] = t
    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }
  return true
}

var G = new Global()

AES.blockSize = 4 * 4

AES.prototype.blockSize = AES.blockSize

AES.keySize = 256 / 8

AES.prototype.keySize = AES.keySize

function bufferToArray (buf) {
  var len = buf.length / 4
  var out = new Array(len)
  var i = -1
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4)
  }
  return out
}
function AES (key) {
  this._key = bufferToArray(key)
  this._doReset()
}

AES.prototype._doReset = function () {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t
  keyWords = this._key
  keySize = keyWords.length
  this._nRounds = keySize + 6
  ksRows = (this._nRounds + 1) * 4
  this._keySchedule = []
  for (ksRow = 0; ksRow < ksRows; ksRow++) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t)
  }
  this._invKeySchedule = []
  for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
    ksRow = ksRows - invKsRow
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)]
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]
  }
  return true
}

AES.prototype.encryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = bufferToArray(new Buffer(M))
  var temp = [M[3], M[1]]
  M[1] = temp[0]
  M[3] = temp[1]
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrub_vec(this._keySchedule)
  scrub_vec(this._invKeySchedule)
  scrub_vec(this._key)
}

AES.prototype._doCryptBlock = function (M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, s0, s1, s2, s3, t0, t1, t2, t3

  s0 = M[0] ^ keySchedule[0]
  s1 = M[1] ^ keySchedule[1]
  s2 = M[2] ^ keySchedule[2]
  s3 = M[3] ^ keySchedule[3]
  ksRow = 4
  for (var round = 1; round < this._nRounds; round++) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ]
}

exports.AES = AES

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 65 */
/***/ (function(module, exports) {

exports['aes-128-ecb'] = {
  cipher: 'AES',
  key: 128,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-192-ecb'] = {
  cipher: 'AES',
  key: 192,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-256-ecb'] = {
  cipher: 'AES',
  key: 256,
  iv: 0,
  mode: 'ECB',
  type: 'block'
}
exports['aes-128-cbc'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-192-cbc'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes-256-cbc'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CBC',
  type: 'block'
}
exports['aes128'] = exports['aes-128-cbc']
exports['aes192'] = exports['aes-192-cbc']
exports['aes256'] = exports['aes-256-cbc']
exports['aes-128-cfb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-192-cfb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-256-cfb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
}
exports['aes-128-cfb8'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-192-cfb8'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-256-cfb8'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
}
exports['aes-128-cfb1'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-192-cfb1'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-256-cfb1'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
}
exports['aes-128-ofb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-192-ofb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-256-ofb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
}
exports['aes-128-ctr'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-192-ctr'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-256-ctr'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
}
exports['aes-128-gcm'] = {
  cipher: 'AES',
  key: 128,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-192-gcm'] = {
  cipher: 'AES',
  key: 192,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}
exports['aes-256-gcm'] = {
  cipher: 'AES',
  key: 256,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
}


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(52)

function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}

function getBlock (self) {
  var out = self._cipher.encryptBlock(self._prev)
  incr32(self._prev)
  return out
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(388)).addNamespace('Atomic', Atomic = (function(superClass) {
  extend(Atomic, superClass);

  function Atomic() {
    return Atomic.__super__.constructor.apply(this, arguments);
  }

  Atomic.version = __webpack_require__(328).version;

  return Atomic;

})(Neptune.PackageNamespace));


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, AtomicBase, Foundation, Point, Rectangle, bound, ceil, float32Precision, floatEq, floatEq0, floor, isArray, isFunction, isNumber, isPoint, isString, log, max, min, point, round, stringToNumberArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(67);

AtomicBase = __webpack_require__(35);

Point = __webpack_require__(53);

max = Foundation.max, min = Foundation.min, bound = Foundation.bound, round = Foundation.round, floatEq = Foundation.floatEq, floor = Foundation.floor, ceil = Foundation.ceil, round = Foundation.round, log = Foundation.log, isNumber = Foundation.isNumber, isArray = Foundation.isArray, isString = Foundation.isString, isFunction = Foundation.isFunction, stringToNumberArray = Foundation.stringToNumberArray, floatEq0 = Foundation.floatEq0, float32Precision = Foundation.float32Precision;

point = Point.point, isPoint = Point.isPoint;

module.exports = Rectangle = (function(superClass) {
  var isRect, rect;

  extend(Rectangle, superClass);

  function Rectangle() {
    return Rectangle.__super__.constructor.apply(this, arguments);
  }

  Rectangle.defineAtomicClass({
    fieldNames: "x y w h",
    constructorFunctionName: "rect"
  });

  Rectangle.isRect = isRect = function(v) {
    return (v != null ? v.constructor : void 0) === Rectangle;
  };

  Rectangle.rect = rect = function(a, b, c, d) {
    if (isRect(a)) {
      return a;
    }
    return new Rectangle(a, b, c, d);
  };

  Rectangle.prototype._initFromObject = function(o) {
    this.x = o.x || 0;
    this.y = o.y || 0;
    this.w = o.w || 0;
    return this.h = o.h || 0;
  };

  Rectangle.prototype._init = function(a, b, c, d) {
    this.x = this.y = this.w = this.h = 0;
    if (d != null) {
      this.x = a - 0;
      this.y = b - 0;
      this.w = c - 0;
      return this.h = d - 0;
    } else if (b != null) {
      if (isPoint(b)) {
        this.x = a.x;
        this.y = a.y;
        this.w = b.w;
        return this.h = b.h;
      } else {
        this.w = a - 0;
        return this.h = b - 0;
      }
    } else if (isPoint(a)) {
      this.w = a.w;
      return this.h = a.h;
    } else if (a != null) {
      return this.w = this.h = a - 0;
    }
  };

  Rectangle.getter({
    location: function() {
      return new Point(this.x, this.y);
    },
    locationMatrix: function() {
      return Atomic.Matrix.translateXY(this.x, this.y);
    },
    size: function() {
      return new Point(this.w, this.h);
    },
    width: function() {
      return this.w;
    },
    height: function() {
      return this.h;
    },
    rounded: function() {
      return this["with"](round(this.x), round(this.y), round(this.w), round(this.h));
    },
    tl: function() {
      return new Point(this.x, this.y);
    },
    tc: function() {
      return new Point(this.hCenter, this.y);
    },
    tr: function() {
      return new Point(this.right, this.y);
    },
    lc: function() {
      return new Point(this.x, this.vCenter);
    },
    cc: function() {
      return new Point(this.hCenter, this.vCenter);
    },
    rc: function() {
      return new Point(this.right, this.vCenter);
    },
    bl: function() {
      return new Point(this.x, this.bottom);
    },
    bc: function() {
      return new Point(this.hCenter, this.bottom);
    },
    br: function() {
      return new Point(this.right, this.bottom);
    },
    topLeft: function() {
      return new Point(this.x, this.y);
    },
    topCenter: function() {
      return new Point(this.hCenter, this.y);
    },
    topRight: function() {
      return new Point(this.right, this.y);
    },
    centerLeft: function() {
      return new Point(this.x, this.vCenter);
    },
    centerCenter: function() {
      return new Point(this.hCenter, this.vCenter);
    },
    centerRight: function() {
      return new Point(this.right, this.vCenter);
    },
    bottomLeft: function() {
      return new Point(this.x, this.bottom);
    },
    bottomCenter: function() {
      return new Point(this.hCenter, this.bottom);
    },
    bottomRight: function() {
      return new Point(this.right, this.bottom);
    },
    locationIsZero: function() {
      return floatEq(this.x, 0) && floatEq(this.y, 0);
    },
    top: function() {
      return this.y;
    },
    left: function() {
      return this.x;
    },
    right: function() {
      return this.x + this.w;
    },
    bottom: function() {
      return this.y + this.h;
    },
    hCenter: function() {
      return this.x + this.w * .5;
    },
    vCenter: function() {
      return this.y + this.h * .5;
    },
    infinite: function() {
      return this.w === 2e308 || this.h === 2e308;
    },
    normalized: function() {
      var h, w, x, y;
      w = this.w;
      h = this.h;
      if (w >= 0 && h >= 0) {
        return this;
      } else {
        x = this.x;
        y = this.y;
        if (w < 0) {
          x += w;
          w = -w;
        }
        if (h < 0) {
          y += h;
          h = -h;
        }
        return this["with"](x, y, w, h);
      }
    },
    area: function() {
      return this.w * this.h;
    },
    corners: function() {
      var bottom, left, right, top;
      left = this.left;
      top = this.top;
      right = this.right;
      bottom = this.bottom;
      return [new Point(left, top), new Point(right, top), new Point(right, bottom), new Point(left, bottom)];
    }
  });

  Rectangle.prototype.withXY = function(x, y) {
    if (floatEq(x, this.x) && floatEq(y, this.y)) {
      return this;
    } else {
      return new Rectangle(x, y, this.w, this.h);
    }
  };

  Rectangle.prototype.withWH = function(w, h) {
    if (floatEq(w, this.w) && floatEq(h, this.h)) {
      return this;
    } else {
      return new Rectangle(this.x, this.y, w, h);
    }
  };

  Rectangle.prototype.withLocation = function(v) {
    return this.withXY(v.x, v.y);
  };

  Rectangle.prototype.withSize = function(v) {
    return this.withWH(v.x, v.y);
  };

  Rectangle.prototype.movedBy = function(d) {
    return this.withXY(this.x + d.x, this.y + d.y);
  };

  Rectangle.prototype.nearestInsidePoint = function(p) {
    return new Point(bound(this.left, p.x, this.right), bound(this.top, p.y, this.bottom));
  };

  Rectangle.prototype.largestInsideRect = function(ofSize) {
    var h, scaler, w;
    scaler = min(this.w / ofSize.w, this.h / ofSize.h);
    w = ofSize.w * scale;
    h = ofSize.h * scale;
    return new Rectangle((this.w - w) / 2, (this.h - h) / 2, w, h);
  };

  Rectangle.prototype.overlaps = function(val) {
    if (val == null) {
      return false;
    }
    if (isPoint(val)) {
      return this.contains(val);
    } else if (isRect(val)) {
      return val.getRight() > this.getLeft() && val.getBottom() > this.getTop() && val.getLeft() < this.getRight() && val.getTop() < this.getBottom();
    } else {
      throw new Error("Invalid arguments for 'overlaps'. Expecting Point or Rectangle. Got: " + val + ".");
    }
  };

  Rectangle.prototype.contains = function(val) {
    if (val == null) {
      return false;
    }
    if (isPoint(val)) {
      return val.x >= this.x && val.y >= this.y && val.x < this.right && val.y < this.bottom;
    } else if (isRect(val)) {
      return val.x >= this.x && val.y >= this.y && val.right <= this.right && val.bottom <= this.bottom;
    } else {
      throw new Error("Invalid arguments for 'contains'. Expecting Point or Rectangle. Got: " + val + ".");
    }
  };

  Rectangle.prototype.round = function(m) {
    var h, w, x, y;
    if (m == null) {
      m = 1;
    }
    x = round(this.x, m);
    y = round(this.y, m);
    w = round(this.x + this.w, m) - x;
    h = round(this.y + this.h, m) - y;
    return this["with"](x, y, w, h);
  };

  Rectangle.prototype.roundOut = function(m, k) {
    var h, w, x, y;
    if (m == null) {
      m = 1;
    }
    if (k == null) {
      k = float32Precision;
    }
    x = floor(this.x + k, m);
    y = floor(this.y + k, m);
    w = ceil(this.x + this.w - k, m) - x;
    h = ceil(this.y + this.h - k, m) - y;
    return this["with"](x, y, w, h);
  };

  Rectangle.prototype.roundIn = function(m, k) {
    var h, w, x, y;
    if (m == null) {
      m = 1;
    }
    if (k == null) {
      k = float32Precision;
    }
    x = ceil(this.x - k, m);
    y = ceil(this.y - k, m);
    w = floor(this.x + this.w + k, m) - x;
    h = floor(this.y + this.h + k, m) - y;
    return this["with"](x, y, w, h);
  };

  Rectangle.prototype.union = function(b) {
    var h, w, x, y;
    if (b == null) {
      return this;
    }
    if (this.getArea() <= 0) {
      return b;
    }
    x = min(this.x, b.left);
    y = min(this.y, b.top);
    w = max(this.getRight(), b.getRight()) - x;
    h = max(this.getBottom(), b.getBottom()) - y;
    return this["with"](x, y, w, h);
  };

  Rectangle.prototype.unionInto = function(into) {
    var area, h, intoArea, w, x, y;
    if (into == null) {
      return new Rectangle(this.x, this.y, this.w, this.h);
    }
    area = this.getArea();
    intoArea = into.getArea();
    if (area <= 0 || intoArea === 2e308) {
      return into;
    }
    if (intoArea <= 0 || area === 2e308) {
      into.x = this.x;
      into.y = this.y;
      into.w = this.w;
      into.h = this.h;
    } else {
      x = into.x, y = into.y, w = into.w, h = into.h;
      into.x = min(x, this.x);
      into.y = min(y, this.y);
      into.w = max(x + w, this.x + this.w) - into.x;
      into.h = max(y + h, this.y + this.h) - into.y;
    }
    return into;
  };

  Rectangle.prototype.intersectInto = function(into) {
    var area, h, intoArea, w, x, y;
    if (into == null) {
      return new Rectangle(this.x, this.y, this.w, this.h);
    }
    area = this.getArea();
    intoArea = into.getArea();
    if (intoArea <= 0 || area === 2e308) {
      return into;
    }
    if (area <= 0 || intoArea === 2e308) {
      into.x = this.x;
      into.y = this.y;
      into.w = this.w;
      return into.h = this.h;
    } else {
      x = into.x, y = into.y, w = into.w, h = into.h;
      into.x = max(x, this.x);
      into.y = max(y, this.y);
      into.w = max(0, min(x + w, this.x + this.w) - into.x);
      into.h = max(0, min(y + h, this.y + this.h) - into.y);
      return into;
    }
  };

  Rectangle.prototype.intersection = function(b) {
    var h, w, x, y;
    if (b == null) {
      return this;
    }
    if (b.getArea() === 2e308 || b.contains(this)) {
      return this;
    }
    if (this.getArea() === 2e308 || this.contains(b)) {
      return b;
    }
    x = max(this.x, b.left);
    y = max(this.y, b.top);
    w = min(this.getRight(), b.getRight()) - x;
    h = min(this.getBottom(), b.getBottom()) - y;
    if (w <= 0 || h <= 0) {
      return Rectangle.nothing;
    } else {
      return this["with"](x, y, w, h);
    }
  };

  Rectangle.prototype.grow = function(a, b) {
    var x, y;
    if (isPoint(a)) {
      x = a.x, y = a.y;
    } else {
      x = a;
      y = b != null ? b : a;
    }
    if (floatEq0(x) && floatEq0(y)) {
      return this;
    }
    return this["with"](this.x - x, this.y - y, this.w + 2 * x, this.h + 2 * y);
  };

  Rectangle.nothing = Object.freeze(new Rectangle(0, 0, 0, 0));

  Rectangle.everything = Object.freeze(new Rectangle(0, 0, 2e308, 2e308));

  Rectangle.prototype.withRect = function(a, b, c, d) {
    return this["with"](a, b, c, d);
  };

  Rectangle.prototype.cutout = function(r) {
    var bottom, h, out, outX, rBottom, rRight, ref, right, w, x, y;
    if (!this.overlaps(r)) {
      return [this];
    }
    ref = this, x = ref.x, y = ref.y, w = ref.w, h = ref.h, right = ref.right, bottom = ref.bottom;
    out = [];
    if (r.x > x) {
      out.push(new Rectangle(x, y, r.x - x, h));
    }
    if ((rRight = r.right) < right) {
      out.push(new Rectangle(rRight, y, right - rRight, h));
    }
    if (r.y > y) {
      out.push(new Rectangle(outX = max(r.x, x), y, min(rRight, right) - outX, r.y - y));
    }
    if ((rBottom = r.bottom) < bottom) {
      out.push(new Rectangle(outX = max(r.x, x), rBottom, min(rRight, right) - outX, bottom - rBottom));
    }
    return out;
  };

  return Rectangle;

})(AtomicBase);


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var BaseClass, BinaryString, BitmapBase, Color, EncodedImage, HTMLCanvasElement, HTMLImageElement, Matrix, Point, Promise, Rectangle, alphaChannelOffset, bound, ceil, debugBitmapSize, floor, getEnv, halfPoint, inspect, isFunction, isNumber, isPoint, isString, log, matrix, max, merge, min, nextTick, pixelStep, point, point0, pureMerge, quarterPoint, rect, ref, ref1, ref2, rgbColor, round, toChannelNumberMap,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(4), point = ref.point, point0 = ref.point0, Point = ref.Point, rect = ref.rect, Rectangle = ref.Rectangle, matrix = ref.matrix, Matrix = ref.Matrix, rgbColor = ref.rgbColor, Color = ref.Color, isPoint = ref.isPoint;

ref1 = __webpack_require__(1), inspect = ref1.inspect, Promise = ref1.Promise, getEnv = ref1.getEnv, nextTick = ref1.nextTick, pureMerge = ref1.pureMerge, isString = ref1.isString, isNumber = ref1.isNumber, log = ref1.log, bound = ref1.bound, merge = ref1.merge, isFunction = ref1.isFunction;

round = Math.round, floor = Math.floor, ceil = Math.ceil, max = Math.max, min = Math.min;

ref2 = (__webpack_require__(2)).Binary, BinaryString = ref2.BinaryString, EncodedImage = ref2.EncodedImage;

BaseClass = __webpack_require__(6).BaseClass;

toChannelNumberMap = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  r: 0,
  g: 1,
  b: 2,
  a: 3,
  red: 0,
  green: 1,
  blue: 2,
  alpha: 3
};

alphaChannelOffset = 3;

pixelStep = 4;

HTMLImageElement = global.HTMLImageElement, HTMLCanvasElement = global.HTMLCanvasElement;

quarterPoint = point(1 / 4);

halfPoint = point(1 / 2);

debugBitmapSize = getEnv().debugBitmapSize;

module.exports = BitmapBase = (function(superClass) {
  var calculateBottom, calculateLeft, calculateRight, calculateTop, emptyOptions, isCanvas, isImage;

  extend(BitmapBase, superClass);

  BitmapBase.bitmapsCreated = 0;

  BitmapBase.prototype.compositeModeSupported = function(mode) {
    return this.supportedCompositeModes.indexOf(mode) >= 0;
  };

  BitmapBase.pixelSnapDefault = true;

  BitmapBase.prototype.defaultColor = rgbColor("black");

  BitmapBase.prototype.defaultColorString = "black";

  BitmapBase.isImage = isImage = function(e) {
    return ((e != null ? e.constructor : void 0) === HTMLImageElement) || e instanceof HTMLImageElement;
  };

  BitmapBase.isCanvas = isCanvas = function(e) {
    return ((e != null ? e.constructor : void 0) === HTMLCanvasElement) || e instanceof HTMLCanvasElement;
  };

  function BitmapBase(a, b) {
    BitmapBase.__super__.constructor.apply(this, arguments);
    this._htmlImageElement = null;
    this._canvas = null;
    this._clippingArea = null;
    this._context = null;
    this._size = null;
    this._lastTransform = null;
    this._imageSmoothing = false;
    this.pixelSnap = BitmapBase.pixelSnapDefault;
    this._pixelsPerPoint = 1;
    BitmapBase.bitmapsCreated++;
    if (b) {
      a = point(a, b);
    }
    if (isFunction(a != null ? a.toMemoryBitmap : void 0)) {
      this.populateClone(this);
    } else if (isCanvas(a)) {
      this.initFromCanvas(a);
    } else if (isImage(a)) {
      this.initFromImage(a);
    } else {
      this.initNewCanvas(point(a, b));
    }
  }

  BitmapBase.getter({
    tainted: function() {
      if (this._context) {
        try {
          this._context.getImageData(0, 0, 1, 1);
          return false;
        } catch (error1) {
          return true;
        }
      } else {
        return this.newBitmap(1).drawBitmap(null, this).tainted;
      }
    },
    isTainted: function() {
      return this.tainted;
    },
    taintedInfo: function() {
      var ref3, ref4;
      return {
        size: this.size,
        tainted: this.tainted,
        "class": this["class"].getName(),
        src: (ref3 = this._htmlImageElement) != null ? (ref4 = ref3.src) != null ? ref4.slice(0, 100) : void 0 : void 0,
        haveCanvas: !!this._canvas
      };
    },
    hasAlpha: function() {
      var data, i, j, len, size, v;
      size = this.size;
      if (size.x <= 128 && size.y <= 128) {
        data = this.imageData.data;
        for (i = j = 0, len = data.length; j < len; i = j += 4) {
          v = data[i];
          if (data[i + 3] < 255) {
            return true;
          }
        }
        return false;
      } else {
        return this.resize(128).hasAlpha;
      }
    },
    inspectedObjects: function() {
      return this;
    },
    canvas: function() {
      if (!this._canvas) {
        if (this._htmlImageElement) {
          this.initNewCanvas(this.size);
          this.drawBitmap(null, this._htmlImageElement);
        } else {
          throw new Error("can't get @canvas");
        }
      }
      return this._canvas;
    },
    bitmapClass: function() {
      return this["class"];
    },
    clippingArea: function() {
      return this._clippingArea || (this._clippingArea = rect(this.getSize()));
    },
    aspectRatio: function() {
      return this.getSize().getAspectRatio();
    }
  });

  BitmapBase.prototype.shouldPixelSnap = function(where) {
    return this.pixelSnap && ((!where) || (isPoint(where)) || where.isTranslateAndPositiveScaleOnly);
  };

  BitmapBase.prototype.drawDrawable = function(drawable, where) {
    return drawable.drawOnBitmap(this, where);
  };

  BitmapBase.prototype.pixelSnapRectangle = function(where, r) {
    var bottom, h, isx, isy, left, right, sx, sy, top, tx, ty, w, x, y;
    left = r.left, right = r.right, bottom = r.bottom, top = r.top;
    isx = isy = sx = sy = 1;
    tx = ty = 0;
    if (isPoint(where)) {
      tx = where.x;
      ty = where.y;
    } else if (where) {
      tx = where.tx;
      ty = where.ty;
      sx = where.sx;
      isx = 1 / sx;
      sy = where.sy;
      isy = 1 / sy;
    }
    x = (Math.round((left * sx) + tx) - tx) * isx;
    y = (Math.round((top * sy) + ty) - ty) * isy;
    w = (Math.round((right * sx) + tx) - tx) * isx - x;
    h = (Math.round((bottom * sy) + ty) - ty) * isy - y;
    return rect(x, y, w, h);
  };

  BitmapBase.prototype.pixelSnapMatrix = function(m) {
    var x, y;
    x = m.transformX(0, 0);
    y = m.transformY(0, 0);
    x -= Math.round(x);
    y -= Math.round(y);
    return m.translateXY(-x, -y);
  };

  BitmapBase.prototype.transformAndRoundOutRectangle = function(where, r) {
    var b, bottom, isx, isy, left, right, sx, sy, top, tx, ty, x, y;
    left = r.left, right = r.right, bottom = r.bottom, top = r.top;
    isx = isy = sx = sy = 1;
    tx = ty = 0;
    if (isPoint(where)) {
      tx = where.x;
      ty = where.y;
    } else if (where) {
      tx = where.tx;
      ty = where.ty;
      sx = where.sx;
      isx = 1 / sx;
      sy = where.sy;
      isy = 1 / sy;
    }
    x = Math.floor((left * sx) + tx);
    y = Math.floor((top * sy) + ty);
    r = Math.ceil((right * sx) + tx);
    b = Math.ceil((bottom * sy) + ty);
    return rect(x, y, r - x, b - y);
  };

  BitmapBase.prototype.pixelSnapAndTransformRectangle = function(where, r) {
    var bottom, left, right, top;
    if (!r) {
      console.error("no r");
    }
    left = r.left, right = r.right, top = r.top, bottom = r.bottom;
    if (isPoint(where)) {
      left += where.x;
      right += where.x;
      top += where.y;
      bottom += where.y;
    } else if (where) {
      left = where.transformX(left, top);
      top = where.transformY(left, top);
      right = where.transformX(right, bottom);
      bottom = where.transformY(right, bottom);
    }
    left = Math.round(left);
    top = Math.round(top);
    right = Math.round(right);
    bottom = Math.round(bottom);
    return rect(left, top, right - left, bottom - top);
  };

  BitmapBase.prototype.clone = function() {
    var b;
    b = this.newBitmap(this.size);
    b.drawBitmap(null, this);
    return b;
  };

  BitmapBase.prototype.crop = function(area) {
    area || (area = this.getAutoCropRectangle());
    area = rect(area).intersection(rect(this.size));
    return this.newBitmap(area.size).drawBitmap(Matrix.translateXY(-area.x, -area.y), this);
  };

  BitmapBase.prototype.initFromCanvas = function(canvas) {
    this._canvas = canvas;
    this._size = point(this._canvas.width, this._canvas.height);
    this.logBitmapSize("initFromCanvas");
    return this.initContext();
  };

  BitmapBase.prototype.logBitmapSize = function(context) {
    if (debugBitmapSize) {
      return log((this["class"].getName()) + "#" + context + " " + this._size);
    }
  };

  BitmapBase.prototype.initFromImage = function(image) {
    this._size = point(image.naturalWidth || image.width, image.naturalHeight || image.height);
    this.logBitmapSize("initFromImage");
    this.initNewCanvas(this.size);
    return this.drawBitmap(point(), image);
  };

  BitmapBase.prototype.initNewCanvas = function(size) {
    if (this._context) {
      return;
    }
    if (!size.gt(point())) {
      throw new Error("invalid size=" + size + " for Art.Canvas.Bitmap");
    }
    this._size = size.floor();
    this.logBitmapSize("initNewCanvas");
    if (global.document) {
      this._canvas = document.createElement('canvas');
      this._canvas.width = this.size.x;
      this._canvas.height = this.size.y;
    } else {
      this._canvas = new HTMLCanvasElement(this.size.x, this.size.y);
    }
    return this.initContext();
  };

  BitmapBase.prototype.populateClone = function(result) {
    result.initNewCanvas(this.size);
    result.drawBitmap(null, this);
    return result._pixelsPerPoint = this._pixelsPerPoint;
  };

  BitmapBase.getter({
    pixelsPerPoint: function() {
      return this._pixelsPerPoint;
    },
    pointsPerPixel: function() {
      return 1 / this._pixelsPerPoint;
    },
    pointSize: function() {
      return this.size.div(this.pixelsPerPoint);
    },
    byteSize: function() {
      return this.size.area * this.getBytesPerPixel();
    },
    bytesPerPixel: function() {
      return 4;
    }
  });

  BitmapBase.setter({
    pixelsPerPoint: function(v) {
      return this._pixelsPerPoint = v;
    },
    pointsPerPixel: function(v) {
      return this._pixelsPerPoint = 1 / v;
    }
  });

  BitmapBase.property({
    size: point(100, 100)
  });

  BitmapBase.property({
    imageSmoothing: false
  });

  BitmapBase.prototype.toMemoryBitmap = function() {
    return this;
  };

  BitmapBase.prototype.toMemoryDrawableBitmap = function() {
    return this;
  };

  BitmapBase.getter({
    memoryContext: function() {
      var error;
      try {
        return this.toMemoryBitmap().context;
      } catch (error1) {
        error = error1;
        log.error({
          message: "ArtCanvas.BitmapBase.memoryContext failure",
          taintedInfo: this.taintedInfo,
          error: error
        });
        throw error;
      }
    },
    imageData: function(a, b, c, d) {
      var area, error, h, w, x, y;
      area = a === null || a === void 0 ? rect(this.size) : rect(a, b, c, d);
      try {
        return this.memoryContext.getImageData(area.x, area.y, area.w, area.h);
      } catch (error1) {
        error = error1;
        x = area.x, y = area.y, w = area.w, h = area.h;
        log.error({
          message: "ArtCanvas.BitmapBase.imageData failure",
          taintedInfo: this.taintedInfo,
          area: {
            x: x,
            y: y,
            w: w,
            h: h
          },
          error: error,
          stack: error.stack
        });
        throw error;
      }
    },
    imageDataBuffer: function(a, b, c, d) {
      return this.getImageData(a, b, c, d).data.buffer;
    }
  });

  BitmapBase.prototype.putImageData = function(imageData, location, sourceArea) {
    if (location == null) {
      location = point();
    }
    if (sourceArea == null) {
      sourceArea = rect(this.size);
    }
    location = location.sub(sourceArea.location);
    this._context.putImageData(imageData, location.x, location.y, sourceArea.x, sourceArea.y, sourceArea.w, sourceArea.h);
    return this;
  };

  BitmapBase.prototype.drawBitmapWithSubtract = function(b) {
    var a, aImageData, aPixels, alpha, ar, bImageData, bPixels, i, j, len;
    a = this.toMemoryBitmap();
    aImageData = a.imageData;
    bImageData = b.imageData;
    aPixels = aImageData.data;
    bPixels = bImageData.data;
    for (i = j = 0, len = aPixels.length; j < len; i = j += 4) {
      ar = aPixels[i];
      alpha = (65536 * bPixels[i + 3]) / 255 | 0;
      aPixels[i] = ar - (bPixels[i] * alpha) / 65536;
      aPixels[i + 1] = aPixels[i + 1] - (bPixels[i + 1] * alpha) / 65536;
      aPixels[i + 2] = aPixels[i + 2] - (bPixels[i + 2] * alpha) / 65536;
    }
    a.context.putImageData(aImageData);
    return a;
  };

  BitmapBase.prototype.getImageDataArray = function(channel) {
    var data, end, i, j, len, results, results1, v;
    if (channel == null) {
      channel = null;
    }
    data = this.getImageData().data;
    if ((channel = toChannelNumberMap[channel]) != null) {
      i = channel;
      end = data.length;
      results = [];
      while (i < end) {
        i += 4;
        results.push(data[i - 4]);
      }
      return results;
    } else {
      results1 = [];
      for (j = 0, len = data.length; j < len; j++) {
        v = data[j];
        results1.push(v);
      }
      return results1;
    }
  };

  BitmapBase.prototype.toPngUri = function() {
    return nextTick().then((function(_this) {
      return function() {
        return _this.toMemoryBitmap().canvas.toDataURL();
      };
    })(this));
  };

  BitmapBase.prototype.toJpgUri = function(quality) {
    if (quality == null) {
      quality = .95;
    }
    return nextTick().then((function(_this) {
      return function() {
        return _this.toMemoryBitmap().canvas.toDataURL("image/jpeg", quality);
      };
    })(this));
  };

  BitmapBase.prototype.toPng = function() {
    return this.toPngUri().then(function(dataURI) {
      return BinaryString.fromDataUri(dataURI);
    });
  };

  BitmapBase.prototype.toJpg = function(quality) {
    return this.toJpgUri(quality).then(function(dataURI) {
      return BinaryString.fromDataUri(dataURI);
    });
  };


  /*
  automatically incode to jpg or png
  png: only if hasAlpha is true
  jpg: all other times
  OUT:
    mimeType:   what mime-type was used
    extension:  what extension was used
    data: binaryString in either PNG or JPG format
   */

  BitmapBase.prototype.autoEncode = function(quality) {
    var encodePromise, extension;
    encodePromise = this.hasAlpha ? (extension = "png", this.toPng()) : (extension = "jpeg", this.toJpg(quality));
    return encodePromise.then(function(data) {
      return {
        extension: extension,
        data: data,
        mimeType: "image/" + extension
      };
    });
  };

  BitmapBase.prototype.toImage = function() {
    return nextTick().then((function(_this) {
      return function() {
        var url;
        if (_this._htmlImageElement) {
          return _this._htmlImageElement;
        } else {
          url = _this.toMemoryBitmap().canvas.toDataURL();
          return EncodedImage.toImage(url).then(function(image) {
            var h, ref3, w;
            ref3 = _this.pointSize, w = ref3.w, h = ref3.h;
            image.width = w;
            image.height = h;
            return image;
          });
        }
      };
    })(this));
  };

  BitmapBase.prototype.hFlipped = function() {
    var result;
    result = this.newBitmap(this.size);
    result.drawBitmap(Matrix.translateXY(-this.size.x / 2, 0).scaleXY(-1, 1).translateXY(this.size.x / 2, 0), this);
    return result;
  };

  BitmapBase.prototype.vFlipped = function() {
    var result;
    result = this.newBitmap(this.size);
    result.drawBitmap(Matrix.translateXY(0, -this.size.y / 2).scaleXY(1, -1).translateXY(0, this.size.y / 2), this);
    return result;
  };

  BitmapBase.getter({
    flipped: function() {
      return this.newBitmap(this.size).drawBitmap(Matrix.scaleXY(-1, 1).translateXY(this.size.x, 0), this);
    },
    rotated180: function() {
      return this.newBitmap(this.size).drawBitmap(Matrix.rotate(Math.PI).translate(this.size), this);
    },
    flippedAndRotated180: function() {
      return this.newBitmap(this.size).drawBitmap(Matrix.scaleXY(-1, 1).rotate(Math.PI).translateXY(0, this.size.y), this);
    },
    rotated90Clockwise: function() {
      return this.newBitmap(this.size.swapped).drawBitmap(Matrix.rotate(Math.PI / 2).translateXY(this.size.y, 0), this);
    },
    flippedAndRotated90Clockwise: function() {
      return this.newBitmap(this.size.swapped).drawBitmap(Matrix.scaleXY(-1, 1).rotate(Math.PI / 2).translateXY(this.size.y, this.size.x), this);
    },
    rotated90CounterClockwise: function() {
      return this.newBitmap(this.size.swapped).drawBitmap(Matrix.rotate(-Math.PI / 2).translateXY(0, this.size.x), this);
    },
    flippedAndRotated90CounterClockwise: function() {
      return this.newBitmap(this.size.swapped).drawBitmap(Matrix.scaleXY(-1, 1).rotate(-Math.PI / 2), this);
    },
    rotated180AndFlipped: function() {
      return this.flippedAndRotated180;
    },
    rotated90ClockwiseAndFlipped: function() {
      return this.flippedAndRotated90CounterClockwise;
    },
    rotated90CounterClockwiseAndFlipped: function() {
      return this.flippedAndRotated90Clockwise;
    },
    mipmap: function(targetMinSize) {
      var result;
      if (targetMinSize && !this.size.mul(halfPoint).ceil().gte(targetMinSize = point(targetMinSize))) {
        return this;
      }
      result = this.scale(halfPoint);
      if (targetMinSize) {
        return result.getMipmap(targetMinSize);
      } else {
        return result;
      }
    }
  });

  BitmapBase.prototype.resize = function(newSize) {
    return this.scale(point(newSize).div(this.size));
  };

  BitmapBase.prototype.scale = function(scale, highQuality) {
    var newBitmap, newSize, source;
    if (highQuality == null) {
      highQuality = true;
    }
    newSize = this.size.mul(scale = point(scale)).ceil();
    source = this;
    if (highQuality) {
      while (scale.lte(quarterPoint)) {
        scale = scale.mul(2);
        source = source.mipmap;
      }
    }
    if (newSize.eq(source.size)) {
      return source;
    }
    newBitmap = this.newBitmap(newSize);
    return newBitmap.drawBitmap(Matrix.scale(newBitmap.size.div(source.size)), source);
  };

  BitmapBase.prototype.drawBorder = function(where, r, options) {
    var c, m, p, w;
    m = matrix(where);
    r = rect(r);
    c = options.color || "#777";
    w = options.width || 1;
    p = options.padding || 0;
    r = r.grow(p);
    this.drawRectangle(m, rect(r.x, r.y, r.w, w), c);
    this.drawRectangle(m, rect(r.x, r.bottom - w, r.w, w), c);
    this.drawRectangle(m, rect(r.x, r.y + w, w, r.h - w * 2), c);
    return this.drawRectangle(m, rect(r.right - w, r.y + w, w, r.h - w * 2), c);
  };

  BitmapBase.prototype.drawStretchedBorderBitmap = function(drawMatrix, targetArea, bitmap, sourceCenterArea, options) {
    var bitmapSize, borderRatio, borderReductionRatio, borderScale, botomCenter, bottomCenter, bottomLeft, bottomRight, centerCenter, centerLeft, centerRight, centertCenter, hide, horizontalBorderHeight, horizontalBorderWidth, m, show, sourceBottomHeight, sourceBottomScale, sourceCenterAreaBottom, sourceCenterAreaHeight, sourceCenterAreaLeft, sourceCenterAreaRight, sourceCenterAreaTop, sourceCenterAreaWidth, sourceCenterHeightScale, sourceCenterWidthScale, sourceLeftScale, sourceLeftWidth, sourceRightScale, sourceRightWidth, sourceTopHeight, sourceTopScale, targetAreaBottom, targetAreaHeight, targetAreaLeft, targetAreaRight, targetAreaTop, targetAreaWidth, targetBottomHeight, targetCenterAreaBottom, targetCenterAreaHeight, targetCenterAreaLeft, targetCenterAreaRight, targetCenterAreaTop, targetCenterAreaWidth, targetLeftWidth, targetRightWidth, targetTopHeight, topCenter, topLeft, topRight, totalBorderHeight, totalBorderWidth;
    if (options == null) {
      options = {};
    }
    hide = options.hide, show = options.show;
    bitmapSize = bitmap.size;
    borderScale = options.borderScale;
    if (!isNumber(borderScale)) {
      borderScale = 1;
    }
    sourceCenterAreaLeft = sourceCenterArea.left;
    sourceCenterAreaTop = sourceCenterArea.top;
    sourceCenterAreaRight = sourceCenterArea.right;
    sourceCenterAreaBottom = sourceCenterArea.bottom;
    sourceCenterAreaWidth = sourceCenterAreaRight - sourceCenterAreaLeft;
    sourceCenterAreaHeight = sourceCenterAreaBottom - sourceCenterAreaTop;
    targetAreaLeft = round(drawMatrix.transformX(targetArea.left, 0));
    targetAreaTop = round(drawMatrix.transformY(0, targetArea.top));
    targetAreaRight = round(drawMatrix.transformX(targetArea.right, 0));
    targetAreaBottom = round(drawMatrix.transformY(0, targetArea.bottom));
    targetAreaWidth = targetAreaRight - targetAreaLeft;
    targetAreaHeight = targetAreaBottom - targetAreaTop;
    sourceLeftWidth = sourceCenterAreaLeft;
    sourceTopHeight = sourceCenterAreaTop;
    sourceRightWidth = bitmapSize.w - sourceCenterAreaRight;
    sourceBottomHeight = bitmapSize.h - sourceCenterAreaBottom;
    targetCenterAreaLeft = round(drawMatrix.transformX(targetArea.left + sourceLeftWidth * borderScale, 0));
    targetCenterAreaTop = round(drawMatrix.transformY(0, targetArea.top + sourceTopHeight * borderScale));
    targetCenterAreaRight = round(drawMatrix.transformX(targetArea.right - sourceRightWidth * borderScale, 0));
    targetCenterAreaBottom = round(drawMatrix.transformY(0, targetArea.bottom - sourceBottomHeight * borderScale));
    targetCenterAreaWidth = targetCenterAreaRight - targetCenterAreaLeft;
    targetCenterAreaHeight = targetCenterAreaBottom - targetCenterAreaTop;
    if (targetCenterAreaWidth < 0) {
      horizontalBorderWidth = targetAreaWidth - targetCenterAreaWidth;
      borderReductionRatio = targetAreaWidth / horizontalBorderWidth;
      borderRatio = sourceLeftWidth / (totalBorderWidth = sourceLeftWidth + sourceRightWidth);
      sourceLeftWidth = round(sourceLeftWidth * borderReductionRatio);
      sourceRightWidth = round(sourceRightWidth * borderReductionRatio);
      sourceCenterAreaRight = bitmap.size.x - sourceRightWidth;
      targetCenterAreaLeft = targetCenterAreaRight = targetAreaLeft + round(targetAreaWidth * borderRatio);
      targetCenterAreaWidth = 0;
    }
    if (targetCenterAreaHeight < 0) {
      horizontalBorderHeight = targetAreaHeight - targetCenterAreaHeight;
      borderReductionRatio = targetAreaHeight / horizontalBorderHeight;
      borderRatio = sourceTopHeight / (totalBorderHeight = sourceTopHeight + sourceBottomHeight);
      sourceTopHeight = round(sourceTopHeight * borderReductionRatio);
      sourceBottomHeight = round(sourceBottomHeight * borderReductionRatio);
      sourceCenterAreaBottom = bitmap.size.x - sourceBottomHeight;
      targetCenterAreaTop = targetCenterAreaBottom = targetAreaTop + round(targetAreaHeight * borderRatio);
      targetCenterAreaHeight = 0;
    }
    targetLeftWidth = targetCenterAreaLeft - targetAreaLeft;
    targetTopHeight = targetCenterAreaTop - targetAreaTop;
    targetRightWidth = targetAreaRight - targetCenterAreaRight;
    targetBottomHeight = targetAreaBottom - targetCenterAreaBottom;
    sourceLeftScale = targetLeftWidth / sourceLeftWidth;
    sourceTopScale = targetTopHeight / sourceTopHeight;
    sourceRightScale = targetRightWidth / sourceRightWidth;
    sourceBottomScale = targetBottomHeight / sourceBottomHeight;
    sourceCenterWidthScale = targetCenterAreaWidth / sourceCenterAreaWidth;
    sourceCenterHeightScale = targetCenterAreaHeight / sourceCenterAreaHeight;
    if (show) {
      topLeft = !show.topLeft;
      topRight = !show.topRight;
      topCenter = !show.topCenter;
      centerLeft = !show.centerLeft;
      centerRight = !show.centerRight;
      centerCenter = !show.centerCenter;
      bottomLeft = !show.bottomLeft;
      bottomRight = !show.bottomRight;
      bottomCenter = !show.bottomCenter;
    }
    if (hide) {
      topLeft = hide.topLeft, topCenter = hide.topCenter, topRight = hide.topRight, centerLeft = hide.centerLeft, centerCenter = hide.centerCenter, centerRight = hide.centerRight, bottomLeft = hide.bottomLeft, botomCenter = hide.botomCenter, bottomRight = hide.bottomRight;
      if (hide.top) {
        topLeft = topCenter = topRight = true;
      }
      if (hide.bottom) {
        bottomLeft = bottomCenter = bottomRight = true;
      }
      if (hide.left) {
        topLeft = centerLeft = bottomLeft = true;
      }
      if (hide.left) {
        topRight = centerRight = bottomRight = true;
      }
      if (hide.centerRow) {
        centerLeft = centerCenter = centerRight = true;
      }
      if (hide.centerColumn) {
        topCenter = centertCenter = bottomRight = true;
      }
    }
    if (!topLeft) {
      m = Matrix.scaleXY(sourceLeftScale, sourceTopScale).translateXY(targetAreaLeft, targetAreaTop);
      options.sourceArea = rect(0, 0, sourceLeftWidth, sourceTopHeight);
      this.drawBitmap(m, bitmap, options);
    }
    if (!topRight) {
      m = Matrix.scaleXY(sourceRightScale, sourceTopScale).translateXY(targetCenterAreaRight, targetAreaTop);
      options.sourceArea = rect(sourceCenterAreaRight, 0, sourceRightWidth, sourceTopHeight);
      this.drawBitmap(m, bitmap, options);
    }
    if (!bottomLeft) {
      m = Matrix.scaleXY(sourceLeftScale, sourceBottomScale).translateXY(targetAreaLeft, targetCenterAreaBottom);
      options.sourceArea = rect(0, sourceCenterAreaBottom, sourceLeftWidth, sourceBottomHeight);
      this.drawBitmap(m, bitmap, options);
    }
    if (!bottomRight) {
      m = Matrix.scaleXY(sourceRightScale, sourceBottomScale).translateXY(targetCenterAreaRight, targetCenterAreaBottom);
      options.sourceArea = rect(sourceCenterAreaRight, sourceCenterAreaBottom, sourceRightWidth, sourceBottomHeight);
      this.drawBitmap(m, bitmap, options);
    }
    if (targetCenterAreaHeight > 0) {
      if (!centerLeft) {
        m = Matrix.scaleXY(sourceLeftScale, sourceCenterHeightScale).translateXY(targetAreaLeft, targetCenterAreaTop);
        options.sourceArea = rect(0, sourceTopHeight, sourceLeftWidth, sourceCenterAreaHeight);
        this.drawBitmap(m, bitmap, options);
      }
      if (!(centerCenter || targetCenterAreaWidth <= 0)) {
        m = Matrix.scaleXY(sourceCenterWidthScale, sourceCenterHeightScale).translateXY(targetCenterAreaLeft, targetCenterAreaTop);
        options.sourceArea = rect(sourceCenterAreaLeft, sourceCenterAreaTop, sourceCenterAreaWidth, sourceCenterAreaHeight);
        this.drawBitmap(m, bitmap, options);
      }
      if (!centerRight) {
        m = Matrix.scaleXY(sourceRightScale, sourceCenterHeightScale).translateXY(targetCenterAreaRight, targetCenterAreaTop);
        options.sourceArea = rect(sourceCenterAreaRight, sourceTopHeight, sourceRightWidth, sourceCenterAreaHeight);
        this.drawBitmap(m, bitmap, options);
      }
    }
    if (sourceCenterAreaWidth > 0) {
      if (!bottomCenter) {
        m = Matrix.scaleXY(sourceCenterWidthScale, sourceBottomScale).translateXY(targetCenterAreaLeft, targetCenterAreaBottom);
        options.sourceArea = rect(sourceLeftWidth, sourceCenterAreaBottom, sourceCenterAreaWidth, sourceBottomHeight);
        this.drawBitmap(m, bitmap, options);
      }
      if (!topCenter) {
        m = Matrix.scaleXY(sourceCenterWidthScale, sourceTopScale).translateXY(targetCenterAreaLeft, targetAreaTop);
        options.sourceArea = rect(sourceCenterAreaLeft, 0, sourceCenterAreaWidth, sourceTopHeight);
        return this.drawBitmap(m, bitmap, options);
      }
    }
  };

  calculateTop = function(data, size, threshold) {
    var lineStep, pos;
    lineStep = size.x * pixelStep;
    pos = alphaChannelOffset;
    while (pos < data.length && data[pos] <= threshold) {
      pos += pixelStep;
    }
    return floor(pos / lineStep);
  };

  calculateBottom = function(data, size, threshold, top) {
    var lineStep, pos, stopPos;
    lineStep = size.x * pixelStep;
    pos = data.length + alphaChannelOffset - pixelStep;
    stopPos = top * lineStep;
    while (pos > stopPos && data[pos] <= threshold) {
      pos -= pixelStep;
    }
    return floor(pos / lineStep);
  };

  calculateLeft = function(data, size, threshold, top, bottom) {
    var bottomOffset, length, lineStep, pos, posX, stop, topOffset;
    lineStep = size.x * pixelStep;
    length = data.length;
    topOffset = top * lineStep;
    bottomOffset = bottom * lineStep;
    posX = alphaChannelOffset;
    while (posX < lineStep) {
      pos = posX + topOffset;
      stop = posX + bottomOffset;
      while (pos < stop) {
        if (data[pos] > threshold) {
          return floor(posX / pixelStep);
        }
        pos += lineStep;
      }
      posX += pixelStep;
    }
  };

  calculateRight = function(data, size, threshold, top, bottom, left) {
    var bottomOffset, length, lineStep, outterStop, pos, posX, stop, topOffset;
    lineStep = size.x * pixelStep;
    length = data.length;
    topOffset = top * lineStep;
    bottomOffset = bottom * lineStep;
    posX = lineStep - pixelStep + alphaChannelOffset;
    outterStop = left * pixelStep;
    while (posX > outterStop) {
      pos = posX + topOffset;
      stop = posX + bottomOffset;
      while (pos < stop) {
        if (data[pos] > threshold) {
          return floor(posX / pixelStep);
        }
        pos += lineStep;
      }
      posX -= pixelStep;
    }
  };

  BitmapBase.getter({
    autoCropRectangle: function(threshold) {
      var bottom, context, data, left, ref3, right, size, top;
      if (threshold == null) {
        threshold = 0;
      }
      ref3 = this, size = ref3.size, context = ref3.context;
      data = context.getImageData(0, 0, size.x, size.y).data;
      top = calculateTop(data, size, threshold);
      if (top === size.y) {
        return rect();
      }
      bottom = calculateBottom(data, size, threshold, top);
      left = calculateLeft(data, size, threshold, top, bottom);
      right = calculateRight(data, size, threshold, top, bottom, left);
      return rect(left, top, right - left + 1, bottom - top + 1);
    }
  });

  emptyOptions = {};


  /*
  IN:
    where:    null, matrix, point
    bitmap:   null or an instance of BitmapBase
    options:
      all drawBitmap's options PLUS:
  
      targetSize: size of the target area to layout in. Default: @size (target bitmap's size)
  
      aspectRatio: for the source pixels to be an aspectRatio other than implied by square-pixels.
        This is useful if you want one bitmap to layout exactly the same as another even though
        they have a different size.
  
      layout: 'zoom', 'fit', 'stretch'
  
        Selects how to layout.
  
  Note that pixels will NEVER be drawn outside of rect(point(), targetSize).
  
  That is why I restricted the layout modes to zoom, fit and stretch.
   */

  BitmapBase.prototype.drawBitmapWithLayout = function(where, bitmap, options) {
    var adjustedTargetSize, aspectRatio, bitmapSize, bitmapToThisMatrix, desiredSourceX, desiredSourceY, effectiveSourceSizeX, effectiveSourceSizeY, focus, layout, opacity, ref3, s, scale, scaler, sourceArea, sourceLoc, sourceSize, sourceX, sourceY, targetSize;
    if (options == null) {
      options = emptyOptions;
    }
    if (!bitmap) {
      return;
    }
    targetSize = (ref3 = options.targetSize) != null ? ref3 : this.size, sourceArea = options.sourceArea, focus = options.focus, aspectRatio = options.aspectRatio, layout = options.layout, opacity = options.opacity;
    if (opacity < 1 / 256) {
      return;
    }
    if (sourceArea) {
      if (bitmap.pixelsPerPoint !== 1) {
        sourceArea = sourceArea.mul(bitmap.pixelsPerPoint);
      }
    } else {
      sourceArea = rect(bitmap.size);
    }
    bitmapSize = bitmap.size;
    sourceSize = sourceArea.size;
    sourceLoc = sourceArea.location;
    aspectRatio || (aspectRatio = sourceSize.aspectRatio);
    bitmapToThisMatrix = (function() {
      switch (layout) {
        case "stretch":
          return Matrix.scaleXY(targetSize.x / sourceSize.x, targetSize.y / sourceSize.y);
        case "zoom":
          adjustedTargetSize = aspectRatio !== sourceSize.aspectRatio ? point(targetSize.x * sourceSize.aspectRatio / aspectRatio, targetSize.y) : targetSize;
          scale = max(adjustedTargetSize.x / sourceSize.x, adjustedTargetSize.y / sourceSize.y);
          effectiveSourceSizeX = min(bitmapSize.x, ceil(adjustedTargetSize.x / scale));
          effectiveSourceSizeY = min(bitmapSize.y, ceil(adjustedTargetSize.y / scale));
          if (focus) {
            desiredSourceX = sourceSize.x * focus.x - effectiveSourceSizeX * .5;
            desiredSourceY = sourceSize.y * focus.y - effectiveSourceSizeY * .5;
          } else {
            desiredSourceX = sourceLoc.x + sourceSize.x * .5 - round(effectiveSourceSizeX * .5);
            desiredSourceY = sourceLoc.y + sourceSize.y * .5 - round(effectiveSourceSizeY * .5);
          }
          sourceX = bound(0, desiredSourceX, bitmapSize.x - effectiveSourceSizeX);
          sourceY = bound(0, desiredSourceY, bitmapSize.y - effectiveSourceSizeY);
          options = merge(options, {
            sourceArea: rect(sourceX, sourceY, effectiveSourceSizeX, effectiveSourceSizeY)
          });
          return Matrix.scaleXY(targetSize.x / effectiveSourceSizeX, targetSize.y / effectiveSourceSizeY);
        case "fit":
          bitmapToThisMatrix = matrix();
          if (aspectRatio !== bitmapSize.aspectRatio) {
            s = bitmapSize;
            bitmapSize = s.withAspectRatio(aspectRatio);
            bitmapToThisMatrix = bitmapToThisMatrix.scale(scaler = bitmapSize.div(s));
            sourceSize = sourceSize.mul(scaler);
            sourceLoc = sourceLoc.mul(scaler);
          }
          return Matrix.translateXY(-sourceArea.w / 2, -sourceArea.h / 2).mul(bitmapToThisMatrix).scale(min(targetSize.x / sourceSize.x, targetSize.y / sourceSize.y)).translateXY(targetSize.x / 2, targetSize.y / 2);
        default:
          throw new Error("unknown mode: " + this._mode);
      }
    }).call(this);
    if (where) {
      bitmapToThisMatrix = bitmapToThisMatrix.mul(matrix(where));
    }
    return this.drawBitmap(bitmapToThisMatrix, bitmap, options);
  };

  return BitmapBase;

})(BaseClass);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, ConfigRegistry, Promise, clone, compactFlatten, deepMerge, defineModule, expandPathedProperties, formattedInspect, inspect, isPlainObject, isString, log, merge, mergeInto, parseQuery, pushIfNotPresent, ref, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, Promise = ref.Promise, inspect = ref.inspect, formattedInspect = ref.formattedInspect, merge = ref.merge, deepMerge = ref.deepMerge, mergeInto = ref.mergeInto, parseQuery = ref.parseQuery, pushIfNotPresent = ref.pushIfNotPresent, isPlainObject = ref.isPlainObject, isString = ref.isString, upperCamelCase = ref.upperCamelCase, expandPathedProperties = ref.expandPathedProperties, clone = ref.clone, compactFlatten = ref.compactFlatten;

BaseObject = __webpack_require__(6).BaseObject;

defineModule(module, ConfigRegistry = (function(superClass) {
  extend(ConfigRegistry, superClass);

  function ConfigRegistry() {
    return ConfigRegistry.__super__.constructor.apply(this, arguments);
  }

  ConfigRegistry.configurables = [];

  ConfigRegistry.configs = {};

  ConfigRegistry.registerConfig = function(name, config) {
    if (!isPlainObject(config)) {
      throw new Error("config must be a plain object");
    }
    return ConfigRegistry.configs[name] = config;
  };

  ConfigRegistry.registerConfigurable = function(configurable) {
    return pushIfNotPresent(ConfigRegistry.configurables, configurable);
  };

  ConfigRegistry.configure = function() {
    var args, ref1;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    console.error("DEPRICATED: use Art.Config.configure");
    return (ref1 = Neptune.Art.Config).configure.apply(ref1, args);
  };

  return ConfigRegistry;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(438);


/***/ }),
/* 72 */
/***/ (function(module, exports) {

var EasingFunctions;

module.exports = EasingFunctions = (function() {
  function EasingFunctions() {}

  EasingFunctions.linear = function(t) {
    return t;
  };

  EasingFunctions.easeOutQuad = function(t) {
    return t * t;
  };

  EasingFunctions.easeInQuad = function(t) {
    return -t * (t - 2);
  };

  EasingFunctions.easeBothQuad = function(t) {
    if (t < .5) {
      return EasingFunctions.easeOutQuad(t * 2) * .5;
    } else {
      return EasingFunctions.easeInQuad(t * 2 - 1) * .5 + .5;
    }
  };

  EasingFunctions.easeOutCubic = function(t) {
    return t * t * t;
  };

  EasingFunctions.easeInCubic = function(t) {
    return (t = t - 1) * t * t + 1;
  };

  EasingFunctions.easeBothCubic = function(t) {
    if (t < .5) {
      return EasingFunctions.easeOutCubic(t * 2) * .5;
    } else {
      return EasingFunctions.easeInCubic(t * 2 - 1) * .5 + .5;
    }
  };

  EasingFunctions.easeOutQuart = function(t) {
    return t * t * t * t;
  };

  EasingFunctions.easeInQuart = function(t) {
    return -((t = t - 1) * t * t * t - 1);
  };

  EasingFunctions.easeBothQuart = function(t) {
    if (t < .5) {
      return EasingFunctions.easeOutQuart(t * 2) * .5;
    } else {
      return EasingFunctions.easeInQuart(t * 2 - 1) * .5 + .5;
    }
  };

  EasingFunctions.easeOutQuint = function(t) {
    return 1 * t * t * t * t * t;
  };

  EasingFunctions.easeInQuint = function(t) {
    return 1 * ((t = t - 1) * t * t * t * t + 1);
  };

  EasingFunctions.easeBothQuint = function(t) {
    if (t < .5) {
      return EasingFunctions.easeOutQuint(t * 2) * .5;
    } else {
      return EasingFunctions.easeInQuint(t * 2 - 1) * .5 + .5;
    }
  };

  EasingFunctions.easeOutSine = function(t) {
    return -Math.cos(t * Math.PI / 2) + 1;
  };

  EasingFunctions.easeInSine = function(t) {
    return Math.sin(t * Math.PI / 2);
  };

  EasingFunctions.easeBothSine = function(t) {
    return -.5 * (Math.cos(Math.PI * t) - 1);
  };

  EasingFunctions.easeOutExp = function(t) {
    if (t <= 0) {
      return 0;
    } else {
      return Math.pow(2, 10 * (t - 1));
    }
  };

  EasingFunctions.easeInExp = function(t) {
    if (t >= 1) {
      return 1;
    } else {
      return -Math.pow(2, -10 * t) + 1;
    }
  };

  EasingFunctions.easeBothExp = function(t) {
    if (t < .5) {
      return EasingFunctions.easeOutExp(t * 2) * .5;
    } else {
      return EasingFunctions.easeInExp(t * 2 - 1) * .5 + .5;
    }
  };

  EasingFunctions.easeOutCirc = function(t) {
    return -(Math.sqrt(1 - t * t) - 1);
  };

  EasingFunctions.easeInCirc = function(t) {
    return Math.sqrt(1 - (t -= 1) * t);
  };

  EasingFunctions.easeBothCirc = function(t) {
    if (t < .5) {
      return EasingFunctions.easeOutCirc(t * 2) * .5;
    } else {
      return EasingFunctions.easeInCirc(t * 2 - 1) * .5 + .5;
    }
  };

  EasingFunctions.easeOutElastic = function(t) {
    var p, s;
    if (t <= 0) {
      return 0;
    }
    if (t >= 1) {
      return 1;
    }
    p = .3;
    s = p / 4;
    t -= 1;
    return -Math.pow(2, 10 * t) * Math.sin((t - s) * (2 * Math.PI) / p);
  };

  EasingFunctions.easeInElastic = function(t) {
    var p, s;
    if (t <= 0) {
      return 0;
    }
    if (t >= 1) {
      return 1;
    }
    p = .3;
    s = p / 4;
    return Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
  };

  EasingFunctions.easeBothElastic = function(t) {
    if (t < .5) {
      return EasingFunctions.easeOutElastic(t * 2) * .5;
    } else {
      return EasingFunctions.easeInElastic(t * 2 - 1) * .5 + .5;
    }
  };

  EasingFunctions.easeOutBack = function(t, s) {
    if (s == null) {
      s = 1.70158;
    }
    return t * t * ((s + 1) * t - s);
  };

  EasingFunctions.easeInBack = function(t, s) {
    if (s == null) {
      s = 1.70158;
    }
    return (t = t - 1) * t * ((s + 1) * t + s) + 1;
  };

  EasingFunctions.easeBothBack = function(t, s) {
    if (t < .5) {
      return EasingFunctions.easeOutBack(t * 2) * .5;
    } else {
      return EasingFunctions.easeInBack(t * 2 - 1) * .5 + .5;
    }
  };

  EasingFunctions.easeOutBounce = function(t) {
    return 1 - EasingFunctions.easeInBounce(1 - t);
  };

  EasingFunctions.easeInBounce = function(t) {
    if (t < 1 / 2.75) {
      return 7.5625 * t * t;
    } else if (t < 2 / 2.75) {
      return 7.5625 * (t -= 1.5 / 2.75) * t + .75;
    } else if (t < 2.5 / 2.75) {
      return 7.5625 * (t -= 2.25 / 2.75) * t + .9375;
    } else {
      return 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }
  };

  EasingFunctions.easeBothBounce = function(t) {
    if (t < .5) {
      return EasingFunctions.easeOutBounce(t * 2) * .5;
    } else {
      return EasingFunctions.easeInBounce(t * 2 - 1) * .5 + .5;
    }
  };

  return EasingFunctions;

})();


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseClass, Config, Configurable, Validator, defineModule, mergeInto, ref, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), w = ref.w, Validator = ref.Validator, defineModule = ref.defineModule, mergeInto = ref.mergeInto, BaseClass = ref.BaseClass, Configurable = ref.Configurable;

defineModule(module, Config = (function(superClass) {
  extend(Config, superClass);

  function Config() {
    return Config.__super__.constructor.apply(this, arguments);
  }

  Config.defaults({
    drawCacheEnabled: true,
    partialRedrawEnabled: true,
    showPartialDrawAreas: false
  });

  return Config;

})(Configurable));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(118);

module.exports.addModules({
  DrawAreaCollector: __webpack_require__(213),
  DrawCacheManager: __webpack_require__(116),
  DrawEpoch: __webpack_require__(214),
  ElementDrawAreaMixin: __webpack_require__(413),
  ElementDrawLib: __webpack_require__(117),
  ElementDrawMixin: __webpack_require__(414)
});


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Atomic, BaseClass, Foundation, abs, isFunction, isPlainObject, log, nearInfinitePoint, nearInfinity, nearInfinityResult, point;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

BaseClass = Foundation.BaseClass, isPlainObject = Foundation.isPlainObject, log = Foundation.log, isFunction = Foundation.isFunction, nearInfinity = Foundation.nearInfinity, nearInfinityResult = Foundation.nearInfinityResult, abs = Foundation.abs;

point = Atomic.point;

module.exports = {
  nearInfinity: nearInfinity,
  nearInfinityResult: nearInfinityResult,
  nearInfinitePoint: nearInfinitePoint = point(nearInfinity),
  nearInfiniteSize: nearInfinitePoint,
  isInfiniteResult: function(x) {
    return abs(x) >= nearInfinityResult;
  },
  isFiniteResult: function(x) {
    return abs(x) < nearInfinityResult;
  }
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Atomic, BaseClass, Foundation, LayoutTools, Point, abs, isFunction, isInfiniteResult, nearInfiniteSize, nearInfinity, nearInfinityResult, perimeter, perimeter0, point, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

point = Atomic.point, Point = Atomic.Point, perimeter = Atomic.perimeter, perimeter0 = Atomic.perimeter0;

BaseClass = Foundation.BaseClass, isFunction = Foundation.isFunction, abs = Foundation.abs;

ref = __webpack_require__(75), nearInfiniteSize = ref.nearInfiniteSize, nearInfinity = ref.nearInfinity, nearInfinityResult = ref.nearInfinityResult, isInfiniteResult = ref.isInfiniteResult;

module.exports = LayoutTools = (function(superClass) {
  extend(LayoutTools, superClass);

  function LayoutTools() {
    return LayoutTools.__super__.constructor.apply(this, arguments);
  }

  LayoutTools.nearInfiniteSize = nearInfiniteSize;

  LayoutTools.nearInfinity = nearInfinity;

  LayoutTools.nearInfinityResult = nearInfinityResult;

  LayoutTools.isInfiniteResult = isInfiniteResult;

  LayoutTools.layoutMargin = function(element, parentSize, parentElement) {
    var margin;
    margin = element.getPendingMargin() || (parentElement != null ? parentElement.getPendingChildrenMargins() : void 0);
    return element._setMarginFromLayout(perimeter(isFunction(margin) ? margin(parentSize) : margin || perimeter0));
  };

  LayoutTools.layoutPadding = function(element, parentSize) {
    var padding;
    padding = element.getPendingPadding();
    return element._setPaddingFromLayout(perimeter(isFunction(padding) ? padding(parentSize) : padding || perimeter0));
  };

  LayoutTools.deinfinitize = function(p) {
    var x, y;
    x = p.x, y = p.y;
    x = isInfiniteResult(x) ? 0 : x;
    y = isInfiniteResult(y) ? 0 : y;
    return p["with"](x, y);
  };

  LayoutTools.sizeWithPadding = function(width, height, currentPadding) {
    return point(width + currentPadding.getWidth(), height + currentPadding.getHeight());
  };


  /*
  NOTE: layoutElement gets set via StateEpochLayout.coffee
  IN:
    element - the element to layout
    parentSizeForChildren - size of the parent, augmented by padding
    skipLocationLayout - if true, only the element's size is laid out.
  
  OUT:
    Element's pending currentSize
   */

  LayoutTools.layoutElement = null;

  return LayoutTools;

})(BaseClass);


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var StandardImport, merge;

merge = (StandardImport = __webpack_require__(126)).merge;

module.exports = merge(__webpack_require__(120), StandardImport);


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(39);

module.exports.includeInNamespace(__webpack_require__(418)).addModules({
  AtomElement: __webpack_require__(121),
  ShadowableElement: __webpack_require__(29)
});

__webpack_require__(225);

__webpack_require__(227);

__webpack_require__(229);

__webpack_require__(231);


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryBaseObject, BaseClass, config, defineModule,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

defineModule = __webpack_require__(1).defineModule;

BaseClass = __webpack_require__(6).BaseClass;

ArtEry = __webpack_require__(41);

config = __webpack_require__(27).config;

defineModule(module, ArtEryBaseObject = (function(superClass) {
  extend(ArtEryBaseObject, superClass);

  function ArtEryBaseObject() {
    return ArtEryBaseObject.__super__.constructor.apply(this, arguments);
  }

  ArtEryBaseObject.abstractClass();

  ArtEryBaseObject.getter({
    pipelines: function() {
      return ArtEry.pipelines;
    }
  });

  return ArtEryBaseObject;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(252);

module.exports.includeInNamespace(__webpack_require__(450)).addModules({
  AfterEventsFilter: __webpack_require__(128),
  DataUpdatesFilter: __webpack_require__(246),
  LinkFieldsFilter: __webpack_require__(247),
  TimestampFilter: __webpack_require__(248),
  Tools: __webpack_require__(249),
  UniqueIdFilter: __webpack_require__(250),
  UserOwnedFilter: __webpack_require__(251),
  UuidFilter: __webpack_require__(451),
  ValidationFilter: __webpack_require__(129)
});


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

var ArtEry, BaseObject, CommunicationStatus, Foundation, Promise, Request, RestClient, Validator, _validator, arrayWith, currentSecond, each, inspect, isFunction, isObject, isPlainObject, isString, log, merge, missing, object, objectHasKeys, objectKeyCount, objectWithout, present, ref, requestConstructorValidator, success, validStatus, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = Foundation = __webpack_require__(2), currentSecond = ref.currentSecond, each = ref.each, present = ref.present, Promise = ref.Promise, BaseObject = ref.BaseObject, RestClient = ref.RestClient, merge = ref.merge, inspect = ref.inspect, isString = ref.isString, isObject = ref.isObject, log = ref.log, Validator = ref.Validator, CommunicationStatus = ref.CommunicationStatus, arrayWith = ref.arrayWith, w = ref.w, objectKeyCount = ref.objectKeyCount, isString = ref.isString, isPlainObject = ref.isPlainObject, objectWithout = ref.objectWithout, isFunction = ref.isFunction, object = ref.object, objectHasKeys = ref.objectHasKeys;

ArtEry = __webpack_require__(41);

success = CommunicationStatus.success, missing = CommunicationStatus.missing, validStatus = CommunicationStatus.validStatus;

_validator = null;

requestConstructorValidator = function() {
  return _validator || (_validator = new Validator({
    pipeline: {
      required: {
        "instanceof": ArtEry.Pipeline
      }
    },
    type: {
      required: {
        fieldType: "string"
      }
    },
    session: {
      required: {
        fieldType: "object"
      }
    },
    parentRequest: {
      "instanceof": ArtEry.Request
    },
    originatedOnServer: "boolean",
    props: "object",
    key: "string"
  }));
};


/*
new Request(options)

IN: options:
  see requestConstructorValidator for the validated options
  below are special-case options

  props: {}
    Any props you want.
    Common props:

    data: - generaly one record's data or an array of record data
    key:  - generally the ID for one record OR the complete set of parameters for a get-query

   * aliases - if either data/key are provided in both props and in these aliases,
   *   these aliases have priority
  data: >> @props.data
  key:  >> @props.key

  NOTE: Request doesn't care about @data, the alias is proved only as a convenience
  NOTE: Request only cares about @key for two things:
    - REST urls
    - cachedGet

    In general, type: "get" and key: "string" is a CACHEABLE request.
    This is why it must be a string.
    Currently there are no controls for HOW cacheable type-get is, though.
    All other requests are NOT cacheable.

CONCEPTS

  context:

    This is the only mutable part of the request. It establishes one shared context for
    a request, all its clones, subrequests, responses and response clones.

    The primary purpose is for subrequests to coordinate their actions with the primary
    request. Currently this is only used server-side.

    There are two contexts when using a remote server: The client-side context is not
    shared with the server-side context. A new context is created server-side when
    responding to the request.

    BUT - there is only one context if location == "both" - if we are running without
    a remote server.
 */

module.exports = Request = (function(superClass) {
  var getRestClientParamsForArtEryRequest, restMap;

  extend(Request, superClass);

  function Request(options) {
    var key, ref1, ref2, ref3;
    Request.__super__.constructor.apply(this, arguments);
    this.type = options.type, this.pipeline = options.pipeline, this.session = options.session, this.parentRequest = options.parentRequest, this.originatedOnServer = options.originatedOnServer, this.props = (ref1 = options.props) != null ? ref1 : {}, this.context = (ref2 = options.context) != null ? ref2 : {};
    this._startTime = null;
    key = (ref3 = options.key) != null ? ref3 : this._props.key;
    if (key != null) {
      options.key = this._props.key = this.pipeline.toKeyString(key);
    }
    if (options.data != null) {
      this._props.data = options.data;
    }
    requestConstructorValidator().validate(options, {
      context: "Art.Ery.Request options",
      logErrors: true
    });
    if (options.requestOptions) {
      throw new Error("options.requestOptions is DEPRICATED - use options.props");
    }
  }

  Request.property("type pipeline session originatedOnServer parentRequest props data key context");

  Request.getter({
    key: function() {
      return this._props.key;
    },
    data: function() {
      return this._props.data;
    },
    requestData: function() {
      return this._props.data;
    },
    requestProps: function() {
      return this._props;
    },
    requestOptions: function() {
      throw new Error("DEPRICATED: use props");
    },
    description: function() {
      return this.requestString + " request";
    }
  });

  Request.getter({
    request: function() {
      return this;
    },
    shortInspect: function() {
      return "" + (this.parentRequest ? this.parentRequest.shortInspect + " > " : "") + (this.pipeline.getName()) + "-" + this.type + "(" + (this.key || '') + ")";
    },
    beforeFilterLog: function() {
      return this.filterLog || [];
    },
    afterFilterLog: function() {
      return [];
    },
    isSuccessful: function() {
      return true;
    },
    notSuccessful: function() {
      return false;
    },
    isRequest: function() {
      return true;
    },
    isRootRequest: function() {
      return !this.parentRequest;
    },
    requestPipelineAndType: function() {
      return this.pipeline.name + "-" + this.type;
    },
    propsForClone: function() {
      return {
        pipeline: this.pipeline,
        type: this.type,
        props: this.props,
        session: this.session,
        parentRequest: this.parentRequest,
        filterLog: this.filterLog,
        originatedOnServer: this.originatedOnServer,
        context: this.context
      };
    },
    urlKeyClause: function() {
      if (present(this.key)) {
        return "/" + this.key;
      } else {
        return "";
      }
    }
  });

  Request.prototype.handled = function(_handledBy) {
    return this.success().then(function(response) {
      return response.handled(_handledBy);
    });
  };

  Request.prototype.getRestRequestUrl = function(server) {
    return server + "/" + this.pipeline.name + this.urlKeyClause;
  };

  Request.prototype.getNonRestRequestUrl = function(server) {
    return server + "/" + this.pipeline.name + "-" + this.type + this.urlKeyClause;
  };

  restMap = {
    get: "get",
    create: "post",
    update: "put",
    "delete": "delete"
  };

  Request.getRestClientParamsForArtEryRequest = getRestClientParamsForArtEryRequest = function(arg) {
    var data, hasSessionData, key, method, restPath, server, session, type, url, urlKeyClause;
    session = arg.session, server = arg.server, restPath = arg.restPath, type = arg.type, key = arg.key, data = arg.data;
    urlKeyClause = present(key) ? "/" + key : "";
    server || (server = "");
    hasSessionData = objectHasKeys(session);
    url = (method = restMap[type]) && (method !== "get" || !hasSessionData) ? "" + server + restPath + urlKeyClause : (method = "post", "" + server + restPath + "-" + type + urlKeyClause);
    return {
      method: method,
      url: url,
      data: data
    };
  };

  Request.getter({
    remoteRequestProps: function() {
      var data, key, pipeline, props, propsCount, ref1, remoteRequestData, session, type;
      ref1 = this, session = ref1.session, data = ref1.data, props = ref1.props, pipeline = ref1.pipeline, type = ref1.type, key = ref1.key;
      propsCount = 0;
      props = object(props, {
        when: function(v, k) {
          return v !== void 0 && k !== "key" && k !== "data";
        }
      });
      data = object(data, {
        when: function(v) {
          return v !== void 0;
        }
      });
      remoteRequestData = null;
      if (session.signature) {
        (remoteRequestData || (remoteRequestData = {})).session = session.signature;
      }
      if (0 < objectHasKeys(props)) {
        (remoteRequestData || (remoteRequestData = {})).props = props;
      }
      if (0 < objectHasKeys(data)) {
        (remoteRequestData || (remoteRequestData = {})).data = data;
      }
      return getRestClientParamsForArtEryRequest({
        restPath: pipeline.restPath,
        server: (function() {
          switch (pipeline.remoteServer) {
            case true:
            case ".":
            case "/":
              return "";
            default:
              return pipeline.remoteServer;
          }
        })(),
        type: type,
        key: key,
        session: session,
        data: remoteRequestData
      });
    }
  });

  Request.createFromRemoteRequestProps = function(options) {
    var data, key, pipeline, props, requestData, session, type;
    session = options.session, pipeline = options.pipeline, type = options.type, key = options.key, requestData = options.requestData;
    data = requestData.data, props = requestData.props;
    return new Request({
      pipeline: pipeline,
      type: type,
      session: session,
      key: key,
      data: data,
      props: props,
      originatedOnClient: true
    });
  };

  Request.prototype.sendRemoteRequest = function() {
    var remoteRequest;
    return RestClient.restJsonRequest(remoteRequest = this.remoteRequestProps)["catch"]((function(_this) {
      return function(arg) {
        var ref1, response, status;
        ref1 = arg.info, status = ref1.status, response = ref1.response;
        return merge(response, {
          status: status
        });
      };
    })(this)).then((function(_this) {
      return function(remoteResponse) {
        return _this.addFilterLog((remoteRequest.method.toLocaleUpperCase()) + " " + remoteRequest.url).toResponse(remoteResponse.status, merge(remoteResponse, {
          remoteRequest: remoteRequest,
          remoteResponse: remoteResponse
        }));
      };
    })(this));
  };

  return Request;

})(__webpack_require__(82));


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryBaseObject, Promise, RequestResponseBase, array, arrayWith, clientFailure, clientFailureNotAuthorized, compactFlatten, config, currentSecond, defineModule, failure, formattedInspect, inspect, inspectedObjectLiteral, isArray, isClientFailure, isFunction, isJsonType, isPlainObject, isPromise, isString, log, merge, missing, networkFailure, object, objectWithDefinedValues, objectWithout, present, ref, ref1, serverFailure, success, timeout, toInspectedObjects,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), timeout = ref.timeout, currentSecond = ref.currentSecond, log = ref.log, arrayWith = ref.arrayWith, defineModule = ref.defineModule, merge = ref.merge, isJsonType = ref.isJsonType, isString = ref.isString, isPlainObject = ref.isPlainObject, isArray = ref.isArray, inspect = ref.inspect, inspectedObjectLiteral = ref.inspectedObjectLiteral, toInspectedObjects = ref.toInspectedObjects, formattedInspect = ref.formattedInspect, Promise = ref.Promise, object = ref.object, isFunction = ref.isFunction, objectWithDefinedValues = ref.objectWithDefinedValues, objectWithout = ref.objectWithout, array = ref.array, isPromise = ref.isPromise, compactFlatten = ref.compactFlatten, present = ref.present;

ArtEry = __webpack_require__(41);

ArtEryBaseObject = __webpack_require__(79);

ref1 = __webpack_require__(19), networkFailure = ref1.networkFailure, failure = ref1.failure, isClientFailure = ref1.isClientFailure, success = ref1.success, missing = ref1.missing, serverFailure = ref1.serverFailure, clientFailure = ref1.clientFailure, clientFailureNotAuthorized = ref1.clientFailureNotAuthorized;

config = __webpack_require__(27).config;


/*
TODO: merge reponse and request into one object

TODO: Work towards the concept of "oldData" - sometimes we need to know
 the oldData when updating. Specifically, ArtEryPusher needs to know the oldData
 to notify clients if a record is removed from one query and added to another.
 Without oldData, there is no way of knowing what old query it was removed from.
 In this case, either a) the client needs to send the oldData to the server of b)
 we need to fetch the oldData before overwriting it - OR we need to us returnValues: "allOld".

 Too bad there isn't a way to return BOTH the old and new fields with DynamoDb.

 Not sure if ArtEry needs any special code for "oldData." It'll probably be a convention
 that ArtEryAws and ArtEryPusher conform to. It's just a props from ArtEry's POV.
 */

defineModule(module, RequestResponseBase = (function(superClass) {
  var cachedGet, defaultWhenTest;

  extend(RequestResponseBase, superClass);

  function RequestResponseBase(options) {
    RequestResponseBase.__super__.constructor.apply(this, arguments);
    this._creationTime = currentSecond();
    this.filterLog = options.filterLog, this.errorProps = options.errorProps;
  }

  RequestResponseBase.property("filterLog errorProps creationTime");

  RequestResponseBase.prototype.addFilterLog = function(filter) {
    this._filterLog = arrayWith(this._filterLog, {
      name: isString(filter) ? filter : filter.getLogName(this.type),
      time: currentSecond()
    });
    return this;
  };

  RequestResponseBase.getter({
    location: function() {
      return this.pipeline.location;
    },
    requestType: function() {
      return this.type;
    },
    pipelineName: function() {
      return this.pipeline.getName();
    },
    requestDataWithKey: function() {
      return merge(this.requestData, this.keyObject);
    },
    keyObject: function() {
      return this.request.pipeline.toKeyObject(this.key);
    },
    rootRequest: function() {
      var ref2;
      return ((ref2 = this.parentRequest) != null ? ref2.rootRequest : void 0) || this.request;
    },
    startTime: function() {
      return this.rootRequest.creationTime;
    },
    endTime: function() {
      return this.creationTime;
    },
    wallTime: function() {
      return this.startTime - this.endTime;
    },
    inspectedObjects: function() {
      var obj;
      return (
        obj = {},
        obj["" + this["class"].namespacePath] = toInspectedObjects(objectWithDefinedValues(objectWithout(this.propsForClone, "context"))),
        obj
      );
    }
  });

  RequestResponseBase.getter({
    requestSession: function() {
      return this.request.session;
    },
    requestProps: function() {
      return this.request.requestProps;
    },
    requestData: function() {
      return this.request.requestData;
    },
    isRootRequest: function() {
      return this.request.isRootRequest;
    },
    key: function() {
      var ref2;
      return this.request.key || ((ref2 = this.responseData) != null ? ref2.id : void 0);
    },
    pipeline: function() {
      return this.request.pipeline;
    },
    parentRequest: function() {
      return this.request.parentRequest;
    },
    type: function() {
      return this.request.type;
    },
    originatedOnServer: function() {
      return this.request.originatedOnServer;
    },
    context: function() {
      return this.request.context;
    },
    requestString: function() {
      var str;
      str = this.pipelineName + "." + this.type;
      if (this.key) {
        return str + (" " + (formattedInspect(this.key)));
      } else {
        return str;
      }
    },
    description: function() {
      return this.requestString;
    },
    requestPathArray: function(into) {
      var localInto, parentRequest;
      localInto = into || [];
      parentRequest = this.parentRequest;
      if (parentRequest) {
        parentRequest.getRequestPathArray(localInto);
      }
      localInto.push(this);
      return localInto;
    },
    requestPath: function() {
      var r;
      return "<" + (((function() {
        var i, len, ref2, results;
        ref2 = this.requestPathArray;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          r = ref2[i];
          results.push(r.toStringCore());
        }
        return results;
      }).call(this)).join(' >> ')) + ">";
    }
  });

  RequestResponseBase.prototype.toStringCore = function() {
    return "ArtEry." + (this.isResponse ? 'Response' : 'Request') + " " + this.pipelineName + "." + this.type + (this.key ? " key: " + this.key : '');
  };

  RequestResponseBase.prototype.toString = function() {
    return "<" + (this.toStringCore()) + ">";
  };

  RequestResponseBase.getter({
    requestCache: function() {
      var base;
      return (base = this.context).requestCache || (base.requestCache = {});
    },
    subrequestCount: function() {
      var base;
      return (base = this.context).subrequestCount || (base.subrequestCount = 0);
    }
  });

  RequestResponseBase.setter({
    responseProps: function() {
      throw new Error("cannot set responseProps");
    }
  });

  RequestResponseBase.prototype.incrementSubrequestCount = function() {
    return this.context.subrequestCount = (this.context.subrequestCount | 0) + 1;
  };


  /*
  TODO:
    I think I may have a way clean up the subrequest API and do
    what is easy in Ruby: method-missing.
  
    Here's the new API:
       * request on the same pipeline
      request.pipeline.requestType requestOptions
  
       * request on another pipeline
      request.pipelines.otherPipelineName.requestType requestOptions
  
    Here's how:
      .pipeline and .pipelines are getters
      And the return proxy objects, generated and cached on the fly.
  
    Alt API idea:
       * same pipeline
      request.subrequest.requestType
  
       * other pipelines
      request.crossSubrequest.user.requestType
  
      I kinda like this more because it makes it clear we are talking
      sub-requests. This is just a ALIASes to the API above.
   */

  RequestResponseBase.prototype.createSubRequest = function(pipelineName, type, requestOptions) {
    var pipeline, ref2;
    if (requestOptions && !isPlainObject(requestOptions)) {
      throw new Error("requestOptions must be an object");
    }
    pipeline = ArtEry.pipelines[pipelineName];
    if (!pipeline) {
      throw new Error("Pipeline not registered: " + (formattedInspect(pipelineName)));
    }
    return new ArtEry.Request(merge({
      originatedOnServer: (ref2 = requestOptions != null ? requestOptions.originatedOnServer : void 0) != null ? ref2 : true
    }, requestOptions, {
      type: type,
      pipeline: pipeline,
      session: (requestOptions != null ? requestOptions.session : void 0) || this.session,
      parentRequest: this.request,
      context: this.context
    }));
  };

  RequestResponseBase.prototype.subrequest = function(pipelineName, type, requestOptions) {
    var promise, ref2, subrequest;
    if (isString(requestOptions)) {
      requestOptions = {
        key: requestOptions
      };
    }
    pipelineName = pipelineName.pipelineName || pipelineName;
    subrequest = this.createSubRequest(pipelineName, type, requestOptions);
    this.incrementSubrequestCount();
    promise = subrequest.pipeline._processRequest(subrequest).then((function(_this) {
      return function(response) {
        return response.toPromise(requestOptions);
      };
    })(this));
    if (type === "update" && !(requestOptions != null ? (ref2 = requestOptions.props) != null ? ref2.returnValues : void 0 : void 0) && isString(subrequest.key)) {
      this._getPipelineTypeCache(pipelineName, type)[subrequest.key] = promise;
    }
    return promise;
  };

  RequestResponseBase.prototype.nonblockingSubrequest = function(pipelineName, type, requestOptions) {
    this.subrequest(pipelineName, type, requestOptions).then((function(_this) {
      return function(result) {
        if (config.verbose) {
          return log({
            ArtEry: {
              RequestResponseBase: {
                nonblockingSubrequest: {
                  status: "success",
                  pipelineName: pipelineName,
                  type: type,
                  requestOptions: requestOptions,
                  parentRequest: {
                    pipelineName: _this.pipelineName,
                    type: _this.type,
                    key: _this.key
                  },
                  result: result
                }
              }
            }
          });
        }
      };
    })(this))["catch"]((function(_this) {
      return function(error) {
        return log({
          ArtEry: {
            RequestResponseBase: {
              nonblockingSubrequest: {
                status: "failure",
                pipelineName: pipelineName,
                type: type,
                requestOptions: requestOptions,
                parentRequest: {
                  pipelineName: _this.pipelineName,
                  type: _this.type,
                  key: _this.key
                },
                error: error
              }
            }
          }
        });
      };
    })(this));
    return Promise.resolve();
  };

  RequestResponseBase.prototype._getPipelineTypeCache = function(pipelineName, type) {
    var base, base1;
    return (base = ((base1 = this.requestCache)[pipelineName] || (base1[pipelineName] = {})))[type] || (base[type] = {});
  };

  RequestResponseBase.prototype.cachedSubrequest = function(pipelineName, cacheType, requestType, options) {
    var base, key;
    key = isString(options) ? options : options.key;
    if (!isString(key)) {
      throw new Error("cachedSubrequest: key must be a string (" + (formattedInspect({
        key: key
      })) + ")");
    }
    return (base = this._getPipelineTypeCache(pipelineName, cacheType))[key] || (base[key] = this.subrequest(pipelineName, requestType, options)["catch"]((function(_this) {
      return function(error) {
        if (error.status === networkFailure && requestType === "get") {
          return timeout(20 + 10 * Math.random()).then(function() {
            return _this.subrequest(pipelineName, requestType, options);
          });
        } else {
          throw error;
        }
      };
    })(this)));
  };

  RequestResponseBase.prototype.setGetCache = function() {
    if (this.status === success && present(this.key) && (this.responseData != null)) {
      return this._getPipelineTypeCache(this.pipelineName, "get")[this.key] = Promise.then((function(_this) {
        return function() {
          return _this.responseData;
        };
      })(this));
    }
  };

  RequestResponseBase.prototype.cachedGet = cachedGet = function(pipelineName, key) {
    if (!isString(key)) {
      throw new Error("cachedGet: key must be a string (" + (formattedInspect({
        key: key
      })) + ")");
    }
    return this.cachedSubrequest(pipelineName, "get", "get", key);
  };

  RequestResponseBase.prototype.cachedGetWithoutInclude = function(pipelineName, key) {
    if (!isString(key)) {
      throw new Error("cachedGetWithoutInclude: key must be a string (" + (formattedInspect({
        key: key
      })) + ")");
    }
    return this._getPipelineTypeCache(pipelineName, "get")[key] || this.cachedSubrequest(pipelineName, "get-no-include", "get", {
      key: key,
      props: {
        include: false
      }
    });
  };

  RequestResponseBase.prototype.cachedPipelineGet = cachedGet;

  RequestResponseBase.prototype.cachedGetIfExists = function(pipelineName, key) {
    if (key == null) {
      return Promise.resolve(null);
    }
    return this.cachedGet(pipelineName, key)["catch"](function(error) {
      if (error.status === missing) {
        return Promise.resolve(null);
      } else {
        throw error;
      }
    });
  };


  /*
  IN:
    test: booleanish
    message: string (optional)
  OUT:
    Success: promise.then (request) ->
    Failure: promise.catch (error) ->
      error.props.response # failing response
      error.props.response.data.message.match message # if message res provided
  
  Success if test is true
   */

  RequestResponseBase.prototype.require = function(test, message) {
    if (test) {
      return Promise.resolve(this);
    } else {
      if (isFunction(message)) {
        message = message();
      }
      return this.clientFailure({
        data: {
          message: "requirement not met: " + (message || 'see stack trace')
        }
      }).then(function(response) {
        return response.toPromise();
      });
    }
  };

  RequestResponseBase.prototype.requiredFields = function(fields, message) {
    var k, v;
    for (k in fields) {
      v = fields[k];
      if (v == null) {
        return this.clientFailure({
          data: {
            message: "requirement not met: '" + k + "' expected" + (message ? " " + message : "")
          }
        }).then(function(response) {
          return response.toPromise();
        });
      }
    }
    return Promise.resolve(fields);
  };

  RequestResponseBase.prototype.rejectIf = function(test, message) {
    return this.require(!test, message);
  };


  /*
  Success if @originatedOnServer is true
  OUT: see require
   */

  RequestResponseBase.prototype.requireServerOrigin = function(message) {
    return this.requireServerOriginOr(true, message);
  };


  /*
  Success if either testResult or @originatedOnServer are true.
  OUT: see require
   */

  RequestResponseBase.prototype.requireServerOriginOr = function(testResult, message) {
    return this.require(testResult || this.originatedOnServer, function() {
      if (!(message != null ? message.match(/\s*to\s/) : void 0)) {
        message = "to " + message;
      }
      return "originatedOnServer required " + (message != null ? message : '');
    });
  };


  /*
  Success if either NOT testResult or @originatedOnServer are true.
  OUT: see require
  
  EXAMPLE: request.requireServerOriginIf createOk, "to use createOk"
   */

  RequestResponseBase.prototype.requireServerOriginIf = function(testResult, message) {
    return this.requireServerOriginOr(!testResult, message);
  };

  RequestResponseBase.prototype["with"] = function(constructorOptions) {
    return Promise.resolve(constructorOptions).then((function(_this) {
      return function(constructorOptions) {
        return _this._with(constructorOptions);
      };
    })(this));
  };

  RequestResponseBase.prototype._with = function(o) {
    return new this["class"](merge(this.propsForClone, o));
  };


  /*
  IN: data can be a plainObject or a promise returning a plainObject
  OUT: promise.then (new request or response instance) ->
  
  withData:           new instance has @data replaced by `data`
  withMergedData:     new instance has @data merged with `data`
  withSession:        new instance has @session replaced by `session`
  withMergedSession:  new instance has @session merged with `session`
   */

  RequestResponseBase.prototype.withData = function(data) {
    return Promise.resolve(data).then((function(_this) {
      return function(data) {
        return _this._with({
          data: data
        });
      };
    })(this));
  };

  RequestResponseBase.prototype.withMergedData = function(data) {
    return Promise.resolve(data).then((function(_this) {
      return function(data) {
        return _this._with({
          data: merge(_this.data, data)
        });
      };
    })(this));
  };

  RequestResponseBase.prototype.withProps = function(props) {
    return Promise.resolve(props).then((function(_this) {
      return function(props) {
        return _this._with({
          props: props,
          key: props.key,
          data: props.data
        });
      };
    })(this));
  };

  RequestResponseBase.prototype.withMergedProps = function(props) {
    return Promise.resolve(props).then((function(_this) {
      return function(props) {
        return _this._with({
          key: props.key,
          data: props.data,
          props: merge(_this.props, props)
        });
      };
    })(this));
  };

  RequestResponseBase.prototype.withSession = function(session) {
    return Promise.resolve(session).then((function(_this) {
      return function(session) {
        return _this._with({
          session: session
        });
      };
    })(this));
  };

  RequestResponseBase.prototype.withMergedSession = function(session) {
    return Promise.resolve(session).then((function(_this) {
      return function(session) {
        return _this._with({
          session: merge(_this.session, session)
        });
      };
    })(this));
  };

  RequestResponseBase.prototype.respondWithSession = function(session) {
    return this.success({
      session: session
    });
  };

  RequestResponseBase.prototype.respondWithMergedSession = function(session) {
    return this.success({
      session: merge(this.session, session)
    });
  };


  /*
  IN:
    withFunction, whenFunction
    OR: object:
      with: withFunction
      when: whenFunction
  
  withFunction: (record, requestOrResponse) ->
    IN:
      record: a plain object
      requestOrResponse: this
    OUT: See EFFECT below
      (can return a Promise in all situations)
  
  whenFunction: (record, requestOrResponse) -> t/f
    withFunction is only applied if whenFunction returns true
  
  EFFECT:
    if isPlainObject @data
      called once: singleRecordTransform @data
      if singleRecordTransform returns:
        null:         >> return status: missing
        plainObject:  >> return @withData data
        response:     >> return response
  
      See singleRecordTransform.OUT above for results
  
    if isArray @data
      Basically:
        @withData array record in @data with singleRecordTransform record
  
      But, each value returned from singleRecordTransform:
        null:                              omitted from array results
        response.status is clientFailure*: omitted from array results
        plainObject:                       returned in array results
        if any error:
            exception thrown
            rejected promise
            response.status is not success and not clientFailure
          then a failing response is returned
  
  TODO:
    Refactor. 'when' should really be a Filter - just like Caffeine/CoffeeScript comprehensions.
      Right now, if when is false, the record is still returned, just not "withed"
      Instead, only records that pass "when" should even be returned.
   */

  defaultWhenTest = function(data, request) {
    return request.pipeline.isRecord(data);
  };

  RequestResponseBase.prototype.withTransformedRecords = function(withFunction, whenFunction) {
    var firstFailure, options, transformedRecords;
    if (whenFunction == null) {
      whenFunction = defaultWhenTest;
    }
    if (isPlainObject(options = withFunction)) {
      withFunction = options["with"];
      whenFunction = options.when || defaultWhenTest;
    }
    if (isPlainObject(this.data)) {
      return Promise.resolve(whenFunction(this.data, this) ? this.next(withFunction(this.data, this)) : this);
    } else if (isArray(this.data)) {
      firstFailure = null;
      transformedRecords = array(this.data, (function(_this) {
        return function(record) {
          return Promise.then(function() {
            if (whenFunction(record, _this)) {
              return withFunction(record, _this);
            } else {
              return record;
            }
          })["catch"](function(error) {
            var ref2, response;
            if (error.status === "missing") {
              return null;
            } else if (response = error != null ? (ref2 = error.props) != null ? ref2.response : void 0 : void 0) {
              return response;
            } else {
              throw error;
            }
          }).then(function(out) {
            if ((out != null ? out.status : void 0) && out instanceof RequestResponseBase) {
              if (isClientFailure(out.status)) {
                if (typeof out._clearErrorStack === "function") {
                  out._clearErrorStack();
                }
                return null;
              } else {
                return firstFailure || (firstFailure = out);
              }
            } else {
              return out;
            }
          });
        };
      })(this));
      return Promise.all(transformedRecords).then((function(_this) {
        return function(records) {
          return firstFailure || _this.withData(compactFlatten(records));
        };
      })(this));
    } else {
      return Promise.resolve(this);
    }
  };


  /*
  next is used right after a filter or a handler.
  It's job is to convert the results into a request or response object.
  
  IN:
    null/undefined OR
    JSON-compabile data-type OR
    Response/Request OR
    something else - which is invalid, but is handled.
  
    OR a Promise returing one of the above
  
  OUT:
    if a Request or Response object was passed in, that is immediatly returned.
    Otherwise, this returns a Response object as follows:
  
  
    if data is null/undefined, return @missing
    if data is a JSON-compatible data structure, return @success with that data
    else, return @failure
   */

  RequestResponseBase.prototype.next = function(data) {
    return Promise.resolve(data).then((function(_this) {
      return function(data) {
        if (data instanceof RequestResponseBase) {
          return data;
        }
        if (data == null) {
          return _this.missing();
        } else if (isJsonType(data)) {
          return _this.success({
            data: data
          });
        } else {
          log.error({
            invalidXYZ: data
          });
          throw new Error("invalid response data passed to RequestResponseBaseNext");
        }
      };
    })(this), (function(_this) {
      return function(error) {
        var ref2, ref3;
        if ((ref2 = error.props) != null ? (ref3 = ref2.response) != null ? ref3.isResponse : void 0 : void 0) {
          return error.props.response;
        } else {
          return _this.failure({
            error: error
          });
        }
      };
    })(this));
  };

  RequestResponseBase.prototype.success = function(responseProps) {
    return this.toResponse(success, responseProps);
  };

  RequestResponseBase.prototype.missing = function(responseProps) {
    return this.toResponse(missing, responseProps);
  };

  RequestResponseBase.prototype.clientFailure = function(responseProps) {
    return this.toResponse(clientFailure, responseProps);
  };

  RequestResponseBase.prototype.clientFailureNotAuthorized = function(responseProps) {
    return this.toResponse(clientFailureNotAuthorized, responseProps);
  };

  RequestResponseBase.prototype.failure = function(responseProps) {
    return this.toResponse(failure, responseProps);
  };


  /*
  IN:
    status: legal CommunicationStatus
    responseProps: (optionally Promise returning:)
      PlainObject:          directly passed into the Response constructor
      String:               becomes data: message: string
      RequestResponseBase:  returned directly
      else:                 considered internal error, but it will create a valid, failing Response object
  OUT:
    promise.then (response) ->
    .catch -> # should never happen
   */

  RequestResponseBase.prototype.toResponse = function(status, responseProps) {
    if (!isString(status)) {
      throw new Error("missing status");
    }
    return Promise.resolve(responseProps).then((function(_this) {
      return function(responseProps) {
        if (responseProps == null) {
          responseProps = {};
        }
        switch (false) {
          case !(responseProps instanceof RequestResponseBase):
            log.warn("toResponse is instanceof RequestResponseBase - is this EVER used???");
            return responseProps;
          case !isPlainObject(responseProps):
            return new ArtEry.Response(merge(_this.propsForResponse, responseProps, {
              status: status,
              request: _this.request
            }));
          case !isString(responseProps):
            return _this.toResponse(status, {
              data: {
                message: responseProps
              }
            });
          default:
            return _this.toResponse(failure, _this._toErrorResponseProps(responseProps));
        }
      };
    })(this));
  };

  RequestResponseBase.prototype._toErrorResponseProps = function(error) {
    return log(this, {
      responseProps: responseProps
    }, {
      data: {
        message: responseProps instanceof Error ? "Internal Error: ArtEry.RequestResponseBase#toResponse received Error instance: " + (formattedInspect(responseProps)) : "Internal Error: ArtEry.RequestResponseBase#toResponse received unsupported type"
      }
    });
  };

  return RequestResponseBase;

})(ArtEryBaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, ModelRegistry, Promise, decapitalize, defineModule, formattedInspect, inspect, isClass, log, ref, timeout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), Promise = ref.Promise, timeout = ref.timeout, log = ref.log, formattedInspect = ref.formattedInspect, BaseObject = ref.BaseObject, decapitalize = ref.decapitalize, isClass = ref.isClass, inspect = ref.inspect, defineModule = ref.defineModule;

defineModule(module, ModelRegistry = (function(superClass) {
  var _registerModel, models;

  extend(ModelRegistry, superClass);

  function ModelRegistry() {
    return ModelRegistry.__super__.constructor.apply(this, arguments);
  }

  ModelRegistry.models = models = {};

  ModelRegistry._modelRegistrationPromiseResolvers = {};

  _registerModel = function(name, model) {
    if (models[name]) {
      throw new Error("ArtFlux.ModelRegistry: model already registered for name: '" + name + "'. " + (formattedInspect({
        alreadyRegisteredModel: models[name],
        attemptingToRegisterModel: model,
        name: name
      })));
    }
    return models[name] = model;
  };

  ModelRegistry.register = function(model) {
    var alias, i, len, modelName, ref1;
    modelName = model.modelName;
    ref1 = model["class"]._aliases;
    for (i = 0, len = ref1.length; i < len; i++) {
      alias = ref1[i];
      _registerModel(alias, model);
    }
    _registerModel(modelName, model);
    return ModelRegistry._modelRegistered(model);
  };

  ModelRegistry._modelRegistered = function(model) {
    var i, len, modelName, resolve, resolvers;
    modelName = model.modelName;
    if (resolvers = this._modelRegistrationPromiseResolvers[modelName]) {
      for (i = 0, len = resolvers.length; i < len; i++) {
        resolve = resolvers[i];
        resolve(model);
      }
    }
    return model;
  };

  ModelRegistry.onModelRegistered = function(modelName) {
    return new Promise((function(_this) {
      return function(resolve, reject) {
        var base, model;
        if (model = _this.models[modelName]) {
          return resolve(model);
        } else {
          return ((base = _this._modelRegistrationPromiseResolvers)[modelName] || (base[modelName] = [])).push(resolve);
        }
      };
    })(this));
  };

  ModelRegistry._singletonName = function(model) {
    return decapitalize(model.name);
  };

  ModelRegistry._reset = function() {
    var i, k, len, ref1, results;
    ref1 = Object.keys(models);
    results = [];
    for (i = 0, len = ref1.length; i < len; i++) {
      k = ref1[i];
      results.push(delete models[k]);
    }
    return results;
  };

  return ModelRegistry;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(264);

module.exports.addModules({
  FluxEntry: __webpack_require__(263),
  FluxModel: __webpack_require__(460),
  FluxStore: __webpack_require__(135),
  FluxSubscriptionsMixin: __webpack_require__(461),
  ModelRegistry: __webpack_require__(83)
});


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var DomConsole,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(273)).addNamespace('DomConsole', DomConsole = (function(superClass) {
  extend(DomConsole, superClass);

  function DomConsole() {
    return DomConsole.__super__.constructor.apply(this, arguments);
  }

  return DomConsole;

})(Neptune.PackageNamespace));

__webpack_require__(270);


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var StandardLib, WebWorker, log;

StandardLib = __webpack_require__(1);

log = StandardLib.log;


/*
SRC:
  http://jsfiddle.net/uqcFM/49/
  http://stackoverflow.com/a/10372280/2121000
 */

module.exports = WebWorker = (function() {
  var startWorkerFromJsString;

  function WebWorker() {}

  WebWorker.echoWebWorker = "self.onmessage=function(e){postMessage('Worker: '+e.data);}";

  WebWorker.isBrowser = !!(self.window && self.navigator && self.document);

  WebWorker.isWebWorker = !WebWorker.isBrowser && self.importScripts;

  WebWorker.startWorkerFromJsString = startWorkerFromJsString = function(workerSource) {
    return new Worker(URL.createObjectURL(new Blob([workerSource], {
      type: 'application/javascript'
    })));
  };

  WebWorker.startWorkerFromFunction = function(workerFunction) {
    return startWorkerFromJsString("(" + workerFunction + ")();");
  };

  return WebWorker;

})();


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var Foundation,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.Foundation', Foundation = (function(superClass) {
  extend(Foundation, superClass);

  function Foundation() {
    return Foundation.__super__.constructor.apply(this, arguments);
  }

  Foundation.version = __webpack_require__(332).version;

  return Foundation;

})(Neptune.PackageNamespace));

__webpack_require__(277);

__webpack_require__(284);


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var ArtEngineCore, Epoch, Foundation, GlobalEpochCycle, ReactArtEngineEpoch, clone, globalCount, inspect, isWebWorker, log, merge, peek, stackTime,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

log = Foundation.log, merge = Foundation.merge, clone = Foundation.clone, peek = Foundation.peek, inspect = Foundation.inspect, Epoch = Foundation.Epoch, globalCount = Foundation.globalCount, stackTime = Foundation.stackTime, isWebWorker = Foundation.isWebWorker;

module.exports = ReactArtEngineEpoch = (function(superClass) {
  extend(ReactArtEngineEpoch, superClass);

  function ReactArtEngineEpoch() {
    return ReactArtEngineEpoch.__super__.constructor.apply(this, arguments);
  }

  ReactArtEngineEpoch.singletonClass();

  ReactArtEngineEpoch.prototype.addChangingComponent = function(component) {
    return this.queueItem(component);
  };

  ReactArtEngineEpoch.prototype.processEpochItems = function(changingComponents) {
    return globalCount("ReactArtEngineEpoch processEpochItems", stackTime((function(_this) {
      return function() {
        var component, i, len, results;
        results = [];
        for (i = 0, len = changingComponents.length; i < len; i++) {
          component = changingComponents[i];
          results.push(component._applyPendingState());
        }
        return results;
      };
    })(this)));
  };

  return ReactArtEngineEpoch;

})(Epoch);

if (ArtEngineCore = Neptune.Art.Engine.Core) {
  GlobalEpochCycle = ArtEngineCore.GlobalEpochCycle;
  GlobalEpochCycle.singleton.includeReact(ReactArtEngineEpoch.singleton);
}


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var React,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(504)).addNamespace('React', React = (function(superClass) {
  extend(React, superClass);

  function React() {
    return React.__super__.constructor.apply(this, arguments);
  }

  React.version = __webpack_require__(594).version;

  return React;

})(Neptune.PackageNamespace));

__webpack_require__(141);


/***/ }),
/* 90 */
/***/ (function(module, exports) {

var ArrayCompactFlatten;

module.exports = ArrayCompactFlatten = (function() {
  var arraySlice, compact, compactFlattenIfNeeded, deepArrayEach, doFlattenInternal, flatten, isArguments, isArrayOrArguments, keepAll, keepUnlessNullOrUndefined, needsFlatteningOrCompacting;

  function ArrayCompactFlatten() {}

  ArrayCompactFlatten.isArguments = isArguments = function(o) {
    return o.constructor === Object && "number" === typeof o.length && "function" === typeof o.callee;
  };

  ArrayCompactFlatten.isArrayOrArguments = isArrayOrArguments = function(o) {
    return o && (o.constructor === Array || isArguments(o));
  };

  ArrayCompactFlatten.needsFlatteningOrCompacting = needsFlatteningOrCompacting = function(array, keepTester) {
    var a, i, len;
    for (i = 0, len = array.length; i < len; i++) {
      a = array[i];
      if (isArrayOrArguments(a) || !keepTester(a)) {
        return true;
      }
    }
    return false;
  };

  ArrayCompactFlatten.keepUnlessNullOrUndefined = keepUnlessNullOrUndefined = function(a) {
    return a !== null && a !== void 0;
  };


  /*
  IN:
    array: array or arguments-object
    keepTester: (value) -> true/false
      OUT: return true if that element should be in the output
  
  OUT: array where all elements test true to keepTester
  NOTE: NOT recursive - just does a shallow pass
   */

  ArrayCompactFlatten.compact = compact = function(array, keepTester) {
    var a, i, len;
    if (keepTester == null) {
      keepTester = keepUnlessNullOrUndefined;
    }
    for (i = 0, len = array.length; i < len; i++) {
      a = array[i];
      if (!keepTester(a)) {
        return (function() {
          var j, len1, results;
          results = [];
          for (j = 0, len1 = array.length; j < len1; j++) {
            a = array[j];
            if (keepTester(a)) {
              results.push(a);
            }
          }
          return results;
        })();
      }
    }
    return array;
  };


  /*
  IN: accepts any number of arguments
  NOTE: RECURSIVE: recurses into all arry or arguments-objects and adds their contents
    to the top level (flatten)
   */

  ArrayCompactFlatten.flatten = flatten = function(firstArg) {
    return compactFlattenIfNeeded(arguments.length === 1 ? firstArg : arguments);
  };


  /*
  IN: array: any object that has a length
  
  EFFECT:
    itterates over array and recurse over any element which isArrayOrArguments
    invokes f on every element that is not isArrayOrArguments
  OUT: array (same as passed in)
   */

  ArrayCompactFlatten.deepArrayEach = deepArrayEach = function(array, f) {
    var el, i, len;
    for (i = 0, len = array.length; i < len; i++) {
      el = array[i];
      if (isArrayOrArguments(el)) {
        deepArrayEach(el, f);
      } else {
        f(el);
      }
    }
    return array;
  };


  /*
  IN:
    array: array or arguments-object
    keepTester: (value) -> true/false
      OUT: return true if that element should be in the output
  
  OUT: array where all elements test true to keepTester
  NOTE: RECURSIVE: recurses into all arry or arguments-objects and adds their contents
    to the top level (flatten)
   */

  ArrayCompactFlatten.compactFlatten = function(array, keepTester) {
    if (keepTester == null) {
      keepTester = keepUnlessNullOrUndefined;
    }
    return compactFlattenIfNeeded(array, keepTester);
  };

  arraySlice = Array.prototype.slice;

  doFlattenInternal = function(array, keepTester) {
    var output;
    output = [];
    deepArrayEach(array, function(el) {
      if (keepTester(el)) {
        return output.push(el);
      }
    });
    return output;
  };

  keepAll = function() {
    return true;
  };

  compactFlattenIfNeeded = function(array, keepTester) {
    if (keepTester == null) {
      keepTester = keepAll;
    }
    if (array == null) {
      return array;
    }
    if ((array != null) && !isArrayOrArguments(array)) {
      return [array];
    }
    if (needsFlatteningOrCompacting(array, keepTester)) {
      return doFlattenInternal(array, keepTester);
    } else if (array.constructor !== Array) {
      return arraySlice.call(array);
    } else {
      return array;
    }
  };

  return ArrayCompactFlatten;

})();


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

var InspectedObjectLiteral, compare;

compare = __webpack_require__(146).compare;

module.exports = InspectedObjectLiteral = (function() {
  InspectedObjectLiteral.inspectedObjectLiteral = function(literal, isError) {
    return new InspectedObjectLiteral(literal, isError);
  };

  function InspectedObjectLiteral(literal1, isError1) {
    this.literal = literal1;
    this.isError = isError1;
  }

  InspectedObjectLiteral.prototype.getInspectedObjects = function() {
    return this;
  };

  InspectedObjectLiteral.prototype.inspect = function() {
    return this.literal;
  };

  InspectedObjectLiteral.prototype.compare = function(b) {
    return compare(this.literal, b.literal);
  };

  return InspectedObjectLiteral;

})();


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var Inspect,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(152)).addNamespace('Inspect', Inspect = (function(superClass) {
  extend(Inspect, superClass);

  function Inspect() {
    return Inspect.__super__.constructor.apply(this, arguments);
  }

  return Inspect;

})(Neptune.PackageNamespace));

__webpack_require__(295);


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var Iteration, compactFlatten, deepArrayEach, isArrayOrArguments, isFunction, isObject, isPlainArray, isPlainObject, log, mergeInto, ref, ref1;

ref = __webpack_require__(16), compactFlatten = ref.compactFlatten, deepArrayEach = ref.deepArrayEach, isArrayOrArguments = ref.isArrayOrArguments, mergeInto = ref.mergeInto;

ref1 = __webpack_require__(12), isPlainObject = ref1.isPlainObject, isObject = ref1.isObject, isFunction = ref1.isFunction, isPlainArray = ref1.isPlainArray;

log = function() {
  var ref2;
  return (ref2 = Neptune.Art.StandardLib).log.apply(ref2, arguments);
};

module.exports = Iteration = (function() {
  var arrayIterableTest, emptyOptions, invokeNormalizedIteration, normalizedArray, normalizedEach, normalizedEachWhile, normalizedFind, normalizedInject, normalizedObject, returnFirst, returnSecond;

  function Iteration() {}

  returnFirst = function(a) {
    return a;
  };

  returnSecond = function(a, b) {
    return b;
  };

  arrayIterableTest = function(source) {
    return (source != null ? source.length : void 0) >= 0;
  };

  emptyOptions = {};


  /*
  COMMON API:
  
  IN: (source, withBlock = returnFirst) ->
  IN: (source, options) ->
  IN: (source, into, withBlock = returnFirst) ->
  IN: (source, into, options) ->
  
  source:
    array-like (see arrayIterableTest)
      use indexes to iterate
  
    non-null
  
  options:
    with: withBlock
    when: whenBlock
    into: into
  
  withBlock: (value, key, into, whenBlockResult) -> value
    Generally, this generates the 'value' used for each part of the iteration.
    When constructing a new collection, this is the value for each entry.
    'find' and 'reduce' use this differently.
  
  OUT: into
  
  TODO:
    - support ES6 iterables and iterators
    - flatten: true - if source is an array, recurse into any sub-arrays
    - compact: effectively `when: (v) -> v?` except you can also have your own when-function in addition, run after this one.
    - skip: N - skip the first N values
    - short: N - stop short N values
    - until: () -> T/F - same args as withBlock, loop stops when true, executed after first withBlock
    - while: () -> T/F - same args as withBlock, loop stops when false, executed before first whenBlock
    - by: N -
        N>0: only stop at every Nth value
        N<0: iterate in reverse order, only stop at every abs(N)th value
   */


  /*
  each differences from the common-api:
  
  1) into defaults to source
   */

  Iteration.each = function(source, a, b) {
    return invokeNormalizedIteration(normalizedEach, source, a, b);
  };

  normalizedEach = function(source, into, withBlock, options) {
    var i, j, k, len, len1, v, w, whenBlock;
    if (into === void 0) {
      into = source;
    }
    if (options) {
      whenBlock = options.when;
    }
    if (arrayIterableTest(source)) {
      if (whenBlock) {
        for (k = i = 0, len = source.length; i < len; k = ++i) {
          v = source[k];
          if (w = whenBlock(v, k)) {
            withBlock(v, k, into, w);
          }
        }
      } else {
        for (k = j = 0, len1 = source.length; j < len1; k = ++j) {
          v = source[k];
          withBlock(v, k, into);
        }
      }
    } else if (source != null) {
      if (whenBlock) {
        for (k in source) {
          v = source[k];
          if (w = whenBlock(v, k)) {
            withBlock(v, k, into, w);
          }
        }
      } else {
        for (k in source) {
          v = source[k];
          withBlock(v, k, into);
        }
      }
    }
    return into;
  };


  /*
  eachWhile differences from the common-api:
  
  1) into defaults to source
  2) stops when withBlock returns false
   */

  Iteration.eachWhile = function(source, a, b) {
    return invokeNormalizedIteration(normalizedEachWhile, source, a, b);
  };

  normalizedEachWhile = function(source, into, withBlock, options) {
    var i, j, k, len, len1, v, w, whenBlock;
    if (into === void 0) {
      into = source;
    }
    if (options) {
      whenBlock = options.when;
    }
    if (arrayIterableTest(source)) {
      if (whenBlock) {
        for (k = i = 0, len = source.length; i < len; k = ++i) {
          v = source[k];
          if (w = whenBlock(v, k)) {
            if (!withBlock(v, k, into, w)) {
              break;
            }
          }
        }
      } else {
        for (k = j = 0, len1 = source.length; j < len1; k = ++j) {
          v = source[k];
          if (!withBlock(v, k, into)) {
            break;
          }
        }
      }
    } else if (source != null) {
      if (whenBlock) {
        for (k in source) {
          v = source[k];
          if (w = whenBlock(v, k)) {
            if (!withBlock(v, k, into, w)) {
              break;
            }
          }
        }
      } else {
        for (k in source) {
          v = source[k];
          if (!withBlock(v, k, into)) {
            break;
          }
        }
      }
    }
    return into;
  };


  /*
  reduce differences from the common-api:
  
  1) The with-block has a different argument order. Into is passed first instead of last:
    with: (into, value, key, whenReturnValue) ->
    This allows you to drop-in functions that take two arguments and reduce them to one like:
      Math.max
      add = (a, b) -> a + b
  
    The default with-block still returns value (which is now the second argument).
  
  1) if into starts out undefined:
    for v = the first value (if whenBlock is present, the first value when whenBlock is true)
      into = v
      skip: withBlock
  
  2) when withBlock is executed, into is updated:
    into = withBlock()
   */

  Iteration.reduce = function(source, a, b) {
    return invokeNormalizedIteration(normalizedInject, source, a, b);
  };

  normalizedInject = function(source, into, withBlock, options) {
    var intoSet;
    if (source == null) {
      return into;
    }
    normalizedEach(source, void 0, (intoSet = into !== void 0) ? function(v, k, __, w) {
      return into = withBlock(into, v, k, w);
    } : function(v, k, __, w) {
      return into = intoSet ? withBlock(into, v, k, w) : (intoSet = true, v);
    }, options);
    return into;
  };


  /*
  object differences from the common-api:
  
  IN:
    options.key: (value, key, into, whenBlockResult) -> value
  
  1) into defaults to a new object ({}) (if into == undefined)
  
  2) when withBlock is executed, into is updated:
    if source is array-like:
      into[v] = withBlock()
    else
      into[k] = withBlock()
   */

  Iteration.object = function(source, a, b) {
    return invokeNormalizedIteration(normalizedObject, source, a, b);
  };

  normalizedObject = function(source, into, withBlock, options) {
    var keyFunction;
    keyFunction = options.key || (arrayIterableTest(source) ? returnFirst : returnSecond);
    return normalizedEach(source, into != null ? into : {}, function(v, k, into, w) {
      return into[keyFunction(v, k, into, w)] = withBlock(v, k, into, w);
    }, options);
  };


  /*
  array differences from the common-api:
  
  1) into defaults to a new array ([]) (if into == undefined)
  
  2) when withBlock is executed, into is updated:
    into.push withBlock()
   */

  Iteration.array = function(source, a, b) {
    return invokeNormalizedIteration(normalizedArray, source, a, b);
  };

  normalizedArray = function(source, into, withBlock, options) {
    return normalizedEach(source, into != null ? into : [], function(v, k, into, w) {
      return into.push(withBlock(v, k, into, w));
    }, options);
  };


  /*
  differs from common api:
  
  1) returns the last value returned by withBlock or undefined if withBlock was never executed
  2) stops if
    a) whenBlock?:  and it returned true (stops after withBlock is evaluated)
    b) !whenBlock?: withBlock returns a truish value
   */

  Iteration.find = function(source, a, b) {
    return invokeNormalizedIteration(normalizedFind, source, a, b);
  };

  normalizedFind = function(source, into, withBlock, options) {
    var found;
    normalizedEachWhile(source, found = void 0, options.whenBlock ? function(v, k, into, w) {
      found = withBlock(v, k, null, w);
      return false;
    } : function(v, k, into, w) {
      return !(found = withBlock(v, k, null, w));
    }, options);
    return found;
  };


  /*
  Normalizes input params for the 'iteration' function.
  Since this normalizes multile params, and therefor would need to return
  an new array or new object otherwise, we pass IN the iteration function
  and pass the params directly to it. This keeps the computed params on the
  stack and doesn't create new objects.
  
  IN signature 1: (iteration, source, into, withBlock) ->
  IN signature 2: (iteration, source, into, options) ->
  IN signature 3: (iteration, source, withBlock) ->
  IN signature 4: (iteration, source, options) ->
  IN signature 5: (iteration, source) ->
  
  IN:
    iteration: (source, into, withBlock, options) -> out
  
      The iteration function is invoked last with the computed args.
      Its retults are returned.
  
      IN:
        source:     passed directly through from inputs
        into:       passed directly through from inputs OR from options.into
        withBlock:  passed directly through from inputs OR from options.with
        options:    passed direftly through from inputs OR {}
                    (guaranteed to be set and a plainObject)
  
    source: the source collection to be iterated over. Passed streight through.
  
    into:       passed through to 'iteration'
    withBlock:  passed through to 'iteration'
    options:    passed through to 'iteration' AND:
  
      into:     set 'into' from the options object
      with:     set 'withBlock' from the options object
  
  OUT: out
   */

  invokeNormalizedIteration = function(iteration, source, a, b) {
    var into, options, withBlock;
    options = b ? (into = a, b) : a;
    if (isPlainObject(options)) {
      if (into == null) {
        into = options.into;
      }
      withBlock = options["with"];
    } else {
      if (isFunction(options)) {
        withBlock = options;
      }
      options = emptyOptions;
    }
    return iteration(source, into, withBlock || returnFirst, options);
  };

  return Iteration;

})();


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/*
TODO: This is almost identical to ES6's Map: Switch to using a Polyfill like:
  https://github.com/paulmillr/es6-shim

Map is a Key-Value map which preserves order.

Unlike Javascript objects, you can use any object or value as keys. This includes:

  Strings
  Numbers
  null
  undefined
  Arrays
  Objects

Arrays and Objects are assigned a unique id using the StandardLib.Unique library.
"0", "", null, undefined and 0 are all different unique keys and can each have unique values.
 */
var KeysIterator, Map, MinimalBaseObject, Node, Unique, ValuesIterator, m,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Unique = __webpack_require__(151);

MinimalBaseObject = __webpack_require__(31);

Node = (function() {
  function Node(key, value, prev, next) {
    this.key = key;
    this.value = value;
    this.prev = prev || null;
    this.next = next || null;
    if (prev) {
      prev.next = this;
    }
    if (next) {
      next.prev = this;
    }
  }

  Node.prototype.remove = function() {
    var n, p;
    n = this.next;
    p = this.prev;
    if (p) {
      p.next = n;
      this.prev = null;
    }
    if (n) {
      n.prev = p;
      return this.next = null;
    }
  };

  return Node;

})();

KeysIterator = (function() {
  function KeysIterator(node1) {
    this.node = node1;
    this.started = false;
  }

  KeysIterator.prototype.next = function() {
    var ref, ref1;
    this.node = this.started ? (ref = this.node) != null ? ref.next : void 0 : (this.started = true, this.node);
    return {
      done: !this.node,
      value: (ref1 = this.node) != null ? ref1.key : void 0
    };
  };

  return KeysIterator;

})();

ValuesIterator = (function() {
  function ValuesIterator(node1) {
    this.node = node1;
    this.started = false;
  }

  ValuesIterator.prototype.next = function() {
    var ref, ref1;
    this.node = this.started ? (ref = this.node) != null ? ref.next : void 0 : (this.started = true, this.node);
    return {
      done: !this.node,
      value: (ref1 = this.node) != null ? ref1.value : void 0
    };
  };

  return ValuesIterator;

})();

module.exports = (m = new global.Map).set(1, 2) === m ? global.Map : Map = (function(superClass) {
  extend(Map, superClass);

  function Map() {
    this._length = 0;
    this._map = {};
    this._first = this._last = null;
  }

  Map.getter({
    size: function() {
      return this._length;
    }
  });

  Map.prototype._getNodes = function() {
    var n, result;
    result = [];
    n = this._first;
    while (n) {
      result.push(n);
      n = n.next;
    }
    return result;
  };

  Map.prototype.keys = function() {
    return new KeysIterator(this._first);
  };

  Map.prototype.values = function() {
    return new ValuesIterator(this._first);
  };

  Map.prototype.get = function(key) {
    var node;
    node = this._map[Unique.id(key)];
    return node && node.value;
  };

  Map.prototype.set = function(key, value) {
    var id;
    id = Unique.id(key);
    if (this._map[id]) {
      this._map[id].value = value;
    } else {
      this._length++;
      this._last = this._map[id] = new Node(key, value, this._last);
      if (!this._first) {
        this._first = this._last;
      }
    }
    return this;
  };

  Map.prototype._remove = function(key) {
    var id, n;
    id = Unique.id(key);
    if (n = this._map[id]) {
      this._length--;
      delete this._map[id];
      if (this._first === n) {
        this._first = n.next;
      }
      if (this._last === n) {
        this._last = n.prev;
      }
      n.remove();
      return n;
    } else {
      return void 0;
    }
  };

  Map.prototype["delete"] = function(key) {
    return !!this._remove(key);
  };

  Map.prototype.forEach = function(f) {
    var i, len, node, ref;
    ref = this._getNodes();
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      f(node.value, node.key, this);
    }
    return void 0;
  };

  Map.prototype.has = function(key) {
    return !!this._map[Unique.id(key)];
  };

  return Map;

})(MinimalBaseObject);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var ParseUrl, escapeRegExp, findUrlOrigin, ref;

ref = __webpack_require__(46), escapeRegExp = ref.escapeRegExp, findUrlOrigin = ref.findUrlOrigin;

module.exports = ParseUrl = (function() {
  var generateQuery, parsedGlobalQuery;

  function ParseUrl() {}

  parsedGlobalQuery = null;

  ParseUrl.sameOrigin = function(url, origin) {
    var ref1, ref2;
    if (origin == null) {
      origin = (ref1 = global.document) != null ? (ref2 = ref1.location) != null ? ref2.origin : void 0 : void 0;
    }
    origin = origin.match(findUrlOrigin)[0];
    return RegExp("^((" + (escapeRegExp(origin)) + ")|(?![a-z]+\\:))", "i").test(url);
  };

  ParseUrl.parseQuery = function(qs) {
    var i, isCurrentLocation, j, key, len, obj, pair, ref1, ref2, val;
    if ((isCurrentLocation = qs == null) && parsedGlobalQuery) {
      return parsedGlobalQuery;
    }
    qs || (qs = ((ref1 = global.location) != null ? ref1.search : void 0) || "");
    obj = {};
    ref2 = qs.replace(/^\?/, '').split('&');
    for (j = 0, len = ref2.length; j < len; j++) {
      pair = ref2[j];
      if ((i = pair.indexOf('=')) >= 0) {
        key = pair.slice(0, i);
        val = pair.slice(i + 1);
        if (key.length > 0) {
          obj[key] = decodeURIComponent(val);
        }
      } else {
        obj[pair] = true;
      }
    }
    if (isCurrentLocation) {
      parsedGlobalQuery = obj;
    }
    return obj;
  };

  ParseUrl.generateQuery = generateQuery = function(o) {
    var k, parts, v;
    parts = (function() {
      var results;
      results = [];
      for (k in o) {
        v = o[k];
        results.push((encodeURIComponent(k)) + "=" + (encodeURIComponent(v)));
      }
      return results;
    })();
    return parts.join("&");
  };

  ParseUrl.urlJoin = function(uri, path) {
    return (uri.replace(/\/$/, '')) + "/" + (path.replace(/^\//, ''));
  };

  ParseUrl.appendQuery = function(uri, o) {
    var str;
    if ((o != null) && (str = generateQuery(o)).length > 0) {
      return "" + uri + (uri.match(/\?/) ? "&" : "?") + str;
    } else {
      return uri;
    }
  };

  ParseUrl.parseUrl = function(url) {
    var __, a, anchor, fileName, host, hostWithPort, m, password, path, pathName, port, protocol, query, username;
    m = url.match(/(([A-Za-z]+):(\/\/)?)?(([\-;&=\+\$,\w]+)(:([\-;:&=\+\$,\w]+))?@)?([A-Za-z0-9\.\-]+)(:([0-9]+))?(\/[\+~%\/\.\w\-]*)?(\?([\-\+=&;%@\.\w,]*))?(\#([\.\!\/\\\w]*))?/);
    if (!m) {
      return void 0;
    }
    __ = m[0], __ = m[1], protocol = m[2], __ = m[3], __ = m[4], username = m[5], __ = m[6], password = m[7], host = m[8], __ = m[9], port = m[10], pathName = m[11], __ = m[12], query = m[13], __ = m[14], anchor = m[15];
    if (pathName) {
      a = pathName.split("/");
      fileName = a[a.length - 1];
      path = (a.slice(0, a.length - 1)).join("/");
    }
    host = host.toLowerCase();
    hostWithPort = host;
    if (port) {
      hostWithPort += ":" + port;
    }
    return {
      protocol: protocol,
      username: username,
      password: password,
      hostWithPort: hostWithPort,
      host: host,
      port: port,
      pathName: pathName,
      path: path,
      fileName: fileName,
      query: query && ParseUrl.parseQuery(query),
      anchor: anchor
    };
  };

  return ParseUrl;

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

var base, isBoolean, isDate, isFunction, isJsonType, isNumber, isPlainArray, isPlainObject, isString, merge, object, ref;

ref = __webpack_require__(1), isBoolean = ref.isBoolean, isNumber = ref.isNumber, isString = ref.isString, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isFunction = ref.isFunction, isDate = ref.isDate, isJsonType = ref.isJsonType, merge = ref.merge, object = ref.object;


/*
@dataTypes only includes the Standard Json types:
  except 'null':
    no field has the type of 'null'
    instead, it has some other type and can be 'null' unless it is 'required'
 */

base = {
  boolean: {
    validate: isBoolean
  },
  number: {
    validate: isNumber
  },
  string: {
    validate: isString
  },
  object: {
    validate: isPlainObject
  },
  array: {
    validate: isPlainArray
  },
  "function": {
    validate: isFunction
  },
  date: {
    validate: isDate
  },
  json: {
    validate: isJsonType
  },
  any: {}
};

module.exports = merge(base, object(base, {
  key: function(v, k) {
    return k + "DataType";
  },
  "with": function(v, k) {
    return k;
  }
}));


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var App,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(98)).addNamespace('App', App = (function(superClass) {
  extend(App, superClass);

  function App() {
    return App.__super__.constructor.apply(this, arguments);
  }

  return App;

})(Neptune.PackageNamespace));

__webpack_require__(315);

__webpack_require__(316);


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var NeedsAndEmotions,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('NeedsAndEmotions', NeedsAndEmotions = (function(superClass) {
  extend(NeedsAndEmotions, superClass);

  function NeedsAndEmotions() {
    return NeedsAndEmotions.__super__.constructor.apply(this, arguments);
  }

  NeedsAndEmotions.version = __webpack_require__(102).version;

  return NeedsAndEmotions;

})(Neptune.PackageNamespace));

__webpack_require__(97);

__webpack_require__(317);

__webpack_require__(319);


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var makeHash = __webpack_require__(549)

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5 (x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32)
  x[(((len + 64) >>> 9) << 4) + 14] = len

  var a = 1732584193
  var b = -271733879
  var c = -1732584194
  var d = 271733878

  for (var i = 0; i < x.length; i += 16) {
    var olda = a
    var oldb = b
    var oldc = c
    var oldd = d

    a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936)
    d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586)
    c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819)
    b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330)
    a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897)
    d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426)
    c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341)
    b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983)
    a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416)
    d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417)
    c = md5_ff(c, d, a, b, x[i + 10], 17, -42063)
    b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162)
    a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682)
    d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101)
    c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290)
    b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329)

    a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510)
    d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632)
    c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713)
    b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302)
    a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691)
    d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083)
    c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335)
    b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848)
    a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438)
    d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690)
    c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961)
    b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501)
    a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467)
    d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784)
    c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473)
    b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734)

    a = md5_hh(a, b, c, d, x[i + 5], 4, -378558)
    d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463)
    c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562)
    b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556)
    a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060)
    d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353)
    c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632)
    b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640)
    a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174)
    d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222)
    c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979)
    b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189)
    a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487)
    d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835)
    c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520)
    b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651)

    a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844)
    d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415)
    c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905)
    b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055)
    a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571)
    d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606)
    c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523)
    b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799)
    a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359)
    d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744)
    c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380)
    b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649)
    a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070)
    d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379)
    c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259)
    b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551)

    a = safe_add(a, olda)
    b = safe_add(b, oldb)
    c = safe_add(c, oldc)
    d = safe_add(d, oldd)
  }

  return [a, b, c, d]
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn (q, a, b, x, s, t) {
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b)
}

function md5_ff (a, b, c, d, x, s, t) {
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t)
}

function md5_gg (a, b, c, d, x, s, t) {
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t)
}

function md5_hh (a, b, c, d, x, s, t) {
  return md5_cmn(b ^ c ^ d, a, b, x, s, t)
}

function md5_ii (a, b, c, d, x, s, t) {
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t)
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add (x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF)
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16)
  return (msw << 16) | (lsw & 0xFFFF)
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

module.exports = function md5 (buf) {
  return makeHash(buf, core_md5)
}


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = exports;

curve.base = __webpack_require__(560);
curve.short = __webpack_require__(563);
curve.mont = __webpack_require__(562);
curve.edwards = __webpack_require__(561);


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var md5 = __webpack_require__(99)
module.exports = EVP_BytesToKey
function EVP_BytesToKey (password, salt, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary')
  }
  if (salt && !Buffer.isBuffer(salt)) {
    salt = new Buffer(salt, 'binary')
  }
  keyLen = keyLen / 8
  ivLen = ivLen || 0
  var ki = 0
  var ii = 0
  var key = new Buffer(keyLen)
  var iv = new Buffer(ivLen)
  var addmd = 0
  var md_buf
  var i
  var bufs = []
  while (true) {
    if (addmd++ > 0) {
      bufs.push(md_buf)
    }
    bufs.push(password)
    if (salt) {
      bufs.push(salt)
    }
    md_buf = md5(Buffer.concat(bufs))
    bufs = []
    i = 0
    if (keyLen > 0) {
      while (true) {
        if (keyLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        key[ki++] = md_buf[i]
        keyLen--
        i++
      }
    }
    if (ivLen > 0 && i !== md_buf.length) {
      while (true) {
        if (ivLen === 0) {
          break
        }
        if (i === md_buf.length) {
          break
        }
        iv[ii++] = md_buf[i]
        ivLen--
        i++
      }
    }
    if (keyLen === 0 && ivLen === 0) {
      break
    }
  }
  for (i = 0; i < md_buf.length; i++) {
    md_buf[i] = 0
  }
  return {
    key: key,
    iv: iv
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-suite":"git://github.com/imikimi/art-suite.git","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.2","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.2.1","commander":"^2.15.1","css-loader":"^0.28.4","dateformat":"^3.0.3","detect-node":"^2.0.3","fs-extra":"^5.0.0","glob":"^7.1.2","glob-promise":"^3.4.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"license":"ISC","name":"nvc","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress"},"version":"2.5.0"}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var asn1 = __webpack_require__(606)
var aesid = __webpack_require__(604)
var fixProc = __webpack_require__(608)
var ciphers = __webpack_require__(108)
var compat = __webpack_require__(338)
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen)
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)))

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    [
      "PointerActionsMixin",
      "FluxComponent",
      "dataNodes",
      "rgbColor",
      "StyleProps",
      "Element",
      "TextElement"
    ],
    [global, __webpack_require__(18), __webpack_require__(24)],
    (
      PointerActionsMixin,
      FluxComponent,
      dataNodes,
      rgbColor,
      StyleProps,
      Element,
      TextElement
    ) => {
      let CategoryButton;
      return (CategoryButton = Caf.defClass(
        class CategoryButton extends PointerActionsMixin(FluxComponent) {},
        function(CategoryButton, classSuper, instanceSuper) {
          let hasAncestorKey;
          this.subscriptions("navState.keyPath", {
            status: function(props) {
              return props.key;
            }
          });
          this.prototype.action = function() {
            return this.models.navState.selectKey(this.props.key);
          };
          hasAncestorKey = function(key, lookFor) {
            let parentKey;
            return key === lookFor
              ? true
              : (({ parentKey } = dataNodes[key]),
                parentKey ? hasAncestorKey(parentKey, lookFor) : false);
          };
          this.prototype.render = function() {
            let key, selected, text, color;
            ({ key } = this.props);
            selected = Caf.in(key, this.keyPath);
            text = key;
            color = rgbColor(
              key === "needs" || dataNodes[key].rootKey === "needs"
                ? StyleProps.colors[this.status || 3] || StyleProps.primaryColor
                : hasAncestorKey(key, "painful")
                  ? "#3399fe"
                  : hasAncestorKey(key, "about")
                    ? "#ffa9f7"
                    : hasAncestorKey(key, "pleasurable")
                      ? "#ffe838"
                      : "#bbb"
            );
            return Element(
              {
                size: { wcw: 1, hch: 1 },
                cursor: "pointer",
                on: this.buttonHandlers,
                clip: true,
                animators: "draw",
                draw: {
                  radius: 100,
                  padding: 5,
                  color:
                    selected || this.pointerIsDown
                      ? color
                      : color.blend("white", 0.5)
                }
              },
              TextElement(
                StyleProps.textStyle,
                { size: "childrenSize", align: "centerCenter", padding: 18 },
                text.replace(/_/g, " ")
              )
            );
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["FluxComponent", "dataNodes", "Element"],
    [global, __webpack_require__(18), __webpack_require__(24)],
    (FluxComponent, dataNodes, Element) => {
      let ShowMenu;
      return (ShowMenu = Caf.defClass(
        class ShowMenu extends FluxComponent {},
        function(ShowMenu, classSuper, instanceSuper) {
          this.prototype.render = function() {
            let keys, cafBase;
            keys =
              this.props.keys ||
              (Caf.exists((cafBase = dataNodes[this.props.key])) &&
                cafBase.childKeys);
            return Element(
              {
                clip: true,
                childrenLayout: "flow",
                childrenAlignment: "bottomCenter",
                size: { ww: 1, hch: 1 },
                animators: { size: { toFrom: { ww: 1, h: 0 } } }
              },
              Caf.array(Caf.exists(keys) && keys.sort(), key =>
                __webpack_require__(105)({ key })
              )
            );
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return __webpack_require__(17).merge(
    __webpack_require__(17),
    __webpack_require__(166)
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var ciphers = __webpack_require__(377)
exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
var deciphers = __webpack_require__(376)
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
var modes = __webpack_require__(65)
function getCiphers () {
  return Object.keys(modes)
}
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(10);
var randomBytes = __webpack_require__(63);
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

var BinaryString, File, Promise, StandardLib;

StandardLib = __webpack_require__(1);

Promise = StandardLib.Promise;

BinaryString = __webpack_require__(28);

module.exports = File = (function() {
  var readAsArrayBuffer;

  function File() {}

  File._readWithPromise = function(readFunction) {
    return function(file) {
      return new Promise(function(resolve, reject) {
        var fr;
        fr = new FileReader;
        fr[readFunction](file);
        fr.onerror = reject;
        return fr.onload = (function(_this) {
          return function(event) {
            return resolve(event.target.result);
          };
        })(this);
      });
    };
  };

  File.readAsArrayBuffer = readAsArrayBuffer = File._readWithPromise("readAsArrayBuffer");

  File.readAsDataURL = File._readWithPromise("readAsDataURL");

  File.readAsBinaryString = function(file) {
    return readAsArrayBuffer(file).then(function(arrayBuffer) {
      return new BinaryString(arrayBuffer);
    });
  };

  return File;

})();


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var Binary,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.Binary', Binary = (function(superClass) {
  extend(Binary, superClass);

  function Binary() {
    return Binary.__super__.constructor.apply(this, arguments);
  }

  Binary.version = __webpack_require__(585).version;

  return Binary;

})(Neptune.PackageNamespace));


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var BaseClass, ExtendablePropertyMixin, Log, MinimalBaseObject, StandardLib, Unique, WebpackHotLoader, callStack, capitalize, clone, concatInto, decapitalize, extendClone, functionName, getModuleBeingDefined, inspectedObjectLiteral, isFunction, isPlainArray, isPlainObject, isString, log, mergeInto, nextUniqueObjectId, object, objectName,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

StandardLib = __webpack_require__(1);

WebpackHotLoader = __webpack_require__(204);

capitalize = StandardLib.capitalize, decapitalize = StandardLib.decapitalize, log = StandardLib.log, extendClone = StandardLib.extendClone, clone = StandardLib.clone, isFunction = StandardLib.isFunction, objectName = StandardLib.objectName, isPlainObject = StandardLib.isPlainObject, functionName = StandardLib.functionName, isString = StandardLib.isString, isPlainArray = StandardLib.isPlainArray, Unique = StandardLib.Unique, callStack = StandardLib.callStack, Log = StandardLib.Log, log = StandardLib.log, inspectedObjectLiteral = StandardLib.inspectedObjectLiteral, MinimalBaseObject = StandardLib.MinimalBaseObject, getModuleBeingDefined = StandardLib.getModuleBeingDefined, concatInto = StandardLib.concatInto, mergeInto = StandardLib.mergeInto, isString = StandardLib.isString, object = StandardLib.object;

nextUniqueObjectId = Unique.nextUniqueObjectId;

ExtendablePropertyMixin = __webpack_require__(203);

module.exports = BaseClass = (function(superClass) {
  var createWithPostCreate, getSingleton, imprintObject, nonImprintableProps, thoroughDeleteProperty, warnedAboutIncludeOnce;

  extend(BaseClass, superClass);

  BaseClass.objectsCreated = 0;

  BaseClass.objectsCreatedByType = {};

  BaseClass.resetStats = function() {
    BaseClass.objectsCreated = 0;
    return BaseClass.objectsCreatedByType = {};
  };

  BaseClass._name = null;


  /*
  NOTE: only hasOwnProperties are considered! Inherited properties are not touched.
  IN:
    targetObject:   object will be altered to be an "imprint" of fromObject
    fromObject: object pattern used to imprint targetObject
    preserveState:
      false:
        targetObject has every property updated to exactly match fromObject
  
        This includes:
          1. delete properties in targetObject that are not in fromObject
          2. add every property in fromObject but not in targetObject
          3. overwriting every property in targetObject also in fromObject
  
      true:
        Attempts to preserve the state of targetObject while updating its functionality.
        This means properties which are functions in either object are updated.
  
        WARNING: This is a grey area for JavaScript. It is not entirely clear what is
          state and what is 'functionality'. I, SBD, have made the following heuristic decisions:
  
        Imprint actions taken when preserving State:
  
        1. DO NOTHING to properties in targetObject that are not in fromObject
        2. add every property in fromObject but not in targetObject
        3. properties in targetObject that are also in fromObject are updated
          if one of the following are true:
          - isFunction fromObject[propName]
          - isFunction targetObject[propName]
          - propName does NOT start with "_"
          NOTE: property existance is detected using Object.getOwnPropertyDescriptor
   */

  thoroughDeleteProperty = function(object, propName) {
    Object.defineProperty(object, propName, {
      configurable: true,
      writable: false,
      value: 1
    });
    return delete object[propName];
  };

  nonImprintableProps = ["__proto__", "prototype"];

  BaseClass.imprintObject = imprintObject = function(targetObject, sourceObject, preserveState) {
    var i, j, len, len1, sourcePropDescriptor, sourcePropName, sourcePropertyNames, targetPropDescriptor, targetPropName, targetPropertyNames;
    if (preserveState == null) {
      preserveState = false;
    }
    targetPropertyNames = Object.getOwnPropertyNames(targetObject);
    sourcePropertyNames = Object.getOwnPropertyNames(sourceObject);
    if (!preserveState) {
      for (i = 0, len = targetPropertyNames.length; i < len; i++) {
        targetPropName = targetPropertyNames[i];
        if (!(indexOf.call(sourcePropertyNames, targetPropName) >= 0)) {
          thoroughDeleteProperty(targetObject, targetPropName);
        }
      }
    }
    for (j = 0, len1 = sourcePropertyNames.length; j < len1; j++) {
      sourcePropName = sourcePropertyNames[j];
      if (!(!(indexOf.call(nonImprintableProps, sourcePropName) >= 0))) {
        continue;
      }
      targetPropDescriptor = Object.getOwnPropertyDescriptor(targetObject, sourcePropName);
      sourcePropDescriptor = Object.getOwnPropertyDescriptor(sourceObject, sourcePropName);
      if (!preserveState || !targetPropDescriptor || isFunction(sourcePropDescriptor.value) || isFunction(targetPropDescriptor != null ? targetPropDescriptor.value : void 0) || !sourcePropName.match(/^_/)) {
        Object.defineProperty(targetObject, sourcePropName, sourcePropDescriptor);
      }
    }
    return sourceObject;
  };


  /*
  imprints both the class and its prototype.
  
  preserved in spite of imprintObject's rules:
    @namespace
    @::constructor
   */

  BaseClass.imprintFromClass = function(updatedKlass) {
    var _name, namespace, namespacePath, oldConstructor, ref;
    if (updatedKlass !== this) {
      ref = this, namespace = ref.namespace, namespacePath = ref.namespacePath, _name = ref._name;
      oldConstructor = this.prototype.constructor;
      imprintObject(this, updatedKlass, true);
      imprintObject(this.prototype, updatedKlass.prototype, false);
      this.prototype.constructor = oldConstructor;
      this.namespace = namespace;
      this.namespacePath = namespacePath;
      this._name = _name;
    }
    return this;
  };

  BaseClass.getHotReloadKey = function() {
    return this.getName();
  };


  /*
  IN:
    _module should be the CommonJS 'module'
    klass: class object which extends BaseClass
  
  liveClass:
    On the first load, liveClass gets set.
    Each subsequent hot-load UPDATES liveClass,
    but liveClass always points to the initially created class object.
  
  OUT: the result of the call to liveClass.postCreate()
  
  postCreate is passed:
    hotReloaded:            # true if this is anything but the initial load
    classModuleState:
      liveClass:            # the original liveClass
      hotUpdatedFromClass:  # the most recently hot-loaded class
      hotReloadVersion:     # number starting at 0 and incremented with each hot reload
    _module:                # the CommonJs module
  
  EFFECTS:
    The following two methods are invoked on liveClass:
  
      if hot-reloading
        liveClass.imprintFromClass klass
  
       * always:
      liveClass.postCreate hotReloaded, classModuleState, _module
   */

  BaseClass.createWithPostCreate = createWithPostCreate = function(a, b) {
    var _module, klass;
    klass = b ? (_module = a, b) : a;
    _module || (_module = getModuleBeingDefined() || global.__definingModule);
    if (!(klass != null ? klass.postCreate : void 0)) {
      return klass;
    }
    if (!(_module != null ? _module.hot : void 0)) {
      return klass.postCreate({
        hotReloadEnabled: false,
        hotReloaded: false,
        classModuleState: {},
        module: _module
      }) || klass;
    }
    return WebpackHotLoader.runHot(_module, function(moduleState) {
      var classModuleState, hotReloadKey, hotReloaded, liveClass;
      hotReloadKey = klass.getHotReloadKey();
      if (classModuleState = moduleState[hotReloadKey]) {
        liveClass = classModuleState.liveClass;
        hotReloaded = true;
        classModuleState.hotReloadVersion++;
        classModuleState.hotUpdatedFromClass = klass;
        liveClass.namespace._setChildNamespaceProps(liveClass.getName(), klass);
        klass._name = liveClass._name;
        liveClass.imprintFromClass(klass);
        liveClass.classModuleState = classModuleState;
        log({
          "Art.ClassSystem.BaseClass: class hot-reload": {
            "class": liveClass.getNamespacePath(),
            version: classModuleState.hotReloadVersion,
            hotReloadKey: hotReloadKey
          }
        });
      } else {
        hotReloaded = false;
        klass._hotClassModuleState = moduleState[hotReloadKey] = klass.classModuleState = classModuleState = {
          liveClass: liveClass = klass,
          hotUpdatedFromClass: null,
          hotReloadVersion: 0
        };
      }
      return liveClass.postCreate({
        hotReloadEnabled: true,
        hotReloaded: hotReloaded,
        classModuleState: classModuleState,
        module: _module
      });
    });
  };

  BaseClass.createHotWithPostCreate = function(a, b) {
    log.error("createHotWithPostCreate is DEPRICATED");
    return createWithPostCreate(a, b);
  };


  /*
  called every load
  IN: options:
    NOTE: hot-loading inputs are only set if this class created as follows:
      createHotWithPostCreate module, class Foo extends BaseClass
  
    hotReload: true/false
      true if this class was hot-reloaded
  
    hotReloadEnabled: true/false
  
    classModuleState:
      liveClass:            the first-loaded version of the class.
                            This is the official version of the class at all times.
                            The hot-reloaded version of the class is "imprinted" onto the liveClass
                            but otherwise is not used (but can be accessed via classModuleState.hotUpdatedFromClass)
      hotUpdatedFromClass:  The most recently loaded version of the class.
      hotReloadVersion:     number, starting at 1, and counting up each load
  
      classModuleState is a plain-object specific to the class and its CommonJS module. If there is
      more than one hot-loaded class in the same module, each will have its own classModuleState.
  
      SBD NOTE: Though we could allow clients to add fields to classModuleState, I think it works
      just as well, and is cleaner, if any state is stored in the actual class objects and
      persisted via postCreate.
  
    module: the CommonJs module object.
  
  {hotReloadEnabled, hotReloaded, classModuleState, module} = options
   */

  BaseClass.postCreate = function(options) {
    if (this.getIsAbstractClass()) {
      return this.postCreateAbstractClass(options);
    } else {
      return this.postCreateConcreteClass(options);
    }
  };

  BaseClass.setNamespace = function(ns) {
    return this._namespace = ns;
  };

  BaseClass.postCreateAbstractClass = function(options) {
    return this;
  };

  BaseClass.postCreateConcreteClass = function(options) {
    return this;
  };

  function BaseClass() {
    this.__uniqueId = null;
  }

  BaseClass.implementsInterface = function(object, methods) {
    var i, len, method;
    for (i = 0, len = methods.length; i < len; i++) {
      method = methods[i];
      if (typeof object[method] !== "function") {
        return false;
      }
    }
    return true;
  };


  /*
  mix-in class methods
  Define getters/setters example:
    class MyMixin
      included: ->
        @getter foo: -> @_foo
        @setter foo: (v) -> @_foo = v
  
  NOTE! This will NOT include any properties you defined with getter or setter!
  NOTE! This only copies over values if there aren't already values in the included-into class
    This somewhat mirrors Ruby's include where the included-into-class's methods take precidence.
    However, if you include two modules in a row, the first module gets priority here.
    In ruby the second module gets priority (I believe).
  
  DEPRICATED!!!
  Time to do it "right" - and it's just a simple pattern:
    Justin Fagnani figured this out. Thanks!
    Read More:
      http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/
  
  To define a mixin:
  
    MyMixin = (superClass) ->
      class MyMixin extends superClass
        ... write your mixin as-if it were part of the normal inheritance hierachy
  
  To use a mixin:
  
    class MyClass extends MyMixin MySuperClass
  
  To use two mixins:
  
    class MyClass extends MyMixin1 MyMixin2 MySuperClass
   */

  warnedAboutIncludeOnce = false;

  BaseClass.include = function(obj) {
    var key, ref, value;
    log.error("DEPRICATED: BaseClass.include. Use pattern.");
    if (!warnedAboutIncludeOnce) {
      warnedAboutIncludeOnce = true;
      console.warn("Mixin pattern:\n\n  To define a mixin:\n\n    MyMixin = (superClass) ->\n      class MyMixin extends superClass\n        ... write your mixin as-if it were part of the normal inheritance hierachy\n\n  To use a mixin:\n\n    class MyClass extends MyMixin MySuperClass\n\n  To use two mixins:\n\n    class MyClass extends MyMixin1 MyMixin2 MySuperClass");
    }
    for (key in obj) {
      value = obj[key];
      if (key !== 'included') {
        if (!this[key]) {
          this[key] = value;
        }
      }
    }
    ref = obj.prototype;
    for (key in ref) {
      value = ref[key];
      if (key) {
        if (!this.prototype[key]) {
          this.prototype[key] = value;
        }
      }
    }
    if (typeof obj.included === "function") {
      obj.included(this);
    }
    return this;
  };

  BaseClass.getNamespacePath = function() {
    if (!this.namespacePath) {
      return "parentNamespaceNotSet." + (this.getName());
    } else {
      return this.namespacePath;
    }
  };

  BaseClass.getNamespacePathWithExtendsInfo = function() {
    var ref, ref1, ref2, ref3;
    if (!this.namespacePath || ((ref = this.__super__) != null ? (ref1 = ref["class"]) != null ? ref1.namespacePath : void 0 : void 0) === this.namespacePath) {
      return this.namespacePath = ((ref2 = (ref3 = this.namespace) != null ? ref3.namespacePath : void 0) != null ? ref2 : '(no parent namespace)') + "." + (this.getName()) + " extends " + (this.__super__["class"].getNamespacePath());
    } else {
      return this.namespacePath;
    }
  };

  BaseClass.getClassName = function(klass) {
    if (klass == null) {
      klass = this;
    }
    return (typeof klass.getName === "function" ? klass.getName() : void 0) || klass.name;
  };


  /*
  inspect: ->
  IN: ()
  OUT: string
  
  Can override with same or alternate, recursion-block-supported signature:
    IN: (inspector) ->
    OUT: if inspector then null else string
  
    To handle the case where the inspector is not set, we
    recommneded declaring your 'inspect' as follows:
      inspect: (inspector) ->
        return StandardLib.inspect @ unless inspector
         * ...
         * custom code which writes all output to inspector.put
         * and uses inspector.inspect for inspecting sub-objects
         * ...
        null
  
    EFFECT:
      call inspector.put one or multiple times with strings to add to the inspected output
      call inspector.inspect foo to sub-inspect other objects WITH RECURSION BLOCK
  
   * Example 1:
  inspect: (inspector) ->
    return StandardLib.inspect @ unless inspector
    inspector.put @getNamespacePath()
  
   * Example 2:
  inspect: ->
    @getNamespacePath()
   */

  BaseClass.inspect = function() {
    return this.getNamespacePath();
  };

  BaseClass.prototype.inspect = function() {
    return "<" + this["class"].namespacePath + ">";
  };


  /*
  getInspectedObjects: -> plainObjects
  
  usually implemented this way:
  @getter inspectedObjects: -> plainObjects or objects which implement "inspect"
  
  TODO: I think I want to refactor inspectedObjects to ONLY return near-JSON-compatible objects:
    1. strings
    2. maps
    3. arrays
  
    Everything else should be rendered to a string. In general, strings should Eval to the object
    they represent:
  
      toInspectedObject(null):                    'null' # null becomes a string
      toInspectedObject(true):                    'true' # true becomes a string
      toInspectedObject(false):                   'false' # false becomes a string
      toInspectedObject(undefined):               'undefined' # undefined becomes a string
      toInspectedObject('hi'):                    '"hi"' # ESCAPED
      toInspectedObject((a) -> a):                'function(a){return a;}'
      toInspectedObject(rgbColor())               "rgbColor('#000000')"
  
    NOTE: inspectedObjects differs from plainObjects. The latter should be 100% JSON,
      and should return actual values where JSON allows, otherwise, return JSON data structures
      that encode the object's information in a human-readable format, ideally one that can be
      used as an input to the constructor of the object's class to recreate the original object.
  
      plainObjects:
        null:         null
        true:         true
        false:        false
        'str':        'str' # NOT escaped
        undefined:    null
        ((a) -> a):   'function(a){return a;}'
        rgbColor():   r: 0, g: 0, b: 0, a: 0
  
  You can provide this function for fine-grained control of what Inspector2 outputs and hence
  what DomConsole displays.
  
  If you would like for a string to appear without quotes, use:
    {inspect: -> 'your string without quotes here'}
   */

  BaseClass.getter({
    inspectObjects: function() {
      console.warn("inspectObjects/getInspectObjects is DEPRICATED. Use: inspectedObjects/getInspectedObjects");
      return this.getInspectedObjects();
    },
    inspectedObjects: function() {
      var ref;
      return inspectedObjectLiteral("<" + ((ref = this["class"]) != null ? ref.getNamespacePath() : void 0) + ">");
    }
  });

  BaseClass.classGetter({
    inspectedObjects: function() {
      return inspectedObjectLiteral(this.getNamespacePath());
    }
  });


  /*
  Define this class as an abstract class. Implicitly it means
  any class it extends is also abstract, at least in this context.
  
  Definition: Abstract classes are not intended to every be instantiated.
    i.e.: never do: new MyAbstractClass
  
  TODO: in Debug mode, in the constructor:
    throw new Error "cannot instantiate abstract classes" if @class.getIsAbstractClass()
   */

  BaseClass.abstractClass = function() {
    if (this.getIsSingletonClass()) {
      throw new Error("abstract classes cannot also be singleton");
    }
    return this._firstAbstractAncestor = this;
  };

  BaseClass.classGetter({
    isAbstractClass: function() {
      return !(this.prototype instanceof this._firstAbstractAncestor);
    },
    abstractPrototype: function() {
      return this._firstAbstractAncestor.prototype;
    },
    firstAbstractAncestor: function() {
      return this._firstAbstractAncestor;
    },
    isSingletonClass: function() {
      var ref;
      return ((ref = this._singleton) != null ? ref["class"] : void 0) === this;
    },
    concretePrototypeProperties: function() {
      var abstractClassPrototype;
      abstractClassPrototype = this.getAbstractClass().prototype;
      return object(this.prototype, {
        when: function(v, k) {
          return k !== "constructor" && abstractClassPrototype[k] !== v;
        }
      });
    }
  });

  BaseClass.getAbstractClass = function() {
    return this._firstAbstractAncestor;
  };

  BaseClass.abstractClass();

  BaseClass.propertyIsAbstract = function(propName) {
    return this.getAbstractClass().prototype[propName] === this.prototype[propName];
  };

  BaseClass.propertyIsConcrete = function(propName) {
    return this.getAbstractClass().prototype[propName] !== this.prototype[propName];
  };


  /*
  SBD2017: this is the new path for singleton classes.
  WHY: We can elliminate the need to DECLARE classes singleton.
    Instead, we can just access the singleton for any class, if needed.
  TODO: once we are 100% CaffeineScript, switch this to a @classGetter
   */

  BaseClass.getSingleton = getSingleton = function() {
    var ref;
    if (((ref = this._singleton) != null ? ref["class"] : void 0) === this) {
      return this._singleton;
    } else {
      if (this.getIsAbstractClass()) {
        throw new Error("singleton classes cannot be abstract");
      }
      return this._singleton = new this;
    }
  };


  /*
  creates the classGetter "singleton" which returns a single instance of the current class.
  
  IN: args are passed to the singleton constructor
  OUT: null
  
  The singleton instance is created on demand the first time it is accessed.
  
  SBD2017: Possibly depricated; maybe we just need a singleton getter for everyone?
    The problem is coffeescript doesn't properly inherit class getters.
    BUT ES6 and CaffeineScript DO. So, when we switch over, I think we can do this.
   */

  BaseClass.singletonClass = function() {
    var obj1;
    if (this.getIsAbstractClass()) {
      throw new Error("singleton classes cannot be abstract");
    }
    this.classGetter((
      obj1 = {
        singleton: getSingleton
      },
      obj1["" + (decapitalize(functionName(this)))] = function() {
        return this.getSingleton();
      },
      obj1
    ));
    return null;
  };

  BaseClass.getter({
    className: function() {
      return this["class"].getClassName();
    },
    "class": function() {
      return this.constructor;
    },
    keys: function() {
      return Object.keys(this);
    },
    namespacePath: function() {
      return this["class"].getNamespacePath();
    },
    classPathNameAndId: function() {
      return this.classPathName + ":" + this.objectId;
    },
    uniqueId: function() {
      return this.__uniqueId || (this.__uniqueId = nextUniqueObjectId());
    },
    objectId: function() {
      return this.__uniqueId || (this.__uniqueId = nextUniqueObjectId());
    }
  });

  BaseClass.prototype.implementsInterface = function(methods) {
    return Function.BaseClass.implementsInterface(this, methods);
  };

  BaseClass.prototype.tap = function(f) {
    f(this);
    return this;
  };

  BaseClass.rawLog = function() {
    return Log.rawLog.apply(Log, arguments);
  };

  BaseClass.log = function() {
    var a, stack, toLog;
    stack = callStack();
    toLog = (function() {
      var i, len, results;
      if (arguments.length > 1) {
        results = [];
        for (i = 0, len = arguments.length; i < len; i++) {
          a = arguments[i];
          results.push(a);
        }
        return results;
      } else {
        return arguments[0];
      }
    }).apply(this, arguments);
    Log.logCore(toLog, stack, {
      className: this.className
    });
    return arguments[arguments.length - 1];
  };

  BaseClass.prototype.log = BaseClass.log;

  BaseClass.prototype.rawLog = BaseClass.rawLog;

  return BaseClass;

})(ExtendablePropertyMixin(MinimalBaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(408);


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, EventedMixin, Events, PersistantAnimator, Promise, capitalize, eq, inspectedObjectLiteral, isArray, isFunction, isNumber, isPlainObject, isString, log, plainObjectsDeepEq, ref, rubyOr, rubyTrue,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Events = __webpack_require__(14);

ref = __webpack_require__(1), log = ref.log, isFunction = ref.isFunction, isString = ref.isString, capitalize = ref.capitalize, inspectedObjectLiteral = ref.inspectedObjectLiteral, plainObjectsDeepEq = ref.plainObjectsDeepEq, isPlainObject = ref.isPlainObject, eq = ref.eq, rubyOr = ref.rubyOr, isNumber = ref.isNumber, rubyTrue = ref.rubyTrue, Promise = ref.Promise, isArray = ref.isArray;

BaseClass = __webpack_require__(6).BaseClass;

EventedMixin = Events.EventedMixin;


/*
Useful ideas about optimizing animations and garbage collection: http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html

1) Properties are marked animatable.
2) Every animatable propoerty is animated every time it changes.
3) A new instance of the Animator is created to start the animation.
   - initalValue
   - initialTargetValue
   - initialTime
4) The animator is called each frame with updates:
   - possible changes in targetValue
   - lastFrameTime
   - currentValue
   - currentTime
5) The animator calls "@done()" when it can be released.
  It need not ever be released. It could be endless.
6) Objects

----------------------------------
INITIAL SUPPORT

ELEMENT SUPPORT (March 2016)

  New property: animators
    Legal values:

       * basic: just name the property to animate to get the default animator
      animators: "location"

       * init a standard animator with custom options:
      animators:
        location:
          d/duration: .25
          f/function: "easeInQuad"

       * start a fully custom animator
      animators:
        location: new CustomAnimator

  Animatable properties:

    Ideally: every concrete property

    This includes both "location" and "currentLocation".

    For currentLocation/currentSize, the animator preprocessor is applied on the output
    of the location and size layouts before _currentLocation or _currentSize are created.

----------------------------------
FUTURE FEATURES

ONE ANIMATOR OVER MULTIPLE PROPS

  I can imagine situations where you might want one animator to be responsible for multiple props.

  Maybe a cartoon-physics animator might want to animate some combination of size, location and scale.

  Clearly, we'd only add this when we really needed it.

  In the cartoon-physics example, it's a 'canned effect'. You'd probably prefer to have the CartoonPhsyics
  animator decide what props it needs to animate. So, perhaps you can specify animators w/o specifying props.
  Instead, the animator itself lists the props it will animate:

  animators: new CartoonPhysicsAnimator

  You can always make an array with multiple different animators specified using any legal method.
  animators: [
    new CartoonPhysicsAnimator
    "color"
  ]

  Once we have that, we may have more than one animator for the same property. Gut says it works like "merge".
  The last specified animator gets sole responsibilty for animating that prop.

  How does an animator for multiple props work? Normally each prop is handled individually. In the case
  of layout-props, they don't even get handled at the same time as the other props. They get handled during
  layout. So, I think the multi-prop animator needs to be able to process each prop in isolation.

ANIMATING WHEN SWITCHING PARENTS

  Use-case:

    Show a thumbnail in a list.
    Tap it to zoom in.
    Animated from the thumbnail to the full-sized view.

  How it might work:

    The Thumbnail gets a unique key.

    The ZoomIn can set its createdFrom props to be taken from another element via its key.

  Need:

    Special-case animated virtual property:
      elementToAbsMatrix

    For nicer animations when scaling and angles are involed, we may add these animatable virtual props:
      absoluteCurrentLocation (new)
      absoluteCurrentScale (new)
      absoluteCurrentAngle (new)

    Enhanced props:
      added/createdFrom:
        element: elementKey or element
        props: props-name list

    Could allow initializing *From from several source elements or
    specific props. All results are passed into "merge":

    added/createdFrom: [
      {element: elementKey1, props: propsString1}
      {element: elementKey2, props: propsString2}
      color: "red"
      ]

  How it might look in user-code:

    Thumbnail = createComponentFactory
      render: ->
        {itemId} = @props
        Element
          key: "thumbnail:#{itemId}"
          ...

    ZoomIn = createComponentFactory
      render: ->
        {itemId} = @props
        Element
          createdFrom:
            element: "thumbnail:#{itemId}"
            props: "elementToAbsMatrix"

          animators: "elementToAbsMatrix"

ADDED / REMOVED ANIMATIONS (March 2016)
  - "from" values
    Each animatable property can have an initial property which gets
    set first. Then, next frame, the normal property value gets set,
    triggering the animator.
    There are two kinds of initial values:
      onCreation - if the Element as added to the parent in the parent's constructor
      onAddition - if the Element as added to the parent sometime later
    Syntax idea:
      new Element
        location: 0
        addedFrom:    location: -10
        createdFrom:  location: -20
        removedTo:    location: -10

SELECTING ELEMENTS BY KEY

  When specifying createdFrom: element: elementKey, how do we match the elementKey with
  a concrete element?

  There are both performance concerns and usability concerns:

    performance:
      - there may be a lot of elements with keys; how do we find a match quickly?
      - a pre-computed & maintained hash is probably the answer... but that may be a lot of work.
    useability:
      - duplicate keys
      - do we need scoping to reduce key-collisions / avoid "globals" / isolate components?

  It seems to me that some amount of scoping would both reduce the number of keys that need
  to be inspected for a lookup / or reduce the work necessary to maintain a precomputed hash.

ELEMENT "KEY" SCOPING BY COMPONENT

  We could scope by "Component". ArtReact already has this information, so the user
  doesn't have to do any additional work.

  - An Element can be flagged as a Component.
  - This would automatically be done by React Components.
  - All Elements in its sub-branch are part of that component,
  - EXCEPT for any Elements which are themselves Components - i.e. SubComponents.
  - Any Element can ask for its parent Component.
  - Every Component maintains a hash of Element keys to Elements for every Element in that Component.
  - Automatic warnings for duplicate "key" values for children who have keys within a component.
    When this happens, the second, duplicate key is renamed to be unique via an appended string.

  Global-scoping vs relative scoping

  I'd rather avoid anything global, but to handle the "animated thumbnail-zoom-in" use-case, we
  will need a way for one element to reference another in a different component. I think the
  rought idea would be some way to express:

  - "within my parent component with key XYZ"
  - "within its subcomponent with key ABC"
  - "select element with key LMO"

  Basically, we can navigate the 'component-defined-key-namespace-tree' by first scanning UP,
  then scanning down, and then select an element within the resulting selected component.

  This avoids ever going to a global scope. There could be other components that use the same
  keys and it wouldn't interfere with this lookup.

  How it might look:

    element:
      withinParentComponent: "XYZ"
      findChildComponent: "ABC"
      findElement: "LMO"

  We could also decide to have a "selector" shorthand:

    element: "^XYZ/** /ABC/LMO"

    HRM - coffeescript doesn't allow * followed by / in a comment block. Makes sense, but I had
      to add a space after '**' above. Ignore the space :).

    split on '/'
    '^' means search up for the first component that matches the rest of the string
    '**' means match any path of sub-components

  When "pathing" sub-components and sub-elements are both found in the same key-lookup-hash.
  The only difference is the key-loopup-hash that is used is found in the first component-element
  at of above the current element. So, if you path to a sub-component, the next key will select
  from within that component, but if you path to just an element, the next key could jump you to
  any other element within the same parent component.

  Possibly we just make this illegal. If you attempt to path "into" an element which is not a component,
  it's an error - logged in debug mode and returning a null result.

  How can we make '**' fast? Each component-element can have a list of all sub-components so we don't
  have to enumerate all elements. That still requires tree traversal. We could maintain pre-computed
  hashs, but anytime an anything changes in the tree that could be quite a lot of updates. Every parent
  needs to be updated since ** could be triggered from any parent to any child.

----------------------------------
REACT IMPLICATIONS

"keys" need to become component-wide, not just Parent-scoped.

Does this mean we still need the following limitation for Component roots?
  a) must be a single element
  b) can't change its Element-type.

NOTE: Span elements will make this less onerous. Just wrap the root in a Span and you can
  do whatever you want within that span as-if you were just returning an array of elements.
 */


/*
Animator is created once, when the Element is created (or the animators prop is set).
It persists as long as the animator property is set and points to it.
If can be "active" or not. If active, that element will get an epoch update each
frame, and the animator will get a chance to animate the property each frame.

Options: (events)
  on:
    done: ->   # fires when the animation completes
    update: -> # fires every time the target object's animated values updated
    start: ->  # fires when the animation starts
    abort: ->  # fires when the animation aborts
  continuous: [false]
    if true
      1. the animation starts as soon as the Element is registered
      2. the animation stops when the Element is unregistered
 */

module.exports = PersistantAnimator = (function(superClass) {
  var interpolate;

  extend(PersistantAnimator, superClass);

  PersistantAnimator.interpolate = interpolate = function(fromValue, toValue, pos, root) {
    var i, k, out, v;
    if (root == null) {
      root = true;
    }
    if (pos === 0) {
      return fromValue;
    } else if (pos === 1) {
      return toValue;
    } else if (!((fromValue != null) && (toValue != null))) {
      return fromValue || toValue;
    } else if (isFunction(fromValue.interpolate)) {
      return fromValue.interpolate(toValue, pos);
    } else if (fromValue.constructor !== toValue.constructor) {
      return toValue;
    } else if (isNumber(fromValue)) {
      return fromValue + (toValue - fromValue) * pos;
    } else {
      out = (function() {
        var j, len, results;
        if (isPlainObject(fromValue)) {
          out = {};
          for (k in fromValue) {
            v = fromValue[k];
            out[k] = interpolate(v, toValue[k], pos, false);
          }
          return out;
        } else if (isArray(fromValue) && fromValue.length === toValue.length) {
          results = [];
          for (i = j = 0, len = fromValue.length; j < len; i = ++j) {
            v = fromValue[i];
            results.push(interpolate(v, toValue[i], pos, false));
          }
          return results;
        } else {
          return toValue || fromValue;
        }
      })();
      return out;
    }
  };

  PersistantAnimator.getter("options prop element startValue currentValue toValue continuous voidValue currentSecond startSecond");

  PersistantAnimator.getter({
    active: function() {
      return this._active || (this._continuous && (!this._element || this._element.isRegistered));
    },
    state: function() {
      return this._state || (this._state = {});
    }
  });

  PersistantAnimator.prototype.deactivate = function() {
    if (this._active) {
      return this._deactivate();
    }
  };

  PersistantAnimator.getter({
    inspectedObjects: function() {
      var obj;
      return (
        obj = {},
        obj["" + this.prop] = this.options,
        obj
      );
    }
  });


  /*
  IN:
    options:
      animate: (animator) -> nextValue
        IN:
          startValue: the value when the aniation started
          currentValue: the element's current value
          toValue: the requested target value for the animation
          secondsSinceStart: seconds since the animation started
          animator: this PersistantAnimator object
            animator.state: place to store state
            animator.element: the element being animated
            animator.stop: call this when done animating
            animator.frameSeconds: seconds since the last frame
  
        OUT: the next value in the animation
  
        SHOULD:
          Call animator.stop() when the animation is done.
          The animation can run forever and never call stop if desired.
          TODO: how do we release a forever animation?
  
        STATE:
          Use animator.state object to store any persistant state the animation function needs.
          animator.state is reserved for exclusive use by the animate function.
      continuous: t/f
      on: handlers
  
       * added and removed animation values
      voidValue:  # both
      fromVoid:   # added animation
      toVoid:     # removed animation
   */

  function PersistantAnimator(prop, options) {
    var ref1, ref2;
    PersistantAnimator.__super__.constructor.apply(this, arguments);
    this._prop = prop;
    this._options = options;
    this._active = false;
    this._startSecond = 0;
    this._currentSecond = 0;
    this._lastSecond = 0;
    this._activatedAtSecond = 0;
    this._startValue = null;
    this._currentValue = null;
    this._toValue = null;
    this._element = null;
    this._animate = options.animate;
    this._continuous = options.continuous;
    this._voidValue = rubyOr(options.voidValue, options.toFromVoid, options.fromToVoid, options["void"], options.toFrom, options.fromTo);
    this._toVoid = (ref1 = options.toVoid) != null ? ref1 : options.to;
    this._fromVoid = (ref2 = options.fromVoid) != null ? ref2 : options.from;
    if (options != null ? options.on : void 0) {
      this.on(options.on);
    }
  }

  PersistantAnimator.getter({
    fromVoid: function() {
      if (this._voidValue != null) {
        return this._voidValue;
      } else {
        return this._fromVoid;
      }
    },
    toVoid: function() {
      if (this._voidValue != null) {
        return this._voidValue;
      } else {
        return this._toVoid;
      }
    },
    hasFromVoidAnimation: function() {
      return this.fromVoid != null;
    },
    hasToVoidAnimation: function() {
      return this.toVoid != null;
    }
  });

  PersistantAnimator.getter({
    animationSeconds: function() {
      return this._currentSecond - this._startSecond;
    },
    frameSeconds: function() {
      if (this._active) {
        return this._currentSecond - this._lastSecond;
      } else {
        return 0;
      }
    },

    /*
    returns a bound function to stop this animator
    OUT: -> toValue
      OUT: toValue
      EFFECT: stops the animator
     */
    stop: function() {
      return this._stop || (this._stop = (function(_this) {
        return function() {
          _this._active = false;
          return _this._toValue;
        };
      })(this));
    }
  });

  PersistantAnimator.prototype.startToVoidAnimation = function(_element) {
    this._element = _element;
    if (!this.hasToVoidAnimation) {
      return Promise.reject();
    }
    return new Promise((function(_this) {
      return function(resolve, reject) {
        if (_this._active) {
          _this._toValueChanged();
        }
        _this._element[_this._prop] = _this._toValue = _this.toVoid;
        return _this.on({
          done: resolve
        });
      };
    })(this));
  };

  PersistantAnimator.prototype.getPreprocessedFromVoid = function(_element, baseValue) {
    this._element = _element;
    return this._element.preprocessProperty(this._prop, this.fromVoid, baseValue);
  };

  PersistantAnimator.prototype.animate = function() {
    if (this._animate) {
      return this._animate(this);
    } else {
      log("no @_animate");
      return this.stop();
    }
  };

  PersistantAnimator.prototype._activate = function() {
    if (this._active) {
      throw new Error;
    }
    this._lastSecond = this._startSecond = this._activatedAtSecond = this._currentSecond;
    this._startValue = this._currentValue;
    this.queueEvent("start", {
      target: this._element,
      animator: this
    });
    return this._active = true;
  };

  PersistantAnimator.prototype._toValueChanged = function() {
    this._lastSecond = this._startSecond = this._currentSecond - this.frameSeconds;
    return this._startValue = this._currentValue;
  };

  PersistantAnimator.prototype._deactivate = function() {
    this.queueEvent("done", {
      target: this._element,
      animator: this
    });
    return this._active = false;
  };

  PersistantAnimator.prototype.animateAbsoluteTime = function(_element, _currentValue, toValue, _currentSecond) {
    var animationSeconds, newValue;
    this._element = _element;
    this._currentValue = _currentValue;
    this._currentSecond = _currentSecond;
    if (this._active) {
      if (eq(toValue, this._toValue)) {
        if (this._activatedAtSecond === this._startSecond) {
          this._startSecond = this._currentSecond;
        }
      } else {
        this._toValueChanged();
      }
    } else {
      this._activate();
    }
    this._toValue = toValue;
    animationSeconds = this.getAnimationSeconds();
    newValue = this.animate();
    if (this._active) {
      if (animationSeconds > 0) {
        this.queueEvent("update", {
          target: this._element,
          animator: this
        });
      }
      this._element.onNextEpoch((function(_this) {
        return function() {
          return _this._element[_this._prop] = _this._toValue;
        };
      })(this));
    } else {
      this._deactivate();
    }
    this._lastSecond = this._currentSecond;
    return this._element.preprocessProperty(this._prop, newValue);
  };

  return PersistantAnimator;

})(EventedMixin(BaseClass));


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(211);

module.exports.addModules({
  Animator: __webpack_require__(210),
  EasingFunctions: __webpack_require__(72),
  EasingPersistantAnimator: __webpack_require__(409),
  PeriodicPersistantAnimator: __webpack_require__(410),
  PersistantAnimator: __webpack_require__(114)
});


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
var ArtEngineCore, Atomic, BaseClass, Bitmap, CacheBitmap, Canvas, DrawCacheManager, Foundation, Map, Matrix, Point, Rectangle, defineModule, getGlobalEpochCycle, globalEpochCycle, inspect, log, mapRemove, matrix, point, rect, remove, timeout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ArtEngineCore = __webpack_require__(118);

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Canvas = __webpack_require__(11);

point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix;

inspect = Foundation.inspect, BaseClass = Foundation.BaseClass, Map = Foundation.Map, timeout = Foundation.timeout, remove = Foundation.remove, log = Foundation.log, defineModule = Foundation.defineModule;

Bitmap = Canvas.Bitmap;

globalEpochCycle = null;

getGlobalEpochCycle = function() {
  return globalEpochCycle || (globalEpochCycle = (__webpack_require__(26)).globalEpochCycle);
};

mapRemove = function(map, key) {
  var out;
  out = map.get(key);
  map["delete"](key);
  return out;
};


/*
PURPOSE
- Keep the maximum byte-size of the cache under a cap.
- recycle unused bitmaps since creating bitmaps is costly

TODO

Stop clearing cached sub-elements when drawing a new cached element.
 - the DrawCacheManager will reclaim their bitmaps in time

Stop tracking caching stats in Element

Call advanceFrameTime every global draw-frame
Call doneWithCacheBitmap from _clearDrawCache(doNotUpdateDrawCacheManager) unless doNotUpdateDrawCacheManager is true
call allocateCacheBitmap when a new cache bitmap is used
call useCacheBitmap every time a the drawCache bitmap is used
 */

CacheBitmap = (function(superClass) {
  extend(CacheBitmap, superClass);

  function CacheBitmap(element1, bitmap1, lastFrameUsed) {
    this.element = element1;
    this.bitmap = bitmap1;
    this._reset(lastFrameUsed);
  }

  CacheBitmap.prototype._reset = function(lastFrameUsed) {
    this.useCount = 0;
    return this.lastFrameUsed = lastFrameUsed || 0;
  };

  CacheBitmap.prototype.recycle = function(newElement, lastFrameUsed) {
    this.elementDoneWithCacheBitmap();
    this.element = newElement;
    this._reset(lastFrameUsed);
    this.bitmap.clear();
    return this.bitmap;
  };

  CacheBitmap.prototype.use = function(currentFrameNumber) {
    this.lastFrameUsed = currentFrameNumber;
    return this.useCount++;
  };

  CacheBitmap.prototype.elementDoneWithCacheBitmap = function() {
    if (this.element && this.element._drawCacheBitmap === this.bitmap) {
      this.element.__clearDrawCacheCallbackFromDrawCacheManager();
    }
    return this.element = null;
  };

  CacheBitmap.getter({
    inspectedObjects: function() {
      return {
        size: this.size,
        byteSize: this.byteSize
      };
    },
    size: function() {
      return this.bitmap.size;
    },
    byteSize: function() {
      return this.bitmap.getByteSize();
    }
  });

  return CacheBitmap;

})(BaseClass);

defineModule(module, DrawCacheManager = (function(superClass) {
  var byteSizeFromSize, canUseBitmap, usableBitmap;

  extend(DrawCacheManager, superClass);

  DrawCacheManager.byteSizeFromSize = byteSizeFromSize = function(size) {
    return size.x * size.y * 4;
  };

  DrawCacheManager.singletonClass();

  DrawCacheManager.usableBitmap = usableBitmap = function(bitmap, w, h) {
    var ref, x, y;
    ref = bitmap.size, x = ref.x, y = ref.y;
    return w <= x && h <= y && x * y < w * h * 2;
  };

  function DrawCacheManager() {
    DrawCacheManager.__super__.constructor.apply(this, arguments);
    this._currentFrameNumber = 0;
    this._maxCacheByteSize = 64 * 1024 * 1024;
    this._cacheByteSize = 0;
    this._unusedCacheByteSize = 0;
    this._cachedBitmaps = new Map;
    this._bitmapsCreated = 0;
    this._unusedCacheBitmaps = [];
  }

  DrawCacheManager.getter({
    currentFrameNumber: function() {
      return this._currentFrameNumber;
    },
    recycleableSortedCacheBitmaps: function() {
      var currentFrameNumber, recyclable;
      recyclable = [];
      currentFrameNumber = this._currentFrameNumber;
      this._cachedBitmaps.forEach(function(v, k) {
        if (v.lastFrameUsed < currentFrameNumber - 1) {
          return recyclable.push(v);
        }
      });
      return recyclable.sort(function(a, b) {
        return a.lastFrameUsed - b.lastFrameUsed;
      });
    }
  });

  DrawCacheManager.prototype.doneWithCacheBitmap = function(element) {
    var byteSize, cachedBitmap;
    if (cachedBitmap = mapRemove(this._cachedBitmaps, element)) {
      cachedBitmap.elementDoneWithCacheBitmap();
      byteSize = cachedBitmap.getByteSize();
      this._unusedCacheByteSize += byteSize;
      this._cacheByteSize -= byteSize;
      this._unusedCacheBitmaps.push(cachedBitmap);
      return this._validateCacheByteSize();
    }
  };

  DrawCacheManager.prototype.useDrawCache = function(element) {
    var ref;
    return (ref = this._cachedBitmaps.get(element)) != null ? ref.use(this._currentFrameNumber) : void 0;
  };

  DrawCacheManager.prototype.allocateCacheBitmap = function(element, size) {
    this.doneWithCacheBitmap(element);
    return this._recycleUnusedCacheBitmap(element, size) || this._createCacheBitmap(element, size);
  };

  DrawCacheManager.prototype.advanceFrame = function() {
    var cfn;
    this._currentFrameNumber++;
    return cfn = this._currentFrameNumber;
  };

  DrawCacheManager.prototype._recycleInUseCacheBitmap = function(element, size) {
    var recyclableCacheBitmap;
    if (recyclableCacheBitmap = this._findRecycleableCacheBitmap(size)) {
      this._cachedBitmaps.set(element, mapRemove(this._cachedBitmaps, recyclableCacheBitmap.element));
      getGlobalEpochCycle().logEvent("recycleUsedCacheBitmap", "recycleUsedCacheBitmap");
      return recyclableCacheBitmap.recycle(element, this._currentFrameNumber);
    }
  };

  DrawCacheManager.prototype._recycleUnusedCacheBitmap = function(element, size) {
    var unusedCacheBitmap;
    if (unusedCacheBitmap = this._getUnusedCacheBitmap(size)) {
      getGlobalEpochCycle().logEvent("recycleUnusedCacheBitmap", "recycleUnusedCacheBitmap");
      unusedCacheBitmap.recycle(element, this._currentFrameNumber);
      this._cachedBitmaps.set(element, unusedCacheBitmap);
      return unusedCacheBitmap.bitmap;
    }
  };

  DrawCacheManager.prototype._createCacheBitmap = function(element, size) {
    var bitmap, cachedBitmap;
    if (!this._roomInCacheForNewBitmap(size)) {
      this._evictCacheBitmaps(size);
    }
    this._validateCacheByteSize();
    this._bitmapsCreated++;
    getGlobalEpochCycle().logEvent("createCacheBitmap", "createCacheBitmap");
    bitmap = element.getBitmapFactory().newBitmap(size);
    this._cachedBitmaps.set(element, cachedBitmap = new CacheBitmap(element, bitmap, this._currentFrameNumber));
    this._cacheByteSize += cachedBitmap.getByteSize();
    this._validateCacheByteSize();
    return bitmap;
  };

  DrawCacheManager.prototype._validateCacheByteSize = function() {};

  DrawCacheManager.prototype.canUseBitmap = canUseBitmap = function(cachedBitmap, requestedSize) {
    var h, size, w, x, y;
    if (cachedBitmap != null) {
      size = cachedBitmap.size;
      if (size.area < requestedSize.area * 2) {
        w = requestedSize.w, h = requestedSize.h;
        x = size.x, y = size.y;
        return x >= w && y >= h;
      }
    }
  };

  DrawCacheManager.prototype._getUnusedCacheBitmap = function(size) {
    var cachedBitmap, i, j, len, ref;
    ref = this._unusedCacheBitmaps;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      cachedBitmap = ref[i];
      if (!(canUseBitmap(cachedBitmap, size))) {
        continue;
      }
      this._unusedCacheBitmaps = remove(this._unusedCacheBitmaps, i);
      this._unusedCacheByteSize -= cachedBitmap.getByteSize();
      return cachedBitmap;
    }
    return void 0;
  };

  DrawCacheManager.prototype._findRecycleableCacheBitmap = function(size) {
    var cachedBitmap, compareSize, currentFrameNumber, valuesIterator, vi;
    currentFrameNumber = this._currentFrameNumber;
    valuesIterator = this._cachedBitmaps.values();
    while (!(vi = this._cachedBitmaps.next()).done) {
      cachedBitmap = vi.value;
      compareSize = cachedBitmap.size;
      if (cachedBitmap.lastFrameUsed < currentFrameNumber - 1 && canUseBitmap(cachedBitmap, size)) {
        return cachedBitmap;
      }
    }
  };

  DrawCacheManager.prototype._roomInCacheForNewBitmap = function(size) {
    var byteSize;
    byteSize = byteSizeFromSize(size);
    return byteSize + this._cacheByteSize <= this._maxCacheByteSize;
  };

  DrawCacheManager.prototype._evictCacheBitmaps = function(size) {
    var byteSize, cachedBitmap, j, len, reduceToAtLeast, ref;
    this._validateCacheByteSize();
    byteSize = byteSizeFromSize(size);
    reduceToAtLeast = this._maxCacheByteSize - size;
    ref = this.recycleableSortedCacheBitmaps;
    for (j = 0, len = ref.length; j < len; j++) {
      cachedBitmap = ref[j];
      if (cachedBitmap = mapRemove(this._cachedBitmaps, cachedBitmap.element)) {
        cachedBitmap.elementDoneWithCacheBitmap();
        this._cacheByteSize -= cachedBitmap.getByteSize();
        if (this._cacheByteSize <= reduceToAtLeast) {
          break;
        }
      }
    }
    this._validateCacheByteSize();
    return null;
  };

  return DrawCacheManager;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
var BaseClass, Color, ElementDrawLib, GradientFillStyle, Matrix, Paths, PointLayout, arrayWithout, circlePath, clone, compactFlatten, defaultLineWidth, defaultMiterLimit, defaultOffset, defineModule, each, ellipsePath, formattedInspect, getDevicePixelRatio, identityMatrix, isArray, isColor, isFunction, isNumber, isPlainObject, isRect, isString, log, max, merge, mergeInto, object, objectWithout, perimeter, point, pointLayout, rect, rectanglePath, ref, ref1, ref2, rgbColor;

ref = __webpack_require__(1), compactFlatten = ref.compactFlatten, arrayWithout = ref.arrayWithout, objectWithout = ref.objectWithout, defineModule = ref.defineModule, formattedInspect = ref.formattedInspect, clone = ref.clone, max = ref.max, isFunction = ref.isFunction, log = ref.log, object = ref.object, isNumber = ref.isNumber, isArray = ref.isArray, isPlainObject = ref.isPlainObject, isString = ref.isString, each = ref.each, isPlainObject = ref.isPlainObject, merge = ref.merge, mergeInto = ref.mergeInto;

ref1 = __webpack_require__(4), Matrix = ref1.Matrix, identityMatrix = ref1.identityMatrix, Color = ref1.Color, point = ref1.point, rect = ref1.rect, rgbColor = ref1.rgbColor, isRect = ref1.isRect, isColor = ref1.isColor, perimeter = ref1.perimeter;

PointLayout = __webpack_require__(40).PointLayout;

pointLayout = PointLayout.pointLayout;

ref2 = __webpack_require__(11), GradientFillStyle = ref2.GradientFillStyle, Paths = ref2.Paths;

rectanglePath = Paths.rectanglePath, ellipsePath = Paths.ellipsePath, circlePath = Paths.circlePath;

BaseClass = __webpack_require__(6).BaseClass;

getDevicePixelRatio = (__webpack_require__(2)).Browser.Dom.getDevicePixelRatio;

defaultMiterLimit = 3;

defaultLineWidth = 1;

defaultOffset = pointLayout({
  y: 2
});

defineModule(module, ElementDrawLib = (function() {
  var colorPrecision, layoutToFrom, legalDrawCommands, looksLikeColor, normalizeDrawProps, normalizeShadow, prepareShadow, sharedDrawOptions, sharedShadowOptions;

  function ElementDrawLib() {}

  ElementDrawLib.colorPrecision = colorPrecision = 1 / 256;

  ElementDrawLib.legalDrawCommands = legalDrawCommands = {
    circle: true,
    rectangle: true,
    clip: true,
    children: true,
    reset: true,
    resetShape: true,
    resetDrawArea: true,
    logicalDrawArea: true,
    paddedDrawArea: true,
    padded: true,
    resetClip: true
  };

  ElementDrawLib.looksLikeColor = looksLikeColor = function(v) {
    if (v == null) {
      return v;
    }
    if (isString(v)) {
      return !legalDrawCommands[v];
    } else {
      return isColor(v) || isArray(v) || ((v[0] != null) && (v[1] != null)) || v.constructor === GradientFillStyle;
    }
  };

  sharedDrawOptions = {};

  sharedShadowOptions = {};

  ElementDrawLib.prepareShadow = prepareShadow = function(shadow, size) {
    var blur, color, o, offset;
    if (shadow == null) {
      return shadow;
    }
    blur = shadow.blur, color = shadow.color, offset = shadow.offset;
    o = sharedShadowOptions;
    o.blur = blur;
    o.color = color;
    o.offsetX = offset.layoutX(size);
    o.offsetY = offset.layoutY(size);
    return o;
  };

  ElementDrawLib.layoutToFrom = layoutToFrom = function(toFromLayout, drawArea) {
    var size, x, y;
    if (isRect(drawArea)) {
      size = drawArea.size, x = drawArea.x, y = drawArea.y;
      x += toFromLayout.layoutX(size);
      y += toFromLayout.layoutY(size);
      return point(x, y);
    } else {
      return toFromLayout.layout(drawArea);
    }
  };

  ElementDrawLib.prepareDrawOptions = function(drawOptions, drawArea, isOutline) {
    var color, colors, compositeMode, from, linCap, lineJoin, lineWidth, miterLimit, o, opacity, radius, ref3, ref4, shadow, to;
    o = sharedDrawOptions;
    color = drawOptions.color, colors = drawOptions.colors, compositeMode = drawOptions.compositeMode, opacity = drawOptions.opacity, shadow = drawOptions.shadow, to = drawOptions.to, from = drawOptions.from, radius = drawOptions.radius;
    if (isOutline) {
      lineWidth = (ref3 = drawOptions.lineWidth) != null ? ref3 : defaultLineWidth, miterLimit = (ref4 = drawOptions.miterLimit) != null ? ref4 : defaultMiterLimit, lineJoin = drawOptions.lineJoin, linCap = drawOptions.linCap;
      o.lineWidth = lineWidth;
      o.miterLimit = miterLimit;
      o.lineJoin = lineJoin;
      o.linCap = linCap;
    }
    o.color = color;
    o.colors = colors;
    o.compositeMode = compositeMode;
    o.opacity = opacity;
    o.shadow = prepareShadow(shadow);
    o.from = colors && (from != null ? layoutToFrom(from, drawArea) : drawArea.topLeft);
    o.to = colors && (to != null ? layoutToFrom(to, drawArea) : drawArea.bottomLeft);
    o.radius = radius;
    if ((colors != null ? colors.constructor : void 0) === GradientFillStyle) {
      colors.to = o.to;
      colors.from = o.from;
    }
    return o;
  };

  ElementDrawLib.normalizeShadow = normalizeShadow = function(shadow) {
    var blur, color, offset;
    if (!shadow) {
      return shadow;
    }
    color = shadow.color, offset = shadow.offset, blur = shadow.blur;
    if (color == null) {
      color = rgbColor(color || "#0007");
    }
    if (color.a < 1 / 255) {
      return null;
    } else {
      return {
        color: color,
        blur: blur != null ? blur : 4,
        offset: offset != null ? pointLayout(offset) : defaultOffset
      };
    }
  };

  ElementDrawLib.normalizeDrawProps = normalizeDrawProps = function(drawProps) {
    var color, colors, from, ref3, ref4, ref5, shadow, to;
    if (drawProps == null) {
      return drawProps;
    }
    if (looksLikeColor(drawProps)) {
      drawProps = {
        color: drawProps
      };
    }
    shadow = drawProps.shadow, color = drawProps.color, colors = drawProps.colors, to = drawProps.to, from = drawProps.from;
    if ((color != null) && color.constructor !== Color) {
      if (color.constructor === GradientFillStyle) {
        colors = color;
      } else {
        if ((isArray(color) && !isNumber(color[0])) || (isPlainObject(color) && (((ref3 = (ref4 = (ref5 = color.r) != null ? ref5 : color.g) != null ? ref4 : color.b) != null ? ref3 : color.a) == null))) {
          colors = color;
        }
        if (colors) {
          colors = GradientFillStyle.normalizeColors(colors);
        }
      }
      color = colors != null ? void 0 : rgbColor(color);
    }
    if (colors != null) {
      from = from && pointLayout(from != null ? from : "topLeft");
      to = to && pointLayout(to != null ? to : "bottomLeft");
    }
    if (shadow) {
      shadow = normalizeShadow(shadow);
    }
    if (shadow || color !== drawProps.color || colors !== drawProps.colors || to !== drawProps.to || from !== drawProps.from) {
      drawProps = merge(drawProps);
      drawProps.shadow = shadow;
      drawProps.color = color;
      drawProps.colors = colors;
      drawProps.to = to;
      drawProps.from = from;
      return drawProps;
    } else {
      return drawProps;
    }
  };

  ElementDrawLib.normalizeDrawStep = function(step) {
    var circle, color, colors, fill, from, outline, padding, r, radius, rectangle, ref3, ref4, ref5, ref6, ref7, shadow, shape, to;
    if (looksLikeColor(step)) {
      return {
        fill: normalizeDrawProps({
          color: step
        })
      };
    }
    if (!isPlainObject(step)) {
      return step;
    }
    fill = step.fill, to = step.to, from = step.from, shadow = step.shadow, outline = step.outline, radius = step.radius, color = step.color, colors = step.colors, padding = step.padding, rectangle = step.rectangle, circle = step.circle, shape = step.shape;
    if ((ref3 = (ref4 = (ref5 = color != null ? color : colors) != null ? ref5 : to) != null ? ref4 : from) != null ? ref3 : shadow) {
      fill = merge(normalizeDrawProps({
        to: to,
        from: from,
        color: color,
        colors: colors,
        shadow: shadow
      }));
      step = objectWithout(step, "color", "colors", "to", "from", "shadow");
    }
    if (radius != null) {
      rectangle = isRect(rectangle) ? {
        radius: radius,
        area: rectangle
      } : isPlainObject(rectangle) ? (r = merge(rectangle), r.radius = radius, r) : {
        radius: radius
      };
    }
    if (padding == null) {
      padding = (ref6 = (ref7 = circle != null ? circle.padding : void 0) != null ? ref7 : rectangle != null ? rectangle.padding : void 0) != null ? ref6 : shape != null ? shape.padding : void 0;
    }
    padding = padding && perimeter(padding);
    fill = normalizeDrawProps(fill);
    outline = normalizeDrawProps(outline);
    if (padding !== step.padding || fill !== step.fill || outline !== step.outline || rectangle !== step.rectangle) {
      return merge(step, {
        fill: fill,
        outline: outline,
        padding: padding,
        rectangle: rectangle
      });
    } else {
      return step;
    }
  };

  ElementDrawLib.validateDrawAreas = function(newDrawAreas, oldDrawAreas, addedDrawArea) {
    var areasToTest;
    areasToTest = compactFlatten([oldDrawAreas, addedDrawArea]);
    return each(areasToTest, function(area) {
      if (!(find(newDrawAreas, function(newDrawArea) {
        return newDrawArea.contains(area);
      }))) {
        throw new Error("expected one of " + (formattedInspect(newDrawAreas)) + " to contain " + area);
      }
    });
  };

  ElementDrawLib.findFirstOverlappingAreaIndex = function(areas, testArea) {
    var area, i, j, len;
    for (i = j = 0, len = areas.length; j < len; i = ++j) {
      area = areas[i];
      if (area.overlaps(testArea)) {
        return i;
      }
    }
  };

  ElementDrawLib.addDirtyDrawArea = function(dirtyDrawAreas, dirtyArea, snapTo) {
    var area, da, da0, da2, dda0, foundNewOverlap, j, len;
    if (dirtyArea.area > 0) {
      da0 = dirtyArea = dirtyArea.roundOut(snapTo, colorPrecision);
      dda0 = dirtyDrawAreas;
      if (dirtyDrawAreas) {
        da = dirtyArea;
        foundNewOverlap = true;
        while (foundNewOverlap) {
          foundNewOverlap = false;
          for (j = 0, len = dirtyDrawAreas.length; j < len; j++) {
            area = dirtyDrawAreas[j];
            if (area.contains(dirtyArea)) {
              return dirtyDrawAreas;
            }
            if (area.overlaps(dirtyArea)) {
              da2 = dirtyArea;
              if (da === dirtyArea) {
                dirtyArea = dirtyArea.clone();
              }
              area.unionInto(dirtyArea);
              foundNewOverlap = da2 !== dirtyArea;
            }
          }
        }
        if (da !== dirtyArea) {
          dirtyDrawAreas = (function() {
            var k, len1, results;
            results = [];
            for (k = 0, len1 = dirtyDrawAreas.length; k < len1; k++) {
              area = dirtyDrawAreas[k];
              if (!area.overlaps(dirtyArea)) {
                results.push(area);
              }
            }
            return results;
          })();
        }
        dirtyDrawAreas.push(dirtyArea);
      } else {
        dirtyDrawAreas = [dirtyArea];
      }
    }
    return dirtyDrawAreas;
  };

  ElementDrawLib.partitionAreasByInteresection = function(partitioningArea, areas) {
    var area, cutArea, insideAreas, j, k, len, len1, outsideAreas, ref3;
    insideAreas = null;
    outsideAreas = null;
    for (j = 0, len = areas.length; j < len; j++) {
      area = areas[j];
      if (area.overlaps(partitioningArea)) {
        (insideAreas != null ? insideAreas : insideAreas = []).push(area.intersection(partitioningArea));
        ref3 = area.cutout(partitioningArea);
        for (k = 0, len1 = ref3.length; k < len1; k++) {
          cutArea = ref3[k];
          (outsideAreas != null ? outsideAreas : outsideAreas = []).push(cutArea);
        }
      } else {
        (outsideAreas != null ? outsideAreas : outsideAreas = []).push(area);
      }
    }
    return {
      insideAreas: insideAreas,
      outsideAreas: outsideAreas
    };
  };

  return ElementDrawLib;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var Drawing,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(54)).addNamespace('Drawing', Drawing = (function(superClass) {
  extend(Drawing, superClass);

  function Drawing() {
    return Drawing.__super__.constructor.apply(this, arguments);
  }

  return Drawing;

})(Neptune.PackageNamespace));


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var BaseClass, ElementFactory, Foundation, inspect, timeout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

BaseClass = Foundation.BaseClass, timeout = Foundation.timeout, inspect = Foundation.inspect;

module.exports = ElementFactory = (function(superClass) {
  extend(ElementFactory, superClass);

  ElementFactory.singletonClass();

  ElementFactory.newElement = function(elementClassName, props, children) {
    return ElementFactory.singleton.newElement(elementClassName, props, children);
  };

  function ElementFactory() {
    ElementFactory.__super__.constructor.apply(this, arguments);
    this._elementClasses = {};
  }

  ElementFactory.classGetter({
    elementClasses: function() {
      return this.singleton._elementClasses;
    }
  });

  ElementFactory.prototype.register = function(klass) {
    var name;
    name = klass.name;
    if (this._elementClasses[name]) {
      return timeout(100, (function(_this) {
        return function() {
          return console.warn("ElementFactory: element with class-name " + name + " already exists. ClassPaths: Existing: " + _this._elementClasses[name].namespacePath + ", Adding: " + klass.namespacePath);
        };
      })(this));
    } else {
      return this._elementClasses[name] = klass;
    }
  };

  ElementFactory.prototype.classForElement = function(elementClassName) {
    return this._elementClasses[elementClassName];
  };

  ElementFactory.prototype.newElement = function(elementClassName, props, children) {
    var klass;
    klass = this._elementClasses[elementClassName];
    if (!klass) {
      throw new Error("ElementFactor: class not found for " + (inspect(elementClassName)) + " (props: " + (inspect(props)) + ")");
    }
    return new this._elementClasses[elementClassName](props, children);
  };

  return ElementFactory;

})(BaseClass);


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var plainObjectsDeepEq, ref, shallowEq;

ref = __webpack_require__(1), shallowEq = ref.shallowEq, plainObjectsDeepEq = ref.plainObjectsDeepEq;

module.exports = {
  propsEq: plainObjectsDeepEq,
  shallowPropsEq: shallowEq
};


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var AtomElement, Color, Element, PointLayout, PointLayoutBase, defaultFrom, defaultTo, defineModule, inspect, isNumber, isPlainArray, isPlainObject, log, ref, ref1, ref2, rgbColor,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), inspect = ref.inspect, defineModule = ref.defineModule, isPlainArray = ref.isPlainArray, isNumber = ref.isNumber, log = ref.log, isPlainObject = ref.isPlainObject;

ref1 = __webpack_require__(4), rgbColor = ref1.rgbColor, Color = ref1.Color;

Element = __webpack_require__(36);

ref2 = __webpack_require__(40), PointLayout = ref2.PointLayout, PointLayoutBase = ref2.PointLayoutBase;

defaultFrom = new PointLayout();

defaultTo = new PointLayout({
  hh: 1
});

defineModule(module, AtomElement = (function(superClass) {
  extend(AtomElement, superClass);

  AtomElement.registerWithElementFactory = function() {
    return this !== AtomElement;
  };

  function AtomElement() {
    AtomElement.__super__.constructor.apply(this, arguments);
    this._drawOptions = {};
  }

  AtomElement.drawProperty({
    color: {
      "default": null,
      preprocess: function(v) {

        /*
        TODO:
          - merge 'color' and 'colors' into, one unified property
          - make everything animatable: gradient <=> gradient, gradient <=> color, color <=> color
          - do all the object-creation here; right now gradients create an object every render
            NOTE - though we create the gradient-object here, the to/from can change
              idependently - they should mutate nor re-create the basic gradient-object.
        
              This means ArtCanvas needs to have a refactor for how it handles gradients.
         */
        var a, b, g, r, ref3, ref4;
        if (v) {
          if (isPlainArray(v) && !isNumber(v[0])) {
            return v;
          } else if (isPlainObject(v)) {
            r = v.r, g = v.g, b = v.b, a = v.a;
            if (((ref3 = (ref4 = r != null ? r : g) != null ? ref4 : b) != null ? ref3 : a) != null) {
              return rgbColor(v);
            } else {
              return v;
            }
          } else {
            return rgbColor(v);
          }
        } else {
          return null;
        }
      },
      setter: function(v) {
        if ((v != null ? v.constructor : void 0) === Color) {
          return v;
        } else {
          if (v) {
            this.setColors(v);
          }
          return null;
        }
      }
    },
    colors: {
      "default": null
    },
    from: {
      preprocess: function(v) {
        return v && (v instanceof PointLayoutBase ? v : new PointLayout(v));
      }
    },
    to: {
      preprocess: function(v) {
        return v && (v instanceof PointLayoutBase ? v : new PointLayout(v));
      }
    },
    gradientRadius: {
      "default": null
    }
  });

  AtomElement.prototype._computeElementSpaceDrawArea = function(upToChild) {
    var ref3;
    if (((ref3 = this._children) != null ? ref3.length : void 0) > 0) {
      return AtomElement.__super__._computeElementSpaceDrawArea.apply(this, arguments);
    } else {
      return this.baseDrawArea;
    }
  };

  AtomElement.prototype.drawBasic = function(target, elementToTargetMatrix, compositeMode, opacity) {
    this._prepareDrawOptions(this._drawOptions, compositeMode, opacity);
    return this.fillShape(target, elementToTargetMatrix, this._drawOptions);
  };

  AtomElement.prototype._useStagingBitmap = function() {
    if (this.getHasChildren()) {
      return AtomElement.__super__._useStagingBitmap.apply(this, arguments);
    }
    return this.getChildRequiresParentStagingBitmap() || this.getIsMask();
  };

  AtomElement.prototype._drawChildren = function(target, elementToTargetMatrix, usingStagingBitmap) {
    if (this.hasChildren) {
      return AtomElement.__super__._drawChildren.apply(this, arguments);
    }
    if (usingStagingBitmap) {
      return this.drawBasic(target, elementToTargetMatrix);
    } else {
      return this.drawBasic(target, elementToTargetMatrix, this.getCompositeMode(), this.getOpacity());
    }
  };


  /*
  Either fillShape or drawBasic must be overridden by each inheriting class
   */

  AtomElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
    throw new Error("fillShape or drawBasic must be overridden");
  };


  /*
  _prepareDrawOptions
  Inheriting classes can override & extend to add additional options
  purpose: to re-use the plain-object for draw options instead of creating a new one every time.
   */

  AtomElement.prototype._prepareDrawOptions = function(drawOptions, compositeMode, opacity) {
    drawOptions.compositeMode = compositeMode;
    drawOptions.opacity = opacity;
    return this._prepareColorOptions(drawOptions);
  };

  AtomElement.prototype._prepareColorOptions = function(drawOptions) {
    var _color, _colors, _currentSize, _from, _gradientRadius, _to, gradientScale, r1, r2, ref3, ref4;
    ref3 = this, _color = ref3._color, _colors = ref3._colors, _currentSize = ref3._currentSize;
    drawOptions.color = _color;
    drawOptions.colors = null;
    drawOptions.gradientRadius = null;
    drawOptions.gradientRadius1 = null;
    drawOptions.gradientRadius2 = null;
    drawOptions.from = null;
    drawOptions.to = null;
    if (_colors) {
      ref4 = this, _from = ref4._from, _to = ref4._to, _gradientRadius = ref4._gradientRadius;
      _from || (_from = defaultFrom);
      drawOptions.colors = _colors;
      if (_gradientRadius != null) {
        _to || (_to = _from);
        gradientScale = _currentSize.min() / 2;
        if (isNumber(_gradientRadius)) {
          drawOptions.gradientRadius = _gradientRadius * gradientScale;
        } else {
          r1 = _gradientRadius[0], r2 = _gradientRadius[1];
          drawOptions.gradientRadius1 = r1 * gradientScale;
          drawOptions.gradientRadius2 = r2 * gradientScale;
        }
      }
      _to || (_to = defaultTo);
      drawOptions.from = _from.layout(_currentSize);
      return drawOptions.to = _to.layout(_currentSize);
    }
  };

  return AtomElement;

})(Element));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var AtomElement, Atomic, FilterElement, Foundation, Matrix, createWithPostCreate, isString, log,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

AtomElement = __webpack_require__(121);

log = Foundation.log, isString = Foundation.isString, createWithPostCreate = Foundation.createWithPostCreate;

Matrix = Atomic.Matrix;


/*
A FilterElement is any Element with a draw method that takes uses "target's" pixels as input to its own draw computations.

Ex: Blur and Shadow

TODO - Fully implelement Blur and Shadow's new semantics:

  Each has a sourceArea, in parent-space, default: rect @parent.size
 */

module.exports = createWithPostCreate(FilterElement = (function(superClass) {
  extend(FilterElement, superClass);

  function FilterElement() {
    return FilterElement.__super__.constructor.apply(this, arguments);
  }

  FilterElement.registerWithElementFactory = function() {
    return this !== FilterElement;
  };


  /*
  SBD 2016-02-25: I don't think filterSource is fully supported for anything other than the direct parent
    I have tried to make FilterElement fully support it, but
    I think Core.Element is missing critical features for Elements with distant decendent filters.
    Lines that mention filterSource in Core.Element are all commented out.
    Somehow, whenever things change, FilterSources need to get an updated list of their FilterElement decendents.
    Then methods like Element#_accountForOverdraw can correctly check each FilterElement decendent instead of only children.
   */

  FilterElement.drawProperty({
    filterSource: {
      "default": null,
      validate: function(v) {
        return !v || isString(v);
      }

      /*
      Radius is interpeted by FilterElement as the size of the convolution kernel the filter will apply.
      I.E. each output pixel can only be based on at most:
        - all pixels +/- "radius" pixel-units on the X and Y dimensions
        - I.E. the (2 * radius + 1)-square pixels centered on the output pixel
       */
    }
  });

  FilterElement.drawAreaProperty({
    radius: {
      "default": 0,
      validate: function(v) {
        return typeof v === "number";
      }

      /*
      Override this for the "simplest" filter control
      
      IN:
        filterScratchBitmap:
          at start contains the pixels to be filtered
      
        pixelData: is an array of RGBA values extracted from filterScratchBitmap
          length: 4 * filterScratchBitmap.size.area (RGBA sets)
      
        scale: number
          If the scale is 1, then the filter's currentSize is 1:1 pixels in filterScratchBitmap.
      
      NOTE: Convert x, y coordinates to array index:
        (x, y) -> (@filterScratchBitmap.size.x * y + x) * 4
       */
    }
  });

  FilterElement.prototype.filterPixelData = function(filterScratchBitmap, pixelData, scale) {
    return pixelData;
  };


  /*
  override this for "normal" filter control.
  IN:
    filterScratchBitmap:
      at start contains the pixels to be filtered
  
    scale: number
      If the scale is 1, then the filter's currentSize is 1:1 pixels in filterScratchBitmap.
  
  OUT: filterScratchBitmap with filter results or new bitmap of the same size
    NOTE: you can, and should if possible, re-use filterScratchBitmap
   */

  FilterElement.prototype.filter = function(filterScratchBitmap, scale, elementToFilterScratchMatrix, options) {
    var imageData;
    imageData = filterScratchBitmap.getImageData();
    this.filterPixelData(filterScratchBitmap, imageData.data, scale);
    filterScratchBitmap.putImageData(imageData);
    return filterScratchBitmap;
  };

  FilterElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
    var filterTarget, filterTargetToElementMatrix, ref, scale;
    scale = elementToTargetMatrix.exactScaler;
    ref = this._filterFilterSource(scale, target, options), filterTargetToElementMatrix = ref.filterTargetToElementMatrix, filterTarget = ref.filterTarget;
    return target.drawBitmap(filterTargetToElementMatrix.mul(elementToTargetMatrix), filterTarget, options);
  };

  FilterElement.prototype.overDraw = function(proposedTargetSpaceDrawArea, parentToTargetMatrix) {
    var minimumElementSpaceDrawArea, propsedElementSpaceDrawArea, requiredTargetSpaceDrawArea, targetToElementMatrix;
    targetToElementMatrix = parentToTargetMatrix.inv.mul(this.parentToElementMatrix);
    propsedElementSpaceDrawArea = targetToElementMatrix.transformBoundingRect(proposedTargetSpaceDrawArea);
    minimumElementSpaceDrawArea = propsedElementSpaceDrawArea.grow(this.radius).intersection(this.elementSpaceDrawArea);
    requiredTargetSpaceDrawArea = parentToTargetMatrix.transformBoundingRect(minimumElementSpaceDrawArea);
    return proposedTargetSpaceDrawArea.union(requiredTargetSpaceDrawArea);
  };

  FilterElement.virtualProperty({
    baseDrawArea: function(pending) {
      var _currentSize, _radius, baseDrawArea, ref;
      ref = this.getState(pending), _currentSize = ref._currentSize, _radius = ref._radius;
      baseDrawArea = this.getElementSpaceSourceDrawArea(pending);
      if (this._inverted) {
        this.filterSourceDrawAreaInElementSpace.unionInto(baseDrawArea);
      }
      return baseDrawArea.grow(_radius);
    }
  });

  FilterElement.getter({
    requiresParentStagingBitmap: function() {
      return true;
    },
    isFilter: function() {
      return true;
    }
  });


  /*
  IN:
    pending: if true, use pending data
    returnChild: see OUT
  
  OUT: if returnChild
      the child of FilterSourceElement which is @ or an ancestor of @
    else
      FilterSourceElement
   */

  FilterElement.prototype._getFilterSourceElement = function(pending, returnChild) {
    var c, filterSource, p, state;
    state = this.getState(pending);
    if (filterSource = state._filterSource) {
      p = state._parent;
      c = this;
      while (p && p.name !== filterSource) {
        c = p;
        p = p.getState(pending)._parent;
      }
      if (p) {
        if (returnChild) {
          return c;
        } else {
          return p;
        }
      }
      console.warn(this.inspectedName + ": no ancestor's name matches filterSource:" + (inspect(filterSource)));
    }
    if (returnChild) {
      return this;
    } else {
      return state._parent;
    }
  };


  /*
  Can only be called when filterSource._currentToTargetMatrix is valid.
  I.E. in the middle of a draw cycle.
   */

  FilterElement.prototype._filterFilterSource = function(scale, bitmapFactory, options) {
    var elementSpaceDrawArea, elementToFilterScratchMatrix, filterScratch, filterSource, filterSourceTargetToFilterScratchMatrix;
    filterSource = this.getFilterSourceElement();
    elementSpaceDrawArea = this.getElementSpaceDrawArea();
    elementToFilterScratchMatrix = Matrix.translate(elementSpaceDrawArea.location.neg.add(this.radius)).scale(scale);
    filterSourceTargetToFilterScratchMatrix = filterSource._currentToTargetMatrix.inv.scale(this.getFilterSourceSizeRatio()).mul(elementToFilterScratchMatrix);
    filterScratch = bitmapFactory.newBitmap(elementSpaceDrawArea.size.add(this.radius * 2).mul(scale)).drawBitmap(filterSourceTargetToFilterScratchMatrix, filterSource._currentDrawTarget);
    return {
      filterTargetToElementMatrix: elementToFilterScratchMatrix.inv,
      filterTarget: this.filter(filterScratch, scale, elementToFilterScratchMatrix, options)
    };
  };

  FilterElement.virtualProperty({
    filterSourceDrawArea: function(pending) {
      var filterSourceChildElement, filterSourceElement;
      filterSourceElement = this.getFilterSourceElement(pending);
      filterSourceChildElement = this.getFilterSourceChildElement(pending);
      return filterSourceElement._computeElementSpaceDrawArea(filterSourceChildElement);
    },
    filterSourceSize: function(pending) {
      return this.getFilterSourceElement(pending).getCurrentSize(pending);
    },
    filterSourceSizeRatio: function(pending) {
      var _currentSize, filterSourceSize;
      _currentSize = this.getState(pending)._currentSize;
      filterSourceSize = this.getFilterSourceSize(pending);
      if (_currentSize.eq(filterSourceSize)) {
        return 1;
      } else {
        return _currentSize.div(filterSourceSize);
      }
    },
    elementSpaceSourceDrawArea: function(pending) {
      return this.getFilterSourceDrawArea(pending).mul(this.getFilterSourceSizeRatio(pending));
    },
    filterSourceElement: function(pending) {
      return this._getFilterSourceElement(pending);
    },
    filterSourceChildElement: function(pending) {
      return this._getFilterSourceElement(pending, true);
    },
    filterSourceDrawAreaInElementSpace: function(pending) {
      return this.getFilterSourceElement(pending).getElementToElementMatrix(this).transformBoundingRect(this.getFilterSourceDrawArea(pending));
    }
  });

  return FilterElement;

})(AtomElement));


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Atomic, BaseClass, Foundation, GestureRecognizer, Pointer, abs, clone, defineModule, first, inspect, isFunction, isPlainObject, log, matrix, merge, objectWithout, peek, point, rect, select,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Pointer = __webpack_require__(124);

log = Foundation.log, defineModule = Foundation.defineModule, inspect = Foundation.inspect, merge = Foundation.merge, clone = Foundation.clone, peek = Foundation.peek, first = Foundation.first, BaseClass = Foundation.BaseClass, isPlainObject = Foundation.isPlainObject, clone = Foundation.clone, abs = Foundation.abs, isFunction = Foundation.isFunction, select = Foundation.select, objectWithout = Foundation.objectWithout;

point = Atomic.point, rect = Atomic.rect, matrix = Atomic.matrix;

defineModule(module, GestureRecognizer = (function(superClass) {
  var pointerHandlers;

  extend(GestureRecognizer, superClass);

  GestureRecognizer.createGestureRecognizer = function(o) {
    var gr;
    gr = new GestureRecognizer(o);
    return gr.getPointerHandlers();
  };

  pointerHandlers = ["pointerDown", "pointerUp", "pointerMove", "pointerCancel"];

  function GestureRecognizer(gestureRecognizers) {
    this._nonGestureHandlers = gestureRecognizers;
    this._gestureRecognizers = objectWithout(gestureRecognizers, pointerHandlers);
    this._activeGesture = null;
    this._lastActiveGesture = null;
    this._startEvent = null;
    this._capturedEvents = false;
    GestureRecognizer.__super__.constructor.apply(this, arguments);
    this.setupDefaultRecognizers();
    this._startEvent = null;
  }

  GestureRecognizer.prototype.setupDefaultRecognizers = function() {
    var k, ref, results, v;
    ref = this._gestureRecognizers;
    results = [];
    for (k in ref) {
      v = ref[k];
      switch (k) {
        case "horizontal":
          results.push(v.recognize || (v.recognize = function(e) {
            return e.delta.absoluteAspectRatio > 1;
          }));
          break;
        case "vertical":
          results.push(v.recognize || (v.recognize = function(e) {
            return e.delta.absoluteAspectRatio < 1;
          }));
          break;
        default:
          results.push(void 0);
      }
    }
    return results;
  };

  GestureRecognizer.getter({
    pointerHandlers: function() {
      return merge(this._nonGestureHandlers, {
        pointerDown: (function(_this) {
          return function(e) {
            var base, ref;
            _this._capturedEvents = false;
            if (typeof (base = _this._nonGestureHandlers).pointerDown === "function") {
              base.pointerDown(e);
            }
            _this._startEvent = e.newEvent ? e.newEvent() : clone(e);
            if ((ref = _this._lastActiveGesture) != null ? typeof ref.resume === "function" ? ref.resume(e) : void 0 : void 0) {
              return _this._resumeGesture(e);
            }
          };
        })(this),
        pointerMove: (function(_this) {
          return function(e) {
            var ag, base, base1, base2, ref;
            if (ag = _this._activeGesture) {
              if (!_this._capturedEvents && !e.pointer.stayedWithinDeadzone && (typeof (base = _this._activeGesture).recognize === "function" ? base.recognize(e) : void 0)) {
                if ((ref = e.target) != null) {
                  if (typeof ref.capturePointerEvents === "function") {
                    ref.capturePointerEvents();
                  }
                }
                _this._capturedEvents = true;
              }
              return typeof ag.move === "function" ? ag.move(e) : void 0;
            } else {
              if (_this._startEvent) {
                _this._startGesture(e);
                return typeof (base1 = _this._nonGestureHandlers).pointerCancel === "function" ? base1.pointerCancel(e) : void 0;
              } else {
                return typeof (base2 = _this._nonGestureHandlers).pointerMove === "function" ? base2.pointerMove(e) : void 0;
              }
            }
          };
        })(this),
        pointerUp: (function(_this) {
          return function(e) {
            var base, base1;
            if (_this._activeGesture) {
              if (typeof (base = _this._activeGesture).end === "function") {
                base.end(e);
              }
              return _this._activeGesture = null;
            } else {
              return typeof (base1 = _this._nonGestureHandlers).pointerUp === "function" ? base1.pointerUp(e) : void 0;
            }
          };
        })(this),
        pointerCancel: (function(_this) {
          return function(e) {
            var base, base1;
            if (_this._activeGesture) {
              if (typeof (base = _this._activeGesture).cancel === "function") {
                base.cancel(e);
              }
              _this._activeGesture = null;
            } else {
              if (typeof (base1 = _this._nonGestureHandlers).pointerCancel === "function") {
                base1.pointerCancel(e);
              }
            }
            return _this._startEvent = null;
          };
        })(this)
      });
    }
  });

  GestureRecognizer.prototype._resumeGesture = function(e) {
    var base, ref;
    if ((ref = e.target) != null) {
      if (typeof ref.capturePointerEvents === "function") {
        ref.capturePointerEvents();
      }
    }
    this._activeGesture = this._lastActiveGesture;
    return typeof (base = this._activeGesture).begin === "function" ? base.begin(this._startEvent) : void 0;
  };

  GestureRecognizer.prototype._startGesture = function(e) {
    var base, base1, k, ref, v;
    ref = this._gestureRecognizers;
    for (k in ref) {
      v = ref[k];
      if (!(typeof v.recognize === "function" ? v.recognize(e) : void 0)) {
        continue;
      }
      this._lastActiveGesture = this._activeGesture = v;
      break;
    }
    if (this._activeGesture) {
      if (typeof (base = this._activeGesture).begin === "function") {
        base.begin(this._startEvent);
      }
      return typeof (base1 = this._activeGesture).move === "function" ? base1.move(e) : void 0;
    }
  };

  return GestureRecognizer;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Atomic, BaseClass, Foundation, Pointer, clone, defineModule, first, inspect, matrix, peek, point, rect,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

inspect = Foundation.inspect, defineModule = Foundation.defineModule, clone = Foundation.clone, peek = Foundation.peek, first = Foundation.first, BaseClass = Foundation.BaseClass;

point = Atomic.point, rect = Atomic.rect, matrix = Atomic.matrix;

defineModule(module, Pointer = (function(superClass) {
  var emptyObject, pointerDeadZone, pointerDeadZoneSquared;

  extend(Pointer, superClass);

  Pointer.pointerDeadZone = pointerDeadZone = 10;

  Pointer.pointerDeadZoneSquared = pointerDeadZoneSquared = pointerDeadZone * pointerDeadZone;

  function Pointer(id, location, lastLocation, firstLocation, stayedWithinDeadzone) {
    if (stayedWithinDeadzone == null) {
      stayedWithinDeadzone = true;
    }
    this.id = id;
    this.location = location;
    this.lastLocation = lastLocation || location;
    this.firstLocation = firstLocation || location;
    this.stayedWithinDeadzone = stayedWithinDeadzone;
  }

  emptyObject = {};

  Pointer.prototype.newPointer = function(options) {
    if (options == null) {
      options = emptyObject;
    }
    return new Pointer(options.id || this.id, options.location || this.location, options.lastLocation || this.lastLocation, options.firstLocation || this.firstLocation, options.stayedWithinDeadzone || this.stayedWithinDeadzone);
  };

  Pointer.prototype.moved = function(newLocation) {
    var stayedWithinDeadzone;
    stayedWithinDeadzone = this.stayedWithinDeadzone && newLocation.distanceSquared(this.firstLocation) <= pointerDeadZoneSquared;
    return new Pointer(this.id, newLocation, this.location, this.firstLocation, stayedWithinDeadzone);
  };

  Pointer.prototype.locationIn = function(element) {
    if (element) {
      return element.absToElementMatrix.transform(this.location);
    } else {
      return this.location;
    }
  };

  Pointer.prototype.lastLocationIn = function(element) {
    if (element) {
      return element.absToElementMatrix.transform(this.lastLocation);
    } else {
      return this.lastLocation;
    }
  };

  Pointer.prototype.firstLocationIn = function(element) {
    if (element) {
      return element.absToElementMatrix.transform(this.firstLocation);
    } else {
      return this.firstLocation;
    }
  };

  Pointer.prototype.deltaIn = function(element) {
    if (element) {
      return element.absToElementMatrix.transformDifference(this.location, this.lastLocation);
    } else {
      return this.location.sub(this.lastLocation);
    }
  };

  Pointer.prototype.totalDeltaIn = function(element) {
    if (element) {
      return element.absToElementMatrix.transformDifference(this.location, this.firstLocation);
    } else {
      return this.location.sub(this.firstLocation);
    }
  };

  return Pointer;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, Point, PointLayoutBase, inspect, inspectedObjectLiteral, isFunction, isNumber, isPlainObject, log, nearInfinity, nearInfinityResult, point, point0, ref, ref1,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(4), point = ref.point, Point = ref.Point;

point0 = Point.point0;

ref1 = __webpack_require__(1), log = ref1.log, inspect = ref1.inspect, isFunction = ref1.isFunction, isNumber = ref1.isNumber, isPlainObject = ref1.isPlainObject, nearInfinity = ref1.nearInfinity, nearInfinityResult = ref1.nearInfinityResult, inspectedObjectLiteral = ref1.inspectedObjectLiteral;

BaseClass = __webpack_require__(6).BaseClass;

module.exports = PointLayoutBase = (function(superClass) {
  var nearInfinityPoint, nearInfinityPointX, nearInfinityPointY;

  extend(PointLayoutBase, superClass);

  function PointLayoutBase(a, previousLayout) {
    this._xRelativeToParentW = this._xRelativeToParentH = this._yRelativeToParentW = this._yRelativeToParentH = this._xRelativeToChildrenW = this._xRelativeToChildrenH = this._yRelativeToChildrenW = this._yRelativeToChildrenH = false;
    this._hasXLayout = this._hasYLayout = false;
    this._inheritedXLayout = this._inheritedYLayout = false;
  }

  PointLayoutBase.prototype.layout = function(ps, cs) {
    return point(this.layoutX(ps, cs), this.layoutY(ps, cs));
  };

  PointLayoutBase.prototype.mergeInLayoutRelativity = function(layout) {
    this._xRelativeToParentW || (this._xRelativeToParentW = layout._xRelativeToParentW);
    this._xRelativeToParentH || (this._xRelativeToParentH = layout._xRelativeToParentH);
    this._yRelativeToParentW || (this._yRelativeToParentW = layout._yRelativeToParentW);
    this._yRelativeToParentH || (this._yRelativeToParentH = layout._yRelativeToParentH);
    this._xRelativeToChildrenW || (this._xRelativeToChildrenW = layout._xRelativeToChildrenW);
    this._xRelativeToChildrenH || (this._xRelativeToChildrenH = layout._xRelativeToChildrenH);
    this._yRelativeToChildrenW || (this._yRelativeToChildrenW = layout._yRelativeToChildrenW);
    return this._yRelativeToChildrenH || (this._yRelativeToChildrenH = layout._yRelativeToChildrenH);
  };

  PointLayoutBase.prototype.interpolate = function(toLayout, p) {
    if (p === 0) {
      return this;
    } else if (p === 1) {
      return toLayout;
    } else {
      return new PointLayoutBase.InterpolatedPointLayout(this, toLayout, p);
    }
  };

  PointLayoutBase.getter({
    inspectedString: function() {
      return this.toString();
    }
  });

  PointLayoutBase.prototype.inspect = function() {
    return this.toString();
  };

  PointLayoutBase.prototype._copyXRelativity = function(sourceLayout) {
    this._xRelativeToParentW = sourceLayout._xRelativeToParentW;
    this._xRelativeToParentH = sourceLayout._xRelativeToParentH;
    this._xRelativeToChildrenW = sourceLayout._xRelativeToChildrenW;
    return this._xRelativeToChildrenH = sourceLayout._xRelativeToChildrenH;
  };

  PointLayoutBase.prototype._copyYRelativity = function(sourceLayout) {
    this._yRelativeToParentW = sourceLayout._yRelativeToParentW;
    this._yRelativeToParentH = sourceLayout._yRelativeToParentH;
    this._yRelativeToChildrenW = sourceLayout._yRelativeToChildrenW;
    return this._yRelativeToChildrenH = sourceLayout._yRelativeToChildrenH;
  };

  PointLayoutBase.getter({
    inspectedObjects: function() {
      return inspectedObjectLiteral(this.toString());
    }
  });

  PointLayoutBase.getter("xRelativeToParentW\nxRelativeToParentH\nyRelativeToParentW\nyRelativeToParentH\nxRelativeToChildrenW\nxRelativeToChildrenH\nyRelativeToChildrenW\nyRelativeToChildrenH\nhasXLayout\nhasYLayout");

  PointLayoutBase.getter({
    hasFullLayout: function() {
      return this._hasXLayout && this._hasYLayout;
    },
    hasLayout: function() {
      return this._hasXLayout || this._hasYLayout;
    },
    parentRelative: function() {
      return this._xRelativeToParentH || this._xRelativeToParentW || this._yRelativeToParentH || this._yRelativeToParentW;
    },
    childrenRelative: function() {
      return this._xRelativeToChildrenH || this._xRelativeToChildrenW || this._yRelativeToChildrenH || this._yRelativeToChildrenW;
    },
    xParentRelative: function() {
      return this._xRelativeToParentH || this._xRelativeToParentW;
    },
    yParentRelative: function() {
      return this._yRelativeToParentH || this._yRelativeToParentW;
    },
    xChildrenRelative: function() {
      return this._xRelativeToChildrenH || this._xRelativeToChildrenW;
    },
    yChildrenRelative: function() {
      return this._yRelativeToChildrenH || this._yRelativeToChildrenW;
    }
  });

  PointLayoutBase.prototype.layoutIsCircular = function(parentLayout) {
    var result, xcx, xcy, xpx, xpy, ycx, ycy, ypx, ypy;
    if (!parentLayout) {
      return false;
    }
    xpx = this._xRelativeToParentW;
    xpy = this._xRelativeToParentH;
    ypx = this._yRelativeToParentW;
    ypy = this._yRelativeToParentH;
    xcx = parentLayout.getXRelativeToChildrenW();
    xcy = parentLayout.getXRelativeToChildrenH();
    ycx = parentLayout.getYRelativeToChildrenW();
    ycy = parentLayout.getYRelativeToChildrenH();
    result = !!((xpx && xcx) || (xpy && ycx) || (ypy && ycy) || (ypx && xcy) || (xpy && ycy && ypx && xcy) || (xpx && xcy && ypy && ycx));
    return result;
  };

  nearInfinityPoint = point(nearInfinity, nearInfinity);

  nearInfinityPointX = point0.withX(nearInfinity);

  nearInfinityPointY = point0.withY(nearInfinity);

  PointLayoutBase.prototype.isParentRelative = function(fName, baseline, baselinePoint, testPoint) {
    return this[fName](testPoint, baselinePoint) !== baseline;
  };

  PointLayoutBase.prototype.isChildrenRelative = function(fName, baseline, baselinePoint, testPoint) {
    return this[fName](baselinePoint, testPoint) !== baseline;
  };

  PointLayoutBase.prototype._detectXRelativity = function() {
    var layoutBaseline, nearInfinityBaseline;
    layoutBaseline = this.layoutX(point0, point0);
    nearInfinityBaseline = this.layoutX(nearInfinityPoint, nearInfinityPoint);
    this._xRelativeToParentW = this.isParentRelative("layoutX", layoutBaseline, point0, nearInfinityPointX) || this.isParentRelative("layoutX", nearInfinityBaseline, nearInfinityPoint, nearInfinityPointY);
    this._xRelativeToParentH = this.isParentRelative("layoutX", layoutBaseline, point0, nearInfinityPointY) || this.isParentRelative("layoutX", nearInfinityBaseline, nearInfinityPoint, nearInfinityPointX);
    this._xRelativeToChildrenW = this.isChildrenRelative("layoutX", layoutBaseline, point0, nearInfinityPointX) || this.isChildrenRelative("layoutX", nearInfinityBaseline, nearInfinityPoint, nearInfinityPointY);
    return this._xRelativeToChildrenH = this.isChildrenRelative("layoutX", layoutBaseline, point0, nearInfinityPointY) || this.isChildrenRelative("layoutX", nearInfinityBaseline, nearInfinityPoint, nearInfinityPointX);
  };

  PointLayoutBase.prototype._detectYRelativity = function() {
    var layoutBaseline, nearInfinityBaseline;
    layoutBaseline = this.layoutY(point0, point0);
    nearInfinityBaseline = this.layoutY(nearInfinityPoint, nearInfinityPoint);
    this._yRelativeToParentW = this.isParentRelative("layoutY", layoutBaseline, point0, nearInfinityPointX) || this.isParentRelative("layoutY", nearInfinityBaseline, nearInfinityPoint, nearInfinityPointY);
    this._yRelativeToParentH = this.isParentRelative("layoutY", layoutBaseline, point0, nearInfinityPointY) || this.isParentRelative("layoutY", nearInfinityBaseline, nearInfinityPoint, nearInfinityPointX);
    this._yRelativeToChildrenW = this.isChildrenRelative("layoutY", layoutBaseline, point0, nearInfinityPointX) || this.isChildrenRelative("layoutY", nearInfinityBaseline, nearInfinityPoint, nearInfinityPointY);
    return this._yRelativeToChildrenH = this.isChildrenRelative("layoutY", layoutBaseline, point0, nearInfinityPointY) || this.isChildrenRelative("layoutY", nearInfinityBaseline, nearInfinityPoint, nearInfinityPointX);
  };

  PointLayoutBase.prototype._detectRelativity = function() {
    this._detectXRelativity();
    return this._detectYRelativity();
  };

  return PointLayoutBase;

})(BaseClass);


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var ArtStandardLib, merge;

merge = (ArtStandardLib = __webpack_require__(1)).merge;

module.exports = merge(__webpack_require__(6), __webpack_require__(4), ArtStandardLib);


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(441);


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var AfterEventsFilter, Filter, Promise, defineModule, formattedInspect, isFunction, isString, log, pushIfNotPresent, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), defineModule = ref.defineModule, log = ref.log, Promise = ref.Promise, isFunction = ref.isFunction, isString = ref.isString, pushIfNotPresent = ref.pushIfNotPresent, formattedInspect = ref.formattedInspect;

Filter = __webpack_require__(21);

defineModule(module, AfterEventsFilter = (function(superClass) {
  extend(AfterEventsFilter, superClass);

  function AfterEventsFilter() {
    return AfterEventsFilter.__super__.constructor.apply(this, arguments);
  }

  AfterEventsFilter.handlers = {};

  AfterEventsFilter._registeredPipelineHandlers = {};

  AfterEventsFilter._reset = function() {
    AfterEventsFilter.handlers = {};
    return AfterEventsFilter._registeredPipelineHandlers = {};
  };

  AfterEventsFilter.on = function(pipelineName, requestType, actionOrPipeline) {
    var base, base1;
    return pushIfNotPresent(((base = ((base1 = this.handlers)[pipelineName] || (base1[pipelineName] = {})))[requestType] || (base[requestType] = [])), actionOrPipeline);
  };

  AfterEventsFilter.registerPipelineListener = function(listeningPipeline, listeningToPipelineName, requestType) {
    if (!isFunction(listeningPipeline.handleRequestAfterEvent)) {
      throw new Error("listeningPipeline must implement handleRequestAfterEvent");
    }
    if (!isString(listeningToPipelineName)) {
      throw new Error("listeningToPipelineName must be a string");
    }
    return this.on(listeningToPipelineName, requestType, listeningPipeline);
  };

  AfterEventsFilter.sendEvents = function(response) {
    return Promise.resolve(response).then(function(response) {
      var actionOrPipeline, actionPromises, pipelineName, requestType;
      pipelineName = response.pipelineName, requestType = response.requestType;
      actionPromises = (function() {
        var i, len, ref1, ref2, results;
        ref2 = ((ref1 = AfterEventsFilter.handlers[pipelineName]) != null ? ref1[requestType] : void 0) || [];
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          actionOrPipeline = ref2[i];
          if (isFunction(actionOrPipeline.handleRequestAfterEvent)) {
            results.push(actionOrPipeline.handleRequestAfterEvent(response));
          } else {
            results.push(actionOrPipeline(response));
          }
        }
        return results;
      })();
      return Promise.all(actionPromises);
    }).then(function() {
      return response;
    });
  };

  AfterEventsFilter.after({
    all: function(response) {
      return AfterEventsFilter.sendEvents(response);
    }
  });

  return AfterEventsFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Filter, Promise, ValidationFilter, Validator, defineModule, log, merge, pluralize, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), defineModule = ref.defineModule, pluralize = ref.pluralize, log = ref.log, Validator = ref.Validator, merge = ref.merge, Promise = ref.Promise;

Filter = __webpack_require__(21);


/*
TODO!!!
 * BUG: ValidationFilter doesn't validated the TimestampFilter's fields! (when using createDatabaseFilters)
 * PROBLEM: ValidationFilter only validates the fields it is passed.
 * SOLUTION: we need it to always validate all fields declared for the pipeline.
 * createDatabaseFilters needs to change order: it needs to run ValidationFilter last.

I almost want to rename this "FieldTypesFilter" - since it both validates and preprocesses.
It should actually also have an @after pass that at least converts timestamps back into Dates.
 */

defineModule(module, ValidationFilter = (function(superClass) {
  extend(ValidationFilter, superClass);

  ValidationFilter.location("both");

  function ValidationFilter(options) {
    ValidationFilter.__super__.constructor.apply(this, arguments);
    this._exclusive = options != null ? options.exclusive : void 0;
    this._validator = new Validator(this.fields);
  }

  ValidationFilter.before({
    create: function(request) {
      return this._validate("validateCreate", request);
    },
    update: function(request) {
      return this._validate("validateUpdate", request);
    }
  });

  ValidationFilter.prototype._validate = function(method, request) {
    return Promise.then((function(_this) {
      return function() {
        var context, data, fields, k, rejection, unexpectedFields, v, validatedData;
        context = (request.pipeline.getClass().getName()) + " Pipeline " + (_this["class"].getName());
        validatedData = _this._validator[method](request.data, {
          context: context
        });
        if (request.location !== "client") {
          data = validatedData;
        }
        rejection = (function() {
          if (this._exclusive) {
            fields = request.pipeline.fields;
            unexpectedFields = null;
            for (k in data) {
              v = data[k];
              if (!fields[k]) {
                (unexpectedFields || (unexpectedFields = [])).push(k);
              }
            }
            if (unexpectedFields) {
              return Promise.reject({
                message: context + " failed. " + (pluralize(unexpectedFields.length, "unexpected field")) + ": " + (unexpectedFields.join(', ')),
                info: {
                  unexpected: unexpectedFields
                }
              });
            }
          }
        }).call(_this);
        return rejection || request.withData(data);
      };
    })(this))["catch"](function(arg) {
      var info, message;
      message = arg.message, info = arg.info;
      return request.clientFailure({
        data: merge({
          message: message
        }, info)
      });
    });
  };

  return ValidationFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, PipelineRegistry, compactFlatten, decapitalize, defineModule, each, inspect, isClass, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), defineModule = ref.defineModule, each = ref.each, compactFlatten = ref.compactFlatten, log = ref.log, BaseObject = ref.BaseObject, decapitalize = ref.decapitalize, isClass = ref.isClass, inspect = ref.inspect;

defineModule(module, PipelineRegistry = (function(superClass) {
  var pipelines;

  extend(PipelineRegistry, superClass);

  function PipelineRegistry() {
    return PipelineRegistry.__super__.constructor.apply(this, arguments);
  }

  PipelineRegistry.pipelines = pipelines = {};

  PipelineRegistry.register = function(PipelineClass) {
    var _aliases, alias, singleton;
    singleton = PipelineClass.singleton, _aliases = PipelineClass._aliases;
    _aliases && (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = _aliases.length; i < len; i++) {
        alias = _aliases[i];
        results.push(pipelines[alias] = singleton);
      }
      return results;
    })();
    return pipelines[singleton.name] = singleton;
  };

  PipelineRegistry._reset = function(testFunction) {
    if (testFunction == null) {
      testFunction = function() {
        return true;
      };
    }
    return each(Object.keys(pipelines), function(key) {
      if (testFunction(pipelines[key])) {
        return delete pipelines[key];
      }
    });
  };

  return PipelineRegistry;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ErrorWithInfo, Promise, RequestHandler, RequestResponseBase, defineModule, isJsonType, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), ErrorWithInfo = ref.ErrorWithInfo, defineModule = ref.defineModule, Promise = ref.Promise, isJsonType = ref.isJsonType, log = ref.log;

RequestResponseBase = __webpack_require__(82);

defineModule(module, RequestHandler = (function(superClass) {
  extend(RequestHandler, superClass);

  function RequestHandler() {
    return RequestHandler.__super__.constructor.apply(this, arguments);
  }

  RequestHandler.abstractClass();


  /*
  OUT:
    promise.then (request or response) ->
      NOTE: response may be failing
    .catch -> internal errors only
   */

  RequestHandler.prototype.applyHandler = function(request, handlerFunction) {
    if (!handlerFunction) {
      return Promise.resolve(request);
    }
    return Promise.then((function(_this) {
      return function() {
        request.addFilterLog(_this);
        return handlerFunction.call(_this, request);
      };
    })(this)).then((function(_this) {
      return function(data) {
        if (data == null) {
          return request.missing();
        } else if (data instanceof RequestResponseBase) {
          return data;
        } else if (isJsonType(data)) {
          return request.success({
            data: data
          });
        } else {
          throw new ErrorWithInfo("invalid response data passed to RequestResponseBaseNext", {
            data: data
          });
        }
      };
    })(this), (function(_this) {
      return function(error) {
        var ref1, ref2;
        if ((ref1 = error.props) != null ? (ref2 = ref1.response) != null ? ref2.isResponse : void 0 : void 0) {
          return error.props.response;
        } else {
          return request.failure({
            errorProps: {
              exception: error,
              source: {
                "this": _this,
                "function": handlerFunction
              }
            }
          });
        }
      };
    })(this));

    /*
    IN:
      request OR response
    
      if response, it is immediately returned
    OUT:
      promise.then -> response
        response may or maynot be successful, but it is always returned via the promise-success path
    
      promise.catch -> always means an internal failure
    
    OVERRIDE THIS
     */
  };

  return RequestHandler;

})(__webpack_require__(79)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, CommunicationStatus, Foundation, Promise, Request, RequestError, Response, Validator, arrayWith, arrayWithoutLast, clientFailure, compactFlatten, config, currentSecond, failure, formattedInspect, inspect, isJsonType, isPlainArray, isPlainObject, log, merge, missing, object, objectKeyCount, objectWithout, peek, pureMerge, responseValidator, serverFailure, success, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Request = __webpack_require__(81);

currentSecond = Foundation.currentSecond, objectWithout = Foundation.objectWithout, arrayWithoutLast = Foundation.arrayWithoutLast, pureMerge = Foundation.pureMerge, Promise = Foundation.Promise, BaseObject = Foundation.BaseObject, compactFlatten = Foundation.compactFlatten, object = Foundation.object, peek = Foundation.peek, isPlainArray = Foundation.isPlainArray, objectKeyCount = Foundation.objectKeyCount, arrayWith = Foundation.arrayWith, inspect = Foundation.inspect, RequestError = Foundation.RequestError, isPlainObject = Foundation.isPlainObject, log = Foundation.log, CommunicationStatus = Foundation.CommunicationStatus, Validator = Foundation.Validator, merge = Foundation.merge, isJsonType = Foundation.isJsonType, formattedInspect = Foundation.formattedInspect, w = Foundation.w;

success = CommunicationStatus.success, missing = CommunicationStatus.missing, failure = CommunicationStatus.failure, serverFailure = CommunicationStatus.serverFailure, clientFailure = CommunicationStatus.clientFailure;

config = __webpack_require__(27).config;

responseValidator = new Validator({
  request: w("required", {
    "instanceof": Request
  }),
  status: w("required communicationStatus"),
  session: "object",
  props: "object"
});


/*
TODO: Merge Response back into Request

  Turns out, Response has very little special functionality.
  At this point, the RequestuestResponseBase / Request / Response class structure
  actually requires more code than just one, Request class would.

What to add to Request:

  @writeOnceProperty "responseStatus responseSession responseProps"

  @getter
    hasResponse: -> !!@responseStatus

  Split out: filterLog into beforeFilterLog and afterFilterLog.
 */


/*
new Response

IN:
  request: Request (required)
  status: CommunicationStatus (required)
  props: plainObject with all JSON values
  session: plainObject with all JSON values

  data: JSON value
    data is an alias for @props.data
    EFFECT: replaces @props.data
    NOTE: for clientRequest, @props.data is the value returned unless returnResponse/returnResponseObject is requested

  remoteRequest: remoteResponse:
    Available for inspecting what exactly went over-the-wire.
    Otherwise ignored by Response
 */

module.exports = Response = (function(superClass) {
  extend(Response, superClass);

  function Response(options) {
    var ref;
    Response.__super__.constructor.apply(this, arguments);
    responseValidator.validate(options, {
      context: "Art.Ery.Response options",
      logErrors: true
    });
    this.request = options.request, this.status = options.status, this.props = (ref = options.props) != null ? ref : {}, this.session = options.session, this.remoteRequest = options.remoteRequest, this.remoteResponse = options.remoteResponse;
    if (options.requestOptions) {
      throw new Error("options.requestOptions is DEPRICATED - use options.props");
    }
    if (options.data != null) {
      this._props.data = options.data;
    }
    this._endTime = null;
    if (this.status !== success) {
      this._captureErrorStack();
    }
    if (this.type === "create" || this.type === "get") {
      this.setGetCache();
    }
  }

  Response.prototype.isResponse = true;

  Response.property("request props session remoteResponse remoteRequest");

  Response.setter("status");

  Response.getter({
    status: function() {
      if (this.failed) {
        switch (this.location) {
          case "server":
            return serverFailure;
          case "client":
            return clientFailure;
        }
      }
      return this._status;
    },
    failed: function() {
      return this._status === failure;
    },
    data: function() {
      return this._props.data;
    },
    session: function() {
      var ref;
      return (ref = this._session) != null ? ref : this.request.session;
    },
    responseData: function() {
      return this._props.data;
    },
    responseProps: function() {
      return this._props;
    },
    responseSession: function() {
      return this._session;
    },
    beforeFilterLog: function() {
      return this.request.filterLog || [];
    },
    handledBy: function() {
      return !this.failed && peek(this.request.filterLog);
    },
    rawRequestLog: function() {
      return compactFlatten([this.beforeFilterLog, this.afterFilterLog]);
    },
    requestLog: function() {
      var endTime, firstTime, lastProps, lastTime, name, out, ref, startTime, time;
      ref = this, startTime = ref.startTime, endTime = ref.endTime;
      firstTime = lastTime = startTime;
      lastProps = null;
      out = (function() {
        var i, len, ref1, ref2, results;
        ref1 = this.rawRequestLog;
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          ref2 = ref1[i], name = ref2.name, time = ref2.time;
          if (firstTime == null) {
            firstTime = lastTime = time;
          }
          if (lastProps != null) {
            lastProps.deltaMs = (time - lastTime) * 1000 | 0;
          }
          lastProps = {
            name: name,
            timeMs: 0,
            wallMs: (time - firstTime) * 1000 | 0
          };
          lastTime = time;
          results.push(lastProps);
        }
        return results;
      }).call(this);
      log({
        startTime: startTime,
        lastTime: lastTime,
        _endTime: this._endTime
      });
      if (lastProps != null) {
        lastProps.deltaMs = (endTime - lastTime) * 1000 | 0;
      }
      return out;
    },
    afterFilterLog: function() {
      return this._filterLog || [];
    },
    isSuccessful: function() {
      return this._status === success;
    },
    isMissing: function() {
      return this._status === missing;
    },
    notSuccessful: function() {
      return this._status !== success;
    },
    description: function() {
      return this.requestString + ": " + this.status;
    },
    propsForClone: function() {
      return {
        request: this.request,
        status: this.status,
        props: this.props,
        session: this._session,
        filterLog: this._filterLog,
        remoteRequest: this.remoteRequest,
        remoteResponse: this.remoteResponse,
        errorProps: this.errorProps
      };
    },
    propsForResponse: function() {
      return this.propsForClone;
    },
    plainObjectsResponse: function(fields) {
      return object(fields || {
        status: this.status,
        props: this.props,
        beforeFilterLog: this.beforeFilterLog,
        afterFilterLog: this.afterFilterLog,
        session: this._session
      }, {
        when: function(v) {
          switch (false) {
            case !isPlainObject(v):
              return objectKeyCount(v) > 0;
            case !isPlainArray(v):
              return v.length > 0;
            default:
              return v !== void 0;
          }
        }
      });
    },
    responseForRemoteRequest: function() {
      return this.getPlainObjectsResponse(!config.returnProcessingInfoToClient ? {
        status: this.status,
        props: this.props,
        session: this._session
      } : void 0);
    }
  });

  Response.prototype.withMergedSession = function(session) {
    return Promise.resolve(session).then((function(_this) {
      return function(session) {
        return new _this["class"](merge(_this.propsForClone, {
          session: merge(_this.session, session)
        }));
      };
    })(this));
  };


  /*
  IN: options:
    returnNullIfMissing: true [default: false]
      if status == missing
        if returnNullIfMissing
          promise.resolve null
        else
          promise.reject new RequestError
  
    returnResponse: true [default: false]
    returnResponseObject: true (alias)
      if true, the response object is returned, otherwise, just the data field is returned.
  
  OUT:
     * if response.isSuccessful && returnResponse == true
    promise.then (response) ->
  
     * if response.isSuccessful && returnResponse == false
    promise.then (data) ->
  
     * if response.isMissing && returnNullIfMissing == true
    promise.then (data) -> # data == null
  
     * else
    promise.catch (errorWithInfo) ->
      {response} = errorWithInfo.info
   */

  Response.prototype.toPromise = function(options) {
    var data, isMissing, isSuccessful, ref, returnNullIfMissing, returnResponse, returnResponseObject;
    if (options) {
      returnNullIfMissing = options.returnNullIfMissing, returnResponse = options.returnResponse, returnResponseObject = options.returnResponseObject;
    }
    ref = this, data = ref.data, isSuccessful = ref.isSuccessful, isMissing = ref.isMissing;
    returnResponse || (returnResponse = returnResponseObject);
    if (isMissing && returnNullIfMissing) {
      data = null;
      isSuccessful = true;
    }
    if (isSuccessful) {
      return Promise.resolve(returnResponse ? this : data);
    } else {
      return Promise.reject(this._getRejectionError());
    }
  };

  Response.prototype._getRejectionError = function() {
    var ref, ref1, ref2, ref3;
    return this._preparedRejectionError || (this._preparedRejectionError = new RequestError({
      sourceLib: "ArtEry " + this.pipelineName,
      requestData: this.requestData,
      type: this.type,
      key: this.key,
      status: this.status,
      data: this.data,
      response: this,
      message: (ref = this.errorProps) != null ? (ref1 = ref.exception) != null ? ref1.message : void 0 : void 0,
      stack: (ref2 = this.errorProps) != null ? (ref3 = ref2.exception) != null ? ref3.stack : void 0 : void 0
    }));
  };


  /*
  EFFECT:
    If we create the RequestError when the error-response is created
    we are much more likely to capture the correct stack-trace for the
    events that lead to the error.
  
  TODO: We may only want to do this when artPromiseDebug=true or dev=true
   */

  Response.prototype._captureErrorStack = function() {
    return this._getRejectionError();
  };

  return Response;

})(__webpack_require__(82));


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, EventedMixin, JsonStore, Promise, Session, Validator, config, eq, formattedInspect, inspect, interval, isBrowser, isObject, isPlainObject, isString, jsonStore, log, merge, plainObjectsDeepEq, ref, toMilliseconds,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventedMixin = __webpack_require__(14).EventedMixin;

config = __webpack_require__(27).config;

ref = __webpack_require__(1), isPlainObject = ref.isPlainObject, Promise = ref.Promise, BaseObject = ref.BaseObject, merge = ref.merge, inspect = ref.inspect, isString = ref.isString, isObject = ref.isObject, log = ref.log, plainObjectsDeepEq = ref.plainObjectsDeepEq, isBrowser = ref.isBrowser, interval = ref.interval, eq = ref.eq, formattedInspect = ref.formattedInspect, toMilliseconds = ref.toMilliseconds;

Validator = __webpack_require__(33).Validator;

JsonStore = __webpack_require__(2).JsonStore;

jsonStore = JsonStore.jsonStore;


/*
TODO:
  rename to SessionManager
  Art.Ery.session should be the raw session data
  Art.Ery.sessionManager should be this singleton
  NOTE: don't break the jsonStore name, though - keep it 'session'
  NOTE: this will break things which expect Art.Ery.session.data to be the session data

  rename: "data" should become "session"

  Pipeline.session
    should be split into: session (raw data) and sessionManager
    However, maybe we should ONLY have the 'session' getter,
    which returns raw-data.
    If you need custom sessions on a per-pipline basis, use
    inheritance... I like! it's simpler!
 */

module.exports = Session = (function(superClass) {

  /*
  A global singleton Session is provided and used by default.
  Or multiple instances can be created and passed to the
  constructor of each Pipeline for per-pipeline custom sessions.
   */
  extend(Session, superClass);

  Session.singletonClass();

  function Session(_data, _jsonStoreKey) {
    this._data = _data != null ? _data : {};
    this._jsonStoreKey = _jsonStoreKey;
    if (isBrowser) {
      this._startPollingSession();
    }
  }

  Session.prototype._startPollingSession = function() {
    return interval(5000, (function(_this) {
      return function() {
        return _this.reloadSession();
      };
    })(this));
  };

  Session.prototype.reloadSession = function() {
    this._sessionLoadPromise = null;
    return this.loadSession();
  };

  Session.prototype.loadSession = function() {
    return this._sessionLoadPromise != null ? this._sessionLoadPromise : this._sessionLoadPromise = Promise.then((function(_this) {
      return function() {
        return jsonStore.getItem(_this.jsonStoreKey);
      };
    })(this)).then((function(_this) {
      return function(data) {
        if (!eq(data, _this.data)) {
          return _this.data = data;
        }
      };
    })(this));
  };

  Session.getter("sessionLoadPromise data updatedAt", {
    jsonStoreKey: function() {
      var ref1;
      return (ref1 = this._jsonStoreKey) != null ? ref1 : "Art.Ery.Session";
    },
    loadedDataPromise: function() {
      if (config.location === "server") {
        throw new Error("INTERNAL ERROR: Attempted to access the global session serverside. HINT: Use 'session: {}' for no-session requests.");
      }
      return this.loadSession().then((function(_this) {
        return function() {
          return _this.data;
        };
      })(this));
    },
    sessionSignature: function() {
      var ref1;
      return (ref1 = this._data) != null ? ref1.signature : void 0;
    },
    inspectedObjects: function() {
      return this._data;
    }
  });

  Session.setter({
    data: function(data) {
      this._updatedAt = toMilliseconds();
      if (isPlainObject(data) && !plainObjectsDeepEq(data, this._data)) {
        this.queueEvent("change", {
          data: data
        });
        return jsonStore.setItem(this.jsonStoreKey, this._data = data);
      }
    }
  });

  Session.prototype.reset = function() {
    return this.data = {};
  };

  if (isBrowser) {
    Session.singleton.loadSession();
  }

  return Session;

})(EventedMixin(__webpack_require__(79)));


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, Event, currentSecond, emptyProps,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

currentSecond = __webpack_require__(1).currentSecond;

BaseClass = __webpack_require__(6).BaseClass;

emptyProps = {};

module.exports = Event = (function(superClass) {
  extend(Event, superClass);

  function Event(type, props, timeStamp) {
    this.type = type;
    this.props = props != null ? props : emptyProps;
    this.timeStamp = timeStamp != null ? timeStamp : currentSecond();
  }

  return Event;

})(BaseClass);


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var EpochClass, FluxEntry, FluxStore, GlobalEpochCycle, ModelRegistry, ReschedulableTimer, Unique, clone, consistentJsonStringify, currentSecond, defineModule, failure, globalCount, inspect, isFunction, isString, log, max, merge, min, missing, object, pending, pushIfNotPresent, ref, ref1, ref2, ref3, removeFirstMatch, success, time, toSeconds,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), merge = ref.merge, removeFirstMatch = ref.removeFirstMatch, pushIfNotPresent = ref.pushIfNotPresent, removeFirstMatch = ref.removeFirstMatch, log = ref.log, isFunction = ref.isFunction, Unique = ref.Unique, clone = ref.clone, consistentJsonStringify = ref.consistentJsonStringify, isString = ref.isString, globalCount = ref.globalCount, time = ref.time, inspect = ref.inspect, object = ref.object, defineModule = ref.defineModule, currentSecond = ref.currentSecond, min = ref.min, max = ref.max, toSeconds = ref.toSeconds, ReschedulableTimer = ref.ReschedulableTimer;

ref1 = __webpack_require__(19), success = ref1.success, pending = ref1.pending, missing = ref1.missing, failure = ref1.failure;

EpochClass = __webpack_require__(127).EpochClass;

FluxEntry = __webpack_require__(263);

ModelRegistry = __webpack_require__(83);

defineModule(module, FluxStore = (function(superClass) {
  extend(FluxStore, superClass);

  FluxStore.singletonClass();

  function FluxStore() {
    FluxStore.__super__.constructor.apply(this, arguments);
    this._reset();
  }

  FluxStore.getter("length");

  FluxStore.prototype.get = function(modelName, key) {
    var ref2;
    return (ref2 = this._getEntry(modelName, key)) != null ? ref2.fluxRecord : void 0;
  };

  FluxStore.prototype.getSubscribers = function(modelName, key) {
    var ref2;
    return (ref2 = this._getEntry(modelName, key)) != null ? ref2.subscribers : void 0;
  };

  FluxStore.prototype.getHasSubscribers = function(modelName, key) {
    var ref2;
    return !!((ref2 = this._getEntry(modelName, key)) != null ? ref2.getHasSubscribers() : void 0);
  };

  FluxStore.prototype.getEntriesForModel = function(modelName) {
    return this._entriesByModelName[modelName];
  };


  /*
  subscribe to all changes to the fluxStore FluxEntry identified by modelName and Key.
  
  subscribers:
    are notified on all changes to the entry's:
      @fluxRecord object
      @subscribers list
    are NOT explicitly notified of when the entry is first added or removed
      However, when an entry is added, subscribers will be notified that a change happened.
      When an entry is removed, subscribers will be again notified, and the "subscribers" param will be [].
    See subscribeToStore for notifications about entries being added or removed
  
  inputs:
    modelName: string
    key: string
  
    subscriber: (fluxRecord, previousFluxRecord) -> null
      IN:
        fluxRecord: plain object; the current value for the fluxRecord
        previousFluxRecord: plain object; the last value for the fluxRecord
      GUARANTEES:
        1. !propsEq fluxRecord, previousFluxRecord
        2. only called once per change
  
    initialFluxRecord: if set, and the key is not in the store, this is used
      as the initial value instead of the calling "load" on the model.
  
  side effects:
    vivifies a new entry with fluxRecord = {status: pending} if one isn't present
    calls ModelRegistry[modelName].load key if vivification occured
    Notifies all subscribers.
  
  returns: current fluxRecord for the entry
   */

  FluxStore.prototype.subscribe = function(modelName, key, subscriber, initialFluxRecord) {
    this._queueChange({
      modelName: modelName,
      key: key,
      addSubscriber: subscriber
    });
    return this._vivifyAndLoadEntry(modelName, key, initialFluxRecord).fluxRecord;
  };


  /*
  inputs:
    modelName: string
    key: string
    subscriber: the exact same function (including closure) used to subscribe
  
  side effects:
    Notifies all subscribers.
  
  returns: null
   */

  FluxStore.prototype.unsubscribe = function(modelName, key, subscriber) {
    return this._queueChange({
      modelName: modelName,
      key: key,
      removeSubscriber: subscriber
    });
  };


  /*
  put updates or creates the record
  updateFunctionOrNewFluxRecord: can be:
    1) an arbitrary function: (oldRecord) -> newRecord
      oldRecord will be null/undefined only if the record has not been created.
      do not alter oldRecord
      must return a new Object or null/undefined (in which case an empty Object is created)
    2) a new Object to replace the existing object
  
  Notifies all subscribers.
  returns: updateFunctionOrNewFluxRecord
   */

  FluxStore.prototype.update = function(modelName, key, updateFunctionOrNewFluxRecord) {
    if (!isString(key)) {
      throw new Error("key must be a string. got: " + (inspect(key)));
    }
    this._queueChange({
      modelName: modelName,
      key: key,
      updateFunction: isFunction(updateFunctionOrNewFluxRecord) ? updateFunctionOrNewFluxRecord : function(oldRecord) {
        return updateFunctionOrNewFluxRecord;
      }
    });
    return updateFunctionOrNewFluxRecord;
  };

  FluxStore.getter({
    status: function() {
      var entries, entry, entryCount, entrySubscribers, key, model, modelCount, nextReload, now, ref2, reloadsPending;
      entrySubscribers = 0;
      modelCount = 0;
      entryCount = 0;
      reloadsPending = 0;
      nextReload = 2e308;
      now = toSeconds();
      ref2 = this._entriesByModelName;
      for (model in ref2) {
        entries = ref2[model];
        modelCount++;
        for (key in entries) {
          entry = entries[key];
          entryCount++;
          entrySubscribers += entry.subscriberCount;
          if (entry.reloadAt > now) {
            reloadsPending++;
            nextReload = Math.ceil(min(nextReload, entry.reloadAt - now));
          }
        }
      }
      return {
        entryCount: entryCount,
        entrySubscribers: entrySubscribers,
        modelCount: modelCount,
        reloadsPending: reloadsPending,
        nextReload: nextReload
      };
    }
  });

  FluxStore.prototype.getEntriesByStatus = function(status) {
    var entry, entryMap, filteredEntries, key, modelName, out, ref2;
    out = {};
    ref2 = this._entriesByModelName;
    for (modelName in ref2) {
      entryMap = ref2[modelName];
      filteredEntries = (function() {
        var results;
        results = [];
        for (key in entryMap) {
          entry = entryMap[key];
          if (entry.status === status) {
            results.push(entry);
          }
        }
        return results;
      })();
      if (filteredEntries.length > 0) {
        out[modelName] = filteredEntries;
      }
    }
    return out;
  };

  FluxStore.prototype._reset = function() {
    this._length = 0;
    this._entriesByModelName = {};
    return this._addedEntries = [];
  };

  FluxStore.prototype._getEntriesForModelName = function(modelName) {
    var base;
    return (base = this._entriesByModelName)[modelName] || (base[modelName] = {});
  };

  FluxStore.prototype._getEntry = function(modelName, key) {
    if (!isString(modelName)) {
      throw new Error("Expected 'modelName' to be a String. Got: " + (inspect(modelName)));
    }
    if (!isString(key)) {
      throw new Error("Expected 'key' to be a String. Got: " + (inspect(key)));
    }
    return this._getEntriesForModelName(modelName)[key];
  };

  FluxStore.prototype._addEntry = function(modelName, key) {
    var entry;
    this._length++;
    entry = this._getEntriesForModelName(modelName)[key] = new FluxEntry(modelName, key);
    pushIfNotPresent(this._addedEntries, entry);
    return entry;
  };

  FluxStore.prototype._removeEntry = function(entry) {
    this._length--;
    return delete this._getEntriesForModelName(entry.fluxRecord.modelName)[entry.fluxRecord.key];
  };


  /*
  Returns existing entry if there is one, otherwise it vivifies a "defaultFluxRecord" and starts the model.load.
  
  _vivifyAndLoadEntry solves the problem of two or more subscriptions starting in the same epoch
  on a new entry. Without this, we'd try to call "load" on the same model+key more than once.
  Ex: if we are loading remote images, loading the same remote image multiple times is a huge waste.
  
  returns: entry
   */

  FluxStore.prototype._vivifyAndLoadEntry = function(modelName, key, initialFluxRecord) {
    var data, entry, ref2, ref3;
    entry = this._getEntry(modelName, key);
    if (!entry) {
      entry = this._addEntry(modelName, key);
      if (!initialFluxRecord) {
        if (data = (ref2 = global.artFluxInit) != null ? (ref3 = ref2[modelName]) != null ? ref3[key] : void 0 : void 0) {
          initialFluxRecord = {
            status: success,
            data: data
          };
        }
      }
      if (initialFluxRecord) {
        entry.setFluxRecord(initialFluxRecord);
      } else {
        this._loadKeyWithRetriesWithExponentalFalloff(modelName, key, entry);
      }
    }
    return entry;
  };

  FluxStore.prototype._loadKeyWithRetriesWithExponentalFalloff = function(modelName, key, entry) {
    var e, fluxRecord, loadRetryCallback, message, model, retryDelay;
    retryDelay = 250;
    if (model = ModelRegistry.models[modelName]) {
      loadRetryCallback = (function(_this) {
        return function(loadInfo) {
          if (loadInfo.status !== pending && loadInfo.status !== success && loadInfo.status !== missing) {
            if (_this._getEntry(modelName, key)) {
              if (retryDelay < 60 * 1000) {
                retryDelay *= 2;
              }
              return console.warn("FluxStore retry is disabled");
            } else {
              return log({
                FluxStore_get_retry: {
                  model: modelName,
                  key: key,
                  status: loadInfo.status,
                  aborting: "no longer have subscribers"
                }
              });
            }
          }
        };
      })(this);
      try {
        if (fluxRecord = model.load(key, loadRetryCallback)) {
          return entry.setFluxRecord(fluxRecord);
        }
      } catch (error) {
        e = error;
        message = "Error loading record from model '" + modelName + "' for key '" + key + "'. Error: " + e;
        console.error(message, e.stack);
        return entry.setFluxRecord({
          status: failure,
          errorObject: e,
          message: message
        });
      }
    } else {
      return console.warn("ArtFlux: there is no model registered with the name: " + modelName + ". FluxEntry for " + modelName + ":" + key + " will forever be status: pending.");
    }
  };

  FluxStore.prototype._vivifyEntry = function(modelName, key) {
    return this._getEntry(modelName, key) || this._addEntry(modelName, key);
  };

  FluxStore.prototype._queueChange = function(change) {
    var key, modelName;
    modelName = change.modelName, key = change.key;
    if (!isString(modelName)) {
      throw new Error("Expected 'modelName' to be a String. Got: " + (inspect(modelName)));
    }
    if (!isString(key)) {
      throw new Error("Expected 'key' to be a String. Got: " + (inspect(key)));
    }
    this.queueItem(change);
    return null;
  };

  FluxStore.prototype.processEpochItems = function(changes) {
    var addSubscriber, entry, i, j, k, key, l, len, len1, len2, len3, modelName, models, ref2, ref3, ref4, ref5, ref6, removeEntry, removeSubscriber, removedEntries, updateFunction, updatedEntries;
    updatedEntries = [];
    removedEntries = [];
    for (i = 0, len = changes.length; i < len; i++) {
      ref2 = changes[i], modelName = ref2.modelName, key = ref2.key, removeEntry = ref2.removeEntry, addSubscriber = ref2.addSubscriber, removeSubscriber = ref2.removeSubscriber, updateFunction = ref2.updateFunction;
      entry = this._vivifyEntry(modelName, key);
      if (updateFunction) {
        entry._updateFluxRecord(updateFunction);
      } else if (addSubscriber) {
        entry._subscribe(addSubscriber);
      } else if (removeSubscriber) {
        entry._unsubscribe(removeSubscriber);
      }
      pushIfNotPresent(updatedEntries, entry);
    }
    models = ModelRegistry.models;
    for (j = 0, len1 = updatedEntries.length; j < len1; j++) {
      entry = updatedEntries[j];
      if ((ref3 = models[entry.getModelName()]) != null) {
        ref3.fluxStoreEntryUpdated(entry);
      }
      entry._notifySubscribers();
      if (entry.subscribers.length === 0) {
        pushIfNotPresent(removedEntries, entry);
        this._removeEntry(entry);
      }
    }
    ref4 = this._addedEntries;
    for (k = 0, len2 = ref4.length; k < len2; k++) {
      entry = ref4[k];
      if ((ref5 = models[entry.getModelName()]) != null) {
        ref5.fluxStoreEntryAdded(entry);
      }
    }
    for (l = 0, len3 = removedEntries.length; l < len3; l++) {
      entry = removedEntries[l];
      if ((ref6 = models[entry.getModelName()]) != null) {
        ref6.fluxStoreEntryRemoved(entry);
      }
    }
    this._addedEntries = [];
    return null;
  };

  return FluxStore;

})(EpochClass));

if (GlobalEpochCycle = (ref2 = Neptune.Art.Engine) != null ? (ref3 = ref2.Core) != null ? ref3.GlobalEpochCycle : void 0 : void 0) {
  GlobalEpochCycle.singleton.includeFlux(FluxStore.singleton);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(489);


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtEngineCore, BaseObject, Foundation, GlobalEpochCycle, HotLoader, InstanceFunctionBindingMixin, PropFieldsMixin, React, ReactArtEngineEpoch, StateEpoch, StateFieldsMixin, VirtualNode, arrayWithout, clone, compactFlatten, countStep, createObjectTreeFactory, createWithPostCreate, defineModule, fastBind, formattedInspect, getModuleBeingDefined, globalCount, globalEpochCycle, inspect, isArray, isFunction, isObject, isString, keepIfRubyTrue, log, merge, mergeInto, onNextStateEpochReady, reactArtEngineEpoch, runHot, select, shallowClone, slice, stackTime, stateEpoch, time, timePerformance, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

VirtualNode = __webpack_require__(139);

ReactArtEngineEpoch = __webpack_require__(88);

defineModule = Foundation.defineModule, log = Foundation.log, merge = Foundation.merge, mergeInto = Foundation.mergeInto, clone = Foundation.clone, shallowClone = Foundation.shallowClone, inspect = Foundation.inspect, compactFlatten = Foundation.compactFlatten, keepIfRubyTrue = Foundation.keepIfRubyTrue, BaseObject = Foundation.BaseObject, fastBind = Foundation.fastBind, slice = Foundation.slice, isObject = Foundation.isObject, isString = Foundation.isString, isArray = Foundation.isArray, isFunction = Foundation.isFunction, globalCount = Foundation.globalCount, time = Foundation.time, stackTime = Foundation.stackTime, countStep = Foundation.countStep, createWithPostCreate = Foundation.createWithPostCreate, arrayWithout = Foundation.arrayWithout, upperCamelCase = Foundation.upperCamelCase, createObjectTreeFactory = Foundation.createObjectTreeFactory, select = Foundation.select, formattedInspect = Foundation.formattedInspect, getModuleBeingDefined = Foundation.getModuleBeingDefined, InstanceFunctionBindingMixin = Foundation.InstanceFunctionBindingMixin;

reactArtEngineEpoch = ReactArtEngineEpoch.reactArtEngineEpoch;

React = __webpack_require__(141);

HotLoader = __webpack_require__(467).HotLoader;

runHot = HotLoader.runHot;

StateFieldsMixin = __webpack_require__(138);

PropFieldsMixin = __webpack_require__(286);

if (ArtEngineCore = Neptune.Art.Engine.Core) {
  StateEpoch = ArtEngineCore.StateEpoch, GlobalEpochCycle = ArtEngineCore.GlobalEpochCycle;
  stateEpoch = StateEpoch.stateEpoch;
  globalEpochCycle = GlobalEpochCycle.globalEpochCycle;
  onNextStateEpochReady = function(f) {
    return stateEpoch.onNextReady(f);
  };
  timePerformance = function(name, f) {
    return globalEpochCycle.timePerformance(name, f);
  };
} else {
  onNextStateEpochReady = function(f) {
    return reactArtEngineEpoch.onNextReady(f);
  };
  timePerformance = function(name, f) {
    return f();
  };
}


/*
React.js vs ReactArtEngine
--------------------------

Generaly, ReactArtEngine is designed to work just like React.js. There is
some evolution, though, which I try to note below. -SBD

ReactArtEngine: "Instantiation"
-------------------------------

This is not a concept in React.js. It isn't important to the client, but it
is useful to understand in the implementation.

In-short: a non-instantiated component only has properties. It doesn't have
state and it isn't rendered. An instantiated component has state and gets
rendered at least once.

When a component is used in a render function, and with every re-render,
an instance-object is created with standard javascript "new ComponentType."
However, that component instance is only a shell - it contains the
properties passed into the constructor and nothing else.

Once the entire render is done, the result is diffed against the current
Virtual-AIM. The component instance is compared against existing components
via the diff rules. If an existing, matching component exists, that
component is updated and the new instance is discard. However, if an
existing match doesn't exist, then the new component instance is
"instantiated" and added to the virtual-Aim.

QUESTIONS
---------

I just discovered it is possible, and useful, for a component to be rendered
after it is unmounted. I don't think this is consistent with Facebook-React.

Possible: if @setState is called after it is unmounted, it will trigger a
render. This can happen in FluxComponents when a subscription updates.

Useful: Why does this even make sense? Well, with Art.Engine we have
removedAnimations. That means the element still exists even though it has been
"removed." It exists until the animation completes. It is therefor useful to
continue to receive updates from React, where appropriate, during that "sunset"
time.

Thoughts: I think this is OK, though this changes what "unmounted" means. I just
fixed a bug where @state got altered without going through preprocessState first
when state changes after the component was unmounted. How should I TEST this???
 */

defineModule(module, function() {
  var Component;
  return Component = (function(superClass) {
    var defaultComponentDidMount, defaultComponentDidUpdate, defaultComponentWillMount, defaultComponentWillReceiveProps, defaultComponentWillUnmount, defaultComponentWillUpdate, defaultPreprocessProps, defaultPreprocessState, emptyArray, emptyProps, emptyState, getModule, unknownModule;

    extend(Component, superClass);

    Component.abstractClass();

    Component.nonBindingFunctions = "getInitialState componentWillReceiveProps componentWillMount componentWillUnmount componentWillUpdate componentDidMount componentDidUpdate render".split(/\s+/);

    Component.created = 0;

    Component.topComponentInstances = [];

    Component.rerenderAll = function() {
      var component, j, len, ref, results;
      ref = this.topComponentInstances;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        component = ref[j];
        results.push(component.rerenderAll());
      }
      return results;
    };

    Component.prototype.rerenderAll = function() {
      var component, j, len, ref, results;
      this._queueRerender();
      ref = this.subComponents;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        component = ref[j];
        results.push(component.rerenderAll());
      }
      return results;
    };

    Component.createAndInstantiateTopComponent = function(spec) {
      return Component.createComponentFactory(spec).instantiateAsTopComponent();
    };

    unknownModule = {};

    Component.createComponentFactory = function(spec, BaseClass) {
      var AnonymousComponent, _module, anonymousComponentName, componentClass;
      if (BaseClass == null) {
        BaseClass = Component;
      }
      componentClass = (function() {
        if ((spec != null ? spec.prototype : void 0) instanceof Component) {
          return spec;
        } else if ((spec != null ? spec.constructor : void 0) === Object) {
          _module = getModule(spec) || unknownModule;
          _module.uniqueComponentNameId || (_module.uniqueComponentNameId = 1);
          anonymousComponentName = "Anonymous" + (BaseClass.getClassName());
          anonymousComponentName += "_" + (_module.uniqueComponentNameId++);
          anonymousComponentName += _module.id ? "_Module" + _module.id : '_ModuleUnknown';
          return AnonymousComponent = (function(superClass1) {
            var k, v;

            extend(AnonymousComponent, superClass1);

            function AnonymousComponent() {
              return AnonymousComponent.__super__.constructor.apply(this, arguments);
            }

            AnonymousComponent._name = anonymousComponentName;

            for (k in spec) {
              v = spec[k];
              AnonymousComponent.prototype[k] = v;
            }

            return AnonymousComponent;

          })(BaseClass);
        } else {
          throw new Error("Specification Object or class inheriting from Component required.");
        }
      }).call(this);
      return createWithPostCreate(componentClass);
    };

    Component.getModule = getModule = function(spec) {
      if (spec == null) {
        spec = this.prototype;
      }
      return spec.module || spec.hotModule || getModuleBeingDefined();
    };

    Component.getCanHotReload = function() {
      var ref;
      return (ref = this.getModule()) != null ? ref.hot : void 0;
    };

    Component._hotReloadUpdate = function(_moduleState) {
      var hotInstances, instance, j, len, name, results;
      this._moduleState = _moduleState;
      name = this.getClassName();
      if (hotInstances = this._moduleState.hotInstances) {
        log({
          HotReload: {
            Component: this,
            instanceCount: hotInstances.length,
            forEachInstance: "instance.componentDidHotReload()"
          }
        });
        results = [];
        for (j = 0, len = hotInstances.length; j < len; j++) {
          instance = hotInstances[j];
          results.push(instance._componentDidHotReload());
        }
        return results;
      }
    };

    Component.allComponents = {};

    Component.postCreateConcreteClass = function(arg) {
      var classModuleState, hotReloadEnabled;
      classModuleState = arg.classModuleState, hotReloadEnabled = arg.hotReloadEnabled;
      Component.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
      if (hotReloadEnabled) {
        this._hotReloadUpdate(classModuleState);
      }
      return this.toComponentFactory();
    };

    Component.toComponentFactory = function() {
      return createObjectTreeFactory(merge(React.objectTreeFactoryOptions, {
        inspectedName: this.getName() + "ComponentFactory",
        "class": this,
        bind: "instantiateAsTopComponent"
      }), (function(_this) {
        return function(props, children) {
          var instance;
          if (children.length > 0) {
            props.children = children;
          }
          instance = new _this(props);
          return instance;
        };
      })(this));
    };

    Component.instantiateAsTopComponent = function(props, options) {
      return new this(props).instantiateAsTopComponent(options);
    };

    Component.createdComponents = null;

    Component.pushCreatedComponent = function(c) {
      this.createdComponents || (this.createdComponents = []);
      return this.createdComponents.push(c);
    };

    Component.resetCreatedComponents = function() {
      return this.createdComponents = null;
    };

    emptyProps = {};

    function Component(props) {
      if (props == null) {
        props = emptyProps;
      }
      Component.created++;
      globalCount("ReactComponent_Created");
      Component.__super__.constructor.call(this, props);
      this.state = {};
      this.refs = null;
      this._pendingState = null;
      this._virtualAimBranch = null;
      this._mounted = false;
      this._wasMounted = false;
      this._bindList = null;
      this._applyingPendingState = false;
      Component.pushCreatedComponent(this);
    }


    /*
    SEE: VirtualElement#withElement for more
    IN: f = (concreteElement) -> x
    OUT: promise.then (x) ->
     */

    Component.prototype.withElement = function(f) {
      return this._virtualAimBranch.withElement(f);
    };

    Component.prototype.instantiateAsTopComponent = function(bindToOrCreateNewParentElementProps) {
      Component.topComponentInstances.push(this);
      return this._instantiate(null, bindToOrCreateNewParentElementProps);
    };

    Component.prototype.unbindTopComponent = function() {
      var index;
      if (!(0 <= (index = Component.topComponentInstances.indexOf(this)))) {
        throw new Error("not a top component!");
      }
      Component.topComponentInstances = arrayWithout(Component.topComponentInstances, index);
      return this._unmount();
    };

    Component.getter({
      inspectedName: function() {
        return "" + this.className + (this.key ? "-" + this.key : '');
      },
      mounted: function() {
        return this._mounted;
      }
    });

    Component.prototype.onNextReady = function(callback, forceEpoch) {
      if (forceEpoch == null) {
        forceEpoch = true;
      }
      return onNextStateEpochReady(callback, forceEpoch, this);
    };

    Component.prototype.setState = function(newState, callback, callbackB) {
      var _state, k, testState, v;
      if (isString(newState)) {
        return this._setSingleState(newState, callback, callbackB);
      }
      this.onNextReady(callback);
      if (newState) {
        testState = this._pendingState || this.state;
        _state = null;
        for (k in newState) {
          v = newState[k];
          if (!(testState[k] !== v)) {
            continue;
          }
          _state || (_state = this._getStateToSet());
          _state[k] = v;
        }
      }
      return newState;
    };

    Component.prototype.replaceState = function(newState, callback) {
      this._setPendingState(newState);
      return this.onNextReady(callback);
    };

    Component.prototype.forceUpdate = function(callback) {
      this._getPendingState();
      return this.onNextReady(callback);
    };

    Component.prototype.getInitialState = function() {
      return {};
    };


    /*
    Called each time webpack hot-reloads a module.
    It is important that this change the components state to trigger a rerender.
    Make sure you add module: module to your component definition or
    run your definition in a runHot module, -> function
     */

    Component.prototype.componentDidHotReload = function() {
      var count;
      count = (this.state._hotModuleReloadCount || 0) + 1;
      return this.setState({
        _hotModuleReloadCount: count
      });
    };

    Component.prototype.componentWillReceiveProps = defaultComponentWillReceiveProps = function(newProps) {};

    Component.prototype.componentWillMount = defaultComponentWillMount = function() {};

    Component.prototype.componentWillUnmount = defaultComponentWillUnmount = function() {};

    Component.prototype.componentWillUpdate = defaultComponentWillUpdate = function(newProps, newState) {};

    Component.prototype.componentDidMount = defaultComponentDidMount = function() {};

    Component.prototype.componentDidUpdate = defaultComponentDidUpdate = function(oldProps, oldState) {};


    /*
    Function:     preprocessProps
    
    When:         Called on component instantiation and any time props are updated
    
    IN:           newProps - The props received from the render call which created/updated this component
    
    OUT:          plain Object - becomes @props. Can be newProps, based on newProps or entirely new.
    
    Guarantee:    @props will allways be passed through preprocessProps before it is set.
                  i.e. Your render code will never see a @props that hasen't been preprocessed.
    
    Be sure your preprocessProps: (requirements)
      - returns a plain Object
      - doesn't modify the newProps object passed in (create and return new object to add/alter props)
      - call super!
    
    Examples:
       * minimal
      preprocessProps: ->
        merge super, myProp: 123
    
       * a little of everything
      preprocessProps: ->
        newProps = super
        @setState foo: newProps.foo
        merge newProps, myProp: "dude: #{newProps.foo}"
    
    Okay:
      you can call @setState (Art.Flux.Component does exactly this!)
    
    Description:
      Either return exactly newProps which were passed in OR create a new, plain object.
      The returned object can contain anything you want.
      These are the props the component will see in any subsequent lifecycle calls.
    
    NOTE: Unique to Art.React. Not in Facebook's React.
    
    NOTES RE Facebook.React:
      Why add this? Well, often you want to apply a transformation to @props whenever its set OR it changes.
      With Facebook.React there is no one lifecycle place for this. Component instantiation/mounting
      and component updating are kept separate. I have found it is very error-prone to implement
      this common functionality manually on each component that needs it.
     */

    Component.prototype.preprocessProps = defaultPreprocessProps = function(newProps) {
      return newProps;
    };


    /*
    Function:     preprocessState
    
    When:         preprocessState is called:
                    immediatly after getInitialState
                    after preprocessProps
                    after componentWillUpdate
                    before rendering
    
    IN:           newState - the state which is proposed to become @state
    OUT:          object which will become @state. Can be newState, be based on newState or completely new.
    
    Guarantees:   @state will allways be passed through preprocessState before it is set.
                  i.e. Your render code will never see a @state that hasen't been preprocessed.
    
    NOTES RE Facebook.React:
      Why add this? Well, often you want to apply a transformation to @state whenever it is initialized
      OR it changes. With Facebook.React there is no one lifecycle place for this. Component
      instantiation/mounting and component updating are kept separate. I have found it is very
      error-prone to implement this common functionality manually on each component that needs it.
    
      An example of this is FluxComponents. They alter state implicitly as the subscription data comes in, and
      and component instantiation. preprocessState makes it easy to transform any data written via FluxComponents
      into a standard form.
    
    SBD NOTES TO SELF:
      I think:
        - it is OK to directly mutate newState, can we declare this offically part of the API?
        - calls to @setState in preprocessState will be applied NEXT epoch.
        - could make getInitialState obsolete, but I think we'll keep it around for convenience and consistency
     */

    Component.prototype.preprocessState = defaultPreprocessState = function(newState) {
      return newState;
    };

    Component.prototype.find = function(pattern, arg, matches, path) {
      var child, findAll, functionResult, j, len, matchFound, pathString, ref, ref1, usedFunction, verbose;
      ref = arg != null ? arg : {}, findAll = ref.findAll, verbose = ref.verbose;
      if (matches == null) {
        matches = [];
      }
      pathString = path ? path + "/" + this.inspectedName : this.inspectedName;
      matchFound = (usedFunction = isFunction(pattern)) ? !!(functionResult = pattern(this)) : pathString.match(pattern);
      if (matchFound) {
        if (verbose) {
          this.log(usedFunction ? {
            matched: pathString,
            functionResult: functionResult
          } : {
            matched: pathString
          });
        }
        matches.push(this);
      } else if (verbose === "all") {
        this.log(usedFunction ? {
          notMatched: pathString,
          functionResult: functionResult
        } : {
          notMatched: pathString
        });
      }
      if ((!matchFound || findAll) && this.subComponents) {
        ref1 = this.subComponents;
        for (j = 0, len = ref1.length; j < len; j++) {
          child = ref1[j];
          child.find(pattern, arguments[1], matches);
        }
      }
      return matches;
    };

    Component.getter({
      inspectedObjects: function() {
        var obj, ref, ref1, ref2, ref3;
        return (
          obj = {},
          obj["Component-" + this.inspectedName + " " + ((ref2 = (ref3 = this._virtualAimBranch) != null ? ref3.inspectedName : void 0) != null ? ref2 : '(not instantiated)')] = (ref = (ref1 = this._virtualAimBranch) != null ? ref1.inspectedObjectsContents : void 0) != null ? ref : {
            props: this.props
          },
          obj
        );
      }
    });

    Component.prototype.getPendingState = function() {
      return this._pendingState || this.state;
    };

    Component.prototype._getStateToSet = function() {
      if (this._wasMounted) {
        return this._getPendingState();
      } else {
        return this.state;
      }
    };

    Component.prototype._setSingleState = function(stateKey, stateValue, callback) {
      this.onNextReady(callback);
      if (this._pendingState || this.state[stateKey] !== stateValue) {
        this._getStateToSet()[stateKey] = stateValue;
      }
      return stateValue;
    };

    Component.prototype._queueRerender = function() {
      return this._getPendingState();
    };

    Component.prototype._setPendingState = function(state) {

      /*
      2016-12: I can't decide! Should we allow state updates on unmounted components or not?!?!
      RELVANCE: allowing state updates allows us to update animating-out Art.Engine Elements.
      This is useful, for example, to hide the TextInput Dom element
      
      I'm generally against updating unmounted components:
        - they don't get new props. Logically, since they are unmounted,
          they should have no props, yet they do. They would surely
          completely break if we set @props = {}.
      
        - Since they don't get new @props, there is no way for the parent-before-unmounting
          to control unmounted Components. If their state can change, their parent-before
          should have some control.
      
      BUT, we need a better answer for animating-out Components. There is a need for re-rendering them
      at the beginning and ending of their animating-out process.
      
      Animating-Out
        - Most things can probably be handled by 1 render just before animating-out starts. This
          is awkward to do manually: First render decides we are going to remove a sub-component, but
          doesn't - during that render - instead it tells that component it is about to be animated-out.
          Then, it queues another render where it actually removes the sub-component. And this must all
          be managed by the parent Component, when really it's 100% the child-component's concern.
      
        - What if a Component can request a "final render" just BEFORE it is unmounted? The parent Component's
          render runs, removing the child Component. Then ArtReact detects the child needs unmounting, but just
          before it unmounts it, the child gets a re-render as-if it's props changed, though they didn't. This
          in turn will update any Element or child Components for their animating-out state. After that,
          the component will get no more renders - since it will then be unmounted and unmounted components don't
          get rendered.
      
        - Further, when we do this final render, we can signal it is "final" via @props.
          - have the component get a final-render notification (via a member function override).
            That function takes as inputs the last-good @props, and returns the final-render @props.
            If it returns null, there will be no final render. This is the default implementation.
      
          - I LIKE!
      
        - Conclusion: New Component override: (TODO - I think we should go for this solution!)
      
            finalRenderProps: (previousProps) -> null
      
          To request a final-render, all you need to do is add this to your Component:
      
            finalRenderProps: (previousProps) -> previousProps
      
          And you may find it handy to also do:
      
            finalRenderProps: (previousProps) -> merge previousProps, finalRender: true
      
          Then you can do something special for your final-render:
      
            render: ->
              {finalRender} = @props
      
              if finalRender ...
      
      DO WE NEED SOMETHING MORE POWERFUL?
      
        - Do we need more than 1 "final render" - during animating-out?
        - Do we need an animating-out-done render?
        - A general solution would be a "manual unmount" option. I don't love this, but
          I also don't love tying this explicitly to ArtEngine's animating-out features.
      
      To ENABLE updates on unmounted Components, remove: || !@_mounted
       */
      if (!(this._pendingState || this._applyingPendingState || !this._mounted)) {
        reactArtEngineEpoch.addChangingComponent(this);
      }
      return this._pendingState = state ? shallowClone(state) : {};
    };

    Component.prototype._getPendingState = function() {
      return this._pendingState || this._setPendingState(this.state);
    };

    Component.prototype._unmount = function() {
      var ref;
      this._removeHotInstance();
      this._componentWillUnmount();
      if ((ref = this._virtualAimBranch) != null) {
        ref._unmount();
      }
      return this._mounted = false;
    };

    Component.prototype._addHotInstance = function() {
      var moduleState;
      if (moduleState = this["class"]._moduleState) {
        return (moduleState.hotInstances || (moduleState.hotInstances = [])).push(this);
      }
    };

    Component.prototype._removeHotInstance = function() {
      var hotInstances, index, moduleState;
      if (moduleState = this["class"]._moduleState) {
        hotInstances = moduleState.hotInstances;
        if (hotInstances && 0 <= (index = hotInstances.indexOf(this))) {
          return moduleState.hotInstances = arrayWithout(hotInstances, index);
        }
      }
    };

    emptyState = {};

    Component.prototype._instantiate = function(parentComponent, bindToOrCreateNewParentElementProps) {
      var __state, initialState;
      Component.__super__._instantiate.apply(this, arguments);
      globalCount("ReactComponent_Instantiated");
      this.bindFunctionsToInstance();
      this.props = this._preprocessProps(this.props);
      this._addHotInstance();
      this._componentWillMount();
      initialState = this.getInitialState();
      __state = this.state;
      this.state = emptyState;
      this.state = this._preprocessState(merge(this.getStateFields(), __state, initialState));
      this._virtualAimBranch = this._renderCaptureRefs();
      this._virtualAimBranch._instantiate(this, bindToOrCreateNewParentElementProps);
      this.element = this._virtualAimBranch.element;
      this._componentDidMount();
      this._wasMounted = this._mounted = true;
      return this;
    };

    emptyArray = [];

    Component.prototype._renderCaptureRefs = function() {
      var ret, start;
      start = globalEpochCycle != null ? globalEpochCycle.startTimePerformance() : void 0;
      ret = null;
      globalCount("ReactComponent_Rendered");
      VirtualNode.assignRefsTo = this.refs = {};
      Component.resetCreatedComponents();
      ret = this.render();
      if (!(ret instanceof VirtualNode)) {
        throw new Error(this.className + ": render must return a VirtualNode. Got: " + (inspect(ret)));
      }
      this.subComponents = Component.createdComponents || emptyArray;
      VirtualNode.assignRefsTo = null;
      if (globalEpochCycle != null) {
        globalEpochCycle.endTimePerformance("reactRender", start);
      }
      return ret;
    };

    Component.prototype._updateRefsAfterReRender = function() {
      var _updateTarget, c, i, j, k, len, ref, ref1, results, update, v;
      ref = this.refs;
      for (k in ref) {
        v = ref[k];
        if (_updateTarget = this.refs[k]._updateTarget) {
          this.refs[k] = _updateTarget;
        }
      }
      ref1 = this.subComponents;
      results = [];
      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
        c = ref1[i];
        if (update = c._updateTarget) {
          results.push(this.subComponents[i] = update);
        }
      }
      return results;
    };

    Component.prototype._canUpdateFrom = function(b) {
      return this["class"] === b["class"] && this.key === b.key;
    };

    Component.prototype._shouldReRenderComponent = function(componentInstance) {
      return this._propsChanged(componentInstance) || this._pendingState;
    };

    Component.prototype._reRenderComponent = function() {
      var newRenderResult, oldRefs, ref;
      oldRefs = this.refs;
      if (!(newRenderResult = this._renderCaptureRefs())) {
        log.error({
          ComponentRenderError: this
        });
        throw new Error("Component render function returned: " + (formattedInspect(newRenderResult)));
      }
      if (this._virtualAimBranch._canUpdateFrom(newRenderResult)) {
        this._virtualAimBranch._updateFrom(newRenderResult);
        this._updateRefsAfterReRender();
      } else {
        console.error("REACT-ART-ENGINE ERROR - The render function's top-level Component/VirtualElement changed 'too much.' The VirtualNode returned by a component's render function cannot change its Type or Key.\n\nSolution: Wrap your changing VirtualNode with a non-changing VirtualElement.\n\nOffending component: " + this.classPathName + "\nOffending component assigned to: self.offendingComponent");
        console.log("CHANGED-TOO-MUCH-ERROR-DETAILS - all these properties must be the same on the oldRoot and newRoot", {
          oldRoot: select(this._virtualAimBranch, "key", "elementClassName", "class"),
          newRoot: select(newRenderResult, "key", "elementClassName", "class")
        });
        self.offendingComponent = this;
        if ((ref = this._virtualAimBranch) != null) {
          ref._unmount();
        }
        (this._virtualAimBranch = newRenderResult)._instantiate(this);
      }
      return this.element = this._virtualAimBranch.element;
    };

    Component.prototype._updateFrom = function(componentInstance) {
      Component.__super__._updateFrom.apply(this, arguments);
      if (this._shouldReRenderComponent(componentInstance)) {
        globalCount("ReactComponent_UpdateFromTemporaryComponent_Changed");
        this._applyPendingState(componentInstance.props);
      } else {
        globalCount("ReactComponent_UpdateFromTemporaryComponent_NoChange");
      }
      return this;
    };

    Component.prototype._applyPendingState = function(newProps) {
      var newState, oldProps, oldState, ref, ref1;
      if (!(this._pendingState || newProps)) {
        return;
      }
      this._applyingPendingState = true;
      if (newProps) {
        newProps = this._preprocessProps(this._rawProps = newProps);
        this._componentWillReceiveProps(newProps);
      }
      oldProps = this.props;
      oldState = this.state;
      if (newProps == null) {
        newProps = oldProps;
      }
      newState = (ref = this._pendingState) != null ? ref : oldState;
      this._componentWillUpdate(newProps, newState);

      /*
      React.js forbids calling setState from componentWillUpdate, but I see no reason for this.
      This next line safely supports state updates in componentWillUpdate in a pure-functionalish way:
        after a setState in @componentWillUpdate,
        the new state will not be visible in the remainder of that @componetWillUpdate call
        but it will be visible in any subsquent lifecycle call such as @render
       */
      newState = (ref1 = this._pendingState) != null ? ref1 : oldState;
      this._pendingState = null;
      this.props = newProps;
      this.state = this._preprocessState(newState);
      this._applyingPendingState = false;
      this._reRenderComponent();
      return this._componentDidUpdate(oldProps, oldState);
    };

    Component.prototype._componentWillReceiveProps = function(newProps) {
      if (defaultComponentWillReceiveProps === this.componentWillReceiveProps) {
        return;
      }
      return this.componentWillReceiveProps(newProps);
    };

    Component.prototype._preprocessProps = function(props) {
      var error;
      props = Component.__super__._preprocessProps.call(this, props);
      if (defaultPreprocessProps === this.preprocessProps) {
        return props;
      }
      try {
        return this.preprocessProps(props);
      } catch (error1) {
        error = error1;
        log({
          preprocessProps: {
            Component: this,
            error: error
          }
        });
        return props;
      }
    };

    Component.prototype._preprocessState = function(state) {
      var error;
      if (defaultPreprocessState === this.preprocessState) {
        return state;
      }
      try {
        return this.preprocessState(state);
      } catch (error1) {
        error = error1;
        log({
          preprocessState: {
            Component: this,
            error: error
          }
        });
        return state;
      }
    };

    Component.prototype._componentWillMount = function() {
      if (defaultComponentWillMount === this.componentWillMount) {
        return;
      }
      return this.componentWillMount();
    };

    Component.prototype._componentDidHotReload = function() {
      this.bindFunctionsToInstance();
      try {
        return this.componentDidHotReload();
      } catch (error1) {}
    };

    Component.prototype._componentWillUnmount = function() {
      if (defaultComponentWillUnmount === this.componentWillUnmount) {
        return;
      }
      return this.componentWillUnmount();
    };

    Component.prototype._componentWillUpdate = function(newProps, newState) {
      if (!defaultComponentWillUpdate) {
        return;
      }
      return this.componentWillUpdate(newProps, newState);
    };

    Component.prototype._componentDidMount = function() {
      if (defaultComponentDidMount === this.componentDidMount) {
        return;
      }
      return this.onNextReady((function(_this) {
        return function() {
          return _this.componentDidMount();
        };
      })(this));
    };

    Component.prototype._componentDidUpdate = function(oldProps, oldState) {
      if (defaultComponentDidUpdate === this.componentDidUpdate) {
        return;
      }
      return this.onNextReady((function(_this) {
        return function() {
          return _this.componentDidUpdate(oldProps, oldState);
        };
      })(this));
    };

    return Component;

  })(PropFieldsMixin(StateFieldsMixin(InstanceFunctionBindingMixin(VirtualNode))));
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var defineModule, each, log, lowerCamelCase, mergeInto, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, mergeInto = ref.mergeInto, each = ref.each, lowerCamelCase = ref.lowerCamelCase;

defineModule(module, function() {
  return function(superClass) {
    var StateFieldsMixin;
    return StateFieldsMixin = (function(superClass1) {
      var sf;

      extend(StateFieldsMixin, superClass1);

      function StateFieldsMixin() {
        return StateFieldsMixin.__super__.constructor.apply(this, arguments);
      }

      StateFieldsMixin.extendableProperty({
        stateFields: {}

        /*
        Declare state fields you intend to use.
        IN: fields
          map from field names to initial values
        
        EFFECTS:
          used to initialize @state
          declares @getters and @setters for each field
          for fieldName, declares:
            @getter :fieldName
            @setter :fieldName
            clearFieldName: ->
        
            if initial value is true or false:
            toggleFieldName: -> @fieldName = !@fieldName
         */
      });

      StateFieldsMixin.stateFields = sf = function(fields) {
        this.extendStateFields(fields);
        return each(fields, (function(_this) {
          return function(initialValue, field) {
            var clearValue, defaultSetValue;
            defaultSetValue = initialValue;
            clearValue = null;
            _this.addSetter(field, function(v) {
              return this.setState(field, v === void 0 ? defaultSetValue : v);
            });
            _this.addGetter(field, function() {
              return this.state[field];
            });
            if (initialValue === true || initialValue === false) {
              clearValue = false;
              defaultSetValue = true;
              _this.prototype[lowerCamelCase("set is " + field)] = function() {
                return this.setState(field, true);
              };
              _this.prototype[lowerCamelCase("trigger " + field)] = function() {
                return this.setState(field, true);
              };
              _this.prototype[lowerCamelCase("toggle " + field)] = function() {
                return this.setState(field, !this.state[field]);
              };
            }
            return _this.prototype[lowerCamelCase("clear " + field)] = function() {
              return this.setState(field, clearValue);
            };
          };
        })(this));
      };

      StateFieldsMixin.stateField = sf;

      return StateFieldsMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, Foundation, ReactArtEngineEpoch, VirtualNode, compact, deepEach, defineModule, emptyObject, flatten, globalCount, inspect, isObject, isPlainObject, keepIfRubyTrue, log, objectKeyCount, propsEq, reactArtEngineEpoch, shallowClone,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

Foundation = __webpack_require__(2);

ReactArtEngineEpoch = __webpack_require__(88);

log = Foundation.log, compact = Foundation.compact, globalCount = Foundation.globalCount, flatten = Foundation.flatten, BaseObject = Foundation.BaseObject, shallowClone = Foundation.shallowClone, inspect = Foundation.inspect, objectKeyCount = Foundation.objectKeyCount, isObject = Foundation.isObject, deepEach = Foundation.deepEach, isPlainObject = Foundation.isPlainObject, keepIfRubyTrue = Foundation.keepIfRubyTrue, propsEq = Foundation.propsEq, defineModule = Foundation.defineModule;

reactArtEngineEpoch = ReactArtEngineEpoch.reactArtEngineEpoch;

emptyObject = {};

defineModule(module, VirtualNode = (function(superClass) {
  extend(VirtualNode, superClass);

  VirtualNode.prototype.onNextReady = function(f, forceEpoch) {
    if (forceEpoch == null) {
      forceEpoch = true;
    }
    return reactArtEngineEpoch.onNextReady(f, forceEpoch, this);
  };

  VirtualNode.assignRefsTo = null;

  function VirtualNode(props) {
    if (props == null) {
      props = emptyObject;
    }
    this._updateTarget = null;
    this._parentComponent = null;
    this.key = props.key;
    this.props = this._rawProps = props;
    this._propsLength = -1;
    this.element = null;
    VirtualNode._assignRefs(this);
  }

  VirtualNode.getter("rawProps", {
    propsLength: function() {
      if (this._propsLength >= 0) {
        return this._propsLength;
      } else {
        return this._propsLength = objectKeyCount(this.props);
      }
    }
  });

  VirtualNode.setter({
    propsLength: function(v) {
      return this._propsLength = v;
    }
  });


  /*
  Evaluate "f" in the thread the Element exists in.
  
  IN: (element) -> plainObjects
  OUT: promise returning function's plain-object-result
  
   * TODO: add worker support
   */

  VirtualNode.prototype.withElement = function(f) {
    return new Promise((function(_this) {
      return function(resolve) {
        return resolve(f(_this.element));
      };
    })(this));
  };


  /*
  Lighter-weight than "withElement"
  
  IN:
    method: string
    args: 0 or more additional arguments
  OUT: promise returning function's plain-object-result
  
  Equivelent to:
    @withElement (element) -> element[method] args...
   */

  VirtualNode.prototype.sendToElement = function() {
    var args, method;
    method = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return new Promise((function(_this) {
      return function(resolve) {
        var ref;
        return resolve((ref = _this.element)[method].apply(ref, args));
      };
    })(this));
  };

  VirtualNode._separateConstructionParams = function(args, propsOut, childrenOut) {
    return deepEach(args, function(obj) {
      var k, results, v;
      if (isPlainObject(obj)) {
        results = [];
        for (k in obj) {
          v = obj[k];
          results.push(propsOut[k] = v);
        }
        return results;
      } else if (keepIfRubyTrue(obj)) {
        return childrenOut.push(obj);
      }
    });
  };

  VirtualNode._assignRefs = function(node) {
    var key;
    if ((key = node.key) && this.assignRefsTo) {
      if (this.assignRefsTo[key]) {
        return console.warn("WARNING: Duplicate key found. This MUST be fixed for correct operation.\n  key: " + (inspect(key)) + "\n  new VirtualNode: " + node.inspectedName + "\n  old VirtualNode: " + this.assignRefsTo[key].inspectedName);
      } else {
        return this.assignRefsTo[key] = node;
      }
    }
  };

  VirtualNode.prototype._validateChildren = function(children) {
    var child, i, len;
    if (!children) {
      return children;
    }
    for (i = 0, len = children.length; i < len; i++) {
      child = children[i];
      if (!(child instanceof VirtualNode)) {
        console.warn({
          "invalid VirtualNode child": child,
          parent: this
        });
        if (isObject(child)) {
          console.warn("Hint: Did you place properties AFTER a child element?");
        }
        throw new Error("VirtualNode child is not a VirtualNode.\ninvalid child: " + (inspect(child)) + "\nparent: " + this.inspectedName);
      }
    }
    return children;
  };

  VirtualNode.prototype._propsChanged = function(virtualNode) {
    var _propsLength, k, newProps, ref, v;
    newProps = virtualNode.rawProps;
    _propsLength = 0;
    ref = this.rawProps;
    for (k in ref) {
      v = ref[k];
      _propsLength++;
      if (!propsEq(v, newProps[k])) {
        return true;
      }
    }
    this._propsLength = _propsLength;
    return _propsLength !== virtualNode.getPropsLength();
  };

  VirtualNode.prototype._updateFrom = function(sourceNode) {
    return sourceNode._updateTarget = this;
  };

  VirtualNode.prototype._canUpdateFrom = function(sourceNode) {
    return false;
  };

  VirtualNode.prototype._instantiate = function(parentComponent, bindToOrCreateNewParentElementProps) {
    this._parentComponent = parentComponent;
    return this;
  };

  return VirtualNode;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(141);

module.exports.includeInNamespace(__webpack_require__(499)).addModules({
  Component: __webpack_require__(137),
  HotStyleProps: __webpack_require__(500),
  PropFieldsMixin: __webpack_require__(286),
  ReactArtEngineEpoch: __webpack_require__(88),
  StateFieldsMixin: __webpack_require__(138),
  VirtualElement: __webpack_require__(501),
  VirtualNode: __webpack_require__(139)
});


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var Core,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(89)).addNamespace('Core', Core = (function(superClass) {
  extend(Core, superClass);

  function Core() {
    return Core.__super__.constructor.apply(this, arguments);
  }

  return Core;

})(Neptune.PackageNamespace));


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(507);


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var AsyncExtensions, Promise, toSeconds;

Promise = __webpack_require__(45);

toSeconds = __webpack_require__(145).toSeconds;

module.exports = AsyncExtensions = (function() {
  var interval, timeout;

  function AsyncExtensions() {}

  AsyncExtensions.timeout = timeout = function(ms, f) {
    var p;
    p = new Promise(function(resolve) {
      return setTimeout(resolve, ms);
    });
    if (f != null) {
      return p.then(f);
    } else {
      return p;
    }
  };

  AsyncExtensions.timeoutAt = function(second, f) {
    return timeout((second - toSeconds()) * 1000, f);
  };

  AsyncExtensions.interval = interval = function(ms, f) {
    var intervalId, p;
    if (f == null) {
      f = function() {};
    }
    intervalId = null;
    p = new Promise(function(resolve) {
      return intervalId = setInterval(function() {
        return Promise.then(f).then(function() {
          return resolve();
        });
      }, ms);
    });
    p.stop = function() {
      if (intervalId != null) {
        return clearInterval(intervalId);
      }
    };
    return p;
  };

  AsyncExtensions.requestAnimationFrame = self.requestAnimationFrame || self.webkitRequestAnimationFrame || self.mozRequestAnimationFrame || self.oRequestAnimationFrame || self.msRequestAnimationFrame || function(f) {
    return setTimeout(f, 1000 / 60);
  };

  AsyncExtensions.nextTick = function(f) {
    return Promise.resolve().then(function() {
      return typeof f === "function" ? f() : void 0;
    });
  };

  AsyncExtensions.throwErrorOutOfStack = function(e) {
    console.log(e);
    return timeout(0, function() {
      throw e;
    });
  };

  AsyncExtensions.evalAndThrowErrorsOutOfStack = function(f) {
    var e;
    try {
      return f();
    } catch (error) {
      e = error;
      Neptune.Art.StandardLib.log.error("evalAndThrowErrorsOutOfStack", e);
      return AsyncExtensions.throwErrorOutOfStack(e);
    }
  };

  return AsyncExtensions;

})();


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var CallStack, inspect, isString, parseUrl;

isString = __webpack_require__(12).isString;

parseUrl = __webpack_require__(95).parseUrl;

inspect = __webpack_require__(30).inspect;

module.exports = CallStack = (function() {
  var CallStackLine;

  function CallStack() {}

  CallStack.errorToString = function(error) {
    return (error != null ? error.error : void 0) || (error != null ? error.message : void 0) || (isString(error) && error) || Neptune.Art.StandardLib.formattedInspect(error);
  };

  CallStack.CallStackLine = CallStackLine = (function() {
    CallStackLine.getter = function(map) {
      var getter, prop, results;
      results = [];
      for (prop in map) {
        getter = map[prop];
        results.push(Object.defineProperty(this.prototype, prop, {
          get: getter,
          configurable: true
        }));
      }
      return results;
    };

    CallStackLine.setter = function(map) {
      var prop, results, setter;
      results = [];
      for (prop in map) {
        setter = map[prop];
        results.push(Object.defineProperty(this.prototype, prop, {
          set: setter,
          configurable: true
        }));
      }
      return results;
    };

    function CallStackLine(line) {
      this.original = line;
      this["function"] = null;
      this.source = null;
      this["class"] = null;
      this.classPath = null;
      this.sourceFileName = null;
      this.sourcePath = null;
      this.sourceHostWithPort = null;
      this.sourceLine = 0;
      this.sourceColumn = 0;
      if (this.parseLineWithFunction(line)) {

      } else {
        this.parseLineWithoutFunction(line);
      }
      this.subParseFunction();
      this.subParseSource();
    }

    CallStackLine.prototype.toString = function() {
      return this.original;
    };

    CallStackLine.getter({
      fileWithLocation: function() {
        return this._fileWithLocation || (this._fileWithLocation = this.sourceFileName ? this.sourcePath + "/" + this.sourceFileName + ":" + this.sourceLine + ":" + this.sourceColumn : this.original);
      }
    });

    CallStackLine.prototype.parseLineWithFunction = function(line) {
      var r;
      if (r = line.match(/\s*at\s((new\s)?[a-zA-Z0-9_.<>]+)\s\(([^)]*):([0-9]+):([0-9]+)\)/)) {
        this["function"] = r[1];
        this.source = r[3];
        this.sourceLine = r[4] | 0;
        return this.sourceColumn = r[5] | 0;
      }
    };

    CallStackLine.prototype.parseLineWithoutFunction = function(line) {
      var r;
      if (r = line.match(/\s*at\s([^)]*):([0-9]+):([0-9]+)/)) {
        this.source = r[1];
        this.sourceLine = r[2] | 0;
        return this.sourceColumn = r[3] | 0;
      }
    };

    CallStackLine.prototype.subParseSource = function() {
      var url;
      if (this.source) {
        url = parseUrl(this.source);
        this.sourceFileName = url.fileName;
        this.sourcePath = url.path;
        return this.sourceHostWithPort = url.hostWithPort;
      }
    };

    CallStackLine.prototype.subParseFunction = function() {
      var f;
      if (this["function"]) {
        f = this["function"].split(".");
        this["function"] = f[f.length - 1];
        if (this["function"] === "<anonymous>") {
          this["function"] = void 0;
        }
        this["class"] = f[f.length - 2];
        return this.classPath = f.slice(0, f.length - 2);
      }
    };

    return CallStackLine;

  })();

  CallStack.rawCallStack = (new Error).stack ? function(ignoreTop) {
    if (ignoreTop == null) {
      ignoreTop = 0;
    }
    return (new Error).stack.split(/\n  */).slice(ignoreTop + 2);
  } : function(ignoreTop) {
    var e;
    if (ignoreTop == null) {
      ignoreTop = 0;
    }
    try {
      throw new Error;
    } catch (error1) {
      e = error1;
      return e.stack.split(/\n  */).slice(ignoreTop + 2);
    }
  };

  CallStack.callStack = function(ignoreTop) {
    var i, len, line, ref, results;
    if (ignoreTop == null) {
      ignoreTop = 0;
    }
    ref = CallStack.rawCallStack(ignoreTop + 1);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      results.push(new CallStackLine(line));
    }
    return results;
  };

  return CallStack;

})();


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var dateFormat, formattedInspect, isDate, isNumber, isString, march1973InMilliseconds, ref, toDate, toMilliseconds;

ref = __webpack_require__(43), isString = ref.isString, isNumber = ref.isNumber, isDate = ref.isDate;

formattedInspect = __webpack_require__(30).formattedInspect;

march1973InMilliseconds = 100000000000;

module.exports = {
  dateFormat: dateFormat = __webpack_require__(321),
  formatDate: function(value, format) {
    if (isString(value)) {
      format = value;
      value = null;
    }
    return dateFormat(toDate(value), format);
  },

  /*
  IN:
    Date
    OR Number of Seconds since epoch-start
    OR Number of Milliseconds since epoch-start
  OUT:
    Number of Milliseconds since epoch-start
   */
  toMilliseconds: toMilliseconds = function(v) {
    if (v == null) {
      return Date.now();
    }
    if (isString(v)) {
      v = v - 0;
    }
    if (isNumber(v)) {
      if (v < march1973InMilliseconds) {
        return v * 1000;
      } else {
        return v;
      }
    } else if (isDate(v)) {
      return v - 0;
    } else {
      throw new Error("invalid timestamp value: " + (formattedInspect(v)));
    }
  },

  /*
  IN:
    Date
    OR Number of Seconds since epoch-start
    OR Number of Milliseconds since epoch-start
  OUT:
    Number of Seconds since epoch-start
   */
  toSeconds: function(v) {
    if (v == null) {
      return Date.now() / 1000;
    }
    return (toMilliseconds(v) / 1000 + .5) | 0;
  },
  toDate: toDate = function(v) {
    if (v == null) {
      return new Date;
    }
    if (isDate(v)) {
      return v;
    } else {
      return new Date(toMilliseconds(v));
    }
  }
};


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var Eq, floatTrue0, isNumber, isString, min, objectKeyCount, ref, remove,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

remove = __webpack_require__(57).remove;

objectKeyCount = __webpack_require__(59).objectKeyCount;

floatTrue0 = __webpack_require__(44).floatTrue0;

ref = __webpack_require__(12), isString = ref.isString, isNumber = ref.isNumber;

min = Math.min;

module.exports = Eq = (function() {
  var plainObjectsDeepDiff, plainObjectsDeepEq;

  function Eq() {}


  /*
  IN: see @compare
  OUT:
    true: if a and b are structurally equal
    false: otherwise
   */

  Eq.eq = function(a, b) {
    return 0 === Eq.compare(a, b, true);
  };

  Eq.neq = function(a, b) {
    return 0 !== Eq.compare(a, b, true);
  };

  Eq.fastEq = function(a, b) {
    return 0 === Eq.compare(a, b, false);
  };

  Eq.fastNeq = function(a, b) {
    return 0 !== Eq.compare(a, b, false);
  };

  Eq._compareArray = function(a, b, recursionBlockArray) {
    var aLength, av, bLength, bv, i, j, ref1, val;
    aLength = a.length;
    bLength = b.length;
    for (i = j = 0, ref1 = Math.min(aLength, bLength); j < ref1; i = j += 1) {
      av = a[i];
      bv = b[i];
      if (0 !== (val = Eq._compare(av, bv, recursionBlockArray))) {
        return val;
      }
    }
    return aLength - bLength;
  };

  Eq._compareObject = function(a, b, recursionBlockArray) {
    var aLength, av, bv, compared, k, val;
    aLength = 0;
    compared = 0;
    for (k in a) {
      av = a[k];
      aLength++;
      av = a[k];
      bv = b[k];
      if (bv !== void 0 || b.hasOwnProperty(k)) {
        compared++;
        if (0 !== (val = Eq._compare(av, bv, recursionBlockArray))) {
          return val;
        }
      }
    }
    if (aLength === compared && compared === objectKeyCount(b)) {
      return 0;
    } else {
      return 0/0;
    }
  };


  /*
  compare is recursive. However, it only recurses for 'plain' objects and arrays.
  
  If you want to compare custom objects deeply, you must add an .eq or .compare function to your custom objects.
    signature: a.eq b, recursionBlockArray => truthy if a equals b
    signature: a.compare b, recursionBlockArray => NaN / <0 / 0 / >0 for incomparable / a<b / a==b / a>b respectively
    IN:
      a: => this/@
      b: compared with a
      recursionBlockArray: an array of objects already on the stack being tested, pass this to
    It is an array of every object recursively currently being tested - don't test an object in this array
    recursionBlockArray can be altered, but should be returned in its original state. It may be null.
  
  IN:
    a and b: compare a and b
    recursionBlockEnabled:
      truthy: recursive structures will be handled correctly
      falsey: (default) faster, but recursive structures result in infinite recursion
  OUT:
    NaN:
      a and b are different types
      a and b are otherwise not comparable
  
    <0: a < b
    0:  a == b
    >0: a > b
   */

  Eq.compare = function(a, b, recursionBlockEnabled) {
    return Eq._compare(a, b, recursionBlockEnabled && []);
  };

  Eq._compare = function(a, b, recursionBlockArray) {
    var _constructor;
    if (a === b) {
      return 0;
    }
    if ((a != null) && (b != null) && a.constructor === (_constructor = b.constructor)) {
      if (isString(a)) {
        return a.localeCompare(b);
      }
      if (isNumber(a)) {
        return floatTrue0(a - b);
      }
      if (recursionBlockArray) {
        if (indexOf.call(recursionBlockArray, a) >= 0 || indexOf.call(recursionBlockArray, b) >= 0) {
          return 0;
        }
        recursionBlockArray.push(a);
        recursionBlockArray.push(b);
      }
      if (a.compare) {
        return a.compare(b, recursionBlockArray);
      }
      if (_constructor === Array) {
        return Eq._compareArray(a, b, recursionBlockArray);
      }
      if (_constructor === Object) {
        return Eq._compareObject(a, b, recursionBlockArray);
      }
      if (a.eq && a.eq(b, recursionBlockArray)) {
        return 0;
      }
      if (recursionBlockArray) {
        remove(recursionBlockArray, recursionBlockArray.length - 2, 2);
      }
    }
    return 0/0;
  };

  Eq.plainObjectsDeepEqArray = function(a, b) {
    var av, i, j, len1;
    if (a.length !== b.length) {
      return false;
    }
    for (i = j = 0, len1 = a.length; j < len1; i = ++j) {
      av = a[i];
      if (!Eq.plainObjectsDeepEq(av, b[i])) {
        return false;
      }
    }
    return true;
  };

  Eq.plainObjectsDeepEqObject = function(a, b) {
    var aLength, av, bv, k;
    aLength = 0;
    for (k in a) {
      av = a[k];
      aLength++;
      bv = b[k];
      if (!((bv !== void 0 || b.hasOwnProperty(k)) && Eq.plainObjectsDeepEq(av, bv))) {
        return false;
      }
    }
    return aLength === objectKeyCount(b);
  };

  Eq.plainObjectsDeepEq = plainObjectsDeepEq = function(a, b) {
    var _constructor;
    if (a === b) {
      return true;
    } else if (a && b && a.constructor === (_constructor = b.constructor)) {
      if (a.eq) {
        return a.eq(b);
      } else if (_constructor === Array) {
        return Eq.plainObjectsDeepEqArray(a, b);
      } else if (_constructor === Object) {
        return Eq.plainObjectsDeepEqObject(a, b);
      } else {
        return false;
      }
    } else {
      return false;
    }
  };

  Eq.propsEq = plainObjectsDeepEq;

  Eq.plainObjectsDeepDiffArray = function(before, after) {
    var diff, i, j, l, len, m, ref1, ref2, ref3, ref4, ref5, res;
    res = null;
    len = min(before.length, after.length);
    for (i = j = 0, ref1 = len; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
      if (!(diff = plainObjectsDeepDiff(before[i], after[i]))) {
        continue;
      }
      res || (res = {});
      res[i] = diff;
    }
    if (len < before.length) {
      for (i = l = ref2 = len, ref3 = before.length; ref2 <= ref3 ? l < ref3 : l > ref3; i = ref2 <= ref3 ? ++l : --l) {
        res || (res = {});
        res[i] = {
          removed: before[i]
        };
      }
    }
    if (len < after.length) {
      for (i = m = ref4 = len, ref5 = after.length; ref4 <= ref5 ? m < ref5 : m > ref5; i = ref4 <= ref5 ? ++m : --m) {
        res || (res = {});
        res[i] = {
          added: after[i]
        };
      }
    }
    return res;
  };

  Eq.plainObjectsDeepDiffObject = function(before, after) {
    var afterV, beforeV, diff, k, res;
    res = null;
    for (k in before) {
      beforeV = before[k];
      if (after.hasOwnProperty(k)) {
        if (diff = plainObjectsDeepDiff(beforeV, after[k])) {
          res || (res = {});
          res[k] = diff;
        }
      } else {
        res || (res = {});
        res[k] = {
          removed: beforeV
        };
      }
    }
    for (k in after) {
      afterV = after[k];
      if (!(!before.hasOwnProperty(k))) {
        continue;
      }
      res || (res = {});
      res[k] = {
        added: afterV
      };
    }
    return res;
  };

  Eq.plainObjectsDeepDiff = plainObjectsDeepDiff = function(before, after) {
    var _constructor;
    if (before === after) {
      return null;
    } else if (before && after && before.constructor === (_constructor = after.constructor)) {
      if (before.eq) {
        if (before.eq(after)) {
          return null;
        } else {
          return {
            before: before,
            after: after
          };
        }
      } else if (_constructor === Array) {
        return Eq.plainObjectsDeepDiffArray(before, after);
      } else if (_constructor === Object) {
        return Eq.plainObjectsDeepDiffObject(before, after);
      } else {
        return {
          before: before,
          after: after
        };
      }
    } else {
      return {
        before: before,
        after: after
      };
    }
  };

  Eq.diff = plainObjectsDeepDiff;

  Eq.shallowEq = function(a, b) {
    return a === b || (a && b && a.eq && a.eq(b));
  };

  return Eq;

})();


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var InspectedObjects, dateFormat, deepMap, escapeJavascriptString, inspectedObjectLiteral, isClass, isDate, isFunction, isNonNegativeInt, isPlainArray, isPlainObject, isPromise, isRegExp, isString, ref;

ref = __webpack_require__(12), isDate = ref.isDate, deepMap = ref.deepMap, isNonNegativeInt = ref.isNonNegativeInt, isClass = ref.isClass, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject, isString = ref.isString, isFunction = ref.isFunction, isPromise = ref.isPromise, isRegExp = ref.isRegExp;

escapeJavascriptString = __webpack_require__(32).escapeJavascriptString;

inspectedObjectLiteral = __webpack_require__(91).inspectedObjectLiteral;

dateFormat = __webpack_require__(321);

module.exports = InspectedObjects = (function() {
  var toInspectedObjects;

  function InspectedObjects() {}

  InspectedObjects.toInspectedObjects = toInspectedObjects = function(m) {
    var functionString, literal, oldm, out, reducedFunctionString;
    if (m == null) {
      return m;
    }
    oldm = m;
    if (m === global) {
      return inspectedObjectLiteral("global");
    } else if (out = typeof m.getInspectedObjects === "function" ? m.getInspectedObjects() : void 0) {
      return out;
    } else if (isPromise(m)) {
      return inspectedObjectLiteral("Promise");
    } else if (isPlainObject(m) || isPlainArray(m)) {
      return deepMap(m, function(v) {
        return toInspectedObjects(v);
      });
    } else if (m instanceof Error) {
      literal = inspectedObjectLiteral(m.stack || m.toString(), true);
      if (m.info) {
        return toInspectedObjects({
          Error: {
            info: m.info,
            stack: literal
          }
        });
      } else {
        return {
          Error: {
            "class": toInspectedObjects(m.constructor),
            stack: literal
          }
        };
      }
    } else if (isRegExp(m)) {
      return inspectedObjectLiteral("" + m);
    } else if (isDate(m)) {
      return inspectedObjectLiteral(dateFormat(m, "UTC:yyyy-mm-dd HH:MM:ss Z"));
    } else if (isClass(m)) {
      return inspectedObjectLiteral("<" + ((typeof m.getName === "function" ? m.getName() : void 0) || m.name) + ">");
    } else if (isFunction(m)) {
      functionString = "" + m;
      reducedFunctionString = functionString.replace(/\s+/g, ' ').replace(/^function (\([^)]*\))/, "$1 ->").replace(/^\(\)\s*/, '');
      return inspectedObjectLiteral(reducedFunctionString.length < 80 ? reducedFunctionString : functionString.slice(0, 5 * 80));
    } else if (m && !isString(m)) {
      if (isNonNegativeInt(m.length)) {
        return inspectedObjectLiteral("{" + m.constructor.name + " length: " + m.length + "}");
      } else if (isNonNegativeInt(m.byteLength)) {
        return inspectedObjectLiteral("{" + m.constructor.name + " byteLength: " + m.byteLength + "}");
      } else {
        return m;
      }
    } else {
      return m;
    }
  };

  return InspectedObjects;

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var Inspector, Map, escapeJavascriptString, isArray, isBrowserObject, isClass, isFunction, isObject, isPlainArray, isPlainObject, isString, objectName, ref,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Map = __webpack_require__(94);

escapeJavascriptString = __webpack_require__(32).escapeJavascriptString;

ref = __webpack_require__(12), objectName = ref.objectName, isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, isObject = ref.isObject, isClass = ref.isClass, isBrowserObject = ref.isBrowserObject, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray;

module.exports = Inspector = (function() {
  var inspect;

  Inspector.unquotablePropertyRegex = /^([0-9]+|[_a-zA-Z][_0-9a-zA-Z]*)$/;

  Inspector.customInspectable = function(obj) {
    return obj.inspect && !(typeof obj === "function");
  };

  Inspector.parentString = function(distance) {
    switch (distance) {
      case 0:
        return "parent";
      case 1:
        return "grandparent";
      case 2:
        return "great grandparent";
      default:
        return "great^" + (distance - 1) + " grandparent";
    }
  };

  function Inspector(options) {
    if (options == null) {
      options = {};
    }
    this.inspect = bind(this.inspect, this);
    this.inspectInternal = bind(this.inspectInternal, this);
    this.inspectObject = bind(this.inspectObject, this);
    this.inspectArray = bind(this.inspectArray, this);
    this.maxLength = options.maxLength || 10000;
    this.allowCustomInspectors = !options.noCustomInspectors;
    this.maxDepth = options.maxDepth != null ? options.maxDepth : 10;
    this.outArray = [];
    this.length = 0;
    this.depth = 0;
    this.inspectingMap = new Map;
    this.done = false;
  }

  Inspector.inspect = inspect = function(obj, options) {
    var inspector;
    if (options == null) {
      options = {};
    }
    if (this !== global) {
      return Neptune.Base.inspect.call(this);
    }
    inspector = new Inspector(options);
    inspector.inspect(obj);
    return inspector.getResult();
  };

  Inspector.shallowInspect = function(obj) {
    if (obj == null) {
      return "" + obj;
    } else if (Inspector.customInspectable(obj)) {
      return Inspector.inspect(obj);
    } else if (isString(obj)) {
      return escapeJavascriptString(obj);
    } else if (isArray(obj)) {
      return "<<Array length: " + obj.length + ">>";
    } else if (isFunction(obj) && obj.name === "") {
      return "<<function args: " + obj.length + ">>";
    } else {
      return "<<" + (typeof obj) + ": " + (obj.name || obj) + ">>";
    }
  };

  Inspector.inspectLean = function(object, options) {
    var fullInspect, match;
    fullInspect = inspect(object, options);
    if (!isFunction(object != null ? object.inspect : void 0) && (isPlainObject(object) || (isPlainArray(object) && (object.length > 1 || (options != null ? options.forArgs : void 0))))) {
      match = fullInspect.match(/^\[(.+)\]$|^\{(.+)\}$/);
      if (match) {
        return match[1] || match[2] || match[3];
      } else {
        return fullInspect;
      }
    } else {
      return fullInspect;
    }
  };

  Inspector.prototype.put = function(s) {
    var remaining;
    if (this.done) {
      return;
    }
    if (this.length + s.length > this.maxLength) {
      this.done = true;
      remaining = this.maxLength - this.length;
      s = (s.slice(0, remaining)) + "<... first " + remaining + "/" + s.length + ">";
    }
    this.length += s.length;
    this.outArray.push(s);
    return s;
  };

  Inspector.prototype.getResult = function() {
    return this.outArray.join("");
  };

  Inspector.prototype.maxDepthOutput = function(obj) {
    var keys, name;
    switch (typeof obj) {
      case "string":
      case "number":
      case "boolean":
      case "undefined":
        return this.inspectInternal(obj);
      case "function":
        return this.put(objectName(obj));
      case "object":
        return this.put(obj === null ? "null" : isArray(obj) ? "[" + obj.length + " elements]" : (keys = Object.keys(obj), name = objectName(obj), name === "Object" ? "{" + keys.length + " keys}" : keys.length > 0 ? "{" + name + " " + keys.length + " keys}" : name));
    }
  };

  Inspector.prototype.inspectArray = function(array) {
    var first, i, len, obj;
    this.put("[");
    first = true;
    for (i = 0, len = array.length; i < len; i++) {
      obj = array[i];
      if (!first) {
        this.put(", ");
      }
      this.inspect(obj);
      first = false;
    }
    return this.put("]");
  };

  Inspector.prototype.inspectObject = function(obj) {
    var attributes, first, i, k, keys, len, name, v;
    attributes = [];
    keys = Object.keys(obj);
    name = objectName(obj);
    if (isFunction(obj) && keys.length === 0) {
      return this.put(name + "()");
    } else if (isBrowserObject(obj)) {
      return this.put("{" + name + "}");
    } else {
      this.put("{");
      if (obj.constructor !== Object) {
        this.put(name + " ");
      }
      first = true;
      for (i = 0, len = keys.length; i < len; i++) {
        k = keys[i];
        if (!(k !== "__uniqueId")) {
          continue;
        }
        if (!first) {
          this.put(", ");
        }
        v = obj[k];
        if (Inspector.unquotablePropertyRegex.test(k)) {
          this.put(k);
        } else {
          this.inspect(k);
        }
        this.put(": ");
        this.inspect(v);
        first = false;
      }
      return this.put("}");
    }
  };

  Inspector.prototype.inspectInternal = function(obj) {
    if (obj == null) {
      return this.put("" + obj);
    } else if (isString(obj)) {
      return this.put(escapeJavascriptString(obj));
    } else if (isArray(obj)) {
      return this.inspectArray(obj);
    } else if (isClass(obj)) {
      return this.put(objectName(obj));
    } else if (this.allowCustomInspectors && Inspector.customInspectable(obj)) {
      if (obj.inspect.length > 0) {
        return obj.inspect(this);
      } else {
        return this.put(obj.inspect());
      }
    } else if (obj instanceof RegExp) {
      return this.put("" + obj);
    } else if (isObject(obj) || isFunction(obj)) {
      return this.inspectObject(obj);
    } else if (isFunction(obj != null ? obj.toString : void 0)) {
      return this.put(obj.toString());
    } else {
      return this.put("" + obj);
    }
  };

  Inspector.prototype.inspect = function(obj) {
    var objDepth;
    if (this.done) {
      return;
    }
    if (objDepth = this.inspectingMap.get(obj)) {
      this.put("<" + (Inspector.parentString(this.depth - objDepth)) + ">");
      return null;
    }
    if (this.depth >= this.maxDepth) {
      this.maxDepthOutput(obj);
    } else {
      this.depth++;
      this.inspectingMap.set(obj, this.depth);
      this.inspectInternal(obj);
      this.inspectingMap["delete"](obj);
      this.depth--;
    }
    return null;
  };

  return Inspector;

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var Inspect, Log, callStack, containsPromises, deepResolve, disableLog, getEnv, isNode, isString, merge, peek, ref, ref1,
  slice = [].slice;

Inspect = __webpack_require__(92);

callStack = __webpack_require__(144).callStack;

isString = __webpack_require__(12).isString;

peek = __webpack_require__(57).peek;

merge = __webpack_require__(16).merge;

ref = __webpack_require__(45), deepResolve = ref.deepResolve, containsPromises = ref.containsPromises;

ref1 = __webpack_require__(58), isNode = ref1.isNode, getEnv = ref1.getEnv;

disableLog = getEnv().disableLog;

module.exports = Log = (function() {
  var getLogger, noOptions, promiseLogId, standardOptions;

  function Log() {}

  Log.contextString = function(stack, defaultContext) {
    var caller, context;
    if (stack && (caller = stack[1])) {
      if (caller.original) {
        return caller.original;
      } else {
        context = caller["function"] ? caller["class"] ? caller["class"] + "::" + caller["function"] + "()" : caller["function"] + "()" : defaultContext ? defaultContext + ":" : "";
        if (caller.sourceFileName) {
          return "at " + caller.sourceFileName + ("-" + caller.sourceLine + ": ") + context;
        }
      }
    } else {
      return "at " + (defaultContext || "(unknown context)");
    }
  };

  Log.autoSizedIndepect = function(toInspect, maxLength, maxDepth) {
    var depth, inspected;
    if (maxLength == null) {
      maxLength = 512;
    }
    if (maxDepth == null) {
      maxDepth = 10;
    }
    inspected = null;
    depth = maxDepth;
    while ((inspected = Inspect.inspectLean(toInspect, {
        maxDepth: depth,
        maxLength: maxLength
      })).match(/\.\.\.$/)) {
      depth--;
    }
    return inspected;
  };

  Log.loggedParamsString = function(params) {
    if (typeof params === "string") {
      return params;
    } else {
      return Log.autoSizedIndepect(params);
    }
  };

  Log.hideLogging = function() {
    return Log.loggingHidden = true;
  };

  Log.showLogging = function() {
    return Log.loggingHidden = false;
  };

  Log.rawLog = function() {
    if (!Log.loggingHidden) {
      return console.log.apply(console, arguments);
    }
  };

  Log.rawErrorLog = function() {
    var a, out, str;
    if (Log.loggingHidden) {
      return;
    }
    if (isNode && "".red) {
      str = arguments.length > 1 ? (out = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = arguments.length; i < len; i++) {
          a = arguments[i];
          results.push(a);
        }
        return results;
      }).apply(Log, arguments), out.join(' ')) : arguments[0];
      return console.error(str.red);
    } else {
      return console.error.apply(console, arguments);
    }
  };

  Log.rawWarningLog = function() {
    var a, out, str;
    if (Log.loggingHidden) {
      return;
    }
    if (isNode && "".red) {
      str = arguments.length > 1 ? (out = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = arguments.length; i < len; i++) {
          a = arguments[i];
          results.push(a);
        }
        return results;
      }).apply(Log, arguments), out.join(' ')) : arguments[0];
      return console.warn(str.yellow);
    } else {
      return console.warn.apply(console, arguments);
    }
  };

  noOptions = {};

  getLogger = function(arg) {
    var isError, isWarning;
    isError = arg.isError, isWarning = arg.isWarning;
    if (isError) {
      return Log.rawErrorLog;
    } else if (isWarning) {
      return Log.rawWarningLog;
    } else {
      return Log.rawLog;
    }
  };

  promiseLogId = 1;

  Log.logCore = function(m, stack, options) {
    if (options == null) {
      options = noOptions;
    }
    if (Log.alternativeLogger) {
      Log.alternativeLogger.logCore(m, stack, options);
    }
    if (options.resolvePromises) {
      return Log.log.resolvePromiseWrapper(m, function(toLog, label) {
        var obj1;
        return Log._logNow((
          obj1 = {},
          obj1["" + label] = toLog,
          obj1
        ), stack, options);
      });
    } else {
      return Log._logNow(m, stack, options);
    }
  };

  Log._logNow = function(m, stack, options) {
    var className, logger;
    className = options.className;
    logger = getLogger(options);
    if (isNode) {
      return logger(isString(m) ? m : Inspect.formattedInspect(m, merge({
        maxLineLength: process.stdout.columns
      }, options)));
    } else {
      return logger(m);
    }
  };

  standardOptions = (function() {
    if (isNode) {
      try {
        eval("require")("colors");
      } catch (error) {}
      return {
        color: true
      };
    } else {
      return {};
    }
  })();

  Log.log = function() {
    var args, ref2;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (disableLog) {
      return peek(args);
    } else {
      return (ref2 = Log.log).withOptions.apply(ref2, [standardOptions].concat(slice.call(args)));
    }
  };

  Log.log.resolvePromiseWrapper = function(m, logger) {
    var logId, toResolve;
    if (containsPromises(m)) {
      toResolve = m;
      logId = promiseLogId++;
      logger(m, "RESOLVING_" + logId, false);
      return deepResolve(toResolve).then((function(_this) {
        return function(resolvedM) {
          return logger(resolvedM, "RESOLVED_" + logId, true);
        };
      })(this))["catch"]((function(_this) {
        return function(rejected) {
          return logger(rejected, "REJECTED_" + logId, true, true);
        };
      })(this));
    } else {
      return logger(m, false);
    }
  };

  Log.log.withOptions = function() {
    var args, m, options;
    options = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    m = args.length === 1 ? args[0] : args;
    Log.logCore(m, callStack(), options);
    return peek(args);
  };


  /*
  
  IN:
    labelString, value
    OR object with one or more properties (usually just one)
      returns the last value of the objects last key-value pair
  
  EX:
    log.withLabel foo: myObject
     * out: myObject
  
    log.withLabel "foo", myObject
     * out: myObject
   */

  Log.log.withLabel = function(a, b) {
    var k, obj, ret, v;
    if (isString(a)) {
      obj = {};
      obj[a] = b;
      Log.log(obj);
      return b;
    } else {
      ret = null;
      for (k in a) {
        v = a[k];
        ret = v;
      }
      Log.log(obj);
      return ret;
    }
  };

  Log.log.labeled = Log.log.withLabel;

  Log.log.error = function() {
    var args, ref2;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (ref2 = Log.log).withOptions.apply(ref2, [{
      isError: true
    }].concat(slice.call(args)));
  };

  Log.log.warn = function() {
    var args, ref2;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (ref2 = Log.log).withOptions.apply(ref2, [{
      isWarning: true
    }].concat(slice.call(args)));
  };

  Log.logL = function(obj) {
    var k, ret, v;
    console.warn("DEPRICATED: logL. USE log.labeled");
    ret = null;
    for (k in obj) {
      v = obj[k];
      ret = v;
    }
    Log.log(obj);
    return ret;
  };

  return Log;

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)))

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var Time, base, commaize, dateSecondMinusPerformanceSecond, initDateSecond, initPerformanceSecond;

commaize = __webpack_require__(44).commaize;

self.performance || (self.performance = {});

(base = self.performance).now || (base.now = self.performance.mozNow || self.performance.msNow || self.performance.oNow || self.performance.webkitNow || function() {
  return new Date().getTime();
});

initPerformanceSecond = self.performance.now() / 1000;

initDateSecond = new Date().getTime() / 1000;

dateSecondMinusPerformanceSecond = initDateSecond - initPerformanceSecond;

module.exports = Time = (function() {
  var currentSecond, multiples, timerStack;

  function Time() {}

  multiples = [["mo", 30 * 24 * 60 * 60], ["d", 24 * 60 * 60], ["h", 60 * 60], ["m", 60], ["s", 1], ["ms", .001], ["s", .000001], ["ns", .000000001]];

  Time.dateSecondToPerformanceSecond = function(dateSecond) {
    return dateSecond - dateSecondMinusPerformanceSecond;
  };

  Time.performanceSecondToDateSecond = function(performanceSecond) {
    return performanceSecond + dateSecondMinusPerformanceSecond;
  };

  Time.timeStampToPerformanceSecond = function(htmlEventTimeStamp) {
    return htmlEventTimeStamp / 1000 - dateSecondMinusPerformanceSecond;
  };

  Time.durationString = function(seconds) {
    var i, len, multiplier, name, ref;
    for (i = 0, len = multiples.length; i < len; i++) {
      ref = multiples[i], name = ref[0], multiplier = ref[1];
      if (seconds >= multiplier) {
        return "" + ((seconds / multiplier) | 0) + name;
      }
    }
    return "0";
  };

  Time.dateAgeInSeconds = function(date) {
    return ((new Date) - date) * .001;
  };

  Time.dateToSeconds = function(date) {
    return post.getTime() * .001;
  };

  Time.perTimeString = function(secondsPerRun) {
    var perTime;
    perTime = 1 / secondsPerRun;
    if (perTime > 100) {
      return (commaize(perTime | 0)) + "/s";
    } else if (perTime * 60 > 100) {
      return (commaize(perTime * 60 | 0)) + "/m";
    } else {
      return (commaize(perTime * 3600 | 0)) + "/h";
    }
  };

  Time.currentMillisecond = function() {
    return self.performance.now();
  };

  Time.currentSecond = currentSecond = function() {
    return self.performance.now() / 1000;
  };

  Time.currentDateSecond = function() {
    return new Date().getTime() / 1000;
  };

  Time.time = function(a, b) {
    var f, fResult, start, timeResult;
    f = b || a;
    start = currentSecond();
    fResult = f();
    timeResult = currentSecond() - start;
    if (b) {
      Neptune.Art.StandardLib.log("time: " + a + " took " + (Time.durationString(timeResult)));
      return fResult;
    } else {
      return timeResult;
    }
  };

  timerStack = [];

  Time.stackTime = function(f) {
    var start, subTimeTotal, timeResult, tsl;
    start = currentSecond();
    timerStack.push(0);
    f();
    subTimeTotal = timerStack.pop();
    timeResult = currentSecond() - start;
    if ((tsl = timerStack.length) > 0) {
      timerStack[tsl - 1] += timeResult;
    }
    return {
      count: 1,
      total: timeResult,
      subTimeTotal: subTimeTotal,
      remainder: timeResult - subTimeTotal
    };
  };

  Time.logTimeSinceLast = function(a) {
    var time;
    time = Time.currentSecond();
    console.log(a + " (" + (Time.lastTime ? Time.durationString(time - Time.lastTime) : void 0) + ")");
    return Time.lastTime = time;
  };

  return Time;

})();


/***/ }),
/* 151 */
/***/ (function(module, exports) {

var Unique, nextId;

nextId = 1;

module.exports = Unique = (function() {
  var nextUniqueObjectId, objectId;

  function Unique() {}

  Unique.nextUniqueObjectId = nextUniqueObjectId = function() {
    return "object_" + nextId++;
  };

  Unique.objectId = objectId = function(o) {
    if (o.hasOwnProperty("__uniqueId")) {
      return o.__uniqueId || (o.__uniqueId = nextUniqueObjectId());
    } else {
      Object.defineProperty(o, "__uniqueId", {
        enumerable: false,
        value: nextUniqueObjectId()
      });
      return o.__uniqueId;
    }
  };

  Unique.id = function(key) {
    if (typeof key === "object" || typeof key === "function") {
      if (key) {
        if (typeof key.getUniqueId === "function") {
          return key.getUniqueId();
        } else {
          return objectId(key);
        }
      } else {
        return "null";
      }
    } else if (typeof key === "number") {
      return "" + key;
    } else if (typeof key === "symbol") {
      return key.toString();
    } else if (typeof key === "string") {
      return "string_" + key;
    } else if (typeof key === "boolean") {
      if (key) {
        return "true";
      } else {
        return "false";
      }
    } else if (key === void 0) {
      return "undefined";
    } else {
      return (typeof key) + "_" + key;
    }
  };

  return Unique;

})();


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

var StandardLib,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.StandardLib', StandardLib = (function(superClass) {
  extend(StandardLib, superClass);

  function StandardLib() {
    return StandardLib.__super__.constructor.apply(this, arguments);
  }

  StandardLib.version = __webpack_require__(596).version;

  return StandardLib;

})(Neptune.PackageNamespace));

__webpack_require__(290);

__webpack_require__(92);


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(526);


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var Art, Xbd,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Art = __webpack_require__(532);

module.exports = Art.Xbd || Art.addNamespace('Xbd', Xbd = (function(superClass) {
  extend(Xbd, superClass);

  function Xbd() {
    return Xbd.__super__.constructor.apply(this, arguments);
  }

  return Xbd;

})(Neptune.Base));


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.utils = __webpack_require__(557);
exports.Cipher = __webpack_require__(554);
exports.DES = __webpack_require__(555);
exports.CBC = __webpack_require__(553);
exports.EDE = __webpack_require__(556);


/***/ }),
/* 156 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(22);
hash.common = __webpack_require__(62);
hash.sha = __webpack_require__(577);
hash.ripemd = __webpack_require__(576);
hash.hmac = __webpack_require__(575);

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var processNextTick = __webpack_require__(104);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(60);
util.inherits = __webpack_require__(7);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(628)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(348);
/*</replacement>*/

/*<replacement>*/
var Buffer = __webpack_require__(159).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = __webpack_require__(347);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(34);

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(34);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23), __webpack_require__(165).setImmediate, __webpack_require__(3)))

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(5)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(345);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(158);
exports.Duplex = __webpack_require__(34);
exports.Transform = __webpack_require__(346);
exports.PassThrough = __webpack_require__(615);


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var inherits = __webpack_require__(7)
var HashBase = __webpack_require__(574)

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var m = new Array(16)
  for (var i = 0; i < 16; ++i) m[i] = this._block.readInt32LE(i * 4)

  var al = this._a
  var bl = this._b
  var cl = this._c
  var dl = this._d
  var el = this._e

  // Mj = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
  // K = 0x00000000
  // Sj = 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8
  al = fn1(al, bl, cl, dl, el, m[0], 0x00000000, 11); cl = rotl(cl, 10)
  el = fn1(el, al, bl, cl, dl, m[1], 0x00000000, 14); bl = rotl(bl, 10)
  dl = fn1(dl, el, al, bl, cl, m[2], 0x00000000, 15); al = rotl(al, 10)
  cl = fn1(cl, dl, el, al, bl, m[3], 0x00000000, 12); el = rotl(el, 10)
  bl = fn1(bl, cl, dl, el, al, m[4], 0x00000000, 5); dl = rotl(dl, 10)
  al = fn1(al, bl, cl, dl, el, m[5], 0x00000000, 8); cl = rotl(cl, 10)
  el = fn1(el, al, bl, cl, dl, m[6], 0x00000000, 7); bl = rotl(bl, 10)
  dl = fn1(dl, el, al, bl, cl, m[7], 0x00000000, 9); al = rotl(al, 10)
  cl = fn1(cl, dl, el, al, bl, m[8], 0x00000000, 11); el = rotl(el, 10)
  bl = fn1(bl, cl, dl, el, al, m[9], 0x00000000, 13); dl = rotl(dl, 10)
  al = fn1(al, bl, cl, dl, el, m[10], 0x00000000, 14); cl = rotl(cl, 10)
  el = fn1(el, al, bl, cl, dl, m[11], 0x00000000, 15); bl = rotl(bl, 10)
  dl = fn1(dl, el, al, bl, cl, m[12], 0x00000000, 6); al = rotl(al, 10)
  cl = fn1(cl, dl, el, al, bl, m[13], 0x00000000, 7); el = rotl(el, 10)
  bl = fn1(bl, cl, dl, el, al, m[14], 0x00000000, 9); dl = rotl(dl, 10)
  al = fn1(al, bl, cl, dl, el, m[15], 0x00000000, 8); cl = rotl(cl, 10)

  // Mj = 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8
  // K = 0x5a827999
  // Sj = 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12
  el = fn2(el, al, bl, cl, dl, m[7], 0x5a827999, 7); bl = rotl(bl, 10)
  dl = fn2(dl, el, al, bl, cl, m[4], 0x5a827999, 6); al = rotl(al, 10)
  cl = fn2(cl, dl, el, al, bl, m[13], 0x5a827999, 8); el = rotl(el, 10)
  bl = fn2(bl, cl, dl, el, al, m[1], 0x5a827999, 13); dl = rotl(dl, 10)
  al = fn2(al, bl, cl, dl, el, m[10], 0x5a827999, 11); cl = rotl(cl, 10)
  el = fn2(el, al, bl, cl, dl, m[6], 0x5a827999, 9); bl = rotl(bl, 10)
  dl = fn2(dl, el, al, bl, cl, m[15], 0x5a827999, 7); al = rotl(al, 10)
  cl = fn2(cl, dl, el, al, bl, m[3], 0x5a827999, 15); el = rotl(el, 10)
  bl = fn2(bl, cl, dl, el, al, m[12], 0x5a827999, 7); dl = rotl(dl, 10)
  al = fn2(al, bl, cl, dl, el, m[0], 0x5a827999, 12); cl = rotl(cl, 10)
  el = fn2(el, al, bl, cl, dl, m[9], 0x5a827999, 15); bl = rotl(bl, 10)
  dl = fn2(dl, el, al, bl, cl, m[5], 0x5a827999, 9); al = rotl(al, 10)
  cl = fn2(cl, dl, el, al, bl, m[2], 0x5a827999, 11); el = rotl(el, 10)
  bl = fn2(bl, cl, dl, el, al, m[14], 0x5a827999, 7); dl = rotl(dl, 10)
  al = fn2(al, bl, cl, dl, el, m[11], 0x5a827999, 13); cl = rotl(cl, 10)
  el = fn2(el, al, bl, cl, dl, m[8], 0x5a827999, 12); bl = rotl(bl, 10)

  // Mj = 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12
  // K = 0x6ed9eba1
  // Sj = 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5
  dl = fn3(dl, el, al, bl, cl, m[3], 0x6ed9eba1, 11); al = rotl(al, 10)
  cl = fn3(cl, dl, el, al, bl, m[10], 0x6ed9eba1, 13); el = rotl(el, 10)
  bl = fn3(bl, cl, dl, el, al, m[14], 0x6ed9eba1, 6); dl = rotl(dl, 10)
  al = fn3(al, bl, cl, dl, el, m[4], 0x6ed9eba1, 7); cl = rotl(cl, 10)
  el = fn3(el, al, bl, cl, dl, m[9], 0x6ed9eba1, 14); bl = rotl(bl, 10)
  dl = fn3(dl, el, al, bl, cl, m[15], 0x6ed9eba1, 9); al = rotl(al, 10)
  cl = fn3(cl, dl, el, al, bl, m[8], 0x6ed9eba1, 13); el = rotl(el, 10)
  bl = fn3(bl, cl, dl, el, al, m[1], 0x6ed9eba1, 15); dl = rotl(dl, 10)
  al = fn3(al, bl, cl, dl, el, m[2], 0x6ed9eba1, 14); cl = rotl(cl, 10)
  el = fn3(el, al, bl, cl, dl, m[7], 0x6ed9eba1, 8); bl = rotl(bl, 10)
  dl = fn3(dl, el, al, bl, cl, m[0], 0x6ed9eba1, 13); al = rotl(al, 10)
  cl = fn3(cl, dl, el, al, bl, m[6], 0x6ed9eba1, 6); el = rotl(el, 10)
  bl = fn3(bl, cl, dl, el, al, m[13], 0x6ed9eba1, 5); dl = rotl(dl, 10)
  al = fn3(al, bl, cl, dl, el, m[11], 0x6ed9eba1, 12); cl = rotl(cl, 10)
  el = fn3(el, al, bl, cl, dl, m[5], 0x6ed9eba1, 7); bl = rotl(bl, 10)
  dl = fn3(dl, el, al, bl, cl, m[12], 0x6ed9eba1, 5); al = rotl(al, 10)

  // Mj = 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2
  // K = 0x8f1bbcdc
  // Sj = 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12
  cl = fn4(cl, dl, el, al, bl, m[1], 0x8f1bbcdc, 11); el = rotl(el, 10)
  bl = fn4(bl, cl, dl, el, al, m[9], 0x8f1bbcdc, 12); dl = rotl(dl, 10)
  al = fn4(al, bl, cl, dl, el, m[11], 0x8f1bbcdc, 14); cl = rotl(cl, 10)
  el = fn4(el, al, bl, cl, dl, m[10], 0x8f1bbcdc, 15); bl = rotl(bl, 10)
  dl = fn4(dl, el, al, bl, cl, m[0], 0x8f1bbcdc, 14); al = rotl(al, 10)
  cl = fn4(cl, dl, el, al, bl, m[8], 0x8f1bbcdc, 15); el = rotl(el, 10)
  bl = fn4(bl, cl, dl, el, al, m[12], 0x8f1bbcdc, 9); dl = rotl(dl, 10)
  al = fn4(al, bl, cl, dl, el, m[4], 0x8f1bbcdc, 8); cl = rotl(cl, 10)
  el = fn4(el, al, bl, cl, dl, m[13], 0x8f1bbcdc, 9); bl = rotl(bl, 10)
  dl = fn4(dl, el, al, bl, cl, m[3], 0x8f1bbcdc, 14); al = rotl(al, 10)
  cl = fn4(cl, dl, el, al, bl, m[7], 0x8f1bbcdc, 5); el = rotl(el, 10)
  bl = fn4(bl, cl, dl, el, al, m[15], 0x8f1bbcdc, 6); dl = rotl(dl, 10)
  al = fn4(al, bl, cl, dl, el, m[14], 0x8f1bbcdc, 8); cl = rotl(cl, 10)
  el = fn4(el, al, bl, cl, dl, m[5], 0x8f1bbcdc, 6); bl = rotl(bl, 10)
  dl = fn4(dl, el, al, bl, cl, m[6], 0x8f1bbcdc, 5); al = rotl(al, 10)
  cl = fn4(cl, dl, el, al, bl, m[2], 0x8f1bbcdc, 12); el = rotl(el, 10)

  // Mj = 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
  // K = 0xa953fd4e
  // Sj = 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
  bl = fn5(bl, cl, dl, el, al, m[4], 0xa953fd4e, 9); dl = rotl(dl, 10)
  al = fn5(al, bl, cl, dl, el, m[0], 0xa953fd4e, 15); cl = rotl(cl, 10)
  el = fn5(el, al, bl, cl, dl, m[5], 0xa953fd4e, 5); bl = rotl(bl, 10)
  dl = fn5(dl, el, al, bl, cl, m[9], 0xa953fd4e, 11); al = rotl(al, 10)
  cl = fn5(cl, dl, el, al, bl, m[7], 0xa953fd4e, 6); el = rotl(el, 10)
  bl = fn5(bl, cl, dl, el, al, m[12], 0xa953fd4e, 8); dl = rotl(dl, 10)
  al = fn5(al, bl, cl, dl, el, m[2], 0xa953fd4e, 13); cl = rotl(cl, 10)
  el = fn5(el, al, bl, cl, dl, m[10], 0xa953fd4e, 12); bl = rotl(bl, 10)
  dl = fn5(dl, el, al, bl, cl, m[14], 0xa953fd4e, 5); al = rotl(al, 10)
  cl = fn5(cl, dl, el, al, bl, m[1], 0xa953fd4e, 12); el = rotl(el, 10)
  bl = fn5(bl, cl, dl, el, al, m[3], 0xa953fd4e, 13); dl = rotl(dl, 10)
  al = fn5(al, bl, cl, dl, el, m[8], 0xa953fd4e, 14); cl = rotl(cl, 10)
  el = fn5(el, al, bl, cl, dl, m[11], 0xa953fd4e, 11); bl = rotl(bl, 10)
  dl = fn5(dl, el, al, bl, cl, m[6], 0xa953fd4e, 8); al = rotl(al, 10)
  cl = fn5(cl, dl, el, al, bl, m[15], 0xa953fd4e, 5); el = rotl(el, 10)
  bl = fn5(bl, cl, dl, el, al, m[13], 0xa953fd4e, 6); dl = rotl(dl, 10)

  var ar = this._a
  var br = this._b
  var cr = this._c
  var dr = this._d
  var er = this._e

  // M'j = 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12
  // K' = 0x50a28be6
  // S'j = 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6
  ar = fn5(ar, br, cr, dr, er, m[5], 0x50a28be6, 8); cr = rotl(cr, 10)
  er = fn5(er, ar, br, cr, dr, m[14], 0x50a28be6, 9); br = rotl(br, 10)
  dr = fn5(dr, er, ar, br, cr, m[7], 0x50a28be6, 9); ar = rotl(ar, 10)
  cr = fn5(cr, dr, er, ar, br, m[0], 0x50a28be6, 11); er = rotl(er, 10)
  br = fn5(br, cr, dr, er, ar, m[9], 0x50a28be6, 13); dr = rotl(dr, 10)
  ar = fn5(ar, br, cr, dr, er, m[2], 0x50a28be6, 15); cr = rotl(cr, 10)
  er = fn5(er, ar, br, cr, dr, m[11], 0x50a28be6, 15); br = rotl(br, 10)
  dr = fn5(dr, er, ar, br, cr, m[4], 0x50a28be6, 5); ar = rotl(ar, 10)
  cr = fn5(cr, dr, er, ar, br, m[13], 0x50a28be6, 7); er = rotl(er, 10)
  br = fn5(br, cr, dr, er, ar, m[6], 0x50a28be6, 7); dr = rotl(dr, 10)
  ar = fn5(ar, br, cr, dr, er, m[15], 0x50a28be6, 8); cr = rotl(cr, 10)
  er = fn5(er, ar, br, cr, dr, m[8], 0x50a28be6, 11); br = rotl(br, 10)
  dr = fn5(dr, er, ar, br, cr, m[1], 0x50a28be6, 14); ar = rotl(ar, 10)
  cr = fn5(cr, dr, er, ar, br, m[10], 0x50a28be6, 14); er = rotl(er, 10)
  br = fn5(br, cr, dr, er, ar, m[3], 0x50a28be6, 12); dr = rotl(dr, 10)
  ar = fn5(ar, br, cr, dr, er, m[12], 0x50a28be6, 6); cr = rotl(cr, 10)

  // M'j = 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2
  // K' = 0x5c4dd124
  // S'j = 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11
  er = fn4(er, ar, br, cr, dr, m[6], 0x5c4dd124, 9); br = rotl(br, 10)
  dr = fn4(dr, er, ar, br, cr, m[11], 0x5c4dd124, 13); ar = rotl(ar, 10)
  cr = fn4(cr, dr, er, ar, br, m[3], 0x5c4dd124, 15); er = rotl(er, 10)
  br = fn4(br, cr, dr, er, ar, m[7], 0x5c4dd124, 7); dr = rotl(dr, 10)
  ar = fn4(ar, br, cr, dr, er, m[0], 0x5c4dd124, 12); cr = rotl(cr, 10)
  er = fn4(er, ar, br, cr, dr, m[13], 0x5c4dd124, 8); br = rotl(br, 10)
  dr = fn4(dr, er, ar, br, cr, m[5], 0x5c4dd124, 9); ar = rotl(ar, 10)
  cr = fn4(cr, dr, er, ar, br, m[10], 0x5c4dd124, 11); er = rotl(er, 10)
  br = fn4(br, cr, dr, er, ar, m[14], 0x5c4dd124, 7); dr = rotl(dr, 10)
  ar = fn4(ar, br, cr, dr, er, m[15], 0x5c4dd124, 7); cr = rotl(cr, 10)
  er = fn4(er, ar, br, cr, dr, m[8], 0x5c4dd124, 12); br = rotl(br, 10)
  dr = fn4(dr, er, ar, br, cr, m[12], 0x5c4dd124, 7); ar = rotl(ar, 10)
  cr = fn4(cr, dr, er, ar, br, m[4], 0x5c4dd124, 6); er = rotl(er, 10)
  br = fn4(br, cr, dr, er, ar, m[9], 0x5c4dd124, 15); dr = rotl(dr, 10)
  ar = fn4(ar, br, cr, dr, er, m[1], 0x5c4dd124, 13); cr = rotl(cr, 10)
  er = fn4(er, ar, br, cr, dr, m[2], 0x5c4dd124, 11); br = rotl(br, 10)

  // M'j = 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13
  // K' = 0x6d703ef3
  // S'j = 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5
  dr = fn3(dr, er, ar, br, cr, m[15], 0x6d703ef3, 9); ar = rotl(ar, 10)
  cr = fn3(cr, dr, er, ar, br, m[5], 0x6d703ef3, 7); er = rotl(er, 10)
  br = fn3(br, cr, dr, er, ar, m[1], 0x6d703ef3, 15); dr = rotl(dr, 10)
  ar = fn3(ar, br, cr, dr, er, m[3], 0x6d703ef3, 11); cr = rotl(cr, 10)
  er = fn3(er, ar, br, cr, dr, m[7], 0x6d703ef3, 8); br = rotl(br, 10)
  dr = fn3(dr, er, ar, br, cr, m[14], 0x6d703ef3, 6); ar = rotl(ar, 10)
  cr = fn3(cr, dr, er, ar, br, m[6], 0x6d703ef3, 6); er = rotl(er, 10)
  br = fn3(br, cr, dr, er, ar, m[9], 0x6d703ef3, 14); dr = rotl(dr, 10)
  ar = fn3(ar, br, cr, dr, er, m[11], 0x6d703ef3, 12); cr = rotl(cr, 10)
  er = fn3(er, ar, br, cr, dr, m[8], 0x6d703ef3, 13); br = rotl(br, 10)
  dr = fn3(dr, er, ar, br, cr, m[12], 0x6d703ef3, 5); ar = rotl(ar, 10)
  cr = fn3(cr, dr, er, ar, br, m[2], 0x6d703ef3, 14); er = rotl(er, 10)
  br = fn3(br, cr, dr, er, ar, m[10], 0x6d703ef3, 13); dr = rotl(dr, 10)
  ar = fn3(ar, br, cr, dr, er, m[0], 0x6d703ef3, 13); cr = rotl(cr, 10)
  er = fn3(er, ar, br, cr, dr, m[4], 0x6d703ef3, 7); br = rotl(br, 10)
  dr = fn3(dr, er, ar, br, cr, m[13], 0x6d703ef3, 5); ar = rotl(ar, 10)

  // M'j = 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14
  // K' = 0x7a6d76e9
  // S'j = 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8
  cr = fn2(cr, dr, er, ar, br, m[8], 0x7a6d76e9, 15); er = rotl(er, 10)
  br = fn2(br, cr, dr, er, ar, m[6], 0x7a6d76e9, 5); dr = rotl(dr, 10)
  ar = fn2(ar, br, cr, dr, er, m[4], 0x7a6d76e9, 8); cr = rotl(cr, 10)
  er = fn2(er, ar, br, cr, dr, m[1], 0x7a6d76e9, 11); br = rotl(br, 10)
  dr = fn2(dr, er, ar, br, cr, m[3], 0x7a6d76e9, 14); ar = rotl(ar, 10)
  cr = fn2(cr, dr, er, ar, br, m[11], 0x7a6d76e9, 14); er = rotl(er, 10)
  br = fn2(br, cr, dr, er, ar, m[15], 0x7a6d76e9, 6); dr = rotl(dr, 10)
  ar = fn2(ar, br, cr, dr, er, m[0], 0x7a6d76e9, 14); cr = rotl(cr, 10)
  er = fn2(er, ar, br, cr, dr, m[5], 0x7a6d76e9, 6); br = rotl(br, 10)
  dr = fn2(dr, er, ar, br, cr, m[12], 0x7a6d76e9, 9); ar = rotl(ar, 10)
  cr = fn2(cr, dr, er, ar, br, m[2], 0x7a6d76e9, 12); er = rotl(er, 10)
  br = fn2(br, cr, dr, er, ar, m[13], 0x7a6d76e9, 9); dr = rotl(dr, 10)
  ar = fn2(ar, br, cr, dr, er, m[9], 0x7a6d76e9, 12); cr = rotl(cr, 10)
  er = fn2(er, ar, br, cr, dr, m[7], 0x7a6d76e9, 5); br = rotl(br, 10)
  dr = fn2(dr, er, ar, br, cr, m[10], 0x7a6d76e9, 15); ar = rotl(ar, 10)
  cr = fn2(cr, dr, er, ar, br, m[14], 0x7a6d76e9, 8); er = rotl(er, 10)

  // M'j = 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
  // K' = 0x00000000
  // S'j = 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
  br = fn1(br, cr, dr, er, ar, m[12], 0x00000000, 8); dr = rotl(dr, 10)
  ar = fn1(ar, br, cr, dr, er, m[15], 0x00000000, 5); cr = rotl(cr, 10)
  er = fn1(er, ar, br, cr, dr, m[10], 0x00000000, 12); br = rotl(br, 10)
  dr = fn1(dr, er, ar, br, cr, m[4], 0x00000000, 9); ar = rotl(ar, 10)
  cr = fn1(cr, dr, er, ar, br, m[1], 0x00000000, 12); er = rotl(er, 10)
  br = fn1(br, cr, dr, er, ar, m[5], 0x00000000, 5); dr = rotl(dr, 10)
  ar = fn1(ar, br, cr, dr, er, m[8], 0x00000000, 14); cr = rotl(cr, 10)
  er = fn1(er, ar, br, cr, dr, m[7], 0x00000000, 6); br = rotl(br, 10)
  dr = fn1(dr, er, ar, br, cr, m[6], 0x00000000, 8); ar = rotl(ar, 10)
  cr = fn1(cr, dr, er, ar, br, m[2], 0x00000000, 13); er = rotl(er, 10)
  br = fn1(br, cr, dr, er, ar, m[13], 0x00000000, 6); dr = rotl(dr, 10)
  ar = fn1(ar, br, cr, dr, er, m[14], 0x00000000, 5); cr = rotl(cr, 10)
  er = fn1(er, ar, br, cr, dr, m[0], 0x00000000, 15); br = rotl(br, 10)
  dr = fn1(dr, er, ar, br, cr, m[3], 0x00000000, 13); ar = rotl(ar, 10)
  cr = fn1(cr, dr, er, ar, br, m[9], 0x00000000, 11); er = rotl(er, 10)
  br = fn1(br, cr, dr, er, ar, m[11], 0x00000000, 11); dr = rotl(dr, 10)

  // change state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = __webpack_require__(621)
exports.sha1 = __webpack_require__(622)
exports.sha224 = __webpack_require__(623)
exports.sha256 = __webpack_require__(349)
exports.sha384 = __webpack_require__(624)
exports.sha512 = __webpack_require__(350)


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(156).EventEmitter;
var inherits = __webpack_require__(7);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(160);
Stream.Writable = __webpack_require__(619);
Stream.Duplex = __webpack_require__(614);
Stream.Transform = __webpack_require__(618);
Stream.PassThrough = __webpack_require__(617);

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = __webpack_require__(5).Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(620);
var global = __webpack_require__(573);
exports.setImmediate = global.setImmediate;
exports.clearImmediate = global.clearImmediate;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return __webpack_require__(443);
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return __webpack_require__(1).merge(
    __webpack_require__(1),
    __webpack_require__(6),
    __webpack_require__(55)
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["FluxComponent", "Element", "TextElement", "StyleProps"],
    [global, __webpack_require__(18)],
    (FluxComponent, Element, TextElement, StyleProps) => {
      let Affirmations;
      return (Affirmations = Caf.defClass(
        class Affirmations extends FluxComponent {},
        function(Affirmations, classSuper, instanceSuper) {
          this.subscriptions({ affirmations: { model: "allAffirmations" } });
          this.prototype.render = function() {
            return Element(
              { childrenLayout: "column", childrenMargins: 10, padding: 10 },
              TextElement(
                StyleProps.textStyle,
                { align: 0.5 },
                "Affirmations - WIP"
              )
            );
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    [
      "FluxComponent",
      "codeWords",
      "Element",
      "StyleProps",
      "TextElement",
      "ScrollElement",
      "Needs"
    ],
    [global, __webpack_require__(18)],
    (
      FluxComponent,
      codeWords,
      Element,
      StyleProps,
      TextElement,
      ScrollElement,
      Needs
    ) => {
      let NeedStatus, NeedsDashboardSection, NeedsDashboard;
      NeedStatus = Caf.defClass(
        class NeedStatus extends FluxComponent {},
        function(NeedStatus, classSuper, instanceSuper) {
          this.subscriptions({
            status: function({ need }) {
              return need;
            }
          });
          this.prototype.pointerClick = function() {
            return this.models.navState.setKeyPath([
              "needs",
              this.props.category,
              this.props.need
            ]);
          };
          this.prototype.render = function() {
            let initials, cafTemp;
            initials = codeWords(this.props.need)[0].slice(0, 3);
            return Element(
              {
                cursor: "pointer",
                size: 44,
                margin: 2,
                on: { pointerClick: this.pointerClick },
                draw: [
                  { radius: 3 },
                  (cafTemp = StyleProps.colors[this.status]) != null
                    ? cafTemp
                    : "#eee"
                ]
              },
              TextElement(
                StyleProps.textStyle,
                { fontSize: 9, align: 0.5, color: "#0006" },
                initials
              )
            );
          };
        }
      );
      NeedsDashboardSection = Caf.defClass(
        class NeedsDashboardSection extends FluxComponent {},
        function(NeedsDashboardSection, classSuper, instanceSuper) {
          this.getter({
            sortedNeeds: function() {
              let statusMap;
              statusMap = this.models.status.state;
              return Caf.array(this.props.needs, (v, need) => {
                let cafTemp;
                return {
                  need,
                  status: (cafTemp = statusMap[need]) != null ? cafTemp : 0
                };
              }).sort(
                (a, b) => b.status - a.status || a.need.localeCompare(b.need)
              );
            }
          });
          this.prototype.render = function() {
            return Element(
              {
                size: "parentWidthChildrenHeight",
                childrenLayout: "column",
                childrenMargins: 10
              },
              TextElement(
                StyleProps.textStyle,
                { size: "childrenSize" },
                this.props.category
              ),
              Element(
                {
                  childrenLayout: "flow",
                  childrenMargins: 1,
                  size: "parentWidthChildrenHeight",
                  padding: { h: 10 },
                  draw: ["padded", "children"]
                },
                Caf.array(this.sortedNeeds, ({ need }) =>
                  NeedStatus({ category: this.props.category, need })
                )
              )
            );
          };
        }
      );
      return (NeedsDashboard = Caf.defClass(
        class NeedsDashboard extends FluxComponent {},
        function(NeedsDashboard, classSuper, instanceSuper) {
          this.prototype.render = function() {
            return ScrollElement(
              { childrenLayout: "column", childrenMargins: 20, padding: 10 },
              Caf.array(Needs, (needs, category) =>
                NeedsDashboardSection({ category, needs })
              )
            );
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["FluxComponent", "Element", "TextInputElement", "TextElement"],
    [global, __webpack_require__(18)],
    (FluxComponent, Element, TextInputElement, TextElement) => {
      let SearchBar;
      return (SearchBar = Caf.defClass(
        class SearchBar extends FluxComponent {},
        function(SearchBar, classSuper, instanceSuper) {
          this.prototype.valueChanged = function({ props }) {
            return this.models.navState.search(props.value);
          };
          this.prototype.render = function() {
            return Element(
              {
                childrenLayout: "row",
                size: { ww: 1, h: 50 },
                padding: { h: 10 },
                animators: { size: { toFrom: { ww: 1, h: 0 } } },
                clip: true
              },
              Element(
                {
                  padding: 5,
                  draw: { padding: 5, color: "#e8e8e8", radius: 1000 }
                },
                TextInputElement({
                  padding: { h: 15 },
                  placeholder: "search needs and emotions",
                  on: { valueChanged: this.valueChanged },
                  value: this.models.navState.searchQuery
                })
              ),
              TextElement({
                size: "childrenSize",
                padding: 5,
                text: "",
                location: { ps: 0.5 },
                axis: "centerCenter",
                layoutMode: "tight",
                fontSize: 32
              })
            );
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    [
      "FluxComponent",
      "Element",
      "BitmapElement",
      "StyleProps",
      "TextElement",
      "dataNodes"
    ],
    [global, __webpack_require__(18), __webpack_require__(24)],
    (
      FluxComponent,
      Element,
      BitmapElement,
      StyleProps,
      TextElement,
      dataNodes
    ) => {
      let SetStatusWidget;
      return (SetStatusWidget = Caf.defClass(
        class SetStatusWidget extends FluxComponent {},
        function(SetStatusWidget, classSuper, instanceSuper) {
          this.subscriptions("viewState.viewState", {
            status: function(props) {
              return props.key;
            }
          });
          this.stateFields({ descriptionFocused: false });
          this.getter({
            status: function() {
              return this.state.status || 3;
            },
            landscape: function() {
              return this.viewState.deviceSize.aspectRatio > 1;
            }
          });
          this.prototype.toggleDescriptionFocused = function() {
            return (this.descriptionFocused = !this.descriptionFocused);
          };
          this.prototype.updateFromPointerEvent = function({
            location,
            target
          }) {
            let x, y;
            ({ x, y } = target.currentSize);
            return this.models.status.set(
              this.props.key,
              (location.x - y / 2) / (x - y) * 4 + 1
            );
          };
          this.prototype.renderBitmap = function() {
            return Element(
              { size: this.landscape ? { hh: 1, wh: 1 } : { ps: 1 } },
              BitmapElement({
                key: `${Caf.toString(this.status)}`,
                location: { ps: 0.5 },
                axis: 0.5,
                size: (ps, cs) => (ps.gt(cs) ? cs : cs.mul(ps.div(cs).min())),
                animators: { opacity: { from: 0, to: 0.99 } },
                source:
                  "assets/" +
                  (() => {
                    switch (this.status) {
                      case 1:
                        return "winter.png";
                      case 2:
                        return "fall.png";
                      case 3:
                        return "unknown.png";
                      case 4:
                        return "summer.png";
                      case 5:
                        return "spring.png";
                    }
                  })()
              })
            );
          };
          this.prototype.renderDescription = function() {
            let textStyle;
            ({ textStyle } = StyleProps);
            return TextElement(textStyle, {
              axis: { x: 0.5 },
              location: { xw: 0.5 },
              size: { w: 300, h: 6 * textStyle.fontSize * textStyle.leading },
              align: "centerCenter",
              text: dataNodes[this.props.key].description,
              margin: { bottom: 20 }
            });
          };
          this.prototype.renderText = function() {
            return TextElement(StyleProps.textStyle, {
              color: StyleProps.colors[this.status],
              text: StyleProps.statuses[this.status],
              margin: 10,
              size: "childrenSize"
            });
          };
          this.prototype.renderSlider = function() {
            let size;
            return Element(
              {
                size: (size = { w: 300, h: 44 }),
                margin: 10,
                cursor: "pointer",
                on: {
                  pointerUp: this.updateFromPointerEvent,
                  pointerMove: this.updateFromPointerEvent
                },
                draw: { padding: 15, radius: 10000, color: "#0001" }
              },
              Element({
                size: 40,
                animators: ["draw", "location"],
                axis: "centerCenter",
                location: {
                  yh: 0.5,
                  x: (size.w - size.h) * (this.status - 1) / 4 + size.h / 2
                },
                draw: [
                  "circle",
                  { color: StyleProps.colors[this.status], shadow: true },
                  { outline: { lineWidth: 2, color: "white" } }
                ]
              })
            );
          };
          this.prototype.renderLandscape = function() {
            return Element(
              { childrenLayout: "row", childrenAlignment: "center" },
              this.renderBitmap(),
              Element(
                {
                  childrenLayout: "column",
                  childrenAlignment: "bottomCenter",
                  padding: { bottom: 10 }
                },
                this.renderDescription(),
                this.renderText(),
                this.renderSlider()
              )
            );
          };
          this.prototype.renderPortrait = function() {
            return Element(
              {
                childrenLayout: "column",
                childrenAlignment: "center",
                padding: { bottom: 25 }
              },
              this.renderBitmap(),
              this.renderDescription(),
              this.renderText(),
              this.renderSlider()
            );
          };
          this.prototype.render = function() {
            return Element(
              this.viewState.deviceSize
                ? this.landscape
                  ? this.renderLandscape()
                  : this.renderPortrait()
                : undefined
            );
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["FluxComponent", "Element", "dataNodes", "TextElement"],
    [global, __webpack_require__(18), __webpack_require__(24)],
    (FluxComponent, Element, dataNodes, TextElement) => {
      let ShowPath;
      return (ShowPath = Caf.defClass(
        class ShowPath extends FluxComponent {},
        function(ShowPath, classSuper, instanceSuper) {
          this.subscriptions("navState.keyPath");
          this.prototype.render = function() {
            return Element(
              {
                childrenLayout: "row",
                clip: true,
                size: { ww: 1, hch: 1 },
                animators: { size: { toFrom: { ww: 1, h: 0 } } }
              },
              Caf.array(this.keyPath, (key, i) => [
                __webpack_require__(105)({ key }),
                dataNodes[key].childKeys
                  ? TextElement({
                      align: "centerCenter",
                      size: "parentHeightChildrenWidth",
                      text: "",
                      fontSize: 28,
                      layoutMode: "tight",
                      color: "#bbb"
                    })
                  : undefined
              ])
            );
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["HotStyleProps"],
    [global, __webpack_require__(17)],
    HotStyleProps => {
      let StyleProps;
      return (StyleProps = Caf.defClass(
        class StyleProps extends HotStyleProps {},
        function(StyleProps, classSuper, instanceSuper) {
          this.primaryColor = "#ccc";
          this.leafColor = "#ccc";
          this.textStyle = {
            color: "#000a",
            fontFamily: "sans-serif",
            fontSize: 18,
            leading: 1.25
          };
          this.statuses = {
            1: "Tragically unfulfilled",
            2: "Somewhat unfulfilled",
            3: "Undecided",
            4: "Somewhat fulfilled",
            5: "Joyfully fulfilled"
          };
          this.colors = {
            1: "#bd954c",
            2: "#f5b87a",
            3: "#bbb",
            4: "#a7df6f",
            5: "#ffa9f7"
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return {
    living: {
      sustenance: "Getting all the healthy food and clean water my body needs.",
      sleep:
        "Getting pleanty of sleep. Waking every day fully rested and alive.\n\nadult: 7.5 to 9 hours\nteen: 9 to 9.5 hours",
      climate:
        "At work, at home and everywhere in between: Cozy and warm when it's cold outside, shady and cool when it's hot, dry and clean when it's wet, moist and refreshed when it's dry.",
      health: "Feeling 100% well, or healing and on the way to full recovery.",
      energy: "Rested, restored, energized and vital.",
      safety: "Living free from violence, accidents, illness and disasters.",
      security: "Life is stable, predictable, and sustainable. Certainty.",
      children: "All the time with children one wants.",
      comfort:
        "All the built-things around me support my body's health and comfort including: clothing and tools, in the bathroom, kitchen, and bedroom, while exercising or working."
    },
    thriving: {
      pleasure:
        "Plenty of rejuvenating light and darkness, lovely fragrances, pleasurable textures, wonderful music, delicious food and drink. All five senses are simulated and alive.",
      movement: "Plenty of exercise, movement and dance.",
      variety: "Plenty of variety and novelty. Uncertainty.",
      leisure:
        "Plenty of comforable, relaxing time without stress or expectations.",
      solitude:
        "Plenty of quiet, solo, alone time. Recharge-time for the introvert.",
      play:
        "Plenty of adventure, excitement, fantasy, fun, humor, joy and laughter.",
      sharing:
        "For each important experience, interest and value, having plenty of people who understand and share ones passions.",
      physical_bonding: "Plenty of hugs, touch, cuddles and sexual-connection.",
      connection:
        "Plenty of close, meaningful relationships with friends, family and lovers. A sense of openness, good communication, intimate sharing, companionship, and feeling free to be 100% oneself with those people.",
      social_balance: "All important relationships are balanced and mutual.",
      belonging:
        "Accepted, acknowledged, included and equal. Valued and have influence within your groups.",
      participation:
        "Plenty of collaboration, cooperation, opportunities for service and sharing.",
      appreciation: "Valued, recognized, and wanted.",
      nurturing:
        "Receiving all the care, help, kindness, affection, support and helpful feedback one needs.",
      understanding:
        "Feeling completely understood by those who matter: empathized, heard, known, seen and respected.",
      compassion:
        'Receiving all the attention, consideration, forgiveness, presence, tenderness, vulnerability and love one needs."',
      social_safety:
        'All important relationships are reliable, honest, and full of mutual trust. All relationships, of any kind, are consensual, just, respecting of privacy, respecting of boundaries and completely safe. # mourning: #   "" #                   Plenty of space, time and support to morn a loss.'
    },
    transcending: {
      acceptance:
        "Accept and love oneself. Allow, approve, care, have empathy and compassion for oneself Trust and honest with oneself",
      awareness:
        "Know oneself at ever deeper levels. Needs and emotional awareness Know one's genius, strengths and weaknesses Know what does and doesn't work fulfilling one's own needs.",
      progress:
        "To make progress and accomplishment in one's own life. To see improvement over time of one's external circumstance.",
      growth: "Intentionally and continually improve oneself.",
      expression:
        "Create and be creative. Imagine, innovate and invent. Actualize and realize ones dreams fully.",
      respect:
        "Respect oneself and be worthy of others' respect. Ingredients: responsible, authentic, confident, courageous, dignified, honorable, honest, worthy, always acting with integrity",
      autonomy:
        "Feeling enabled, empowered and in control. Feeling free to make ones own choices and be spontaneous. Given complete flexibility and independence. Feeling limitless, full of possibility and full of potential.",
      engagement: "Plenty of flow, mindfulness and gratitude.",
      mastery:
        "Competent, efficient and effective. Constantly improving, feeling ever more skillful and masterful. Mentally stimulated and challenged.",
      meaning:
        "Ever deepening understanding and celebration of life, the universe and everything, including: perspective, awareness, celebration, deepening, discovery, exploration, legacy and spirituality.",
      peace:
        "Complete ease, balance, clarity, faith, grace, sanctuary, harmony, hope, order, structure, tranquility, unity and oneness with the universe. A sense of stillness.",
      beauty:
        "My life is beautiful. My home, workplace, city, public spaces, people, landscape, and personal possessions all stimulate my sense of beauty.",
      purpose:
        "Have a greater purpose, impact, importance, doing something that matters, contribute something of significance, dedication, inspiration, passion and vision. Dream vividly of a better world and a better life."
    }
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return {
    afraid:
      "apprehensive dread foreboding frightened mistrustful panicked petrified scared suspicious terrified wary worried",
    annoyed:
      "aggravated dismayed disgruntled displeased exasperated frustrated impatient irritated irked",
    angry: "enraged furious incensed indignant irate livid outraged resentful",
    aversion:
      "animosity appalled contempt disgusted dislike hate horrified hostile repulsed",
    confused:
      "ambivalent baffled bewildered dazed hesitant lost mystified perplexed puzzled torn",
    disconnected:
      "alienated aloof apathetic bored cold detached distant distracted indifferent numb removed uninterested withdrawn",
    disquiet:
      "agitated alarmed discombobulated disconcerted disturbed perturbed rattled restless shocked startled surprised troubled turbulent turmoil uncomfortable uneasy unnerved unsettled upset",
    embarrassed: "ashamed chagrined flustered guilty mortified self-conscious",
    fatigued:
      "beat burnt-out depleted exhausted lethargic listless sleepy tired weary worn-out",
    pain:
      "agony anguished bereaved devastated grief heartbroken hurt lonely miserable regretful remorseful",
    sad:
      "depressed dejected despair despondent disappointed discouraged disheartened forlorn gloomy heavy-hearted hopeless melancholy unhappy wretched",
    tense:
      "anxious cranky distressed distraught edgy fidgety frazzled irritable jittery nervous overwhelmed restless stressed out",
    vulnerable:
      "fragile guarded helpless insecure leery reserved sensitive shaky",
    yearning: "envious jealous longing nostalgic pining wistful"
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return {
    affectionate:
      "compassionate friendly loving open-hearted sympathetic tender warm",
    engaged:
      "absorbed alert curious engrossed enchanted entranced fascinated interested intrigued involved spellbound stimulated",
    hopeful: "expectant encouraged optimistic",
    confident: "empowered open proud safe secure",
    excited:
      "amazed animated ardent aroused astonished dazzled eager energetic enthusiastic giddy invigorated lively passionate surprised vibrant",
    grateful: "appreciative moved thankful touched",
    inspired: "amazed awed wonder",
    joyful: "amused delighted glad happy jubilant pleased tickled",
    exhilarated:
      "blissful ecstatic elated enthralled exuberant radiant rapturous thrilled",
    peaceful:
      "calm clear-headed comfortable centered content equanimous fulfilled mellow quiet relaxed relieved satisfied serene still tranquil trusting"
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["Error", "merge", "isPlainObject", "Object", "isString"],
    [global, __webpack_require__(17)],
    (Error, merge, isPlainObject, Object, isString) => {
      let flatten;
      return {
        flatten: (flatten = function(
          map,
          intoObject = {},
          parentKey,
          rootKey,
          depth = -1
        ) {
          if (!rootKey && parentKey !== "core") {
            rootKey = parentKey;
          }
          return Caf.object(
            map,
            (v, k) => {
              if (intoObject[k]) {
                throw new Error(`key ${Caf.toString(k)} already exists`);
              }
              return merge(
                isPlainObject(v)
                  ? (flatten(v, intoObject, k, rootKey, depth + 1),
                    { childKeys: Object.keys(v) })
                  : isString(v)
                    ? { description: v }
                    : undefined,
                { key: k, parentKey, rootKey, depth }
              );
            },
            null,
            intoObject
          );
        })
      };
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(7);
var Reporter = __webpack_require__(51).Reporter;
var Buffer = __webpack_require__(5).Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = __webpack_require__(369);


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(7);

var asn1 = __webpack_require__(50);
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(7);
var Buffer = __webpack_require__(5).Buffer;

var asn1 = __webpack_require__(50);
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(634);
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(64)
var Transform = __webpack_require__(25)
var inherits = __webpack_require__(7)
var GHASH = __webpack_require__(378)
var xor = __webpack_require__(52)
inherits(StreamCipher, Transform)
module.exports = StreamCipher

function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])])
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])])
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  iv.copy(this._prev)
  this._mode = mode
  var h = new Buffer(4)
  h.fill(0)
  this._ghash = new GHASH(this._cipher.encryptBlock(h))
  this._authTag = null
  this._called = false
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = new Buffer(rump)
      rump.fill(0)
      this._ghash.update(rump)
    }
  }
  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data')
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data')
    }
  } else {
    this._authTag = tag
  }
  this._cipher.scrub()
}
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag
  } else {
    throw new Error('Attempting to get auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag
  } else {
    throw new Error('Attempting to set auth tag in unsupported state')
  }
}
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf)
    this._alen += buf.length
  } else {
    throw new Error('Attempting to set AAD in unsupported state')
  }
}
function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) {
    out++
  }
  var len = Math.min(a.length, b.length)
  var i = -1
  while (++i < len) {
    out += (a[i] ^ b[i])
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

var xor = __webpack_require__(52)

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(52)

exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('')
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = new Buffer('')
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}
function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}
function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = new Buffer(buffer.length)
  buffer = Buffer.concat([buffer, new Buffer([value])])
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt ? byteParam : out])])
  return out
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = new Buffer(len)
  var i = -1
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }
  return out
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 188 */
/***/ (function(module, exports) {

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}
exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var xor = __webpack_require__(52)

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(64)
var Transform = __webpack_require__(25)
var inherits = __webpack_require__(7)

inherits(StreamCipher, Transform)
module.exports = StreamCipher
function StreamCipher (mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv)
  }
  Transform.call(this)
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  this._cache = new Buffer('')
  this._secCache = new Buffer('')
  this._decrypt = decrypt
  iv.copy(this._prev)
  this._mode = mode
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}
StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var AtomicBase, Color, Foundation, abs, bound, colorFloatEq, float32Eq, float32Eq0, hex16ColorRegex, hex256ColorRegex, inspect, isString, log, max, min, modulo, object, pad, parseRGBColorComponent, rgbColorRegex, rgbaColorRegex,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

AtomicBase = __webpack_require__(35);

inspect = Foundation.inspect, bound = Foundation.bound, modulo = Foundation.modulo, pad = Foundation.pad, min = Foundation.min, max = Foundation.max, abs = Foundation.abs, float32Eq = Foundation.float32Eq, isString = Foundation.isString, log = Foundation.log, hex16ColorRegex = Foundation.hex16ColorRegex, hex256ColorRegex = Foundation.hex256ColorRegex, rgbColorRegex = Foundation.rgbColorRegex, rgbaColorRegex = Foundation.rgbaColorRegex, float32Eq0 = Foundation.float32Eq0, object = Foundation.object;

colorFloatEq = float32Eq;

parseRGBColorComponent = function(str) {
  var percentIndex;
  if ((percentIndex = str.indexOf('%')) !== -1) {
    return (str.slice(0, percentIndex) | 0) * .01;
  } else {
    return (str | 0) * 1 / 255;
  }
};

module.exports = Color = (function(superClass) {
  var colorNames, colorNamesMap, defaultAlpha, hexString, hslColor, isColor, k, parseCache, rgbColor, v, withSat, zeroString;

  extend(Color, superClass);

  function Color() {
    return Color.__super__.constructor.apply(this, arguments);
  }

  Color.defineAtomicClass({
    fieldNames: "r g b a",
    constructorFunctionName: "rgbColor"
  });

  Color.isColor = isColor = function(c) {
    return !!((c != null ? c.constructor : void 0) === Color);
  };

  Color.colorNames = colorNames = ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];

  Color.colorNamesMap = colorNamesMap = {
    transparent: "rgba(0,0,0,0)",
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgrey: "#a9a9a9",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategrey: "#2f4f4f",
    darkslategray: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgrey: "#696969",
    dimgray: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    grey: "#808080",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgrey: "#d3d3d3",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategrey: "#778899",
    lightslategray: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategrey: "#708090",
    slategray: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };

  Color.parseCache = parseCache = {};

  defaultAlpha = 1;

  Color.rgbColor = rgbColor = function(a, b, c, d) {
    var clr;
    if ((b == null) && isColor(a)) {
      return a;
    }
    if (isString(a) && (clr = colorNamesMap[a] || parseCache[a])) {
      return clr;
    }
    return new Color(a, b, c, d);
  };

  Color.rgb256Color = function(a, b, c, d) {
    var clr, out;
    if ((b == null) && isColor(a)) {
      return a;
    }
    if (isString(a) && (clr = colorNamesMap[a] || parseCache[a])) {
      return clr;
    }
    defaultAlpha = 255;
    out = new Color(a, b, c, d);
    defaultAlpha = 1;
    out.r /= 255;
    out.g /= 255;
    out.b /= 255;
    out.a /= 255;
    return out;
  };

  Color.newColor = rgbColor;

  Color.color = function(a, b, c, d) {
    log.error("Atomic.color DEPRICATED. Use rgbColor.");
    return rgbColor(a, b, c, d);
  };

  Color.hslColor = hslColor = function(h, s, l, a) {
    var f, p, phase, q, t;
    if (a == null) {
      a = 1;
    }
    if (isColor(h)) {
      return h;
    }
    h = modulo(h, 1);
    phase = h * 6 | 0;
    f = h * 6 - phase;
    p = l * (1 - s);
    q = l * (1 - f * s);
    t = l * (1 - (1 - f) * s);
    h = colorFloatEq(h, 1) ? 1 : h % 1;
    switch (phase % 6) {
      case 0:
        return new Color(l, t, p, a, h, s, l);
      case 1:
        return new Color(q, l, p, a, h, s, l);
      case 2:
        return new Color(p, l, t, a, h, s, l);
      case 3:
        return new Color(p, q, l, a, h, s, l);
      case 4:
        return new Color(t, p, l, a, h, s, l);
      case 5:
        return new Color(l, p, q, a, h, s, l);
    }
  };

  Color.parse = function(string, existing) {
    if (existing == null) {
      existing = null;
    }
    if (existing) {
      throw new Error("existing feature is no longer supported");
    }
    return new Artomic.Color(string);
  };

  Color.prototype._initFromObject = function(obj) {
    return this.r = obj.r, this.g = obj.g, this.b = obj.b, this.a = obj.a, obj;
  };

  Color.prototype._initFromString = function(string) {
    var a, b, clr, elements, g, lcString, match, r, x;
    this.initProperties();
    parseCache[string] = this;
    if (match = string.match(hex16ColorRegex)) {
      x = match[0], r = match[1], g = match[2], b = match[3], a = match[4];
      if (!a) {
        this._htmlColorString = string;
      }
      a || (a = "f");
      this.r = parseInt(r, 16) / 15;
      this.g = parseInt(g, 16) / 15;
      this.b = parseInt(b, 16) / 15;
      return this.a = parseInt(a, 16) / 15;
    } else if (match = string.match(hex256ColorRegex)) {
      x = match[0], r = match[1], g = match[2], b = match[3], a = match[4];
      if (!a) {
        this._htmlColorString = string;
      }
      a || (a = "ff");
      this.r = parseInt(r, 16) / 255;
      this.g = parseInt(g, 16) / 255;
      this.b = parseInt(b, 16) / 255;
      return this.a = parseInt(a, 16) / 255;
    } else if (elements = string.match(rgbColorRegex)) {
      this._htmlColorString = string;
      this.a = 1;
      this.r = parseRGBColorComponent(elements[1]);
      this.g = parseRGBColorComponent(elements[2]);
      return this.b = parseRGBColorComponent(elements[3]);
    } else if (elements = string.match(rgbaColorRegex)) {
      this._htmlColorString = string;
      this.r = parseRGBColorComponent(elements[1]);
      this.g = parseRGBColorComponent(elements[2]);
      this.b = parseRGBColorComponent(elements[3]);
      return this.a = elements[4] - 0;
    } else if (/^[a-z]+$/i.test(lcString = string.toLowerCase())) {
      if (!(clr = colorNamesMap[lcString])) {
        return this.log({
          parseError: this.parseError = "WARNING: Color.parse failure. Unknown rgbColor name: " + (inspect(string))
        });
      }
      this._htmlColorString = clr._htmlColorString;
      this.r = clr.r;
      this.g = clr.g;
      this.b = clr.b;
      return this.a = clr.a;
    } else if (/^([a-f0-9]{3,4}|[a-f0-9]{6}|[a-f0-9]{8})$/i.test(string)) {
      return this._initFromString("#" + string);
    } else {
      return this.log({
        parseError: this.parseError = "WARNING: Color.parse failure for " + (inspect(string))
      });
    }
  };

  Color.prototype.initProperties = function() {
    this.r = this.g = this.b = 0;
    this.a = defaultAlpha;
    this._hue = this._saturation = this._lightness = null;
    this.parseError = null;
    return this._htmlColorString = null;
  };

  Color.prototype._init = function(a, b, c, d, h, s, l) {
    this.initProperties();
    if (h != null) {
      this._hue = h - 0;
    }
    if (s != null) {
      this._saturation = s - 0;
    }
    if (l != null) {
      this._lightness = l - 0;
    }
    if (a == null) {
      return this.r = this.g = this.b = 0;
    } else if (b == null) {
      return this.r = this.g = this.b = a - 0;
    } else if (c != null) {
      this.r = a - 0;
      this.g = b - 0;
      this.b = c - 0;
      if (d != null) {
        return this.a = d - 0;
      }
    }
  };

  Color.prototype.interpolate = function(toColor, p) {
    var a, b, g, oneMinusP, r, ref;
    ref = this, r = ref.r, g = ref.g, b = ref.b, a = ref.a;
    toColor = rgbColor(toColor);
    if (float32Eq0(a)) {
      r = toColor.r, g = toColor.g, b = toColor.b;
    }
    if (float32Eq0(toColor.a)) {
      toColor = this.withAlpha(0);
    }
    oneMinusP = 1 - p;
    return new Color(toColor.r * p + r * oneMinusP, toColor.g * p + g * oneMinusP, toColor.b * p + b * oneMinusP, toColor.a * p + a * oneMinusP);
  };

  Color.prototype.blend = function(color, amount) {
    var a, b, g, r, ref;
    color = rgbColor(color);
    ref = this, r = ref.r, g = ref.g, b = ref.b, a = ref.a;
    switch (false) {
      case amount == null:
        return new Color((color.r - r) * amount + r, (color.g - g) * amount + g, (color.b - b) * amount + b, (color.a - a) * amount + a);
      case !colorFloatEq(color.a, 1):
        return color;
      case !colorFloatEq(color.a, 0):
        return this;
      default:
        amount = color.a;
        return new Color((color.r - r) * amount + r, (color.g - g) * amount + g, (color.b - b) * amount + b, (1 - a) * amount + a);
    }
  };

  Color.prototype.withAlpha = function(a) {
    return new Color(this.r, this.g, this.b, a);
  };

  Color.prototype.withLightness = function(v) {
    return hslColor(this.h, this.s, v, this.a);
  };

  Color.prototype.withHue = function(v) {
    return hslColor(v, this.s, this.l, this.a);
  };

  Color.prototype.withHueShift = function(amount) {
    return hslColor(this.h + amount, this.s, this.l, this.a);
  };

  Color.prototype.withSat = withSat = function(v) {
    return hslColor(this.h, v, this.l, this.a);
  };

  Color.prototype.withSaturation = withSat;

  Color.prototype.withScaledLightness = function(s) {
    return hslColor(this.h, this.s, s * this.l, this.a);
  };

  Color.prototype.withScaledSaturation = function(s) {
    return hslColor(this.h, s * this.s, this.l, this.a);
  };

  Color.prototype.withScaledLAndS = function(l, s) {
    return hslColor(this.h, s * this.s, l * this.l, this.a);
  };

  Color.prototype.withChannel = function(c, v) {
    switch (c) {
      case "r":
      case "red":
        return new Color(v, this.g, this.b, this.a);
      case "g":
      case "green":
        return new Color(this.r, v, this.b, this.a);
      case "b":
      case "blue":
        return new Color(this.r, this.g, v, this.a);
      case "h":
      case "hue":
        return hslColor(v, this.s, this.l, this.a);
      case "s":
      case "sat":
      case "saturation":
        return hslColor(this.h, v, this.l, this.a);
      case "l":
      case "lightness":
        return this.withLightness(v);
      case "a":
      case "alpha":
        return this.withAlpha(v);
      default:
        throw new Error("invalid channel: " + (inspect(c)));
    }
  };

  Color.prototype.withChannels = function(c) {
    var a, b, g, h, l, r, s;
    if (c.h || c.s || c.l) {
      h = c.h != null ? c.h : this.h;
      s = c.s != null ? c.s : this.s;
      l = c.l != null ? c.l : this.l;
      a = c.a != null ? c.a : this.a;
      return hslColor(h, s, l, a);
    } else {
      r = c.r != null ? c.r : this.r;
      g = c.g != null ? c.g : this.g;
      b = c.b != null ? c.b : this.b;
      a = c.a != null ? c.a : this.a;
      return new Color(r, g, b, a);
    }
  };

  zeroString = "0";

  hexString = function(number, length) {
    if (length == null) {
      length = 2;
    }
    return pad(number.toString(16), length, zeroString, true);
  };

  Color.getter({
    arrayRGB: function() {
      return [this.r, this.g, this.b];
    },
    arrayRgb: function() {
      return [this.r, this.g, this.b];
    },
    arrayHsl: function() {
      return this._computeHsl() && [this._hue, this._saturation, this._lightness];
    },
    rgbSum: function() {
      return this.r + this.g + this.b;
    },
    rgbSquaredSum: function() {
      return this.r * this.r + this.g * this.g + this.b * this.b;
    },
    clamped: function() {
      return new Color(bound(0, this.r, 1), bound(0, this.g, 1), bound(0, this.b, 1), bound(0, this.a, 1));
    },
    r256: function() {
      return bound(0, Math.round(this.r * 255), 255);
    },
    g256: function() {
      return bound(0, Math.round(this.g * 255), 255);
    },
    b256: function() {
      return bound(0, Math.round(this.b * 255), 255);
    },
    a256: function() {
      return bound(0, Math.round(this.a * 255), 255);
    },
    r16: function() {
      return bound(0, Math.round(this.r * 15), 15);
    },
    g16: function() {
      return bound(0, Math.round(this.g * 15), 15);
    },
    b16: function() {
      return bound(0, Math.round(this.b * 15), 15);
    },
    a16: function() {
      return bound(0, Math.round(this.a * 15), 15);
    },
    h256: function() {
      return bound(0, Math.round(this.h * 255), 255);
    },
    s256: function() {
      return bound(0, Math.round(this.s * 255), 255);
    },
    b256: function() {
      return bound(0, Math.round(this.b * 255), 255);
    },
    rClamped: function() {
      return bound(0, this.r, 1);
    },
    gClamped: function() {
      return bound(0, this.g, 1);
    },
    bClamped: function() {
      return bound(0, this.b, 1);
    },
    aClamped: function() {
      return bound(0, this.a, 1);
    },
    premultiplied: function() {
      return new Color(this.r * this.a, this.g * this.a, this.b * this.a, this.a);
    },
    demultiplied: function() {
      return new Color(this.r / this.a, this.g / this.a, this.b / this.a, this.a);
    },
    cssString: function() {
      var a;
      a = this.aClamped;
      return "rgba(" + [this.r256, this.g256, this.b256, a.toFixed(3).replace(/\.?0+$/, '')].join(', ') + ")";
    },
    rgbaString: function() {
      return "rgbColor(" + [this.r256, this.g256, this.b256, this.a256].join('/255, ') + "/255)";
    },
    hexString: function() {
      return "#" + this.rawHexString;
    },
    rgbaHexString: function() {
      return "#" + this.getRawRgbaHexString();
    },
    hex16String: function() {
      return "#" + hexString(this.r16, 1) + hexString(this.g16, 1) + hexString(this.b16, 1);
    },
    rgbaHex16String: function() {
      return this.hex16String + hexString(this.a16, 1);
    },
    hslHexString: function() {
      return "#" + hexString(this.h256) + hexString(this.s256) + hexString(this.b256);
    },
    autoRgbaHexString: function() {
      if (colorFloatEq(1, this.a)) {
        return this.getHexString();
      } else {
        return this.rgbaHexString;
      }
    },
    rawHexString: function() {
      return hexString(this.r256) + hexString(this.g256) + hexString(this.b256);
    },
    rawRgbaHexString: function() {
      return this.rawHexString + hexString(this.a256);
    }
  });

  Color.prototype.inspect = function() {
    var a;
    a = colorFloatEq(1, this.a) ? this.hexString : this.rgbaHexString;
    return "rgbColor('" + a + "')";
  };

  Color.prototype.toString = function() {
    return this._htmlColorString || (this._htmlColorString = colorFloatEq(1, this.a) ? this.getHexString() : this.getCssString());
  };

  Color.prototype.getHueDelta = function(c) {
    var d;
    d = this.hue - c.hue;
    if (d < -.5) {
      return d + 1;
    } else if (d > .5) {
      return d - 1;
    } else {
      return d;
    }
  };

  Color.prototype.getHueDifference = function(c) {
    return Math.abs(this.getHueDelta(c));
  };

  Color.getter({
    plainObjects: function() {
      if (this.a < 1) {
        return this.rgbaHexString;
      } else {
        return this.hexString;
      }
    },
    inspectedObjectInitializer: function() {
      return "'" + this.autoRgbaHexString + "1'";
    }
  });

  Color.getter({
    h: function() {
      return this._hue != null ? this._hue : this._hue = this._computeHsl() && this._hue;
    },
    s: function() {
      return this._saturation != null ? this._saturation : this._saturation = this._computeHsl() && this._saturation;
    },
    l: function() {
      return this._lightness != null ? this._lightness : this._lightness = this._computeHsl() && this._lightness;
    },
    inverseL: function() {
      return 1 - this.l;
    },
    inverseS: function() {
      return 1 - this.s;
    },
    inverseH: function() {
      return 1 - this.h;
    },
    hue: function() {
      return this._hue != null ? this._hue : this._hue = this._computeHsl() && this._hue;
    },
    sat: function() {
      return this._saturation != null ? this._saturation : this._saturation = this._computeHsl() && this._saturation;
    },
    lit: function() {
      return this._lightness != null ? this._lightness : this._lightness = this._computeHsl() && this._lightness;
    },
    saturation: function() {
      return this._saturation != null ? this._saturation : this._saturation = this._computeHsl() && this._saturation;
    },
    lightness: function() {
      return this._lightness != null ? this._lightness : this._lightness = this._computeHsl() && this._lightness;
    },
    perceptualLightness: function() {
      var b, bWeight, bWeighted, g, gWeight, gWeighted, r, rWeight, rWeighted, ref;
      ref = this, r = ref.r, g = ref.g, b = ref.b;
      rWeighted = r * (rWeight = .7);
      gWeighted = g * (gWeight = .8);
      bWeighted = b * (bWeight = .3);
      if (gWeighted >= rWeighted && gWeighted >= bWeighted) {
        return gWeighted + (r + b) * .5 * (1 - gWeight);
      } else if (bWeighted >= rWeighted && bWeighted >= gWeighted) {
        return bWeighted + (r + g) * .5 * (1 - bWeight);
      } else {
        return rWeighted + (g + b) * .5 * (1 - rWeight);
      }
    },
    perceptualSaturation: function() {
      return Math.pow(this.perceptualLightness, 1 / 3) * this.saturation;
    },
    satLightness: function() {
      return (2 - this._saturation) * this._lightness * .5;
    }
  });

  Color.prototype._computeHsl = function() {
    var b, delta, g, maxRgb, minRgb, r, ref;
    if (this._hue != null) {
      return true;
    }
    ref = this, r = ref.r, g = ref.g, b = ref.b;
    maxRgb = this._lightness = max(r, g, b);
    minRgb = min(r, g, b);
    this._hue = (function() {
      if (maxRgb === minRgb) {
        return this._saturation = 0;
      } else {
        this._saturation = 1 - (minRgb / maxRgb);
        delta = maxRgb - minRgb;
        switch (maxRgb) {
          case r:
            return (g - b) / delta + (g >= b ? 0 : 6);
          case g:
            return (b - r) / delta + 2;
          case b:
            return (r - g) / delta + 4;
        }
      }
    }).call(this);
    this._hue /= 6;
    return true;
  };

  for (k in colorNamesMap) {
    v = colorNamesMap[k];
    colorNamesMap[k] = rgbColor(v);
  }

  Color.namedValues = colorNamesMap;

  return Color;

})(AtomicBase);


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {
/*

With the exception of the setter methods, this is a pure-functional class.
 */

/*
Experiment: Instead of storing the matrix as 6 members, use a Float32Array:

  Bonus: if we order the 6 elements correctly, we can just pass the Float32Array directly to Webgl uniformMatrix3fv
  Result:
    FF is about 2x as fast with this implementation, but Chrome is about 10x slower (see below)
    Sticking with Members implementation for now.

On my Macbook pro Retina (2.6 GHz Intel Core i7)

Chrome 29.0.1547.57 (members)
  Matrix.translate 14,716,649/s
  matrix().translate 8,052,404/s
  transform point 3,922,725/s
  invert 12,733,472/s
  mul 16,146,097/s

Chrome 29.0.1547.57 (float32Array)
  Matrix.translate 926,402/s
  matrix().translate 463,791/s
  transform point 3,684,177/s
  invert 978,248/s
  mul 992,078/s

FF 23.0.1 (members)
  Matrix.translate 1,281,078/s
  matrix().translate 534,542/s
  transform point 768,224/s
  invert 1,374,788/s
  mul 1,413,206/s

FF 23.0.1 (float32Array)
  Matrix.translate 2,126,281/s
  matrix().translate 1,013,548/s
  transform point 832,604/s
  invert 2,524,903/s
  mul 2,669,331/s

NOTE! the order of the fields in the float32array for Webgl uniformMatrix3fv should be:
  @values[0] = @sx
  @values[1] = @shy
  @values[2] = @tx
  @values[3] = @shx
  @values[4] = @sy
  @values[5] = @ty
 */
var AtomicBase, Foundation, Matrix, Point, Rectangle, ceil, compact, defineModule, float32Eq, floor, inspect, isNumber, isPoint, log, point, rect, simplifyNum, sqrt,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

AtomicBase = __webpack_require__(35);

Point = __webpack_require__(53);

Rectangle = __webpack_require__(68);

point = Point.point, isPoint = Point.isPoint;

rect = Rectangle.rect;

ceil = Math.ceil, floor = Math.floor, sqrt = Math.sqrt;

inspect = Foundation.inspect, simplifyNum = Foundation.simplifyNum, float32Eq = Foundation.float32Eq, compact = Foundation.compact, log = Foundation.log, isNumber = Foundation.isNumber, defineModule = Foundation.defineModule;

defineModule(module, Matrix = (function(superClass) {
  var cleanInspect, identityMatrix, intermediatResultMatrix, isMatrix, matrix, transform1D;

  extend(Matrix, superClass);

  function Matrix() {
    return Matrix.__super__.constructor.apply(this, arguments);
  }

  Matrix.defineAtomicClass({
    fieldNames: "sx sy shx shy tx ty"
  });

  Matrix.isMatrix = isMatrix = function(v) {
    return (v != null ? v.constructor : void 0) === Matrix;
  };

  Matrix.matrix = matrix = function(a, b, c, d, e, f) {
    if (isMatrix(a)) {
      return a;
    } else if (a === null || a === void 0) {
      return identityMatrix;
    } else {
      return new Matrix(a, b, c, d, e, f);
    }
  };

  Matrix._cleanInspect = cleanInspect = function(pointName, s) {
    var out, r;
    out = pointName ? (r = new RegExp("([0-9])" + pointName, "g"), s.replace(r, "$1 * " + pointName).replace(/-1 \* /g, "-").replace(/\ \+ -/g, " - ").replace(/0\./g, ".")) : s.replace(/-1([A-Za-z]+)/g, "-$1").replace(/\ \+ -/g, " - ").replace(/0\./g, ".");
    return out;
  };

  Matrix.translate = function(a, b) {
    var x, y;
    if (isNumber(b)) {
      throw new Error("Matrix.translate no longer accepts two numbers. Use translateXY");
    }
    if (isNumber(a)) {
      x = y = a;
    } else {
      x = a.x, y = a.y;
    }
    return Matrix.translateXY(x, y);
  };

  Matrix.translateXY = function(x, y) {
    if (x === 0 && y === 0) {
      return identityMatrix;
    } else {
      return new Matrix(1, 1, 0, 0, x, y);
    }
  };

  Matrix.scale = function(a, b) {
    var x, y;
    if (isNumber(b)) {
      throw new Error("Matrix.scale no longer accepts two numbers. Use translateXY");
    }
    if (isNumber(a)) {
      x = y = a;
    } else {
      x = a.x, y = a.y;
    }
    return Matrix.scaleXY(x, y);
  };

  Matrix.scaleXY = function(sx, sy) {
    if (sx === 1 && sy === 1) {
      return identityMatrix;
    } else {
      return new Matrix(sx, sy, 0, 0, 0, 0);
    }
  };

  Matrix.rotate = function(radians) {
    var cr, sr;
    cr = Math.cos(radians);
    sr = Math.sin(radians);
    if (cr === 1 && sr === 0) {
      return identityMatrix;
    } else {
      return new Matrix(cr, cr, -sr, sr, 0, 0);
    }
  };

  Matrix.prototype.initDefaults = function() {
    this.sx = this.sy = 1;
    this.shy = this.shx = 0;
    this.tx = this.ty = 0;
    this._exactScale = this._exactScaler = null;
    return this;
  };

  Matrix.prototype._init = function(a, b, c, d, e, f) {
    this.initDefaults();
    if (a == null) {
      return;
    }
    if (isPoint(a)) {
      return this._initFromPoint(a);
    } else if (isMatrix(a)) {
      return this._initFromMatrix(a);
    } else {
      this.sx = a - 0;
      if (b != null) {
        this.sy = b - 0;
      }
      if (c != null) {
        this.shx = c - 0;
      }
      if (d != null) {
        this.shy = d - 0;
      }
      if (e != null) {
        this.tx = e - 0;
      }
      if (f != null) {
        return this.ty = f - 0;
      }
    }
  };

  Matrix.prototype.getScale = function() {
    return this.getS();
  };

  Matrix.getter({
    t: function() {
      return point(this.tx, this.ty);
    },
    s: function() {
      return point(this.sx, this.sy);
    },
    sh: function() {
      return point(this.shx, this.shy);
    },
    xsv: function() {
      return point(this.sx, this.shx);
    },
    ysv: function() {
      return point(this.sy, this.shy);
    },
    xsvMagnitude: function() {
      return sqrt(this.sx * this.sx + this.shx * this.shx);
    },
    ysvMagnitude: function() {
      return sqrt(this.sy * this.sy + this.shy * this.shy);
    },
    exactScale: function() {
      return this._exactScale || (this._exactScale = point(this.xsv.magnitude, this.ysv.magnitude));
    },
    exactScaler: function() {
      return this._exactScaler || (this._exactScaler = (this.getXsvMagnitude() + this.getYsvMagnitude()) / 2);
    },
    inv: function() {
      return this.invert();
    },
    locationX: function() {
      return this.tx;
    },
    locationY: function() {
      return this.ty;
    },
    scaleX: function() {
      return this.sx;
    },
    scaleY: function() {
      return this.sy;
    },
    location: function() {
      return point(this.tx, this.ty);
    },
    rounded: function() {
      return this.getWithRoundedTranslation();
    },
    withRoundedTranslation: function() {
      if (this.translationIsIntegral) {
        return this;
      } else {
        return new Matrix(this.sx, this.sy, this.shx, this.shy, Math.round(this.tx), Math.round(this.ty));
      }
    },
    angle: function() {
      var p1, p2;
      p1 = this.transform(Point.point0);
      p2 = this.transform(new Point(0, 1));
      return (p2.sub(p1)).angle - Math.PI * .5;
    },
    float32Array: function() {
      return this.fillFloat32Array(new Float32Array(9));
    },
    isIdentity: function() {
      return float32Eq(this.sx, 1) && float32Eq(this.sy, 1) && float32Eq(this.shx, 0) && float32Eq(this.shy, 0) && float32Eq(this.tx, 0) && float32Eq(this.ty, 0);
    },
    isTranslateOnly: function() {
      return float32Eq(this.sx, 1) && float32Eq(this.sy, 1) && float32Eq(this.shx, 0) && float32Eq(this.shy, 0);
    },
    translationIsIntegral: function() {
      return float32Eq(this.tx, Math.round(this.tx)) && float32Eq(this.ty, Math.round(this.ty));
    },
    isIntegerTranslateOnly: function() {
      return this.isTranslateOnly && float32Eq(this.tx, this.tx | 0) && float32Eq(this.ty, this.ty | 0);
    },
    isTranslateAndScaleOnly: function() {
      return float32Eq(this.shx, 0) && float32Eq(this.shy, 0);
    },
    hasSkew: function() {
      return !this.getIsTranslateAndScaleOnly();
    },
    isTranslateAndPositiveScaleOnly: function() {
      return this.sx > 0 && this.sy > 0 && float32Eq(this.shx, 0) && float32Eq(this.shy, 0);
    }
  });

  Matrix.prototype.fillFloat32Array = function(a) {
    a[0] = this.sx;
    a[1] = this.shx;
    a[2] = this.tx;
    a[3] = this.shy;
    a[4] = this.sy;
    a[5] = this.ty;
    return a;
  };

  Matrix.prototype.simplify = function() {
    return new Matrix(simplifyNum(this.sx), simplifyNum(this.sy), simplifyNum(this.shx), simplifyNum(this.shy), simplifyNum(this.tx), simplifyNum(this.ty));
  };

  Matrix.prototype.withAngle = function(a) {
    return this.rotate(a - this.angle);
  };

  Matrix.prototype.withScale = function(a, b) {
    var x, y;
    if (isNumber(a)) {
      x = a;
      y = b != null ? b : x;
    } else {
      x = a.x, y = a.y;
    }
    return this.scale(x / this.sx, y / this.sy);
  };

  Matrix.prototype.withLocation = function(a, b) {
    var x, y;
    if (isNumber(a)) {
      x = a;
      y = b != null ? b : x;
    } else {
      x = a.x, y = a.y;
    }
    if (x === this.tx && y === this.ty) {
      return this;
    } else {
      return new Matrix(this.sx, this.sy, this.shx, this.shy, x, y);
    }
  };

  Matrix.prototype.withLocationXY = function(x, y) {
    if (x === this.tx && y === this.ty) {
      return this;
    } else {
      return new Matrix(this.sx, this.sy, this.shx, this.shy, x, y);
    }
  };


  /*
  IN:
    amount: point or number
    into: t/f
   */

  Matrix.prototype.translate = function(amount, into) {
    var x, y;
    if (isNumber(amount)) {
      x = y = amount;
    } else {
      x = amount.x, y = amount.y;
    }
    if (isNumber(into)) {
      throw new Error("Illegal second input: number (" + into + "). Use translateXY.");
    }
    return this.translateXY(x, y, into);
  };

  Matrix.prototype.translateXY = function(x, y, into) {
    return this._into(into, this.sx, this.sy, this.shx, this.shy, this.tx + x, this.ty + y);
  };

  Matrix.prototype.rotate = function(radians, into) {
    var cr, sr;
    cr = Math.cos(radians);
    sr = Math.sin(radians);
    return this._into(into, this.sx * cr - this.shy * sr, this.shx * sr + this.sy * cr, this.shx * cr - this.sy * sr, this.sx * sr + this.shy * cr, this.tx * cr - this.ty * sr, this.tx * sr + this.ty * cr);
  };

  Matrix.prototype.scale = function(a, into) {
    var x, y;
    if (isNumber(into)) {
      throw new Error("Matrix.scale no longer accepts two numbers. Use translateXY");
    }
    if (isNumber(a)) {
      x = y = a;
    } else {
      x = a.x, y = a.y;
    }
    return this.scaleXY(x, y, into);
  };

  Matrix.prototype.scaleXY = function(x, y, into) {
    return this._into(into, this.sx * x, this.sy * y, this.shx * x, this.shy * y, this.tx * x, this.ty * y);
  };

  Matrix.getter({
    determinantReciprocal: function() {
      return 1.0 / (this.sx * this.sy - this.shy * this.shx);
    }
  });

  Matrix.prototype.invert = function(into) {
    var d;
    d = this.getDeterminantReciprocal();
    return this._into(into, d * this.sy, d * this.sx, d * -this.shx, d * -this.shy, d * (-this.tx * this.sy + this.ty * this.shx), d * (this.tx * this.shy - this.ty * this.sx));
  };

  Matrix.prototype.mul = function(m, into) {
    if (isNumber(m)) {
      return this._into(into, this.sx * m, this.sy * m, this.shx * m, this.shy * m, this.tx * m, this.ty * m);
    } else {
      return this._into(into, this.sx * m.sx + this.shy * m.shx, this.shx * m.shy + this.sy * m.sy, this.shx * m.sx + this.sy * m.shx, this.sx * m.shy + this.shy * m.sy, this.tx * m.sx + this.ty * m.shx + m.tx, this.tx * m.shy + this.ty * m.sy + m.ty);
    }
  };

  Matrix.prototype.div = function(m, into) {
    var multipler;
    multipler = isNumber(m) ? 1 / m : m.invert(intermediatResultMatrix);
    return this.mul(multipler, into);
  };

  Matrix.prototype.inspectX = function(pointName, nullForZeroString) {
    var pn;
    pn = pointName;
    pointName = pointName ? pointName + "." : "";
    if (!(this.sx || this.shx || this.tx)) {
      return (!nullForZeroString ? "0" : void 0);
    }
    return cleanInspect(pn, compact([this.sx === 1 ? pointName + "x" : this.sx ? "" + this.sx + pointName + "x" : void 0, this.shx === 1 ? pointName + "y" : this.shx ? "" + this.shx + pointName + "y" : void 0, this.tx ? "" + this.tx : void 0]).join(" + "));
  };

  Matrix.prototype.inspectY = function(pointName, nullForZeroString) {
    var pn;
    pn = pointName;
    pointName = pointName ? pointName + "." : "";
    if (!(this.sy || this.shy || this.ty)) {
      return (!nullForZeroString ? "0" : void 0);
    }
    return cleanInspect(pn, compact([this.sy === 1 ? pointName + "y" : this.sy ? "" + this.sy + pointName + "y" : void 0, this.shy === 1 ? pointName + "x" : this.shy ? "" + this.shy + pointName + "x" : void 0, this.ty ? "" + this.ty : void 0]).join(" + "));
  };

  Matrix.prototype.inspectBoth = function(pointName) {
    return "(" + (this.inspectX(pointName)) + ", " + (this.inspectY(pointName)) + ")";
  };

  Matrix.transform1D = transform1D = function(x, y, sx, shx, tx) {
    return x * sx + y * shx + tx;
  };


  /*
  IN: a: Point or any object where .x and .y are numbers
  IN: a: x (number; required), b: y (number, default: x)
   */

  Matrix.prototype.transform = function(a, b) {
    var x, y;
    if (isNumber(a)) {
      log.error("DEPRICATED: matrix.transform(x, y) - use matrix.transformXY");
      x = a;
      y = b != null ? b : x;
    } else {
      x = a.x, y = a.y;
    }
    return this.transformXY(x, y);
  };

  Matrix.prototype.transformX = function(x, y) {
    return transform1D(x, y, this.sx, this.shx, this.tx);
  };

  Matrix.prototype.transformY = function(x, y) {
    return transform1D(y, x, this.sy, this.shy, this.ty);
  };

  Matrix.prototype.transformXY = function(x, y) {
    return new Point(this.transformX(x, y), this.transformY(x, y));
  };

  Matrix.prototype.inverseTransform = function(a, b) {
    var d, shx, shy, sx, sy, tx, ty, x, y;
    if (isNumber(a)) {
      x = a;
      y = b != null ? b : x;
    } else {
      x = a.x, y = a.y;
    }
    d = this.getDeterminantReciprocal();
    sx = d * this.sy;
    sy = d * this.sx;
    shx = d * -this.shx;
    shy = d * -this.shy;
    tx = d * (-this.tx * this.sy + this.ty * this.shx);
    ty = d * (this.tx * this.shy - this.ty * this.sx);
    return new Point(transform1D(x, y, sx, shx, tx), transform1D(y, x, sy, shy, ty));
  };

  Matrix.prototype.transformVector = function(a, b) {
    var dx, dy;
    switch ((a != null) && a.constructor) {
      case false:
        dx = dy = 0;
        break;
      case Point:
        dx = a.x;
        dy = a.y;
        break;
      default:
        dx = a;
        dy = b;
    }
    return new Point(dx * this.sx + dy * this.shx, dy * this.sy + dx * this.shy);
  };

  Matrix.prototype.transformDifference = function(v1, v2) {
    var dx, dy;
    dx = v1.x - v2.x;
    dy = v1.y - v2.y;
    return new Point(dx * this.sx + dy * this.shx, dy * this.sy + dx * this.shy);
  };

  Matrix.prototype.transformBoundingRect = function(r, roundOut) {
    var bottom, h, left, right, top, w, x, x1, x2, x3, x4, y, y1, y2, y3, y4;
    if (roundOut == null) {
      roundOut = false;
    }
    r = rect(r);
    if (r.infinite || this.isIdentity) {
      return r;
    }
    if (this.shx === 0 && this.shy === 0) {
      x = r.x * this.sx + this.tx;
      y = r.y * this.sy + this.ty;
      w = r.w * this.sx;
      h = r.h * this.sy;
      if (w < 0) {
        x += w;
        w = -w;
      }
      if (h < 0) {
        y += h;
        h = -h;
      }
    } else {
      top = r.top, left = r.left, right = r.right, bottom = r.bottom;
      x1 = transform1D(left, top, this.sx, this.shx, this.tx);
      y1 = transform1D(top, left, this.sy, this.shy, this.ty);
      x2 = transform1D(right, top, this.sx, this.shx, this.tx);
      y2 = transform1D(top, right, this.sy, this.shy, this.ty);
      x3 = transform1D(right, bottom, this.sx, this.shx, this.tx);
      y3 = transform1D(bottom, right, this.sy, this.shy, this.ty);
      x4 = transform1D(left, bottom, this.sx, this.shx, this.tx);
      y4 = transform1D(bottom, left, this.sy, this.shy, this.ty);
      x = Math.min(x1, x2, x3, x4);
      w = Math.max(x1, x2, x3, x4) - x;
      y = Math.min(y1, y2, y3, y4);
      h = Math.max(y1, y2, y3, y4) - y;
    }
    if (roundOut) {
      right = ceil(x + w);
      bottom = ceil(y + h);
      x = floor(x);
      y = floor(y);
      w = right - x;
      h = bottom - y;
    }
    return new Rectangle(x, y, w, h);
  };

  Matrix.identityMatrix = identityMatrix = new Matrix;

  Matrix.matrix0 = new Matrix(0, 0, 0, 0, 0, 0);

  intermediatResultMatrix = new Matrix;

  Matrix.prototype._initFromMatrix = function(m) {
    this.sx = m.sx;
    this.sy = m.sy;
    this.shx = m.shx;
    this.shy = m.shy;
    this.tx = m.tx;
    this.ty = m.ty;
    return this;
  };

  Matrix.prototype._initFromPoint = function(p) {
    this.tx = p.x;
    this.ty = p.y;
    return this;
  };

  return Matrix;

})(AtomicBase));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var AtomicBase, Foundation, Perimeter, Point, floatEq, inspect, isPlainObject, isString, log, point, rect,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

AtomicBase = __webpack_require__(35);

Point = __webpack_require__(53);

log = Foundation.log, inspect = Foundation.inspect, floatEq = Foundation.floatEq, isPlainObject = Foundation.isPlainObject, isString = Foundation.isString;

point = Point.point;

rect = __webpack_require__(68).rect;

module.exports = Perimeter = (function(superClass) {
  var isPerimeter, k, namedPerimeters, perimeter, perimeter0, ref, v;

  extend(Perimeter, superClass);

  function Perimeter() {
    return Perimeter.__super__.constructor.apply(this, arguments);
  }

  Perimeter.defineAtomicClass({
    fieldNames: "left right top bottom"
  });

  Perimeter.isPerimeter = isPerimeter = function(v) {
    return (v != null ? v.constructor : void 0) === Perimeter;
  };

  Perimeter.perimeter = perimeter = function(a, b, c, d) {
    var p;
    if (isPerimeter(a)) {
      return a;
    }
    if (isString(a) && (p = namedPerimeters[a])) {
      return p;
    }
    if ((b == null) && (floatEq(a, 0)) || !a) {
      return perimeter0;
    }
    return new Perimeter(a, b, c, d);
  };

  Perimeter.prototype._initFields = function() {
    return this.left = this.right = this.top = this.bottom = 0;
  };

  Perimeter.prototype._initFromObject = function(obj) {
    this._initFields();
    this.left = (obj.left || 0) + (obj.l || 0) + (obj.h || 0) + (obj.horizontal || 0);
    this.right = (obj.right || 0) + (obj.r || 0) + (obj.h || 0) + (obj.horizontal || 0);
    this.top = (obj.top || 0) + (obj.t || 0) + (obj.v || 0) + (obj.vertical || 0);
    return this.bottom = (obj.bottom || 0) + (obj.b || 0) + (obj.v || 0) + (obj.vertical || 0);
  };

  Perimeter.prototype._init = function(a, b, c, d) {
    var argLength;
    this._initFields();
    argLength = a != null ? b != null ? c != null ? d != null ? 4 : 3 : 2 : 1 : 0;
    switch (argLength) {
      case 0:
        return this.left = this.right = this.top = this.bottom = 0;
      case 1:
        return this.left = this.right = this.top = this.bottom = a;
      case 2:
        this.left = this.right = a;
        return this.top = this.bottom = b;
      case 4:
        this.left = a;
        this.right = b;
        this.top = c;
        return this.bottom = d;
      default:
        throw new Error("invalid number of arguments: " + (inspect(arguments)));
    }
  };

  Perimeter.getter({
    exportedValue: function() {
      var bottom, left, out, ref, right, top;
      ref = this, left = ref.left, right = ref.right, top = ref.top, bottom = ref.bottom;
      if ((left === right) && (left === top) && (left === bottom)) {
        return left;
      } else {
        out = {};
        if (left === right) {
          if (left !== 0) {
            out.h = left;
          }
        } else {
          if (left !== 0) {
            out.left = left;
          }
          if (right !== 0) {
            out.right = right;
          }
        }
        if (top === bottom) {
          if (top !== 0) {
            return out.v = top;
          }
        } else {
          if (top !== 0) {
            out.top = top;
          }
          if (bottom !== 0) {
            return out.bottom = bottom;
          }
        }
      }
    },
    width: function() {
      return this.left + this.right;
    },
    height: function() {
      return this.top + this.bottom;
    },
    w: function() {
      return this.left + this.right;
    },
    h: function() {
      return this.top + this.bottom;
    },
    needsTranslation: function() {
      return this.left !== 0 || this.top !== 0;
    }
  });

  Perimeter.prototype.subtractedFromSize = function(size) {
    var h, w;
    w = this.getWidth();
    h = this.getHeight();
    if (floatEq(w, 0) && floatEq(h, 0)) {
      return size;
    } else {
      return point(size.x - w, size.y - h);
    }
  };

  Perimeter.prototype.addedToSize = function(size) {
    var h, w;
    w = this.getWidth();
    h = this.getHeight();
    if (floatEq(w, 0) && floatEq(h, 0)) {
      return size;
    } else {
      return point(size.x + w, size.y + h);
    }
  };


  /*
  Named Instances
   */

  Perimeter.namedPerimeters = namedPerimeters = {
    perimeter0: perimeter0 = Object.freeze(new Perimeter(0))
  };

  ref = Perimeter.namedPerimeters;
  for (k in ref) {
    v = ref[k];
    Perimeter[k] = v;
  }

  Perimeter.prototype.pad = function(rectangle) {
    var bottom, h, left, ref1, right, top, w, x, y;
    x = rectangle.left, y = rectangle.top, w = rectangle.w, h = rectangle.h;
    ref1 = this, left = ref1.left, right = ref1.right, top = ref1.top, bottom = ref1.bottom;
    return rectangle.withRect(x + left, y + top, w - left - right, h - top - bottom);
  };

  return Perimeter;

})(AtomicBase);


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var DataUri, Promise, StandardLib, binary, isString, readAsDataURL;

StandardLib = __webpack_require__(1);

binary = __webpack_require__(28).binary;

readAsDataURL = __webpack_require__(110).readAsDataURL;

Promise = StandardLib.Promise, isString = StandardLib.isString;

module.exports = DataUri = (function() {
  var isDataUri;

  function DataUri() {}

  DataUri.isDataUri = isDataUri = function(dataString) {
    return isString(dataString) && dataString.slice(0, 5) === "data:";
  };


  /*
  IN: data can be any of
    File: HTML File object is read as ArrayBuffer
    DataURI string: if it is already a data-uri string it is just returned as a successful promise
    any type 'binary' accepts
  
  OUT:
    promise.then (dataUri) ->
    , (errorEventOrErrorObject) ->
   */

  DataUri.toDataUri = function(data, mimeType) {
    if (mimeType == null) {
      mimeType = 'image/png';
    }
    if (!data) {
      throw new Error("data not set");
    }
    if (global.File && data instanceof global.File) {
      return readAsDataURL(data);
    }
    if (isDataUri(data)) {
      return Promise.resolve(data);
    }
    return binary(data).toBase64().then(function(base64) {
      return "data:" + mimeType + ";base64," + base64;
    });
  };

  return DataUri;

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, Binary, ClassSystem, Stream, binary,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ClassSystem = __webpack_require__(6);

Binary = __webpack_require__(111);

BaseObject = ClassSystem.BaseObject;

binary = __webpack_require__(28).binary;

module.exports = Stream = (function(superClass) {
  extend(Stream, superClass);

  Stream.stream = function(arg) {
    if (arg instanceof Stream) {
      return arg;
    } else if (arg instanceof ArrayBuffer) {
      return Stream.fromArrayBuffer(arg);
    } else if (arg instanceof Uint8Array) {
      return new Stream(arg);
    } else {
      return new Stream(binary(arg).bytes);
    }
  };

  Stream.fromArrayBuffer = function(arrayBuffer) {
    return new Stream(new Uint8Array(arrayBuffer, 0, arrayBuffer.byteLength));
  };

  function Stream(byteView) {
    this.byteView = byteView;
    this.pos = 0;
  }

  Stream.prototype.readByte = function() {
    return this.byteView[this.pos++];
  };

  Stream.prototype.readAsi = function() {
    var ret, shift, val;
    ret = 0;
    shift = 0;
    val = 128;
    while (val >= 128) {
      val = this.readByte();
      ret += (val % 128) << shift;
      shift += 7;
    }
    return ret;
  };

  Stream.prototype.uint8Array = function() {
    return this.byteView;
  };

  Stream.prototype.read = function(length) {
    var begin, end;
    begin = this.pos;
    this.pos += length;
    end = this.pos;
    return new Stream(this.byteView.subarray(begin, end));
  };

  Stream.prototype.inspect = function() {
    return "{Stream pos=" + this.pos + " byteOffset=" + this.byteView.byteOffset + " length=" + this.byteView.length + "}";
  };

  Stream.prototype.readAsiString = function() {
    return this.read(this.readAsi());
  };

  Stream.prototype.done = function() {
    return this.pos >= this.byteView.length;
  };

  Stream.getter({
    isDone: function() {
      return this.pos >= this.byteView.length;
    },
    binaryString: function() {
      return binary(this.byteView);
    },
    inspectedString: function() {
      return this.binaryString.inspectedString;
    }
  });

  Stream.prototype.toString = function() {
    return this.binaryString.toString();
  };

  return Stream;

})(BaseObject);


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var base, base1, base10, base11, base2, base3, base4, base5, base6, base7, base8, base9, bound, genericSlice, ref, ref1;

bound = __webpack_require__(1).bound;

(base = Uint8Array.prototype).slice || (base.slice = genericSlice = function(start, end) {
  var i, j, length, out, outIndex, ref, ref1;
  if (end == null) {
    end = this.length;
  }
  if (start < 0) {
    start += this.length;
  }
  if (end < 0) {
    end += this.length;
  }
  start = bound(0, start, this.length);
  end = bound(0, end, this.length);
  out = new Uint8Array(length = end - start);
  outIndex = 0;
  for (i = j = ref = start, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
    out[outIndex++] = this[i];
  }
  return out;
});

(base1 = Int8Array.prototype).slice || (base1.slice = genericSlice);

(base2 = Uint8Array.prototype).slice || (base2.slice = genericSlice);

(base3 = Int16Array.prototype).slice || (base3.slice = genericSlice);

(base4 = Uint16Array.prototype).slice || (base4.slice = genericSlice);

(base5 = Int32Array.prototype).slice || (base5.slice = genericSlice);

(base6 = Uint32Array.prototype).slice || (base6.slice = genericSlice);

(base7 = Float32Array.prototype).slice || (base7.slice = genericSlice);

(base8 = Float64Array.prototype).slice || (base8.slice = genericSlice);

if ((ref = self.Uint8ClampedArray) != null) {
  (base9 = ref.prototype).slice || (base9.slice = genericSlice);
}

if ((ref1 = self.CanvasPixelArray) != null) {
  (base10 = ref1.prototype).slice || (base10.slice = genericSlice);
}

(base11 = ArrayBuffer.prototype).slice || (base11.slice = function(start, end) {
  return (new Uint8Array(this)).slice(start, end).buffer;
});


/***/ }),
/* 197 */
/***/ (function(module, exports) {

var Utf8;

module.exports = Utf8 = (function() {
  function Utf8() {}

  Utf8.toBuffer = function(string) {
    return new Uint8Array(this.toArray(string));
  };

  Utf8.toArray = function(string) {
    var char, i, out, uriEncoded;
    uriEncoded = encodeURIComponent(string);
    i = 0;
    out = (function() {
      var results;
      results = [];
      while (i < uriEncoded.length) {
        char = uriEncoded.charCodeAt(i++);
        if (char === 0x25) {
          i += 2;
          results.push(parseInt(uriEncoded.substr(i - 2, 2), 16));
        } else {
          results.push(char);
        }
      }
      return results;
    })();
    return out;
  };

  Utf8.toString = function(a) {
    var error, x, y;
    if (a === void 0) {
      return "<undefined>";
    }
    if (a === null) {
      return "<null>";
    }
    try {
      if (a instanceof ArrayBuffer) {
        a = new Uint8Array(a);
      }
      return decodeURIComponent(((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = a.length; j < len; j++) {
          x = a[j];
          y = x.toString(16);
          if (y.length < 2) {
            y = "0" + y;
          }
          y = "%" + y;
          results.push(y);
        }
        return results;
      })()).join(''));
    } catch (error1) {
      error = error1;
      console.warn(error.toString(), error);
      return "<" + a.length + " binary bytes>";
    }
  };

  return Utf8;

})();


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var Atomic, Binary, Bitmap, BitmapBase, Browser, Color, EncodedImage, GradientFillStyle, IdentityMatrix, Matrix, Point, Promise, Rectangle, StackBlur, canvasBlenders, currentSecond, emptyOptions, eq, floatEq0, getEnv, inspect, isFunction, isMatrix, isNumber, isPlainObject, isPoint, isSimpleRectangle, isString, linePath, log, matrix, max, min, point, point0, rect, rectanglePath, ref, ref1, ref2, rgbColor, round, roundedRectanglePath,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Atomic = __webpack_require__(4);

GradientFillStyle = __webpack_require__(199);

BitmapBase = __webpack_require__(69);

StackBlur = __webpack_require__(201);

ref = __webpack_require__(200), roundedRectanglePath = ref.roundedRectanglePath, rectanglePath = ref.rectanglePath, linePath = ref.linePath;

isSimpleRectangle = function(pathFunction, pathOptions) {
  var radius;
  return (pathFunction === rectanglePath || pathFunction === roundedRectanglePath) && (((radius = pathOptions != null ? pathOptions.radius : void 0) == null) || radius === 0);
};

ref1 = __webpack_require__(1), inspect = ref1.inspect, log = ref1.log, min = ref1.min, max = ref1.max, Binary = ref1.Binary, isFunction = ref1.isFunction, isPlainObject = ref1.isPlainObject, eq = ref1.eq, currentSecond = ref1.currentSecond, round = ref1.round, isNumber = ref1.isNumber, floatEq0 = ref1.floatEq0, Promise = ref1.Promise, isPlainObject = ref1.isPlainObject, isString = ref1.isString, getEnv = ref1.getEnv;

ref2 = __webpack_require__(2), Binary = ref2.Binary, Browser = ref2.Browser;

EncodedImage = Binary.EncodedImage;

isPoint = Atomic.isPoint, isMatrix = Atomic.isMatrix, point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix, rgbColor = Atomic.rgbColor, Color = Atomic.Color, IdentityMatrix = Atomic.IdentityMatrix, point0 = Atomic.point0;

emptyOptions = {};

canvasBlenders = {
  add: "lighter",
  normal: "source-over",
  target_alphamask: "source-in",
  alphamask: "destination-in",
  destover: "destination-over",
  sourcein: "source-atop",
  inverse_alphamask: "destination-out",
  alphaMask: "destination-in",
  targetAlphaMask: "source-in",
  inverseAlphaMask: "destination-out",
  destOver: "destination-over",
  sourceIn: "source-atop",
  replace: "copy"
};

module.exports = Bitmap = (function(superClass) {
  var k, transparent, v;

  extend(Bitmap, superClass);

  function Bitmap() {
    return Bitmap.__super__.constructor.apply(this, arguments);
  }

  Bitmap.supportedCompositeModes = (function() {
    var results;
    results = [];
    for (k in canvasBlenders) {
      v = canvasBlenders[k];
      results.push(k);
    }
    return results;
  })();

  Bitmap.getter({
    supportedCompositeModes: function() {
      return Bitmap.supportedCompositeModes;
    }
  });

  Bitmap.artToCanvasCompositeModeMap = canvasBlenders;

  Bitmap.prototype.initContext = function() {
    var ref3;
    return this._context = (ref3 = this._canvas) != null ? ref3.getContext("2d") : void 0;
  };

  Bitmap.getter({
    context: function() {
      if (!this._context && this._htmlImageElement) {
        this.logBitmapSize("'context' getter needs to make a new canvas");
        this.initNewCanvas(this.size);
        this.drawBitmap(point(), this._htmlImageElement);
        this._htmlImageElement = null;
      }
      return this._context;
    },
    context2D: function() {
      return this.getContext();
    },
    htmlImageElement: function() {
      return this._htmlImageElement;
    },
    htmlElement: function() {
      return this._htmlImageElement || this._canvas;
    }
  });

  Bitmap.get = function(url, options) {
    return EncodedImage.get(url, options).then(function(image) {
      var _, bitmap, match, resolution;
      bitmap = new Bitmap(image);
      if (isString(url) && (match = url.match(/@([2-9])x\.[a-zA-Z]+$/))) {
        _ = match[0], resolution = match[1];
        bitmap.pixelsPerPoint = resolution | 0;
      }
      return bitmap;
    });
  };


  /*
  Uses the browser's file-request dialog to have the user select a local image file.
  
  OUT:
    promise.then ({bitmap, file}) ->
       * bitmap is a Canvas.Bitmap
       * file is a javascript File object
   */

  Bitmap.requestImage = function() {
    return Browser.File.request({
      accept: "image/*"
    }).then((function(_this) {
      return function(arg) {
        var file;
        file = arg[0];
        return EncodedImage.toImage(file).then(function(image) {
          return new Bitmap(image);
        }).then(function(bitmap) {
          log({
            ArtCanvasBitmap_requestImage: {
              size: bitmap.size,
              tainted: bitmap.tainted,
              type: file.type
            }
          });
          return {
            bitmap: bitmap,
            file: file,
            mimeType: file.type
          };
        });
      };
    })(this));
  };

  Bitmap.prototype.initFromImage = function(image) {
    var message, ref3, tainted;
    this._size = point(image.naturalWidth || image.width, image.naturalHeight || image.height);
    this.logBitmapSize("initFromImage");
    this._htmlImageElement = image;
    if (getEnv().debugTaint) {
      tainted = this.tainted;
      message = "Canvas.Bitmap.initFromImage " + this._size + ", tainted: " + tainted + ", " + ((ref3 = image.src) != null ? ref3.slice(0, 100) : void 0);
      if (tainted) {
        return log.error(message);
      } else {
        return log(message);
      }
    }
  };

  Bitmap.setter({
    imageSmoothing: function(bool) {
      return this._context.imageSmoothingEnabled = this._context.mozImageSmoothingEnabled = this._context.webkitImageSmoothingEnabled = this._context.msImageSmoothingEnabled = this._imageSmoothing = !!bool;
    }
  });

  Bitmap.bitmapClass = Bitmap;

  Bitmap.newBitmap = function(size) {
    return new Bitmap.bitmapClass(size);
  };

  Bitmap.prototype.newBitmap = function(size) {
    return new this.bitmapClass(size || this.size).tap((function(_this) {
      return function(b) {
        return b.pixelsPerPoint = _this.pixelsPerPoint;
      };
    })(this));
  };


  /*
  IN:
    area is either:
      rectangle or point
      OR
      path-function
   */

  Bitmap.prototype.setClippingArea = function(area, drawMatrix, pathArea, pathOptions) {
    var _context, pathFunction, simple, transformedArea;
    _context = this._context;
    if (isFunction(area)) {
      if (!(simple = isSimpleRectangle(area, pathOptions))) {
        pathFunction = area;
      }
      area = pathArea;
    }
    if (area) {
      this._setTransform(drawMatrix);
      transformedArea = this.transformAndRoundOutRectangle(drawMatrix, area);
      area = this.pixelSnapRectangle(drawMatrix, area);
      this._clippingArea = transformedArea.intersection(this._clippingArea);
    } else {
      this._setTransform(drawMatrix);
    }
    _context.beginPath();
    if (pathFunction) {
      pathFunction(_context, area, pathOptions);
    } else {
      _context.rect(area.x, area.y, area.w, area.h);
    }
    return _context.clip();
  };

  Bitmap.prototype.clippedTo = function(area, f, drawMatrix, pathArea, pathOptions) {
    var previousClippingArea;
    this._context.save();
    previousClippingArea = this._clippingArea;
    try {
      this.setClippingArea(area, drawMatrix, pathArea, pathOptions);
      return f();
    } finally {
      this._context.restore();
      this._clippingArea = previousClippingArea;
    }
  };

  Bitmap.prototype.openClipping = function(area, drawMatrix, pathArea, pathOptions) {
    var lastClippingInfo;
    this._context.save();
    lastClippingInfo = this._clippingArea;
    this.setClippingArea(area, drawMatrix, pathArea, pathOptions);
    return lastClippingInfo || rect(this.size);
  };

  Bitmap.prototype.closeClipping = function(lastClippingInfo) {
    this._context.restore();
    return this._clippingArea = lastClippingInfo;
  };

  transparent = rgbColor("transparent");

  Bitmap.prototype.clear = function(a, b, c, d) {
    this.clearArea(null, a != null ? rgbColor(a, b, c, d) : transparent);
    return this;
  };

  Bitmap.prototype.clearOutsideArea = function(area, color) {
    var currentHeight, currentWidth, h, ref3, w, x, y;
    if (!area) {
      return;
    }
    x = area.left, y = area.top, w = area.w, h = area.h;
    if (!(x === 0 && y === 0)) {
      throw new Error("area(" + area + ") must start in the top-right corner");
    }
    ref3 = this.size, currentWidth = ref3.w, currentHeight = ref3.h;
    w = min(w, currentWidth);
    h = min(h, currentHeight);
    if (w === currentWidth && h === currentHeight) {
      return;
    }
    if (h === currentHeight) {
      return this.clearArea(rect(w, 0, currentWidth - w, currentHeight));
    } else if (w === currentWidth) {
      return this.clearArea(rect(0, h, currentWidth, currentHeight - h));
    } else {
      this.clearArea(rect(w, 0, currentWidth - w, currentHeight));
      return this.clearArea(rect(0, h, w, currentHeight - h));
    }
  };

  Bitmap.prototype.clearArea = function(area, color) {
    var h, ref3, w, x, y;
    if (color == null) {
      color = transparent;
    }
    if (area) {
      x = area.left, y = area.top, w = area.w, h = area.h;
    } else {
      x = y = 0;
      ref3 = this.size, w = ref3.w, h = ref3.h;
    }
    this._clearTransform();
    if (color.a !== 1.0) {
      this._context.clearRect(x, y, w, h);
    }
    if (!color.eq(transparent)) {
      this._context.globalCompositeOperation = "source-over";
      this._setFillStyle(color);
      return this._context.fillRect(x, y, w, h);
    }
  };

  Bitmap.prototype.strokeRectangle = function(where, rectangle, options) {
    var _context, grow, lineWidth, lineWidthMod2, r, radius;
    if (options == null) {
      options = emptyOptions;
    }
    r = rect(rectangle);
    radius = options.radius;
    _context = this._context;
    if (this.shouldPixelSnap(where)) {
      lineWidth = options.lineWidth || 1;
      r = this.pixelSnapRectangle(where, r);
      lineWidthMod2 = lineWidth % 2;
      grow = lineWidthMod2 < 1 ? -lineWidthMod2 / 2 : lineWidthMod2 / 2 - 1;
      if (!floatEq0(grow)) {
        r = r.grow(grow);
      }
    }
    if (this._setupDraw(where, options, true)) {
      if (radius > 0 || isPlainObject(radius)) {
        _context.beginPath();
        roundedRectanglePath(_context, r, radius);
        _context.stroke();
      } else {
        _context.strokeRect(r.x, r.y, r.w, r.h);
      }
      this._cleanupDraw(options);
    }
    return this;
  };

  Bitmap.prototype.strokeShape = function(where, options, pathFunction, pathArea, pathOptions) {
    var _context, h, left, top, w;
    _context = this._context;
    if (this._setupDraw(where, options, true)) {
      if (isSimpleRectangle(pathFunction, pathOptions)) {
        if (this.shouldPixelSnap(where)) {
          pathArea = this.pixelSnapRectangle(where, pathArea);
        }
        top = pathArea.top, left = pathArea.left, w = pathArea.w, h = pathArea.h;
        _context.strokeRect(left, top, w, h);
      } else {
        _context.beginPath();
        pathFunction(_context, pathArea, pathOptions);
        _context.stroke();
      }
      this._cleanupDraw(options);
    }
    return this;
  };

  Bitmap.prototype.drawBorder = function(where, rectangle, options) {
    var a, a1, g, p, w;
    if (this._setupDraw(where, options, true)) {
      p = options.padding || 0;
      w = options.width || 1;
      a1 = rect(rectangle);
      g = p - w / 2;
      a = a1.grow(g);
      this._context.beginPath();
      rectanglePath(this._context, a);
      this._context.stroke();
      this._cleanupDraw(options);
    }
    return this;
  };

  Bitmap.prototype.drawLine = function(where, fromPoint, toPoint, options) {
    var _context;
    if (options == null) {
      options = emptyOptions;
    }
    _context = this._context;
    if (this._setupDraw(where, options, true)) {
      _context.beginPath();
      linePath(_context, fromPoint, toPoint);
      _context.stroke();
      this._cleanupDraw(options);
    }
    return this;
  };

  Bitmap.prototype.drawRectangle = function(where, rectangle, options) {
    var _context, fillRule, r, radius;
    if (options == null) {
      options = emptyOptions;
    }
    r = rect(rectangle);
    radius = options.radius, fillRule = options.fillRule;
    if (this.shouldPixelSnap(where)) {
      r = this.pixelSnapRectangle(where, r);
    }
    _context = this._context;
    if (this._setupDraw(where, options)) {
      if (radius > 0 || isPlainObject(radius)) {
        _context.beginPath();
        roundedRectanglePath(_context, r, radius);
        _context.fill(fillRule || "nonzero");
      } else {
        _context.fillRect(r.x, r.y, r.w, r.h);
      }
      this._cleanupDraw(options);
    }
    return this;
  };

  Bitmap.prototype.fillShape = function(where, options, pathFunction, pathArea, pathOptions) {
    var _context, h, left, top, w;
    _context = this._context;
    if (this._setupDraw(where, options)) {
      if (isSimpleRectangle(pathFunction, pathOptions)) {
        if (this.shouldPixelSnap(where)) {
          pathArea = this.pixelSnapRectangle(where, pathArea);
        }
        top = pathArea.top, left = pathArea.left, w = pathArea.w, h = pathArea.h;
        _context.fillRect(left, top, w, h);
      } else {
        _context.beginPath();
        pathFunction(_context, pathArea, pathOptions);
        _context.fill(options.fillRule || "nonzero");
      }
      this._cleanupDraw(options);
    }
    return this;
  };

  Bitmap.prototype.drawBitmap = function(where, bitmap, options) {
    var aboutToDrawTime, drawed, endTime, h, inputBitmap, inputBitmapSize, origSourceArea, ref3, ref4, sh, sourceArea, startTime, sw, sx, sy, w, x, y;
    if (options == null) {
      options = emptyOptions;
    }
    startTime = currentSecond();
    sourceArea = options.sourceArea;
    inputBitmap = bitmap;
    if (bitmap.toMemoryDrawableBitmap) {
      bitmap = bitmap.toMemoryDrawableBitmap();
    }
    bitmap = bitmap._canvas || bitmap._htmlImageElement || bitmap;
    inputBitmapSize = inputBitmap.size || point(inputBitmap.width, inputBitmap.height);
    drawed = "";
    if (this.shouldPixelSnap(where)) {
      ref3 = this.pixelSnapAndTransformRectangle(where, (sourceArea != null ? sourceArea.size : void 0) || inputBitmapSize), x = ref3.x, y = ref3.y, w = ref3.w, h = ref3.h;
      if (sourceArea) {
        sx = round(sourceArea.x);
        sy = round(sourceArea.y);
        sw = round(sourceArea.w);
        sh = round(sourceArea.h);
      } else {
        sx = sy = 0;
        sw = inputBitmapSize.x;
        sh = inputBitmapSize.y;
      }
      if (this._setupDraw(null, options)) {
        drawed = "pixelSnap - " + (inspect([sx, sy, sw, sh]));
        aboutToDrawTime = currentSecond();
        this._context.drawImage(bitmap, sx, sy, sw, sh, x, y, w, h);
        this._cleanupDraw(options);
      }
    } else {
      if (this._setupDraw(where, options)) {
        aboutToDrawTime = currentSecond();
        if (origSourceArea = sourceArea) {
          drawed = "sourceArea";
          ref4 = sourceArea.intersection(rect(inputBitmap.size)), x = ref4.x, y = ref4.y, w = ref4.w, h = ref4.h;
          this._context.drawImage(bitmap, x, y, w, h, 0, 0, w, h);
        } else {
          drawed = "other";
          this._context.drawImage(bitmap, 0, 0);
        }
        this._cleanupDraw(options);
      }
    }
    endTime = currentSecond();
    if (endTime - startTime > .1) {
      global.slowDraw = {
        target: this,
        source: bitmap,
        where: where,
        options: options
      };
      log({
        Canvas_Bitmap_drawBitmap: {
          message: "details: global.slowDraw",
          slowDraw: ((endTime - startTime) * 1000 | 0) + "ms",
          time2: ((endTime - aboutToDrawTime) * 1000 | 0) + "ms",
          where: where,
          options: options,
          drawed: drawed,
          bitmapSize: [bitmap._size, bitmap.width, bitmap.height]
        }
      });
    }
    return this;
  };


  /*
  IN:
    options:
      fontFamily:
      fontSize:
      align:
      baseline:
  
      DEPRICATED:
        size:
        family:
   */

  Bitmap.prototype.drawText = function(where, text, options) {
    if (options == null) {
      options = emptyOptions;
    }
    if (this._setupDraw(where, options)) {
      this._context.font = (options.fontSize || options.size || 16) + "px " + (options.fontFamily || options.family || 'Arial') + ", Arial";
      this._context.textAlign = options.align || 'start';
      this._context.textBaseline = options.baseline || 'alphabetic';
      this._context.fillText(text, 0, 0);
      this._cleanupDraw(options);
    }
    return this;
  };

  Bitmap.prototype.blur = function(radius, toClone) {
    return (toClone ? this.clone() : this).tap((function(_this) {
      return function(target) {
        return StackBlur.blur(_this, radius, target);
      };
    })(this));
  };

  Bitmap.prototype.blurAlpha = function(radius, options) {
    if (options == null) {
      options = emptyOptions;
    }
    return (options.clone ? this.clone() : this).tap((function(_this) {
      return function(target) {
        var func;
        func = options.inverted ? "blurInvertedAlpha" : "blurAlpha";
        return StackBlur[func](_this, radius, target);
      };
    })(this));
  };

  Bitmap.prototype._clearTransform = function() {
    this._lastTransform = IdentityMatrix;
    return this._context.setTransform(1, 0, 0, 1, 0, 0);
  };

  Bitmap.prototype._setTransform = function(m) {
    if (m) {
      this._lastTransform = m;
      if (isPoint(m)) {
        return this._context.setTransform(1, 0, 0, 1, m.x, m.y);
      } else {
        return this._context.setTransform(m.sx, m.shy, m.shx, m.sy, m.tx, m.ty);
      }
    } else {
      return this._clearTransform();
    }
  };

  Bitmap.prototype._setStrokeStyle = function(strokeStyle) {
    return this._context.strokeStyle = strokeStyle.toCanvasStyle ? strokeStyle.toCanvasStyle(this._context) : strokeStyle.toString();
  };

  Bitmap.prototype._setFillStyle = function(fillStyle) {
    return this._context.fillStyle = fillStyle.toCanvasStyle ? fillStyle.toCanvasStyle(this._context) : fillStyle.toString();
  };

  Bitmap.prototype._getFillStyleFromOptions = function(options) {
    var colors, fromPoint, gradientRadius1, toPoint;
    if (colors = options.colors) {
      if (colors.constructor === GradientFillStyle) {
        return colors;
      } else {
        fromPoint = options.from || point0;
        gradientRadius1 = options.gradientRadius1 || options.gradientRadius;
        toPoint = options.to || (gradientRadius1 != null ? fromPoint : this.size);
        return new GradientFillStyle(fromPoint, toPoint, options.colors, gradientRadius1, options.gradientRadius2);
      }
    } else {
      return options.fillStyle || options.color || this.defaultColorString;
    }
  };

  Bitmap.prototype._setStrokeStyleFromOptions = function(options) {
    var lineCap, lineDash, lineJoin, lineWidth, miterLimit;
    this._setStrokeStyle(this._getFillStyleFromOptions(options));
    lineWidth = options.lineWidth, lineCap = options.lineCap, lineJoin = options.lineJoin, miterLimit = options.miterLimit, lineDash = options.lineDash;
    this._context.setLineDash(lineDash || []);
    this._context.lineWidth = lineWidth || 1;
    this._context.lineCap = lineCap || "butt";
    this._context.lineJoin = lineJoin || "miter";
    return this._context.miterLimit = miterLimit || 10;
  };

  Bitmap.prototype._setFillStyleFromOptions = function(options) {
    return this._setFillStyle(this._getFillStyleFromOptions(options));
  };

  Bitmap.prototype._setupDraw = function(where, options, stroke) {
    var _context, blur, compositeMode, offset, offsetX, offsetY, opacity, shadow, shadowColor;
    compositeMode = options.compositeMode, shadow = options.shadow, opacity = options.opacity;
    stroke || (stroke = options.stroke);
    if (!isNumber(opacity)) {
      opacity = 1;
    }
    if (opacity < 1 / 256) {
      return false;
    }
    _context = this._context;
    if (stroke) {
      this._setStrokeStyleFromOptions(options);
    } else {
      this._setFillStyleFromOptions(options);
    }
    if (compositeMode && compositeMode !== "normal") {
      _context.globalCompositeOperation = canvasBlenders[compositeMode] || canvasBlenders.normal;
    }
    if (opacity < 1) {
      _context.globalAlpha = opacity;
    }
    if (shadow) {
      blur = shadow.blur, offsetX = shadow.offsetX, offsetY = shadow.offsetY, offset = shadow.offset;
      shadowColor = shadow.color;
      _context.shadowColor = rgbColor(shadowColor || "black");
      if (blur) {
        _context.shadowBlur = blur;
      }
      offsetX || (offsetX = 0);
      offsetY || (offsetY = 0);
      if (isMatrix(where)) {

        /*
        Shadows seem to ignore scale and rotation transformations.
        
        It seems someone wanted to enforce consistent shadows while completely breaking
        the setTransform abstraction. Bah! :)
        
        I believe this was a design mistake. It introduces inconsistencies both subtle
        and large. For example, it makes shadow placement vary across devices depending
        upon their devicePixelsPerPoint. No other draw command works this way.
        
        Consistent shadows should be up to the programmer, not the drawing engine.
        
        I believe this hack solves the problem. Shadow SHAPE does obey setTransforms. It
        is also correctly proporitonal to the shape it is creating a shadow of. Said shape
        fully obeys setTrasform - including location. Only the vector from the center of
        the shape to the center of the shadow seems to ignore setTransform.
         - July 2016, SBD
         */
        _context.shadowOffsetX = Matrix.transform1D(offsetX, offsetY, where.sx, where.shx, 0);
        _context.shadowOffsetY = Matrix.transform1D(offsetY, offsetX, where.sy, where.shy, 0);
      } else {
        _context.shadowOffsetX = offsetX;
        _context.shadowOffsetY = offsetY;
      }
    }
    this._setTransform(where);
    return true;
  };

  Bitmap.prototype._cleanupDraw = function(options) {
    var _context, compositeMode, opacity, shadow;
    compositeMode = options.compositeMode, shadow = options.shadow, opacity = options.opacity;
    if (!isNumber(opacity)) {
      opacity = 1;
    }
    _context = this._context;
    if (compositeMode && compositeMode !== "normal") {
      _context.globalCompositeOperation = canvasBlenders.normal;
    }
    if (opacity < 1) {
      _context.globalAlpha = 1;
    }
    if (shadow) {
      _context.shadowColor = "transparent";
      _context.shadowBlur = 0;
      _context.shadowOffsetX = 0;
      return _context.shadowOffsetY = 0;
    }
  };

  return Bitmap;

})(BitmapBase);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, Foundation, GradientFillStyle, arrayWith, bound, clone, flatten, floatEq, inspect, isNumber, isPlainArray, isPlainObject, isString, log, min, peek, point, point1, rgbColor, shallowClone,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Atomic = __webpack_require__(4);

Foundation = __webpack_require__(2);

point = Atomic.point, rgbColor = Atomic.rgbColor, point1 = Atomic.point1;

inspect = Foundation.inspect, shallowClone = Foundation.shallowClone, flatten = Foundation.flatten, isPlainObject = Foundation.isPlainObject, log = Foundation.log, isNumber = Foundation.isNumber, isString = Foundation.isString, isPlainArray = Foundation.isPlainArray, clone = Foundation.clone, min = Foundation.min, floatEq = Foundation.floatEq, peek = Foundation.peek, arrayWith = Foundation.arrayWith, bound = Foundation.bound;

module.exports = GradientFillStyle = (function(superClass) {
  var generateStripes;

  extend(GradientFillStyle, superClass);


  /*
  from and to are points where the lineary gradient will begin and end.
  "colors" is a list of the colors for the gradient. There must be at least two colors.
  In the explicit form, each rgbColor should be formatted as {n:<number>, c:<html rgbColor string>}
    Ex: {n:.45, c:"#ff0"}
  Implicitly, you can:
    provide just a HTML rgbColor string with no "n".
    N is determined as follows:
      The first and last rgbColor will be forced to have n=0 and n=1 respectively
      Any string of omitted Ns will be interpolated between the specified ns.
  
  Examples:
    black to white:
      new GradientFillStyle point(0,0), point(100,0), {c:"#000"}, {c:"#fff"}
      OR
      new GradientFillStyle point(0,0), point(100,0), "#000", "#fff"
  
    black to red to white:
      new GradientFillStyle point(0,0), point(100,0), {c:"#000"}, {n:.5, c:"#f00"}, {c:"#fff"}
      OR
      new GradientFillStyle point(0,0), point(100,0), "#000", "#f00", "#fff"
  
    red to transparent
      new GradientFillStyle point(0,0), point(100,0), #f00", "rgba(1,0,0,0)"
  
    rainbow:
      new GradientFillStyle(
        point(0,0), point(100,0)
        "#f00"
        "#ff0"
        "#0f0"
        "#0ff"
        "#00f"
        "#f0f"
        "#f00"
      )
   */

  GradientFillStyle.colorsToObjectsAndColorObjects = function(colors) {
    var clr, j, len, results;
    results = [];
    for (j = 0, len = colors.length; j < len; j++) {
      clr = colors[j];
      if (isPlainObject(clr)) {
        results.push({
          n: clr.n,
          c: rgbColor(clr.c)
        });
      } else {
        results.push({
          c: rgbColor(clr)
        });
      }
    }
    return results;
  };

  GradientFillStyle.colorsFromObjects = function(colors) {
    var c, clr, j, k, len, n, ret;
    ret = [];
    for (j = 0, len = colors.length; j < len; j++) {
      clr = colors[j];
      if (isPlainObject(clr)) {
        if (isNumber(clr.r)) {
          ret.push(rgbColor(clr));
        } else if (isNumber(clr.n)) {
          ret.push(clr);
        } else {
          for (k in clr) {
            c = clr[k];
            n = k - 0;
            ret.push({
              n: n,
              c: c
            });
          }
        }
      } else {
        ret.push(clr);
      }
    }
    return ret;
  };

  GradientFillStyle.interpolateColorPositionRange = function(outColors, colors, start, end, firstN, lastN) {
    var i, j, nDelta, ref, ref1, results, steps;
    steps = end - start + 1;
    nDelta = (lastN - firstN) / steps;
    results = [];
    for (i = j = ref = start, ref1 = end; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
      results.push(outColors.push({
        c: colors[i].c,
        n: (i - start + 1) * nDelta
      }));
    }
    return results;
  };

  GradientFillStyle.needToInterpolateColors = function(colors) {
    var clr, j, len, ret;
    ret = false;
    for (j = 0, len = colors.length; j < len; j++) {
      clr = colors[j];
      if (!(clr.n == null)) {
        continue;
      }
      ret = true;
      break;
    }
    return ret;
  };

  GradientFillStyle.interpolateColorPositions = function(colors) {
    var clr, firstColor, i, interpolateCount, j, lastColor, len, n, outColors, startN;
    if (!GradientFillStyle.needToInterpolateColors(colors)) {
      return colors;
    }
    firstColor = colors[0], lastColor = colors[colors.length - 1];
    if (firstColor.n == null) {
      firstColor = {
        c: firstColor.c,
        n: 0
      };
    }
    if (lastColor.n == null) {
      lastColor = {
        c: lastColor.c,
        n: 1
      };
    }
    outColors = [firstColor];
    startN = firstColor.n;
    interpolateCount = 0;
    for (i = j = 0, len = colors.length; j < len; i = ++j) {
      clr = colors[i];
      if (!(i > 0)) {
        continue;
      }
      if (i === colors.length - 1) {
        clr = lastColor;
      }
      n = clr.n;
      if (n != null) {
        if (interpolateCount > 0) {
          GradientFillStyle.interpolateColorPositionRange(outColors, colors, i - interpolateCount, i, startN, n);
          interpolateCount = 0;
        }
        startN = n;
      } else {
        interpolateCount++;
      }
    }
    outColors.push(lastColor);
    return outColors;
  };

  GradientFillStyle.sortColorsByN = function(colors) {
    return colors.sort(function(a, b) {
      return a.n - b.n;
    });
  };

  GradientFillStyle.normalizeColors = function(colors) {
    var k, v;
    if (isPlainArray(colors)) {
      return this.sortColorsByN(this.interpolateColorPositions(this.colorsToObjectsAndColorObjects(this.colorsFromObjects(colors))));
    } else if (isPlainObject(colors)) {
      colors = (function() {
        var results;
        results = [];
        for (k in colors) {
          v = colors[k];
          results.push({
            n: k * 1,
            c: isString(v) ? v : String(rgbColor(v))
          });
        }
        return results;
      })();
      return this.interpolateColorPositions(this.sortColorsByN(colors));
    } else {
      return [
        {
          n: 0,
          c: rgbColor("black"),
          n: 1,
          c: rgbColor("white")
        }
      ];
    }
  };

  generateStripes = function(colors) {
    var color, i, j, lastColor, len, pos, ref, stripeColors;
    stripeColors = {};
    lastColor = stripeColors[0] = colors[0];
    stripeColors[1] = peek(colors);
    ref = colors = colors.slice(1, colors.length);
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      color = ref[i];
      pos = (i + 1) / (colors.length + 1);
      stripeColors[pos] = lastColor;
      stripeColors[pos + .0001] = lastColor = color;
    }
    return log(stripeColors);
  };

  function GradientFillStyle(from, to, colors, radius11, radius21) {
    var stripes;
    this.from = from;
    this.to = to;
    this.radius1 = radius11;
    this.radius2 = radius21;
    if (stripes = colors != null ? colors.stripes : void 0) {
      colors = generateStripes(stripes);
    }
    this.setColors(this.inputColors = colors);
  }

  GradientFillStyle.prototype.inspect2 = function() {
    return "gradient(from:" + this.from + ", to:" + this.to + ", colors:" + (inspect(this.inputColors)) + ")";
  };

  GradientFillStyle.clone = function() {
    return new GradientFillStyle(this.from, this.to, shallowClone(this.colors), this.radius1, this.radius2);
  };

  GradientFillStyle.getter({
    colors: function() {
      return this._colors;
    },
    premultipliedColorPositions: function() {
      var a, j, len, ref, results;
      ref = this._colors;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        a = ref[j];
        results.push({
          n: a.n,
          c: rgbColor(a.c).premultiplied
        });
      }
      return results;
    }
  });

  GradientFillStyle.setter({
    colors: function(colors) {
      var k, v;
      return this._colors = isPlainArray(colors) ? GradientFillStyle.normalizeColors(colors) : isPlainObject(colors) ? (colors = (function() {
        var results;
        results = [];
        for (k in colors) {
          v = colors[k];
          results.push({
            n: k * 1,
            c: isString(v) ? v : String(rgbColor(v))
          });
        }
        return results;
      })(), colors = GradientFillStyle.sortColorsByN(colors), GradientFillStyle.interpolateColorPositions(colors)) : [
        {
          n: 0,
          c: rgbColor("black"),
          n: 1,
          c: rgbColor("white")
        }
      ];
    }
  });

  GradientFillStyle.getter({
    inspectedObjects: function() {
      return {
        GradientFillStyle: {
          from: this.from,
          to: this.to,
          colors: this.colors,
          radius1: this.radius1,
          radius2: this.radius2
        }
      };
    }
  });

  GradientFillStyle.prototype.getColorAt = function(atN) {
    var c, i, j, lastC, lastN, len, n, range, ref, ref1;
    lastN = null;
    lastC = null;
    ref = this.colors;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      ref1 = ref[i], c = ref1.c, n = ref1.n;
      if (atN <= n) {
        if (lastC) {
          range = n - lastN;
          return rgbColor(lastC).interpolate(c, (atN - lastN) / range);
        } else {
          return c;
        }
      }
      lastC = c;
      lastN = n;
    }
    return null;
  };

  GradientFillStyle.prototype.toCanvasStyle = function(context) {
    var clr, e, gradient, j, len, n, radius1, radius2, ref, ref1;
    if (context.context) {
      context = context.context;
    }
    gradient = this.radius1 != null ? (this.radius2 != null ? (ref = this, radius1 = ref.radius1, radius2 = ref.radius2, ref) : (radius1 = 0, radius2 = this.radius1), context.createRadialGradient(this.from.x, this.from.y, radius1, this.to.x, this.to.y, radius2)) : context.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);
    ref1 = this._colors;
    for (j = 0, len = ref1.length; j < len; j++) {
      clr = ref1[j];
      n = bound(0, clr.n, 1);
      try {
        gradient.addColorStop(n, clr.c.toString());
      } catch (error) {
        e = error;
        gradient.addColorStop(n, "black");
      }
    }
    return gradient;
  };

  return GradientFillStyle;

})(Foundation.BaseObject);


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

var Paths, bound, float32Eq0, floatEq, isFunction, isNumber, isPlainObject, isRect, log, max, min, ref;

isRect = __webpack_require__(4).isRect;

ref = __webpack_require__(1), log = ref.log, floatEq = ref.floatEq, min = ref.min, max = ref.max, isNumber = ref.isNumber, isPlainObject = ref.isPlainObject, isFunction = ref.isFunction, float32Eq0 = ref.float32Eq0, bound = ref.bound;


/*
Path functions all take the same signature:
  context: the HTML5 2d-canvas context
  pathArea: a point or rectangle
    ALL PATHS SHOULD BE 100% INSIDE
    THE AREA SPECIFIEDY BY 'SIZE'
    Paths should scale to just fit within
    the pathArea specified.

  options: optional options-object
    Example: rectanglePath takes a 'radius' parameter

EXCEPTION: linePath - is special for now
 */

module.exports = Paths = (function() {
  var rectangle, roundedRectanglePath;

  function Paths() {}

  Paths.linePath = function(context, fromPoint, toPoint) {
    context.moveTo(fromPoint.x, fromPoint.y);
    return context.lineTo(toPoint.x, toPoint.y);
  };

  Paths.circlePath = function(context, pathArea, options) {
    var h, hCenter, radius, vCenter, w;
    hCenter = pathArea.hCenter, vCenter = pathArea.vCenter, w = pathArea.w, h = pathArea.h;
    radius = min(w, h) / 2;
    context.arc(hCenter, vCenter, radius, 0, Math.PI * 2, true);
    return context.closePath();
  };

  Paths.circlePath.obtuse = true;


  /*
  options:
    radius:
      number >= 0
      OR
      object:
        With one or more number props:
          tl, tr, bl, br, bottomLeft, bottomRight, topLeft, topRight, top, bottom, left, right
        Each specifies one or two corners to set the radius for
   */

  Paths.rectanglePath = function(context, pathArea, options) {
    return roundedRectanglePath(context, pathArea, options != null ? options.radius : void 0);
  };

  Paths.rectanglePath.obtuse = true;

  Paths.roundedRectanglePath = roundedRectanglePath = function(context, r, radius) {
    var bl, bottom, bottomLeft, bottomRight, br, h, hCenter, halfW, left, maxRadius, ref1, ref2, ref3, ref4, right, tl, top, topLeft, topRight, tr, vCenter, w;
    if (!((radius != null) && !float32Eq0(radius))) {
      left = r.left, right = r.right, top = r.top, bottom = r.bottom;
      context.moveTo(left, top);
      context.lineTo(right, top);
      context.lineTo(right, bottom);
      context.lineTo(left, bottom);
      return context.closePath();
    } else {
      if (isPlainObject(radius)) {
        tl = radius.tl, tr = radius.tr, bl = radius.bl, br = radius.br, bottomLeft = radius.bottomLeft, bottomRight = radius.bottomRight, topLeft = radius.topLeft, topRight = radius.topRight, top = radius.top, bottom = radius.bottom, left = radius.left, right = radius.right;
        if (tr == null) {
          tr = (ref1 = topRight != null ? topRight : top) != null ? ref1 : right;
        }
        if (tl == null) {
          tl = (ref2 = topLeft != null ? topLeft : top) != null ? ref2 : left;
        }
        if (br == null) {
          br = (ref3 = bottomRight != null ? bottomRight : bottom) != null ? ref3 : right;
        }
        if (bl == null) {
          bl = (ref4 = bottomLeft != null ? bottomLeft : bottom) != null ? ref4 : left;
        }
      } else {
        tl = tr = bl = br = radius;
      }
      if (float32Eq0(tl) && float32Eq0(tr) && float32Eq0(bl) && float32Eq0(br)) {
        return rectangle(context, r);
      }
      w = r.w, h = r.h;
      w = max(0, w);
      h = max(0, h);
      if (floatEq(w, h) && isNumber(radius) && radius >= (halfW = w / 2)) {
        hCenter = r.hCenter, vCenter = r.vCenter;
        context.arc(hCenter, vCenter, halfW, 0, Math.PI * 2, true);
        return;
      }
      maxRadius = min(w / 2, h / 2);
      bl = bound(0, bl, maxRadius);
      br = bound(0, br, maxRadius);
      tl = bound(0, tl, maxRadius);
      tr = bound(0, tr, maxRadius);
      left = r.left, right = r.right, top = r.top, bottom = r.bottom;
      context.moveTo(left, top + tl);
      context.arcTo(left, top, left + tl, top, tl);
      context.lineTo(right - tr, top);
      context.arcTo(right, top, right, top + tr, tr);
      context.lineTo(right, bottom - br);
      context.arcTo(right, bottom, right - br, bottom, br);
      context.lineTo(left + bl, bottom);
      context.arcTo(left, bottom, left, bottom - bl, bl);
      return context.closePath();
    }
  };

  Paths.roundedRectanglePath.obtuse = true;

  Paths.roundedRectangle = function(a, b, c) {
    log.error("DEPRIACTED - use roundedRectanglePath");
    return roundedRectanglePath(a, b, c);
  };

  Paths.rectangle = rectangle = function(context, r) {
    var bottom, left, right, top;
    log.error("DEPRIACTED - use rectanglePath");
    left = r.left, right = r.right, top = r.top, bottom = r.bottom;
    context.moveTo(left, top);
    context.lineTo(right, top);
    context.lineTo(right, bottom);
    context.lineTo(left, bottom);
    return context.closePath();
  };

  Paths.curriedRoundedRectangle = function(r, radius) {
    log.error("DEPRICATED - use roundedRectanglePath && pathOptions");
    return function(context) {
      return roundedRectanglePath(context, r, radius);
    };
  };

  return Paths;

})();


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {
/*
SBD TODO

Bluring transparencies has errors. Repro:
  clear background to: color(1,0,0,.5)
  drawRectangle color(0,1,0,1) over a sub-area of the bitmap
  blur

The problem (I think) is transparent colors have equal weight as non-transparent colors.

...

I need to test bluring on the edge of the bitmap. I'm not convinced it works right.

...

Possible speedup and simplification:

One solution which may be faster overall is to reserve one line of pixels in memory plus
the blur radius amount of pixels on each side. Those pixel colors should be repetitions of the edge colors.
Then we can blur over that range with reduced tests in our inner loop.
It looks like "slice" allows us to quickly get a subsection of an ArrayBuffer. That will work for all lines
except the first and last one(s). Just slice and then overwrite the first and end colors with the edge-colors.

UInt8Array .subarray and .set should make moving the pixles to and from pretty fast. The only slow part will
be filling the edge pixels in.
 */

/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version:  0.5
Author:   Mario Klingemann
Contact:  mario@quasimondo.com
Website:  http://www.quasimondo.com/StackBlurForCanvas
Twitter:  @quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr:
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
 */
var BaseClass, Canvas, color, defineModule, inspect, matrix, nextTick, point, rect, ref, ref1,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Canvas = __webpack_require__(202);

ref = __webpack_require__(4), point = ref.point, matrix = ref.matrix, rect = ref.rect, color = ref.color;

ref1 = __webpack_require__(1), defineModule = ref1.defineModule, inspect = ref1.inspect, nextTick = ref1.nextTick;

BaseClass = __webpack_require__(6).BaseClass;

__webpack_require__(69);

defineModule(module, function() {
  var BlurStack;
  BlurStack = (function() {
    function BlurStack() {
      this.r = this.g = this.b = this.a = 0;
      this.next = null;
    }

    return BlurStack;

  })();
  return Canvas.StackBlur = (function(superClass) {
    extend(StackBlur, superClass);

    function StackBlur() {
      return StackBlur.__super__.constructor.apply(this, arguments);
    }

    StackBlur.blur = function(bitmap, radius) {
      return (new Canvas.StackBlur).blur(bitmap, radius);
    };

    StackBlur.blurRGB = function(bitmap, radius) {
      return (new Canvas.StackBlur).blurRGB(bitmap, radius);
    };

    StackBlur.blurAlpha = function(bitmap, radius) {
      return (new Canvas.StackBlur).blurAlpha(bitmap, radius);
    };

    StackBlur.blurInvertedAlpha = function(bitmap, radius) {
      return (new Canvas.StackBlur).blurInvertedAlpha(bitmap, radius);
    };

    StackBlur.prototype.blur = function(bitmap, radius, targetBitmap) {
      var imageData, pixels;
      targetBitmap || (targetBitmap = bitmap);
      imageData = bitmap.getImageData();
      pixels = imageData.data;
      radius = radius + .5 | 0;
      if (radius > 0) {
        this.stackBlurCanvasRGBA(pixels, bitmap.size.w, bitmap.size.h, radius);
      }
      return targetBitmap.putImageData(imageData);
    };

    StackBlur.prototype.blurRGB = function(bitmap, radius, targetBitmap) {
      var imageData, pixels;
      targetBitmap || (targetBitmap = bitmap);
      imageData = bitmap.getImageData();
      pixels = imageData.data;
      radius = radius + .5 | 0;
      if (radius > 0) {
        this.stackBlurCanvasRGB(pixels, bitmap.size.w, bitmap.size.h, radius);
      }
      return targetBitmap.putImageData(imageData);
    };

    StackBlur.prototype.blurAlpha = function(bitmap, radius, targetBitmap) {
      var imageData, pixels;
      targetBitmap || (targetBitmap = bitmap);
      imageData = bitmap.getImageData();
      pixels = imageData.data;
      radius = radius + .5 | 0;
      if (radius > 0) {
        this.stackBlurCanvasAlpha(pixels, bitmap.size.w, bitmap.size.h, radius);
      }
      return targetBitmap.putImageData(imageData);
    };

    StackBlur.prototype.blurInvertedAlpha = function(bitmap, radius, targetBitmap) {
      var imageData, pixels;
      targetBitmap || (targetBitmap = bitmap);
      imageData = bitmap.getImageData();
      pixels = imageData.data;
      radius = radius + .5 | 0;
      this.invertAlpha(pixels, bitmap.size.area);
      if (radius > 0) {
        this.stackBlurCanvasAlpha(pixels, bitmap.size.w, bitmap.size.h, radius);
      }
      return targetBitmap.putImageData(imageData);
    };

    StackBlur.prototype.invertAlpha = function(pixels, numPixels) {
      var end, end8, i, results;
      i = 0;
      end = numPixels * 4 - 4;
      end8 = end - (end % 8);
      while (i <= end) {
        pixels[i + 3] = 255 - pixels[i + 3];
        i += 4;
        pixels[i + 3] = 255 - pixels[i + 3];
        i += 4;
        pixels[i + 3] = 255 - pixels[i + 3];
        i += 4;
        pixels[i + 3] = 255 - pixels[i + 3];
        i += 4;
        pixels[i + 3] = 255 - pixels[i + 3];
        i += 4;
        pixels[i + 3] = 255 - pixels[i + 3];
        i += 4;
        pixels[i + 3] = 255 - pixels[i + 3];
        i += 4;
        pixels[i + 3] = 255 - pixels[i + 3];
        i += 4;
      }
      results = [];
      while (i <= end) {
        pixels[i + 3] = 255 - pixels[i + 3];
        results.push(i += 4);
      }
      return results;
    };

    StackBlur.prototype.createStack = function(radius) {
      var i, j, ref2, stack;
      this.stackStart = new BlurStack();
      stack = this.stackStart;
      for (i = j = 1, ref2 = 2 * radius; j <= ref2; i = j += 1) {
        stack = stack.next = new BlurStack();
        if (i === radius + 1) {
          this.stackEnd = stack;
        }
      }
      return stack.next = this.stackStart;
    };

    StackBlur.prototype.rgbaPass = function(radius, pixels, outterStep, outterEnd, innerStep, innerEndDelta) {
      var a_in_sum, a_out_sum, a_sum, b_in_sum, b_out_sum, b_sum, firstPixelSumWeight, g_in_sum, g_out_sum, g_sum, i, innerEnd, innerPos, innerRadiusEnd, j, oneOverStackWeight, outterPos, pa, pb, pg, pr, r_in_sum, r_out_sum, r_sum, radiusPlus1, rbs, readPos, readPosOffset, ref2, results, stackEnd, stackIn, stackOut, stackStart, stackWeight, weight;
      radiusPlus1 = radius + 1;
      stackWeight = radiusPlus1 * radiusPlus1;
      oneOverStackWeight = 1 / stackWeight;
      firstPixelSumWeight = (stackWeight + radiusPlus1) / 2;
      stackStart = this.stackStart;
      stackEnd = this.stackEnd;
      outterPos = 0;
      results = [];
      while (outterPos <= outterEnd) {
        r_in_sum = g_in_sum = b_in_sum = a_in_sum = 0;
        pr = pixels[outterPos];
        pg = pixels[outterPos + 1];
        pb = pixels[outterPos + 2];
        pa = pixels[outterPos + 3];
        if (pa < 255) {
          weight = pa / 255;
          pr *= weight;
          pg *= weight;
          pb *= weight;
        }
        r_out_sum = radiusPlus1 * pr;
        g_out_sum = radiusPlus1 * pg;
        b_out_sum = radiusPlus1 * pb;
        a_out_sum = radiusPlus1 * pa;
        r_sum = firstPixelSumWeight * pr;
        g_sum = firstPixelSumWeight * pg;
        b_sum = firstPixelSumWeight * pb;
        a_sum = firstPixelSumWeight * pa;
        stackIn = stackStart;
        for (i = j = 0, ref2 = radius; j <= ref2; i = j += 1) {
          stackIn.r = pr;
          stackIn.g = pg;
          stackIn.b = pb;
          stackIn.a = pa;
          stackIn = stackIn.next;
        }
        innerEnd = outterPos + innerEndDelta;
        rbs = radius;
        innerRadiusEnd = outterPos + radius * innerStep;
        innerPos = outterPos + innerStep;
        while (innerPos <= innerRadiusEnd) {
          readPos = innerPos;
          if (innerPos > innerEnd) {
            readPos = innerEnd;
          }
          pr = pixels[readPos];
          pg = pixels[readPos + 1];
          pb = pixels[readPos + 2];
          pa = pixels[readPos + 3];
          if (pa < 255) {
            weight = pa / 255;
            pr *= weight;
            pg *= weight;
            pb *= weight;
          }
          r_in_sum += stackIn.r = pr;
          g_in_sum += stackIn.g = pg;
          b_in_sum += stackIn.b = pb;
          a_in_sum += stackIn.a = pa;
          r_sum += pr * rbs;
          g_sum += pg * rbs;
          b_sum += pb * rbs;
          a_sum += pa * rbs;
          rbs--;
          stackIn = stackIn.next;
          innerPos += innerStep;
        }
        stackOut = stackEnd;
        readPosOffset = radiusPlus1 * innerStep;
        innerPos = outterPos;
        while (innerPos <= innerEnd) {
          pixels[innerPos + 3] = pa = a_sum * oneOverStackWeight;
          if (pa !== 0) {
            pa = oneOverStackWeight * 255 / pa;
            pixels[innerPos] = r_sum * pa;
            pixels[innerPos + 1] = g_sum * pa;
            pixels[innerPos + 2] = b_sum * pa;
          } else {
            pixels[innerPos] = pixels[innerPos + 1] = pixels[innerPos + 2] = 0;
          }
          r_sum -= r_out_sum;
          g_sum -= g_out_sum;
          b_sum -= b_out_sum;
          a_sum -= a_out_sum;
          r_out_sum -= stackIn.r;
          g_out_sum -= stackIn.g;
          b_out_sum -= stackIn.b;
          a_out_sum -= stackIn.a;
          readPos = innerPos + readPosOffset;
          if (readPos > innerEnd) {
            readPos = innerEnd;
          }
          pr = pixels[readPos];
          pg = pixels[readPos + 1];
          pb = pixels[readPos + 2];
          pa = pixels[readPos + 3];
          if (pa < 255) {
            weight = pa / 255;
            pr *= weight;
            pg *= weight;
            pb *= weight;
          }
          r_in_sum += stackIn.r = pr;
          g_in_sum += stackIn.g = pg;
          b_in_sum += stackIn.b = pb;
          a_in_sum += stackIn.a = pa;
          r_sum += r_in_sum;
          g_sum += g_in_sum;
          b_sum += b_in_sum;
          a_sum += a_in_sum;
          r_out_sum += pr = stackOut.r;
          g_out_sum += pg = stackOut.g;
          b_out_sum += pb = stackOut.b;
          a_out_sum += pa = stackOut.a;
          r_in_sum -= pr;
          g_in_sum -= pg;
          b_in_sum -= pb;
          a_in_sum -= pa;
          stackIn = stackIn.next;
          stackOut = stackOut.next;
          innerPos += innerStep;
        }
        results.push(outterPos += outterStep);
      }
      return results;
    };

    StackBlur.prototype.rgbPass = function(radius, pixels, outterStep, outterEnd, innerStep, innerEndDelta) {
      var b_in_sum, b_out_sum, b_sum, firstPixelSumWeight, g_in_sum, g_out_sum, g_sum, i, innerEnd, innerPos, innerRadiusEnd, j, oneOverStackWeight, outterPos, pb, pg, pr, r_in_sum, r_out_sum, r_sum, radiusPlus1, rbs, readPos, readPosOffset, ref2, results, stackEnd, stackIn, stackOut, stackStart, stackWeight;
      radiusPlus1 = radius + 1;
      stackWeight = radiusPlus1 * radiusPlus1;
      oneOverStackWeight = 1 / stackWeight;
      firstPixelSumWeight = (stackWeight + radiusPlus1) / 2;
      stackStart = this.stackStart;
      stackEnd = this.stackEnd;
      outterPos = 0;
      results = [];
      while (outterPos <= outterEnd) {
        r_in_sum = g_in_sum = b_in_sum = 0;
        pr = pixels[outterPos];
        pg = pixels[outterPos + 1];
        pb = pixels[outterPos + 2];
        r_out_sum = radiusPlus1 * pr;
        g_out_sum = radiusPlus1 * pg;
        b_out_sum = radiusPlus1 * pb;
        r_sum = firstPixelSumWeight * pr;
        g_sum = firstPixelSumWeight * pg;
        b_sum = firstPixelSumWeight * pb;
        stackIn = stackStart;
        for (i = j = 0, ref2 = radius; j <= ref2; i = j += 1) {
          stackIn.r = pr;
          stackIn.g = pg;
          stackIn.b = pb;
          stackIn = stackIn.next;
        }
        innerEnd = outterPos + innerEndDelta;
        rbs = radius;
        innerRadiusEnd = outterPos + radius * innerStep;
        innerPos = outterPos + innerStep;
        while (innerPos <= innerRadiusEnd) {
          readPos = innerPos;
          if (innerPos > innerEnd) {
            readPos = innerEnd;
          }
          pr = pixels[readPos];
          pg = pixels[readPos + 1];
          pb = pixels[readPos + 2];
          r_in_sum += stackIn.r = pr;
          g_in_sum += stackIn.g = pg;
          b_in_sum += stackIn.b = pb;
          r_sum += pr * rbs;
          g_sum += pg * rbs;
          b_sum += pb * rbs;
          rbs--;
          stackIn = stackIn.next;
          innerPos += innerStep;
        }
        stackOut = stackEnd;
        readPosOffset = radiusPlus1 * innerStep;
        innerPos = outterPos;
        while (innerPos <= innerEnd) {
          pixels[innerPos] = r_sum * oneOverStackWeight;
          pixels[innerPos + 1] = g_sum * oneOverStackWeight;
          pixels[innerPos + 2] = b_sum * oneOverStackWeight;
          r_sum -= r_out_sum;
          g_sum -= g_out_sum;
          b_sum -= b_out_sum;
          r_out_sum -= stackIn.r;
          g_out_sum -= stackIn.g;
          b_out_sum -= stackIn.b;
          readPos = innerPos + readPosOffset;
          if (readPos > innerEnd) {
            readPos = innerEnd;
          }
          pr = pixels[readPos];
          pg = pixels[readPos + 1];
          pb = pixels[readPos + 2];
          r_in_sum += stackIn.r = pr;
          g_in_sum += stackIn.g = pg;
          b_in_sum += stackIn.b = pb;
          r_sum += r_in_sum;
          g_sum += g_in_sum;
          b_sum += b_in_sum;
          r_out_sum += pr = stackOut.r;
          g_out_sum += pg = stackOut.g;
          b_out_sum += pb = stackOut.b;
          r_in_sum -= pr;
          g_in_sum -= pg;
          b_in_sum -= pb;
          stackIn = stackIn.next;
          stackOut = stackOut.next;
          innerPos += innerStep;
        }
        results.push(outterPos += outterStep);
      }
      return results;
    };

    StackBlur.prototype.alphaPass = function(radius, pixels, outterStep, outterEnd, innerStep, innerEndDelta) {
      var a_in_sum, a_out_sum, a_sum, firstPixelSumWeight, i, innerEnd, innerPos, innerRadiusEnd, j, oneOverStackWeight, outterPos, pa, radiusPlus1, rbs, readPos, readPosOffset, ref2, results, stackEnd, stackIn, stackOut, stackStart, stackWeight;
      radiusPlus1 = radius + 1;
      stackWeight = radiusPlus1 * radiusPlus1;
      oneOverStackWeight = 1 / stackWeight;
      firstPixelSumWeight = (stackWeight + radiusPlus1) / 2;
      stackStart = this.stackStart;
      stackEnd = this.stackEnd;
      outterPos = 3;
      outterEnd += 3;
      results = [];
      while (outterPos <= outterEnd) {
        a_in_sum = 0;
        pa = pixels[outterPos];
        a_out_sum = radiusPlus1 * pa;
        a_sum = firstPixelSumWeight * pa;
        stackIn = stackStart;
        for (i = j = 0, ref2 = radius; j <= ref2; i = j += 1) {
          stackIn.a = pa;
          stackIn = stackIn.next;
        }
        innerEnd = outterPos + innerEndDelta;
        rbs = radius;
        innerRadiusEnd = outterPos + radius * innerStep;
        innerPos = outterPos + innerStep;
        while (innerPos <= innerRadiusEnd) {
          readPos = innerPos;
          if (innerPos > innerEnd) {
            readPos = innerEnd;
          }
          pa = pixels[readPos];
          a_in_sum += stackIn.a = pa;
          a_sum += pa * rbs;
          rbs--;
          stackIn = stackIn.next;
          innerPos += innerStep;
        }
        stackOut = stackEnd;
        readPosOffset = radiusPlus1 * innerStep;
        innerPos = outterPos;
        while (innerPos <= innerEnd) {
          pixels[innerPos] = a_sum * oneOverStackWeight;
          a_sum -= a_out_sum;
          a_out_sum -= stackIn.a;
          readPos = innerPos + readPosOffset;
          if (readPos > innerEnd) {
            readPos = innerEnd;
          }
          a_in_sum += stackIn.a = pixels[readPos];
          a_sum += a_in_sum;
          a_out_sum += pa = stackOut.a;
          a_in_sum -= pa;
          stackIn = stackIn.next;
          stackOut = stackOut.next;
          innerPos += innerStep;
        }
        results.push(outterPos += outterStep);
      }
      return results;
    };

    StackBlur.prototype.stackBlurCanvasRGBA = function(pixels, width, height, radius) {
      if (radius <= 0) {
        return;
      }
      this.createStack(radius);
      this.rgbaPass(radius, pixels, 4, (width - 1) * 4, width * 4, (height - 1) * width * 4);
      return this.rgbaPass(radius, pixels, width * 4, (height - 1) * width * 4, 4, (width - 1) * 4);
    };

    StackBlur.prototype.stackBlurCanvasAlpha = function(pixels, width, height, radius) {
      if (radius <= 0) {
        return;
      }
      this.createStack(radius);
      this.alphaPass(radius, pixels, 4, (width - 1) * 4, width * 4, (height - 1) * width * 4);
      return this.alphaPass(radius, pixels, width * 4, (height - 1) * width * 4, 4, (width - 1) * 4);
    };

    StackBlur.prototype.stackBlurCanvasRGB = function(pixels, width, height, radius) {
      if (radius <= 0) {
        return;
      }
      this.createStack(radius);
      this.rgbPass(radius, pixels, 4, (width - 1) * 4, width * 4, (height - 1) * width * 4);
      return this.rgbPass(radius, pixels, width * 4, (height - 1) * width * 4, 4, (width - 1) * 4);
    };

    return StackBlur;

  })(BaseClass);
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var Canvas,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.Canvas', Canvas = (function(superClass) {
  extend(Canvas, superClass);

  function Canvas() {
    return Canvas.__super__.constructor.apply(this, arguments);
  }

  Canvas.version = __webpack_require__(586).version;

  return Canvas;

})(Neptune.PackageNamespace));


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var clone, concatInto, defineModule, each, formattedInspect, isFunction, isPlainArray, isPlainObject, isString, log, lowerCamelCase, merge, mergeInto, object, ref, upperCamelCase,
  extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, object = ref.object, upperCamelCase = ref.upperCamelCase, lowerCamelCase = ref.lowerCamelCase, each = ref.each, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isFunction = ref.isFunction, clone = ref.clone, isString = ref.isString, mergeInto = ref.mergeInto, concatInto = ref.concatInto, formattedInspect = ref.formattedInspect, merge = ref.merge;


/*
Todo:
  validatedDeclarable / validatedExtendableProperty
    Which use Art.Validation

TODO:
  When we switch to ES6, we should make the
  class API look identical to the current instance API.

  That means declarable API looks like this:
    @extendableProperty foo: {}

     * extend:
    @foo: hi: 123

  The differnce is we add a ":".

  The benefit is it's a normal getter/setter pair:

    @foo = hi: 123

    log @foo

  The one diference is the "setter" is really an
  "extender"
 */

defineModule(module, function() {
  return function(superClass) {
    var ExtendablePropertyMixin;
    return ExtendablePropertyMixin = (function(superClass1) {
      var arrayPropertyExtender, defaultExtender, getOwnProperty, noOptions, objectPropertyExtender;

      extend1(ExtendablePropertyMixin, superClass1);

      function ExtendablePropertyMixin() {
        return ExtendablePropertyMixin.__super__.constructor.apply(this, arguments);
      }


      /*
      IN
        object: any object
        property: string, property name
        init:
          (object) -> returning initial value for object
          OR
            initial value is computed by:
            clone object[property] || init
      
      EFFECT:
        if object.hasOwnProperty property, return its current value
        otherwise, initialize and return it with init()
       */

      ExtendablePropertyMixin.getOwnProperty = getOwnProperty = function(object, property, init) {
        var ref1;
        if (object.hasOwnProperty(property)) {
          return object[property];
        } else {
          return object[property] = isFunction(init) ? init(object) : clone((ref1 = object[property]) != null ? ref1 : init);
        }
      };


      /*
      objectPropertyExtender
      
      IN: @ is set to the property-value to extend
      
      API 1:
        IN: map
        EFFECT: mergeInto propValue, map
      
      API 2:
        IN: key, value
        EFFECT: propValue[key] = valuee
      
      OUT: ignore
       */

      ExtendablePropertyMixin.objectPropertyExtender = objectPropertyExtender = function(toExtend, mapOrKey, value) {
        if (mapOrKey === void 0 || mapOrKey === null) {
          return toExtend;
        }
        if (isString(mapOrKey)) {
          toExtend[mapOrKey] = value;
        } else if (isPlainObject(mapOrKey)) {
          mergeInto(toExtend, mapOrKey);
        } else {
          log({
            mapOrKey: mapOrKey,
            value: value,
            type: mapOrKey != null ? mapOrKey.constructor : void 0
          });
          throw new Error("first value argument must be a plain object or string: " + (formattedInspect({
            key: mapOrKey,
            value: value
          })));
        }
        return toExtend;
      };


      /*
      arrayPropertyExtender
      
      IN: valueToExtend, value
        value:
          array: concatInto propValue, array
          non-array: propValue.push value
      
      NOTE: if you want to concat an array-as-a-value to the end of propValue, do this:
        arrayPropertyExtender.call propValue, [arrayAsValue]
      
      OUT: ignore
       */

      ExtendablePropertyMixin.arrayPropertyExtender = arrayPropertyExtender = function(toExtend, arrayOrValue) {
        if (isPlainArray(arrayOrValue)) {
          concatInto(toExtend, arrayOrValue);
        } else {
          toExtend.push(arrayOrValue);
        }
        return toExtend;
      };


      /*
      Extendable Properties
      
      EXAMPLE:
        class Foo extends BaseClass
          @extendableProperty foo: {}
      
      Extendable properties work like inheritance:
      
        When any subclass or instance extends an extendable property, they
        inherit a clone of the property from up the inheritance tree, and then
        add their own extensions without effecting the parent copy.
      
        With Object property types, this can just be a parallel prototype chain.
        (It isn't currently: if you modify a parent after extending it to a child,
        the child won't get updates.)
      
        BUT, you can also have array or other types of extend-properties, which
        JavaScript doesn't have any built-in mechanisms for inheriting.
      
      BASIC API:
      @extendableProperty: (map, options) -> ...
      
      IN:
        map: name: defaultValue
        options:
          declarable: true/false
            if true, slightly alters the created functions:
              for: @extendableProperty foo: ...
              generates:
                @foo
      
          extend:
            DEFAULTS:
              switch defaultValue
              when is Object then objectPropertyExtender
              when is Array  then arrayPropetyExtender
              else                defaultExtender
      
            (extendable, extendWithValues...) -> newExtendedOwnPropertyValue
              IN:
                extendable: the current, extended value, already cloned, so direct mutation is OK
                extendWithValues: 1 or more values passed into the extend funtion by the client.
                  Ex: for an array, this is either a single value or an array
                  Ex: for an object, this is either a single object or two args: key, value
              OUT: new property value to set own-property to
              EFFECT:
                Can be pure functional and just return the new, extended data.
                OR
                Can modify extendable directly, since it is an object/array/atomic value unique to the current class/instance.
                  If modifying extendable directly, be sure to return extendable.
                Regardless, the returned value becomes the new extendable prop's value.
      
      
      
      EFFECT: for each {foo: defaultValue} in map, extendableProperty:
        WARNING:
          !!! Don't modify the object returned by a getter !!!
      
          Getters only return the current, most-extended property value. It may not be extended to the
          current subclass or instance! Instead, call @extendFoo() if you wish to manually modify
          the extended property.
      
        declarable:
          getters:
            @getFoo:
            getFoo:
      
          extenders:
            @foo:
            foo:
      
        non-declarable:
      
          getters:
            @getFoo:
            @getter foo:
      
          extenders:
            @foo:
            @extendFoo:
            extendFoo:
      
            IN:
              0-args: nothing happens beyond the standard EFFECT
              1+args: passed to the "extend" function
      
            EFFECT: creates a extension (clone) of the property for the currnet class, subclass or instance
            OUT: the current, extendedPropValue
      
            API 1: IN: 0 args
              NO ADDITIONAL EFFECT - just returns the extended property
            API 2: IN: 1 or more args
              In addition to extending and returning the extended property:
              calls: propExtender extendedPropValue, args...
      
          NOTE: gthe prototype getters call the class getter for extension purposes.
            The result is each instance won't get its own version of the property.
            E.G. Interitance is done at the Class level, not the Instance level.
       */

      defaultExtender = function(toExtend, v) {
        if (v === void 0) {
          throw new Error("not expecting undefined");
        }
        return v;
      };

      noOptions = {};

      ExtendablePropertyMixin.extendableProperty = function(map, options) {
        var declarable, extend, noSetter, oldExtender;
        if (options == null) {
          options = noOptions;
        }
        if (isFunction(oldExtender = options)) {
          log.error("DEPRICATED customPropertyExtender not supported, use extend: option ");
          options = {
            extend: function() {
              var args, extendable;
              extendable = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
              return oldExtender.apply(extendable, args);
            }
          };
        }
        extend = options.extend, declarable = options.declarable, noSetter = options.noSetter;
        return each(map, (function(_this) {
          return function(defaultValue, name) {
            var extenderName, getterName, instanceExtender, instanceGetter, internalName, propertyExtender, ucProp;
            name = lowerCamelCase(name);
            ucProp = upperCamelCase(name);
            internalName = _this.propInternalName(name);
            getterName = "get" + ucProp;
            extenderName = "extend" + ucProp;
            propertyExtender = (function() {
              if (extend != null) {
                return extend;
              } else if (isPlainObject(defaultValue)) {
                return objectPropertyExtender;
              } else if (isPlainArray(defaultValue)) {
                return arrayPropertyExtender;
              } else {
                if (defaultValue === void 0) {
                  throw new Error("defaultValue must not be undefined");
                }
                return defaultExtender;
              }
            })();
            _this[getterName] = function() {
              var ref1;
              return (ref1 = this.prototype[internalName]) != null ? ref1 : defaultValue;
            };
            _this[name] = _this[extenderName] = function(value) {
              var extendablePropValue;
              extendablePropValue = getOwnProperty(this.prototype, internalName, defaultValue);
              if (arguments.length > 0 && value !== void 0) {
                this.prototype[internalName] = propertyExtender.apply(null, [extendablePropValue].concat(slice.call(arguments)));
              }
              return extendablePropValue;
            };
            instanceGetter = function() {
              var ref1;
              return (ref1 = this[internalName]) != null ? ref1 : defaultValue;
            };
            instanceExtender = _this.prototype[extenderName] = function(value) {
              var extendablePropValue;
              extendablePropValue = getOwnProperty(this, internalName, defaultValue);
              if (arguments.length > 0 && value !== void 0) {
                this[internalName] = propertyExtender.apply(null, [extendablePropValue].concat(slice.call(arguments)));
              }
              return extendablePropValue;
            };
            if (declarable) {
              _this.prototype[getterName] = instanceGetter;
              return _this.prototype[name] = instanceExtender;
            } else {
              if (!noSetter) {
                _this.addSetter(name, instanceExtender);
              }
              return _this.addGetter(name, instanceGetter);
            }
          };
        })(this));
      };

      ExtendablePropertyMixin.declarable = function(map, options) {
        return this.extendableProperty(map, merge(options, {
          declarable: true
        }));
      };

      return ExtendablePropertyMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 204 */
/***/ (function(module, exports) {

var WebpackHotLoader;

module.exports = WebpackHotLoader = (function() {
  function WebpackHotLoader() {}


  /*
  IN:
    _module should be the CommonJS 'module'
    modulePostLoadAction: (moduleState) -> ignored internally, returned from @runHot
  
  OUT: modulePostLoadAction moduleState
  
  EFFECT:
    modulePostLoadAction is run every time the module is loaded.
  
    Initially, moduleState is {}.
  
    moduleState is the same object every load:
      modulePostLoadAction can modify moduleState and it will persist through every reload.
  
    modulePostLoadAction is responsible for any and all
    update actions required due to the module load.
  
  NOTE:
    If _module is not hot, modulePostLoadAction will be invoked once with an empty {}.
   */

  WebpackHotLoader.runHot = function(_module, modulePostLoadAction) {
    var base, moduleState;
    if (!(_module != null ? _module.hot : void 0)) {
      return modulePostLoadAction({});
    }
    moduleState = (((base = _module.hot).data || (base.data = {
      moduleState: {}
    }))).moduleState;
    _module.hot.accept();
    _module.hot.dispose(function(data) {
      return data.moduleState = moduleState;
    });
    return modulePostLoadAction(moduleState);
  };

  return WebpackHotLoader;

})();


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var CommunicationStatus,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(405)).addNamespace('CommunicationStatus', CommunicationStatus = (function(superClass) {
  extend(CommunicationStatus, superClass);

  function CommunicationStatus() {
    return CommunicationStatus.__super__.constructor.apply(this, arguments);
  }

  CommunicationStatus.version = __webpack_require__(588).version;

  return CommunicationStatus;

})(Neptune.PackageNamespace));


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, ConfigRegistry, Configuration, deepMerge, defineModule, log, merge, mergeInto, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, merge = ref.merge, mergeInto = ref.mergeInto, deepMerge = ref.deepMerge;

BaseObject = __webpack_require__(6).BaseObject;

ConfigRegistry = __webpack_require__(70);

defineModule(module, Configuration = (function(superClass) {
  extend(Configuration, superClass);

  function Configuration() {
    return Configuration.__super__.constructor.apply(this, arguments);
  }

  Configuration.abstractClass();

  Configuration.register = function() {
    return ConfigRegistry.registerConfig(this.getName(), this.getProps());
  };

  Configuration.postCreateConcreteClass = function(arg) {
    var hotReloaded;
    hotReloaded = arg.hotReloaded;
    this.register();
    if (hotReloaded) {
      ConfigRegistry.reload();
    }
    return Configuration.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
  };

  Configuration.getProps = function() {
    return this.getConcretePrototypeProperties();
  };

  Configuration.deepMergeInConfig = function(config) {
    return mergeInto(this.prototype, deepMerge(this.getProps(), config));
  };

  return Configuration;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Lib, Promise, clone, compactFlatten, deepMerge, defineModule, expandPathedProperties, formattedInspect, getEnv, inspect, isPlainObject, isString, jsonParsableRegexp, log, merge, mergeInto, parseQuery, pushIfNotPresent, ref, upperCamelCase;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, Promise = ref.Promise, inspect = ref.inspect, formattedInspect = ref.formattedInspect, merge = ref.merge, deepMerge = ref.deepMerge, mergeInto = ref.mergeInto, parseQuery = ref.parseQuery, pushIfNotPresent = ref.pushIfNotPresent, isPlainObject = ref.isPlainObject, isString = ref.isString, upperCamelCase = ref.upperCamelCase, expandPathedProperties = ref.expandPathedProperties, clone = ref.clone, compactFlatten = ref.compactFlatten, getEnv = ref.getEnv;

jsonParsableRegexp = /^(\[.*\]|\{.*\}|\".*\"|((-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|true|false|null))$/;

defineModule(module, Lib = (function() {
  var smartJsonDecode;

  function Lib() {}

  Lib.smartJsonDecode = smartJsonDecode = function(value) {
    if (isString(value) && jsonParsableRegexp.test(value)) {
      return JSON.parse(value);
    } else {
      return value != null ? value : null;
    }
  };

  Lib.getExternalEnvironment = function(externalEnvironment) {
    var artConfig, artConfigName, e, k, m, v;
    if (externalEnvironment == null) {
      externalEnvironment = getEnv();
    }
    artConfig = externalEnvironment.artConfig, artConfigName = externalEnvironment.artConfigName;
    artConfig = (function() {
      if (isPlainObject(artConfig)) {
        return artConfig;
      } else if (isString(artConfig)) {
        try {
          return JSON.parse(artConfig);
        } catch (error) {
          e = error;
          log.error("\nInvalid 'artConfig' from externalEnvironment. Must be valid JSON.\n\n" + (formattedInspect({
            externalEnvironment: externalEnvironment
          })) + "\n\nartConfig: " + (formattedInspect(artConfig)) + "\n\nerror: " + e + "\n");
          return null;
        }
      } else {
        return {};
      }
    })();
    for (k in externalEnvironment) {
      v = externalEnvironment[k];
      if (m = k.match(/^artConfig([\._])(.+)$/)) {
        if (m[1] === "_") {
          artConfig[m[2].replace(/_/g, '.')] = smartJsonDecode(v);
        } else {
          artConfig[m[2]] = smartJsonDecode(v);
        }
      }
    }
    return {
      artConfig: artConfig,
      artConfigName: artConfigName
    };
  };


  /*
  normalized:
    map standard aliases (dev and prod)
    upperCamelCase
   */

  Lib.normalizeArtConfigName = function(artConfigName) {
    switch (artConfigName) {
      case "dev":
        return "Development";
      case "prod":
        return "Production";
      default:
        return artConfigName && upperCamelCase(artConfigName);
    }
  };

  return Lib;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var ConfigRegistry, Main, Promise, clone, compactFlatten, deepMerge, defineModule, expandPathedProperties, formattedInspect, getExternalEnvironment, inspect, isPlainObject, isString, log, merge, mergeInto, normalizeArtConfigName, parseQuery, pushIfNotPresent, ref, ref1, upperCamelCase,
  slice = [].slice;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, Promise = ref.Promise, inspect = ref.inspect, formattedInspect = ref.formattedInspect, merge = ref.merge, deepMerge = ref.deepMerge, mergeInto = ref.mergeInto, parseQuery = ref.parseQuery, pushIfNotPresent = ref.pushIfNotPresent, isPlainObject = ref.isPlainObject, isString = ref.isString, upperCamelCase = ref.upperCamelCase, expandPathedProperties = ref.expandPathedProperties, clone = ref.clone, compactFlatten = ref.compactFlatten;

ConfigRegistry = __webpack_require__(70);

ref1 = __webpack_require__(207), normalizeArtConfigName = ref1.normalizeArtConfigName, getExternalEnvironment = ref1.getExternalEnvironment;

defineModule(module, Main = (function() {
  var getArtConfig, getArtConfigName, getDefaultArtConfigName, setArtConfigName;

  function Main() {}

  Main.getArtConfigName = getArtConfigName = function() {
    return Neptune.Art.Config.configName;
  };

  Main.getArtConfig = getArtConfig = function() {
    return Neptune.Art.Config.config;
  };

  Main.getDefaultArtConfigName = getDefaultArtConfigName = function() {
    return Neptune.Art.Config.defaultArtConfigName;
  };

  setArtConfigName = function(name) {
    return Neptune.Art.Config.configName = name;
  };


  /*
  IN: configureOptions:
    artConfigName: string
      can be passed in:
        as an argument
        via process.env
        via the browser query string
  
      default: "Development"
  
      EFFECT:
        ArtConfig.configName =
          externalEnvironment.artConfigName ||
          artConfigName
  
    artConfig: JSON string OR plain object structure
      can be passed in:
        as an argument
        via process.env
        via the browser query string
  
      default: {}
  
      EFFECT:
        mergeInto ArtConfig.config, deepMerge
          ConfigRegistry.configs[artConfigName]
          global.artConfig
          artConfig
          externalEnvironment.artConfig
  
  EFFECTS:
    callback @artConfig for callback in ConfigRegistry.configurables
  
  Note the priority order of artConfig sources:
  
  Priority:
    #1. externalEnvironment.artConfig
    #2. the artConfig passed into configure
  
  
  EXAMPLES:
     * artConfig = verbose: true
    ConfigRegistry.configure
      verbose: true
  
     * artConfig = verbose: true
     * artConfigName = "Production"
    ConfigRegistry.configure
      artConfigName: "Production"
      verbose: true
  
     * artConfig = verbose: true
     * artConfigName = "Production"
    ConfigRegistry.configure
      artConfigName: "Production"
      artConfig: verbose: true
  
  TEST INPUTS: the second and third inputs are env and
    queryString, and are only there as mocks for testing.
   */

  Main.configure = function() {
    var __testEnv, artConfigArgument, artConfigNameArgument, c, conf, config, configName, configurable, configureOptions, defaultArtConfigName, externalEnvironment, i, len, obj, ref2, ref3, ref4, verbose;
    configureOptions = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    ref2 = Main.configureOptions = deepMerge.apply(null, configureOptions), artConfigNameArgument = ref2.artConfigName, artConfigArgument = ref2.artConfig, __testEnv = ref2.__testEnv;
    externalEnvironment = getExternalEnvironment(__testEnv);
    config = getArtConfig();
    defaultArtConfigName = getDefaultArtConfigName();
    configName = (function() {
      if (normalizeArtConfigName(externalEnvironment.artConfigName || artConfigNameArgument || global.artConfigName)) {
        configName = normalizeArtConfigName(externalEnvironment.artConfigName || artConfigNameArgument || global.artConfigName);
        if (configName && !ConfigRegistry.configs[configName]) {
          throw new Error("no config registered with name: " + configName);
        }
        return configName;
      } else {
        return defaultArtConfigName;
      }
    })();
    setArtConfigName(configName);
    Main.resetCurrentConfig();
    ref3 = compactFlatten([
      (function() {
        var j, len, ref3, results;
        ref3 = ConfigRegistry.configurables;
        results = [];
        for (j = 0, len = ref3.length; j < len; j++) {
          configurable = ref3[j];
          results.push(configurable.getPathedDefaultConfig());
        }
        return results;
      })(), ConfigRegistry.configs[configName], global.artConfig, artConfigArgument, externalEnvironment.artConfig
    ]);
    for (i = 0, len = ref3.length; i < len; i++) {
      conf = ref3[i];
      expandPathedProperties(conf, config);
    }
    verbose = config.verbose;
    verbose || (verbose = (ref4 = Main.configureOptions) != null ? ref4.verbose : void 0);
    if (verbose) {
      log("------------- ConfigRegistry: inputs");
      log({
        ConfigRegistry: {
          configNames: Object.keys(ConfigRegistry.configs),
          configurables: (function() {
            var j, len1, ref5, results;
            ref5 = ConfigRegistry.configurables;
            results = [];
            for (j = 0, len1 = ref5.length; j < len1; j++) {
              c = ref5[j];
              results.push(c.namespacePath);
            }
            return results;
          })(),
          setConfigName: {
            algorithm: "select LAST non-null",
            inputs: {
              defaultArtConfigName: defaultArtConfigName,
              "global.artConfigName": global.artConfigName,
              "arguments.artConfigName": artConfigNameArgument,
              "environment.artConfigName": externalEnvironment.artConfigName
            }
          },
          setConfig: {
            algorithm: "deep, pathed merge-all, LAST has priority",
            inputs: (
              obj = {
                defaultConfigs: (function() {
                var j, len1, ref5, results;
                ref5 = ConfigRegistry.configurables;
                results = [];
                for (j = 0, len1 = ref5.length; j < len1; j++) {
                  configurable = ref5[j];
                  results.push(configurable.getPathedDefaultConfig());
                }
                return results;
              })()
              },
              obj["configs." + configName] = ConfigRegistry.configs[configName],
              obj["global.artConfig"] = global.artConfig,
              obj["arguments.artConfig"] = artConfigArgument,
              obj["environment.artConfig"] = externalEnvironment.artConfig,
              obj
            )
          }
        }
      });
      log("------------- ConfigRegistry: configuring Configurables...");
    }
    Main._configureAllConfigurables();
    if (verbose) {
      log("------------- ConfigRegistry: configured");
      log({
        Art: {
          configName: configName,
          config: config
        }
      });
      log("------------- ConfigRegistry: done");
    }
    return config;
  };

  Main.resetCurrentConfig = function() {
    var config, k, results, v;
    config = getArtConfig();
    results = [];
    for (k in config) {
      v = config[k];
      results.push(delete config[k]);
    }
    return results;
  };

  Main.reload = function() {
    return Main.configure(Main.configureOptions);
  };

  Main._configureAllConfigurables = function() {
    var configurable, i, len, ref2;
    ref2 = ConfigRegistry.configurables;
    for (i = 0, len = ref2.length; i < len; i++) {
      configurable = ref2[i];
      configurable.configure(getArtConfig());
    }
    return this._notifyConfigurablesConfigured();
  };

  Main._notifyConfigurablesConfigured = function() {
    var configurable, i, len, ref2, results;
    ref2 = ConfigRegistry.configurables;
    results = [];
    for (i = 0, len = ref2.length; i < len; i++) {
      configurable = ref2[i];
      results.push(configurable.configured());
    }
    return results;
  };

  return Main;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var Config,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.Config', Config = (function(superClass) {
  extend(Config, superClass);

  function Config() {
    return Config.__super__.constructor.apply(this, arguments);
  }

  Config.version = __webpack_require__(589).version;

  return Config;

})(Neptune.PackageNamespace));


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {


/*
Useful ideas about optimizing animations and garbage collection: http://blog.artillery.com/2012/10/browser-garbage-collection-and-framerate.html

See Foundation.Transaction for most constructor options.

from-values are either explicitly specified in the constructor, or any other properties defined
  in the constructor will have their from-values saved during construction.

The animation is automatically started on construction UNLESS there are no to-values.
If there are no to-values specified, then you must manually, later, call "start". At that point, all to-values
are set to the current values.
 */
var Animator, BaseClass, Color, EasingFunctions, Event, EventEpoch, EventedMixin, Matrix, Point, Rectangle, Transaction, currentSecond, eventEpoch, inspect, inspectLean, log, matrix, max, min, point, rect, ref, ref1, ref2, rgbColor,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), currentSecond = ref.currentSecond, min = ref.min, max = ref.max, Transaction = ref.Transaction, inspect = ref.inspect, inspectLean = ref.inspectLean, log = ref.log, BaseClass = ref.BaseClass;

ref1 = __webpack_require__(4), rgbColor = ref1.rgbColor, Color = ref1.Color, point = ref1.point, Point = ref1.Point, rect = ref1.rect, Rectangle = ref1.Rectangle, matrix = ref1.matrix, Matrix = ref1.Matrix;

ref2 = __webpack_require__(14), Event = ref2.Event, EventEpoch = ref2.EventEpoch, EventedMixin = ref2.EventedMixin;

EasingFunctions = __webpack_require__(72);

eventEpoch = EventEpoch.eventEpoch;

module.exports = Animator = (function(superClass) {
  extend(Animator, superClass);

  Animator.animate = function(objects, options) {
    return new Animator(objects, options);
  };

  function Animator(objects, options) {
    if (options == null) {
      options = {};
    }
    Animator.__super__.constructor.apply(this, arguments);
    this.transaction = new Transaction(objects, options);
    this.fixedStep = options.fixedStep;
    if (this.fixedStep && this.fixedStep <= 0) {
      throw new Error("fixedStep must be > 0");
    }
    this.duration = options.duration || 0.25;
    this.f = options.f;
    if (!this.f) {
      this.f = EasingFunctions[this.fName = "easeInQuad"];
    } else if (typeof this.f === "string") {
      this.fName = this.f;
      this.f = EasingFunctions[this.f];
    } else {
      this.fName = "custom";
    }
    if (options.on) {
      this.on(options.on);
    }
    this.then = options.then;
    this.start();
  }

  Animator.prototype.inspect = function(inspector) {
    inspector.put(this.classPathName);
    inspector.put(" duration: " + this.duration + ", function: " + this.fName);
    if (this.activated) {
      inspector.put(", activated, frames: " + this.frames + ", pos: " + this.pos);
    }
    if (this.aborted) {
      inspector.put(", aborted");
    }
    if (this.deactivated) {
      inspector.put(", deactivated");
    }
    return this.transaction.inspectParts(inspector);
  };

  Animator.prototype.abort = function() {
    if (!this.aborted) {
      eventEpoch.logEvent("animationAborted", this.getObjectId());
      this.aborted = true;
      this.deactivateAnimation();
      return this.queueEvent("abort");
    }
  };

  Animator.prototype.start = function() {
    this.transaction.saveFromValues();
    this.transaction.saveToValues();
    this.transaction.optimize();
    this.updateValues(0);
    this.activateAnimation();
    this.frames = 0;
    return eventEpoch.queue((function(_this) {
      return function() {
        if (_this.deactivated) {
          return;
        }
        _this.updateValues(0);
        eventEpoch.logEvent("animation", _this.getObjectId());
        _this.startTime = currentSecond();
        _this.queueEvent("start");
        return eventEpoch.queue(function() {
          return _this.advance();
        });
      };
    })(this));
  };

  Animator.prototype.finish = function() {
    this.updateValues(1);
    return this.done();
  };

  Animator.getter({
    pos: function() {
      if (this.fixedStep) {
        return this.frames * this.fixedStep;
      } else {
        return (this.now - this.startTime) / this.duration;
      }
    },
    objects: function() {
      return this.transaction.objects;
    }
  });

  Animator.prototype.activateAnimation = function() {
    var animatedObject, i, len, ref3, results;
    if (this.activated) {
      return;
    }
    this.activated = true;
    log({
      activateAnimation: this
    });
    ref3 = this.objects;
    results = [];
    for (i = 0, len = ref3.length; i < len; i++) {
      animatedObject = ref3[i];
      log("  for: " + (inspect(animatedObject)));
      if (animatedObject._activeAnimator) {
        log(animatedObject.classPathName + " already has _activeAnimator... aborting last animation to start this one");
        animatedObject._activeAnimator.abort();
      }
      results.push(animatedObject._activeAnimator = this);
    }
    return results;
  };

  Animator.prototype.deactivateAnimation = function() {
    var animatedObject, i, len, ref3, results;
    if (this.deactivated) {
      return;
    }
    this.deactivated = true;
    ref3 = this.objects;
    results = [];
    for (i = 0, len = ref3.length; i < len; i++) {
      animatedObject = ref3[i];
      if (animatedObject._activeAnimator !== this) {
        this.log("INTERNAL WARNING - animatedObject._activeAnimator should == @");
        this.log("  animatedObject: (" + (inspect(animatedObject, 1)));
        this.log("  animatedObject._activeAnimator: (" + (inspect(animatedObject._activeAnimator, 1)));
        this.log("  @: (" + (inspect(this, 1)));
      }
      results.push(animatedObject._activeAnimator = null);
    }
    return results;
  };

  Animator.prototype.advance = function() {
    var pos;
    if (this.aborted || this.deactivated) {
      return;
    }
    this.frames++;
    this.now = currentSecond();
    pos = this.pos;
    if (pos < 1) {
      this.updateValues(this.f(pos));
      return eventEpoch.queue((function(_this) {
        return function() {
          return _this.advance();
        };
      })(this));
    } else {
      this.updateValues(1);
      return this.done();
    }
  };

  Animator.prototype.done = function() {
    if (this.aborted) {
      return;
    }
    eventEpoch.logEvent("animation", this.getObjectId());
    this.deactivateAnimation();
    this.queueEvent("done");
    return this.nextAnimation();
  };

  Animator.prototype.nextAnimation = function() {
    var objects;
    if (!this.then) {
      return;
    }
    objects = this.then.objects || this.then.object || this.objects;
    return new Animator(objects, this.then);
  };

  Animator.prototype.updateValues = function(p) {
    this.transaction.interpolate(p);
    return this.queueEvent("update", {
      p: p
    });
  };

  return Animator;

})(EventedMixin(BaseClass));


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

var Animation,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(20)).addNamespace('Animation', Animation = (function(superClass) {
  extend(Animation, superClass);

  function Animation() {
    return Animation.__super__.constructor.apply(this, arguments);
  }

  return Animation;

})(Neptune.PackageNamespace));


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

var EasingPersistantAnimator, PeriodicPersistantAnimator, PersistantAnimator, StateEpoch, _addAnimator, _addAnimators, isFunction, isNumber, isPlainArray, isString, log, merge, nextTick, processedAnimators, propsEq, ref, ref1, stateEpoch,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(77), log = ref.log, isFunction = ref.isFunction, isNumber = ref.isNumber, isString = ref.isString, isPlainArray = ref.isPlainArray, merge = ref.merge, propsEq = ref.propsEq, nextTick = ref.nextTick;

stateEpoch = (StateEpoch = __webpack_require__(37)).stateEpoch;

ref1 = __webpack_require__(115), PersistantAnimator = ref1.PersistantAnimator, EasingPersistantAnimator = ref1.EasingPersistantAnimator, PeriodicPersistantAnimator = ref1.PeriodicPersistantAnimator;

processedAnimators = null;

_addAnimator = (function(_this) {
  return function(prop, options) {
    var __, internalName, match;
    processedAnimators || (processedAnimators = {});
    if (match = prop.match(/^_(.*)/)) {
      internalName = prop;
      __ = match[0], prop = match[1];
    } else {
      internalName = "_" + prop;
    }
    return processedAnimators[internalName] = options instanceof PersistantAnimator ? options : isFunction(options) ? new PersistantAnimator(prop, {
      animate: options
    }) : isNumber(options != null ? options.period : void 0) ? new PeriodicPersistantAnimator(prop, merge(options, {
      continuous: true
    })) : (options != null ? options.animate : void 0) ? new PersistantAnimator(prop, options) : new EasingPersistantAnimator(prop, options);
  };
})(this);

_addAnimators = function(v) {
  var el, i, j, len, len1, options, prop, ref2, results, results1, results2;
  if (!v) {
    return;
  }
  if (isString(v)) {
    ref2 = v.match(/[a-z]+/gi);
    results = [];
    for (i = 0, len = ref2.length; i < len; i++) {
      prop = ref2[i];
      results.push(_addAnimator(prop));
    }
    return results;
  } else if (isPlainArray(v)) {
    results1 = [];
    for (j = 0, len1 = v.length; j < len1; j++) {
      el = v[j];
      results1.push(_addAnimators(el));
    }
    return results1;
  } else {
    results2 = [];
    for (prop in v) {
      options = v[prop];
      results2.push(_addAnimator(prop, options));
    }
    return results2;
  }
};

module.exports = function(superClass) {
  var AnimatedElementMixin;
  return AnimatedElementMixin = (function(superClass1) {
    extend(AnimatedElementMixin, superClass1);

    function AnimatedElementMixin() {
      return AnimatedElementMixin.__super__.constructor.apply(this, arguments);
    }

    AnimatedElementMixin.concreteProperty({
      animateOnCreation: {
        "default": false,
        validate: function(v) {
          return !v || v === true;
        }
      },
      animators: {
        "default": null,
        preprocess: function(v) {
          processedAnimators = null;
          _addAnimators(v);
          return processedAnimators;
        }
      }
    });

    AnimatedElementMixin.prototype._deactivatePersistantAnimators = function() {
      var animator, prop, ref2, results;
      ref2 = this.animators;
      results = [];
      for (prop in ref2) {
        animator = ref2[prop];
        results.push(animator.deactivate());
      }
      return results;
    };

    AnimatedElementMixin.prototype._activateContinuousPersistantAnimators = function() {
      return nextTick((function(_this) {
        return function() {
          return _this._elementChanged();
        };
      })(this));
    };

    AnimatedElementMixin.prototype.getPendingCreatedAndAddedToExistingParent = function() {
      var _animateOnCreation, _parent, ref2, ref3;
      ref2 = this._pendingState, _parent = ref2._parent, _animateOnCreation = ref2._animateOnCreation;
      return this.__stateEpochCount === 0 && (_animateOnCreation || !(((ref3 = this._pendingState._parent) != null ? ref3.__stateEpochCount : void 0) === 0));
    };

    AnimatedElementMixin.prototype.preprocessForEpoch = function() {
      var active, animateFromVoid, animator, baseValue, currentValue, epochCount, frameSecond, hasFromVoidAnimation, newValue, pendingAnimators, pendingValue, prop;
      if (pendingAnimators = this._pendingState._animators) {
        animateFromVoid = this.getPendingCreatedAndAddedToExistingParent();
        frameSecond = stateEpoch.frameSecond, epochCount = stateEpoch.epochCount;
        for (prop in pendingAnimators) {
          animator = pendingAnimators[prop];
          active = animator.active;
          pendingValue = this._pendingState[prop];
          baseValue = this.__stateEpochCount === 0 ? pendingValue : this[prop];
          currentValue = animateFromVoid && (hasFromVoidAnimation = animator.hasFromVoidAnimation) ? (this._animatingFromVoid = true, animator.getPreprocessedFromVoid(this, baseValue)) : baseValue;
          newValue = active || !propsEq(currentValue, pendingValue) ? animator.animateAbsoluteTime(this, currentValue, pendingValue, frameSecond) : pendingValue;
          this._pendingState[prop] = newValue;
        }
      }
      return null;
    };

    return AnimatedElementMixin;

  })(superClass);
};


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
var BaseClass, defineModule, log, max, min, rect, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, min = ref.min, max = ref.max;

BaseClass = __webpack_require__(6).BaseClass;

rect = __webpack_require__(4).rect;

defineModule(module, function() {
  var DrawAreaCollector, expandDrawAreaByOutline, expandDrawAreaByShadow;
  expandDrawAreaByShadow = function(area, arg) {
    var blur, bottom, expandBottom, expandLeft, expandRight, expandTop, left, normalizedShadow, offsetX, offsetY, right, top;
    normalizedShadow = arg.shadow;
    if (!normalizedShadow) {
      return area;
    }
    left = area.left, right = area.right, top = area.top, bottom = area.bottom;
    blur = normalizedShadow.blur, offsetX = normalizedShadow.offsetX, offsetY = normalizedShadow.offsetY;
    if (offsetX == null) {
      offsetX = 0;
    }
    if (offsetY == null) {
      offsetY = 0;
    }
    if (blur == null) {
      blur = 0;
    }
    expandLeft = max(0, blur - offsetX - 1);
    expandTop = max(0, blur - offsetY - 1);
    expandRight = max(0, blur + offsetX + 1);
    expandBottom = max(0, blur + offsetY + 1);
    return rect(left - expandLeft, top - expandTop, right - left + expandLeft + expandRight, bottom - top + expandTop + expandBottom);
  };
  expandDrawAreaByOutline = function(area, outline, arg) {
    var lineJoin, lineWidth, miterLimit, obtuse, ref1, ref2, ref3;
    obtuse = arg.obtuse;
    lineWidth = (ref1 = outline.lineWidth) != null ? ref1 : defaultLineWidth, lineJoin = (ref2 = outline.lineJoin) != null ? ref2 : "miter", miterLimit = (ref3 = outline.miterLimit) != null ? ref3 : defaultMiterLimit;
    if (!obtuse && lineJoin === "miter") {
      lineWidth = max(lineWidth, miterLimit * lineWidth);
    }
    return rect(area).grow(.5 * lineWidth);
  };
  return DrawAreaCollector = (function(superClass) {
    extend(DrawAreaCollector, superClass);

    DrawAreaCollector.singletonClass();

    function DrawAreaCollector(padding) {
      this.padding = padding;
      this.reset();
    }

    DrawAreaCollector.prototype.reset = function() {
      this.totalDrawArea = null;
      return this.clippingArea = null;
    };

    DrawAreaCollector.getter({
      drawArea: function() {
        return this.totalDrawArea || rect();
      }
    });

    DrawAreaCollector.prototype.addDrawArea = function(drawArea) {
      var drawAreaBefore, drawAreaBeforeString;
      if (this.clippingArea) {
        drawAreaBefore = drawArea;
        drawAreaBeforeString = drawArea.toString();
        drawArea = drawArea.intersection(this.clippingArea);
      }
      return this.totalDrawArea = drawArea.unionInto(this.totalDrawArea);
    };

    DrawAreaCollector.prototype.fillShape = function(drawMatrix, options, pathFunction, pathSize, pathOptions) {
      return this.addDrawArea(drawMatrix.transformBoundingRect(expandDrawAreaByShadow(pathSize, options)));
    };

    DrawAreaCollector.prototype.strokeShape = function(drawMatrix, options, pathFunction, pathSize, pathOptions) {
      return this.addDrawArea(drawMatrix.transformBoundingRect(expandDrawAreaByOutline(expandDrawAreaByShadow(pathSize, options), options, pathFunction)));
    };

    DrawAreaCollector.prototype.openClipping = function(area, drawMatrix, pathSize, areaArg2) {
      var oldClipArea;
      oldClipArea = this.clippingArea;
      this.clippingArea = drawMatrix.transformBoundingRect(pathSize);
      return oldClipArea != null ? oldClipArea : false;
    };

    DrawAreaCollector.prototype.closeClipping = function(oldClipArea) {
      return this.clippingArea = oldClipArea;
    };

    DrawAreaCollector.prototype.drawDrawable = function(child, elementToTargetMatrix) {
      var targetSpaceChildDrawArea;
      targetSpaceChildDrawArea = elementToTargetMatrix.transformBoundingRect(child.elementSpaceDrawArea);
      switch (child.compositeMode) {
        case "alphaMask":
          return this.totalDrawArea = targetSpaceChildDrawArea.intersectInto(this.totalDrawArea);
        case "sourceIn":
        case "targetAlphaMask":
        case "inverseAlphaMask":
          return null;
        case "normal":
        case "add":
        case "replace":
        case "destOver":
          return this.addDrawArea(targetSpaceChildDrawArea);
        default:
          throw new Error("unknown compositeMode:" + child.compositeMode);
      }
    };

    return DrawAreaCollector;

  })(BaseClass);
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Atomic, DrawCacheManager, DrawEpoch, Epoch, Foundation, Point, drawCacheManager, globalCount, inspect, log, longestCommonSubsequence, point, requestAnimationFrame, select,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

DrawCacheManager = __webpack_require__(116);

point = Atomic.point, Point = Atomic.Point;

log = Foundation.log, requestAnimationFrame = Foundation.requestAnimationFrame, longestCommonSubsequence = Foundation.longestCommonSubsequence, select = Foundation.select, inspect = Foundation.inspect, Epoch = Foundation.Epoch, globalCount = Foundation.globalCount;

drawCacheManager = DrawCacheManager.drawCacheManager;

module.exports = DrawEpoch = (function(superClass) {
  extend(DrawEpoch, superClass);

  function DrawEpoch() {
    return DrawEpoch.__super__.constructor.apply(this, arguments);
  }

  DrawEpoch.singletonClass();

  DrawEpoch.prototype.processEpochItems = function() {
    DrawEpoch.__super__.processEpochItems.apply(this, arguments);
    return drawCacheManager.advanceFrame();
  };

  return DrawEpoch;

})(Epoch);


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var AnimatedElementMixin, Atomic, BaseClass, Bitmap, ElementBase, EpochedElementMixin, EventedElementMixin, compact, elementFactory, inspect, inspectLean, isFunction, isObject, log, merge, object, peek, present, ref, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Atomic = __webpack_require__(4);

elementFactory = __webpack_require__(119).elementFactory;

EventedElementMixin = __webpack_require__(222);

EpochedElementMixin = __webpack_require__(221);

AnimatedElementMixin = __webpack_require__(212);

BaseClass = __webpack_require__(6).BaseClass;

ref = __webpack_require__(1), log = ref.log, inspect = ref.inspect, merge = ref.merge, peek = ref.peek, present = ref.present, isFunction = ref.isFunction, inspectLean = ref.inspectLean, compact = ref.compact, isObject = ref.isObject, object = ref.object, w = ref.w;

Bitmap = __webpack_require__(11).Bitmap;


/*
ElementBase adds:

  1. automatic ElementFactory registration
  2. Element instance registration
  3. The name and key properties (TODO: reduce to just 'key')
  4. Inspectors

ElementBase is the root for Element and eventually Span. All elements in the AIM
must inherit from ElementBase.

TODO:
  5. parent and children relationships should be in ElementBase not Element
 */

module.exports = ElementBase = (function(superClass) {
  var _elementInstanceRegistry, dontExportProps, exportProp, exportedPropsFirst, inspectedPropsFirst, inspectedPropsNotToInclude, rawDNI;

  extend(ElementBase, superClass);

  function ElementBase() {
    return ElementBase.__super__.constructor.apply(this, arguments);
  }

  ElementBase.registerWithElementFactory = function() {
    return false;
  };

  ElementBase.postCreate = function() {
    if (this.registerWithElementFactory()) {
      elementFactory.register(this);
    }
    return ElementBase.__super__.constructor.postCreate.apply(this, arguments);
  };

  ElementBase.prototype._initFields = function() {
    ElementBase.__super__._initFields.apply(this, arguments);
    this.remoteId = null;
    this.creator = null;
    this.__depth = 0;
    return this.__redrawRequired = false;
  };

  ElementBase.concreteProperty({
    key: {
      "default": null,
      validate: function(v) {
        return v === null || isFunction(v.toString);
      },
      preprocess: function(v) {
        if (v === null) {
          return v;
        } else {
          return v.toString();
        }
      }
    }
  });

  ElementBase.virtualProperty({
    name: {
      getter: function(pending) {
        return this.getState(pending)._key;
      },
      setter: function(v) {
        return this.setKey(v);
      }
    }
  });

  ElementBase.layoutProperty = function(map) {
    var options, prop, results;
    results = [];
    for (prop in map) {
      options = map[prop];
      options.layoutProperty = true;
      results.push(this._defineElementProperty(prop, options));
    }
    return results;
  };

  ElementBase.drawProperty = function(map) {
    var options, prop, results;
    results = [];
    for (prop in map) {
      options = map[prop];
      options.drawProperty = true;
      results.push(this._defineElementProperty(prop, options));
    }
    return results;
  };

  ElementBase.drawLayoutProperty = function(map) {
    var options, prop, results;
    results = [];
    for (prop in map) {
      options = map[prop];
      options.layoutProperty = true;
      options.drawAreaProperty = true;
      options.drawProperty = true;
      results.push(this._defineElementProperty(prop, options));
    }
    return results;
  };

  ElementBase.drawAreaProperty = function(map) {
    var options, prop, results;
    results = [];
    for (prop in map) {
      options = map[prop];
      options.drawAreaProperty = true;
      options.drawProperty = true;
      results.push(this._defineElementProperty(prop, options));
    }
    return results;
  };

  ElementBase.prototype._layoutPropertyChanged = function() {
    return this._elementChanged(true);
  };

  ElementBase.prototype._drawPropertyChanged = function() {
    return this._elementChanged(false, true, false);
  };

  ElementBase.prototype._drawAreaPropertyChanged = function() {
    return this._elementChanged(false, true, true);
  };

  ElementBase.concreteProperty({

    /*
    willConsumeKeyboardEvent:
      "beforeDescendents":   (highest priority) no descendend will get keyboard events
      "beforeAncestors":     (medium priority) no ancestor will get keyboard events UNLESS an ancestor is set to "beforeDescendents"
      false:              (lowest priority)
        will only receive keyboard events if, on the currentFocusPath
          a) there are no elements that return "beforeAncestors" AND
          b) this element comes before the first element, if any, that returns "beforeDescendents"
          If all elements return false, all elements will get the event in ancestor > descendent order
    
      (artEngineKeyboardEventType, keyboardEvent) -> "beforeDescendents"/"beforeAncestors"/false
        IN: artEngineKeyboardEventType: "keyUp", "keyDown", or "keyPress"
        IN: keyboardEvent: DOM/HTMLKeyboardEvent
          NOTE: use keyboardEvent.key for checking the key-type. It has been polyfilled to the latest HTML standards (2016)
        OUT:
          "beforeDescendents":
            keyboardEvent.preventDefault() is called
            decendents will not get this keyboardEvent
          "beforeAncestors":
            keyboardEvent.preventDefault() is called
            ancestors will not get this keyboardEvent UNLESS they return "beforeDescendents"
          false: (default)
            children, if focused, will get this keyboardEvent
     */
    willConsumeKeyboardEvent: {
      "default": function(artEngineKeyboardEventType, keyboardEvent) {
        return false;
      },
      validate: function(v) {
        return isObject(v) || v === "beforeDescendents" || v === "beforeAncestors" || isFunction(v);
      },
      preprocess: function(v) {
        if (!isFunction(v)) {
          return function() {
            return v;
          };
        } else {
          return v;
        }
      }
    }
  });

  ElementBase._elementInstanceRegistry = _elementInstanceRegistry = {};

  ElementBase.getter({
    isRegistered: function() {
      return !!_elementInstanceRegistry[this.getInstanceId()];
    }
  });

  ElementBase.getElementByInstanceId = function(instanceId) {
    return _elementInstanceRegistry[instanceId];
  };

  ElementBase.prototype._register = function() {
    var child, i, instanceId, len1, ref1;
    if (_elementInstanceRegistry[instanceId = this.getInstanceId()]) {
      return;
    }
    this._activateContinuousPersistantAnimators();
    _elementInstanceRegistry[instanceId] = this;
    ref1 = this._children;
    for (i = 0, len1 = ref1.length; i < len1; i++) {
      child = ref1[i];
      child._register();
    }
    return this;
  };

  ElementBase.prototype._unregister = function() {
    var child, i, instanceId, len1, ref1;
    if (!_elementInstanceRegistry[instanceId = this.getInstanceId()]) {
      return;
    }
    this._deactivatePersistantAnimators();
    delete _elementInstanceRegistry[instanceId];
    ref1 = this._children;
    for (i = 0, len1 = ref1.length; i < len1; i++) {
      child = ref1[i];
      child._unregister();
    }
    this.queueEvent("unregistered");
    return null;
  };

  ElementBase.prototype._updateRegistryFromPendingState = function() {
    var pendingParent;
    if (pendingParent = this.getPendingParent()) {
      if (pendingParent.getIsRegistered()) {
        return this._register();
      }
    } else {
      return this._unregister();
    }
  };

  ElementBase.getter({
    instanceId: function() {
      return this.remoteId || this.getUniqueId();
    },
    shortNamespacePath: function() {
      var name;
      name = this.namespacePath;
      return peek(name.split('.'));
    },
    inspectedName: function() {
      return this.shortNamespacePath + ":" + (this.pendingKey || this.instanceId);
    },
    inspectedNameWithoutIds: function() {
      var key;
      return this.shortNamespacePath + ((key = this.pendingKey) ? ":" + key : "");
    },
    inspectedString: function() {
      return this.inspectedName;
    }
  });

  inspectedPropsNotToInclude = w(rawDNI = "pages children name on parent");

  inspectedPropsFirst = w("key instanceId location size currentLocation currentSize");

  exportedPropsFirst = w("key location size");

  dontExportProps = w(rawDNI + " currentLocation currentSize currentPadding elementToParentMatrix");

  exportProp = function(value) {
    var ref1, ref2, ref3;
    if (value.constructor === Bitmap) {
      return ["Bitmap", value.size.exportedValue];
    } else {
      return (ref1 = (ref2 = (ref3 = value && value.initializer) != null ? ref3 : value.exportedValue) != null ? ref2 : value.plainObjects) != null ? ref1 : value;
    }
  };

  ElementBase.getter({
    inspectedPropsMaps: function() {
      var defaultValue, i, internalName, k, len1, props, ref1, ref2, value, virtual;
      props = {};
      for (i = 0, len1 = inspectedPropsFirst.length; i < len1; i++) {
        k = inspectedPropsFirst[i];
        if (present(value = this[k])) {
          props[k] = value;
        }
      }
      ref1 = this.metaProperties;
      for (k in ref1) {
        ref2 = ref1[k], internalName = ref2.internalName, virtual = ref2.virtual, defaultValue = ref2.defaultValue;
        if (!virtual && !(indexOf.call(inspectedPropsNotToInclude, k) >= 0) && (!ElementBase.propsEq(defaultValue, value = this[internalName])) && k !== "parent") {
          props[k] = exportProp(value);
        }
      }
      return props;
    },
    exportedProps: function() {
      var out;
      out = object(this.metaProperties, {
        into: object(exportedPropsFirst, {
          when: (function(_this) {
            return function(v, k) {
              return present(_this[k]);
            };
          })(this),
          "with": (function(_this) {
            return function(v, k) {
              return exportProp(_this[k]);
            };
          })(this)
        }),
        when: (function(_this) {
          return function(arg, k) {
            var defaultValue, internalName, virtual;
            internalName = arg.internalName, virtual = arg.virtual, defaultValue = arg.defaultValue;
            return !virtual && !(indexOf.call(dontExportProps, k) >= 0) && !ElementBase.propsEq(defaultValue, _this[internalName]);
          };
        })(this),
        "with": (function(_this) {
          return function(arg) {
            var internalName;
            internalName = arg.internalName;
            return exportProp(_this[internalName]);
          };
        })(this)
      });
      if (!this.parent) {
        out.size || (out.size = exportProp(this.currentSize));
      }
      return out;
    },
    exportedStructure: function() {
      var child, result;
      result = [this["class"].getName(), this.exportedProps];
      if (this.hasChildren) {
        result = result.concat((function() {
          var i, len1, ref1, results;
          ref1 = this.children;
          results = [];
          for (i = 0, len1 = ref1.length; i < len1; i++) {
            child = ref1[i];
            results.push(child.exportedStructure);
          }
          return results;
        }).call(this));
      }
      return result;
    },
    plainObjectProps: function() {
      var k, out, ref1, v;
      ref1 = out = this.minimalProps;
      for (k in ref1) {
        v = ref1[k];
        if (v != null ? v.getPlainObjects : void 0) {
          out[k] = v.getPlainObjects();
        }
      }
      return out;
    },
    propsInspectObjects: function() {
      var fn, k, length, out, ref1, v;
      length = 0;
      ref1 = out = this.minimalProps;
      fn = function(k, v) {
        return out[k] = (function() {
          var ref2;
          switch ((ref2 = v["class"]) != null ? typeof ref2.getName === "function" ? ref2.getName() : void 0 : void 0) {
            case "Bitmap":
              return v;
            default:
              if (v != null ? v.getInspectObjects : void 0) {
                return v.getInspectObjects();
              } else {
                return {
                  inspect: function() {
                    if (v != null ? v.getPlainObjects : void 0) {
                      v = v.getPlainObjects();
                    }
                    return inspectLean(v);
                  }
                };
              }
          }
        })();
      };
      for (k in ref1) {
        v = ref1[k];
        length++;
        fn(k, v);
      }
      if (length === 0) {
        return null;
      } else {
        return out;
      }
    },
    inspectedProps: function() {
      return inspectLean(this.getPlainObjectProps());
    },
    plainObjects: function() {
      var child;
      return [this["class"].getName(), this.plainObjectProps].concat((function() {
        var i, len1, ref1, results;
        ref1 = this._children;
        results = [];
        for (i = 0, len1 = ref1.length; i < len1; i++) {
          child = ref1[i];
          results.push(child.plainObjects);
        }
        return results;
      }).call(this));
    },
    inspectObjects: function() {
      var child;
      return compact([
        {
          inspect: (function(_this) {
            return function() {
              return _this["class"].getName();
            };
          })(this)
        }, this.propsInspectObjects
      ].concat((function() {
        var i, len1, ref1, results;
        ref1 = this._children;
        results = [];
        for (i = 0, len1 = ref1.length; i < len1; i++) {
          child = ref1[i];
          results.push(child.inspectObjects);
        }
        return results;
      }).call(this)));
    },
    inspectTree: function() {
      var c;
      return [
        this.getInspectedName(), (function() {
          var i, len1, ref1, results;
          ref1 = this._children;
          results = [];
          for (i = 0, len1 = ref1.length; i < len1; i++) {
            c = ref1[i];
            results.push(c.inspectTree);
          }
          return results;
        }).call(this)
      ];
    },
    inspectedStructure: function() {
      return inspect(this.plainObjects);
    }
  });

  ElementBase.prototype.inspect = function() {
    var a, child, inspectedProps, len;
    inspectedProps = this.inspectedProps;
    a = this["class"].getName() + " " + inspectedProps;
    if (0 < (len = this._children.length)) {
      a += (inspectedProps.length > 0 ? ',' : '') + " children: [" + (((function() {
        var i, len1, ref1, results;
        ref1 = this._children;
        results = [];
        for (i = 0, len1 = ref1.length; i < len1; i++) {
          child = ref1[i];
          results.push(child["class"].getName());
        }
        return results;
      }).call(this)).join(', ')) + "]";
    }
    return a;
  };

  return ElementBase;

})(AnimatedElementMixin(EventedElementMixin(EpochedElementMixin(BaseClass))));


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
var BaseClass, EngineStat, Foundation, Stat, arrayWithout, currentSecond, defineModule, log, miniInspect,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

defineModule = Foundation.defineModule, log = Foundation.log, miniInspect = Foundation.miniInspect, currentSecond = Foundation.currentSecond, arrayWithout = Foundation.arrayWithout, BaseClass = Foundation.BaseClass, Stat = Foundation.Stat;

defineModule(module, EngineStat = (function(superClass) {
  extend(EngineStat, superClass);

  function EngineStat() {
    this.reset();
  }

  EngineStat.prototype.reset = function() {
    return this.stats = {};
  };

  EngineStat.prototype.add = function(statName, value) {
    var base;
    return ((base = this.stats)[statName] || (base[statName] = new Stat)).add(value);
  };

  EngineStat.prototype.length = function(statName) {
    var stat;
    if (stat = this.stats[statName]) {
      return stat.length;
    } else {
      return 0;
    }
  };

  EngineStat.prototype.log = function() {
    var greatestPow10LessThanMax, k, ref, smallestMultipleGreaterThanMax, toLog, v;
    toLog = {};
    ref = this.stats;
    for (k in ref) {
      v = ref[k];
      greatestPow10LessThanMax = Math.pow(10, Math.floor(Math.log10(v.max)));
      smallestMultipleGreaterThanMax = (Math.ceil(v.max / greatestPow10LessThanMax)) * greatestPow10LessThanMax;
      toLog[k] = {
        min: v.min.toPrecision(5) / 1,
        av: v.average.toPrecision(5) / 1,
        max: v.max.toPrecision(5) / 1,
        hist: v.histogram(10, 0, smallestMultipleGreaterThanMax),
        histMax: smallestMultipleGreaterThanMax
      };
    }
    return log(toLog);
  };

  return EngineStat;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var FlexLayout, LayoutTools, Point, abs, combineMargins, floatEq, inspect, isFiniteResult, isInfiniteResult, layoutMargin, log, max, peek, perimeter, point, point0, ref, ref1, ref2, ref3, select, shallowEq, sizeWithPadding, toPoint;

ref = __webpack_require__(1), log = ref.log, inspect = ref.inspect, shallowEq = ref.shallowEq, select = ref.select, peek = ref.peek, inspect = ref.inspect, floatEq = ref.floatEq;

ref1 = __webpack_require__(75), isInfiniteResult = ref1.isInfiniteResult, isFiniteResult = ref1.isFiniteResult;

ref2 = __webpack_require__(4), point = ref2.point, Point = ref2.Point, perimeter = ref2.perimeter;

ref3 = LayoutTools = __webpack_require__(76), layoutMargin = ref3.layoutMargin, sizeWithPadding = ref3.sizeWithPadding;

point0 = Point.point0;

abs = Math.abs, max = Math.max;

combineMargins = function(a, b) {
  return (a + b) / 2;
};

toPoint = function(isRowLayout, mainPos, crossPos, currentPadding) {
  var x, y;
  x = y = 0;
  if (isRowLayout) {
    x = mainPos;
    y = crossPos;
  } else {
    x = crossPos;
    y = mainPos;
  }
  if (currentPadding) {
    return sizeWithPadding(x, y, currentPadding);
  } else {
    return point(x, y);
  }
};

module.exports = FlexLayout = (function() {
  function FlexLayout() {}

  FlexLayout.layoutChildrenFlex = function(isRowLayout, element, currentPadding, elementSizeForChildren, inFlowChildren, parentSize) {

    /*
    Flexbox terminology: https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Flexible_boxes
    
    Names for row-layout: (swap x/y, width/height, left/top and right/bottom for column-layout)
      main-axis:    x
      cross-axis:   y
      main-size:    w
      cross-size    h
      main-start:   left / 0
      main-end:     right / parent-width
      cross-start:  top / 0
      cross-end:    bottom / parent-height
     */
    var adjustedCrossSize, adjustedParentSize, child, childCrossSize, childFlexWeight, childrenAlignment, childrenSize, crossAlignment, crossCoordinate, crossElementSizeForChildren, crossOffset, crossRelativeTestFunction, crossSize, currentSize, effectivePrevMargin, finalPassSizeLayoutChildren, flexParentSize, hasCrossAlignment, heightRemainingChildren, i, isLastChild, j, k, l, lastChildsNextMargin, len, len1, len2, len3, locationX, locationY, m, mainAlignment, mainAxisRelativeTestFunction, mainChildrenOffset, mainChildrenSize, mainCoordinate, mainElementSizeForChildren, mainLayoutIsFinite, mainPos, mainSize, mainSizeForChild, margin, maxCrossSize, n, nextMargin, oldMaxCrossSize, previousMargin, ratio, ref4, ref5, relativeSizeIndex, secondPassSizeForChildren, sizeForChild, spaceForFlexChildren, totalFlexWeight;
    if (isRowLayout) {
      mainCoordinate = "x";
      crossCoordinate = "y";
      previousMargin = "left";
      nextMargin = "right";
      mainAxisRelativeTestFunction = "getXRelativeToParentW";
      crossRelativeTestFunction = "getYRelativeToParentH";
    } else {
      mainCoordinate = "y";
      crossCoordinate = "x";
      previousMargin = "top";
      nextMargin = "bottom";
      mainAxisRelativeTestFunction = "getYRelativeToParentH";
      crossRelativeTestFunction = "getXRelativeToParentW";
    }
    mainElementSizeForChildren = elementSizeForChildren[mainCoordinate];
    crossElementSizeForChildren = elementSizeForChildren[crossCoordinate];
    heightRemainingChildren = null;
    maxCrossSize = totalFlexWeight = 0;
    spaceForFlexChildren = elementSizeForChildren[mainCoordinate];
    mainChildrenSize = 0;
    lastChildsNextMargin = 0;
    finalPassSizeLayoutChildren = null;
    for (i = j = 0, len = inFlowChildren.length; j < len; i = ++j) {
      child = inFlowChildren[i];
      if (child.getPendingSize()[mainAxisRelativeTestFunction]()) {
        currentSize = child._layoutSize(elementSizeForChildren, point0);
        childFlexWeight = child.getPendingLayoutWeight();
        totalFlexWeight += childFlexWeight;
      } else {
        LayoutTools.layoutElement(child, elementSizeForChildren, true);
        currentSize = child.getPendingCurrentSize();
        mainSize = currentSize[mainCoordinate];
        mainChildrenSize += mainSize;
        spaceForFlexChildren -= mainSize;
        if (child.getPendingLayoutSizeParentCircular()) {
          (finalPassSizeLayoutChildren || (finalPassSizeLayoutChildren = [])).push(child);
          if ((!isRowLayout && child._pendingState._size.xChildrenRelative) || (isRowLayout && child._pendingState._size.yChildrenRelative)) {
            maxCrossSize = max(maxCrossSize, currentSize[crossCoordinate]);
          }
        } else {
          maxCrossSize = max(maxCrossSize, currentSize[crossCoordinate]);
        }
      }
      margin = layoutMargin(child, elementSizeForChildren, element);
      if (i > 0) {
        mainChildrenSize += effectivePrevMargin = combineMargins(lastChildsNextMargin, margin[previousMargin]);
        spaceForFlexChildren -= effectivePrevMargin;
      }
      lastChildsNextMargin = margin[nextMargin];
    }
    relativeSizeIndex = 0;
    spaceForFlexChildren = max(0, spaceForFlexChildren);
    for (i = k = 0, len1 = inFlowChildren.length; k < len1; i = ++k) {
      child = inFlowChildren[i];
      if (!(child.getPendingSize()[mainAxisRelativeTestFunction]())) {
        continue;
      }
      childFlexWeight = child.getPendingLayoutWeight();
      ratio = childFlexWeight / totalFlexWeight;
      flexParentSize = toPoint(isRowLayout, mainSizeForChild = spaceForFlexChildren * ratio, crossElementSizeForChildren);
      LayoutTools.layoutElement(child, flexParentSize, true);
      currentSize = child.getPendingCurrentSize();
      mainSize = currentSize[mainCoordinate];
      if (child.getPendingLayoutSizeParentCircular()) {
        (finalPassSizeLayoutChildren || (finalPassSizeLayoutChildren = [])).push(child);
      } else {
        crossSize = currentSize[crossCoordinate];
        maxCrossSize = max(maxCrossSize, crossSize);
      }
      totalFlexWeight -= childFlexWeight;
      spaceForFlexChildren -= mainSize;
      mainChildrenSize += mainSize;
    }
    childrenSize = toPoint(isRowLayout, mainChildrenSize, maxCrossSize, currentPadding);
    if (isRowLayout) {
      mainElementSizeForChildren = element.getPendingSize().layoutX(parentSize, childrenSize) - currentPadding.getWidth();
      crossElementSizeForChildren = element.getPendingSize().layoutY(parentSize, childrenSize) - currentPadding.getHeight();
    } else {
      crossElementSizeForChildren = element.getPendingSize().layoutX(parentSize, childrenSize) - currentPadding.getWidth();
      mainElementSizeForChildren = element.getPendingSize().layoutY(parentSize, childrenSize) - currentPadding.getHeight();
    }
    if (finalPassSizeLayoutChildren) {
      oldMaxCrossSize = maxCrossSize;
      secondPassSizeForChildren = toPoint(isRowLayout, mainElementSizeForChildren, crossElementSizeForChildren);
      for (i = l = 0, len2 = finalPassSizeLayoutChildren.length; l < len2; i = ++l) {
        child = finalPassSizeLayoutChildren[i];
        sizeForChild = toPoint(isRowLayout, child.getPendingCurrentSize()[mainCoordinate], crossElementSizeForChildren);
        LayoutTools.layoutElement(child, sizeForChild, true);
        maxCrossSize = max(maxCrossSize, child.getPendingCurrentSize()[crossCoordinate]);
      }
      if (oldMaxCrossSize !== maxCrossSize) {
        childrenSize = toPoint(isRowLayout, mainChildrenSize, maxCrossSize, currentPadding);
        if (isRowLayout) {
          mainElementSizeForChildren = element.getPendingSize().layoutX(parentSize, childrenSize) - currentPadding.getWidth();
          crossElementSizeForChildren = element.getPendingSize().layoutY(parentSize, childrenSize) - currentPadding.getHeight();
        } else {
          crossElementSizeForChildren = element.getPendingSize().layoutX(parentSize, childrenSize) - currentPadding.getWidth();
          mainElementSizeForChildren = element.getPendingSize().layoutY(parentSize, childrenSize) - currentPadding.getHeight();
        }
      }
    }
    lastChildsNextMargin = 0;
    childrenAlignment = element.getPendingChildrenAlignment();
    mainAlignment = childrenAlignment[mainCoordinate];
    crossAlignment = childrenAlignment[crossCoordinate];
    hasCrossAlignment = !floatEq(0, crossAlignment);
    mainLayoutIsFinite = (isFiniteResult(mainElementSizeForChildren)) && isFiniteResult(mainChildrenSize);
    mainChildrenOffset = mainPos = mainLayoutIsFinite ? (mainElementSizeForChildren - mainChildrenSize) * childrenAlignment[mainCoordinate] : 0;
    for (i = n = 0, len3 = inFlowChildren.length; n < len3; i = ++n) {
      child = inFlowChildren[i];
      margin = child.getPendingCurrentMargin();
      if (i > 0) {
        effectivePrevMargin = combineMargins(lastChildsNextMargin, margin[previousMargin]);
        mainPos += effectivePrevMargin;
      }
      lastChildsNextMargin = margin[nextMargin];
      currentSize = child.getPendingCurrentSize();
      isLastChild = i === inFlowChildren.length - 1;
      mainSize = isLastChild && isFiniteResult(mainElementSizeForChildren) ? mainElementSizeForChildren - mainPos : currentSize[mainCoordinate];
      crossOffset = 0;
      adjustedCrossSize = crossElementSizeForChildren;
      if (hasCrossAlignment) {
        childCrossSize = currentSize[crossCoordinate];
        crossOffset = (crossElementSizeForChildren - childCrossSize) * crossAlignment;
        adjustedCrossSize = childCrossSize;
      }
      adjustedParentSize = toPoint(isRowLayout, mainSize, adjustedCrossSize);
      locationX = child._layoutLocationX(adjustedParentSize);
      locationY = child._layoutLocationY(adjustedParentSize);
      if (isRowLayout) {
        locationX += mainPos;
        locationY += crossOffset;
      } else {
        locationY += mainPos;
        locationX += crossOffset;
      }
      child._setElementToParentMatrixFromLayoutXY(locationX, locationY, adjustedParentSize);
      mainPos += mainSize;
    }
    element.postFlexLayout(mainCoordinate, inFlowChildren, mainChildrenSize, mainElementSizeForChildren, mainChildrenOffset);
    if (mainChildrenSize > (m = mainElementSizeForChildren)) {
      ((ref4 = element._on) != null ? ref4.childrenDontFit : void 0) && element.queueEvent("childrenDontFit", {
        mainChildrenSize: mainChildrenSize,
        mainSize: m
      });
    } else {
      ((ref5 = element._on) != null ? ref5.childrenFit : void 0) && element.queueEvent("childrenFit", {
        mainChildrenSize: mainChildrenSize,
        mainSize: m
      });
    }
    return null;
  };

  return FlexLayout;

})();


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
var FlexLayout, LayoutTools, defineModule, floatEq, max, point, point0, ref, ref1, sizeWithPadding;

ref = __webpack_require__(1), defineModule = ref.defineModule, floatEq = ref.floatEq, max = ref.max;

ref1 = __webpack_require__(4), point = ref1.point, point0 = ref1.point0;

sizeWithPadding = (LayoutTools = __webpack_require__(76)).sizeWithPadding;

defineModule(module, FlexLayout = (function() {
  var layoutChildrenFlowLine, subLayoutChildrenAndGatherInformation;

  function FlexLayout() {}

  subLayoutChildrenAndGatherInformation = function(parentSize, children, finalPassChildrenSizeOnly) {
    var child, i, len, results;
    results = [];
    for (i = 0, len = children.length; i < len; i++) {
      child = children[i];
      if (child.getPendingLayoutSizeParentCircular() && !child._pendingState._size.childrenRelative) {
        child._setSizeFromLayout(child._layoutSize(point0, point0));
        results.push(finalPassChildrenSizeOnly.push(child));
      } else {
        results.push(LayoutTools.layoutElement(child, parentSize, true));
      }
    }
    return results;
  };

  layoutChildrenFlowLine = function(children, rightEdge, state) {
    var child, childI, childSize, childrenLength, currentMargin, firstChildOnLine, i, j, lastChildOnLine, lastLineMarginBottom, lastMarginRight, lineFull, lineHeight, maxLineMarginBottom, maxLineMarginTop, maxWidth, ref2, ref3, ref4, ref5, x, y;
    y = state.y, firstChildOnLine = state.firstChildOnLine, lastLineMarginBottom = state.lastLineMarginBottom, maxWidth = state.maxWidth;
    childrenLength = children.length;
    maxLineMarginBottom = 0;
    maxLineMarginTop = 0;
    lineHeight = 0;
    lastMarginRight = 0;
    lastChildOnLine = firstChildOnLine;
    x = 0;
    for (childI = i = ref2 = firstChildOnLine, ref3 = childrenLength; i < ref3; childI = i += 1) {
      lastChildOnLine = childI;
      child = children[lastChildOnLine];
      currentMargin = child.getPendingCurrentMargin();
      childSize = child.getPendingCurrentSize();
      if (lastChildOnLine !== firstChildOnLine) {
        x += max(currentMargin.left, lastMarginRight);
      }
      x += childSize.x;
      lastMarginRight = currentMargin.right;
      lineFull = x >= rightEdge;
      if (child.getPendingLayoutSizeParentCircular() && child.getPendingSize().getXParentRelative()) {
        if (lastChildOnLine !== firstChildOnLine) {
          lastChildOnLine--;
        }
        lineFull = true;
      }
      if (!lineFull || lastChildOnLine === firstChildOnLine) {
        maxLineMarginTop = max(currentMargin.top, maxLineMarginTop);
        maxLineMarginBottom = max(currentMargin.bottom, maxLineMarginBottom);
        lineHeight = max(lineHeight, childSize.y);
        if (lineFull) {
          break;
        }
      } else {
        lastChildOnLine--;
        break;
      }
    }
    if (lastLineMarginBottom != null) {
      y += max(lastLineMarginBottom, maxLineMarginTop);
    }
    x = 0;
    lastMarginRight = 0;
    for (childI = j = ref4 = firstChildOnLine, ref5 = lastChildOnLine; j <= ref5; childI = j += 1) {
      child = children[childI];
      currentMargin = child.getPendingCurrentMargin();
      childSize = child.getPendingCurrentSize();
      if (childI !== firstChildOnLine) {
        x += max(currentMargin.left, lastMarginRight);
      }
      child._setElementToParentMatrixFromLayout(point(x, y), point(childSize.x, lineHeight));
      x += childSize.x;
      lastMarginRight = currentMargin.right;
    }
    if (state.flowChildren) {
      state.firstChildIndexOfEachLine.push(firstChildOnLine);
      state.lastChildIndexOfEachLine.push(lastChildOnLine);
      state.widthOfEachLine.push(x);
    }
    state.lastLineMarginBottom = maxLineMarginBottom;
    state.y = y + lineHeight;
    state.firstChildOnLine = lastChildOnLine + 1;
    return state.maxWidth = max(maxWidth, x);
  };

  FlexLayout.layoutChildrenFlow = function(element, currentPadding, firstPassSizeForChildrenUnconstrained, firstPassSizeForChildrenConstrained, children, finalPassChildrenSizeOnly) {
    var childrenAlignment, childrenLength, halfPixel, rightEdge, state;
    subLayoutChildrenAndGatherInformation(firstPassSizeForChildrenConstrained, children, finalPassChildrenSizeOnly);
    halfPixel = .5;
    rightEdge = firstPassSizeForChildrenUnconstrained.x + halfPixel;
    state = {
      y: 0,
      firstChildOnLine: 0,
      lastLineMarginBottom: null,
      maxWidth: 0
    };
    childrenAlignment = element.getPendingChildrenAlignment();
    if (!floatEq(childrenAlignment.x, 0) || !floatEq(childrenAlignment.y, 0)) {
      state.childrenAlignment = childrenAlignment;
      state.flowChildren = children;
      state.firstChildIndexOfEachLine = [];
      state.lastChildIndexOfEachLine = [];
      state.widthOfEachLine = [];
    }
    childrenLength = children.length;
    while (state.firstChildOnLine < childrenLength) {
      layoutChildrenFlowLine(children, rightEdge, state);
    }
    state.childrenSize = sizeWithPadding(state.maxWidth, state.y, currentPadding);
    return state;
  };

  return FlexLayout;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArtEngineCore, BaseClass, LayoutTools, Point, Rectangle, StateEpochLayout, Unique, abs, deinfinitize, eachRunAsCharCodes, floatEq, globalEpochCycle, inspect, isFunction, isInfiniteResult, isNumber, layoutChildrenFlex, layoutChildrenFlow, layoutMargin, layoutPadding, log, longestCommonSubsequence, max, min, nearInfiniteSize, nearInfinity, nearInfinityResult, peek, perimeter, point, point0, ref, ref1, ref2, select, shallowEq, sizeWithPadding,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

abs = Math.abs;

ref = __webpack_require__(1), log = ref.log, max = ref.max, min = ref.min, shallowEq = ref.shallowEq, longestCommonSubsequence = ref.longestCommonSubsequence, select = ref.select, Unique = ref.Unique, peek = ref.peek, inspect = ref.inspect, isFunction = ref.isFunction, eachRunAsCharCodes = ref.eachRunAsCharCodes, floatEq = ref.floatEq, isNumber = ref.isNumber;

BaseClass = __webpack_require__(6).BaseClass;

ref1 = __webpack_require__(4), point = ref1.point, Point = ref1.Point, perimeter = ref1.perimeter, point0 = ref1.point0, Rectangle = ref1.Rectangle;

ArtEngineCore = __webpack_require__(54);


/*
TODO:

  I'd like to move away from my isInfiniteResult tests.
  I'd rather just use circular tests.
  The problem is if we have a "max" test in layout, infinite results get masked and appear finite.
  Circular tests are not 100% reliable though!
    Perhaps we can let you specific relitivity in the PointLayout Props, if needed:
      w: (ps, cs) -> blah
      parentRelative: false # blah isn't actually parent relative
 */

layoutChildrenFlex = __webpack_require__(217).layoutChildrenFlex;

layoutChildrenFlow = __webpack_require__(218).layoutChildrenFlow;

ref2 = LayoutTools = __webpack_require__(76), nearInfiniteSize = ref2.nearInfiniteSize, nearInfinity = ref2.nearInfinity, nearInfinityResult = ref2.nearInfinityResult, layoutMargin = ref2.layoutMargin, sizeWithPadding = ref2.sizeWithPadding, layoutPadding = ref2.layoutPadding, deinfinitize = ref2.deinfinitize, isInfiniteResult = ref2.isInfiniteResult;

globalEpochCycle = null;

module.exports = StateEpochLayout = (function(superClass) {
  var alignChildren, childIsAllowedToAffectParentSize, computeChildrenSizeWithPadding, defaultWidthOfEachLine, layoutChildren, layoutElement, markParentLayoutPropertiesChanged, reusableRectForChildrenSizeCalc;

  extend(StateEpochLayout, superClass);

  function StateEpochLayout() {
    return StateEpochLayout.__super__.constructor.apply(this, arguments);
  }

  StateEpochLayout.markLayoutPropertiesChanged = function(changingElements) {
    var element, k, len, results;
    results = [];
    for (k = 0, len = changingElements.length; k < len; k++) {
      element = changingElements[k];
      if ((element.getParentChanged() && element.getPendingParent()) || (element.getChildrenChanged() && element.getPendingLayoutMovesChildren())) {
        if (!element.__layoutPropertiesChanged) {
          element.__layoutPropertiesChanged = true;
          element._elementChanged();
        }
      }
      results.push(markParentLayoutPropertiesChanged(element));
    }
    return results;
  };

  StateEpochLayout.updateLayouts = function(layoutChangedElements) {
    var element, k, len, start;
    if (globalEpochCycle == null) {
      globalEpochCycle = ArtEngineCore.GlobalEpochCycle.globalEpochCycle;
    }
    start = globalEpochCycle.startTimePerformance();
    for (k = 0, len = layoutChangedElements.length; k < len; k++) {
      element = layoutChangedElements[k];
      if (element.__layoutPropertiesChanged) {
        layoutElement(element, element.getPendingParentSizeForChildren());
      }
    }
    globalEpochCycle.endTimePerformance("aimLayout", start);
    return null;
  };

  markParentLayoutPropertiesChanged = function(element) {
    var results;
    results = [];
    while ((element = element.getPendingParent()) && (element.getPendingSize().getChildrenRelative() || element.getPendingLayoutMovesChildren()) && !element.__layoutPropertiesChanged) {
      element.__layoutPropertiesChanged = true;
      results.push(element._elementChanged());
    }
    return results;
  };

  layoutChildren = function(element, currentPadding, parentSize, children, finalPassChildren, finalPassChildrenLocationOnly) {
    var child, k, layoutLocationInSecondPass, len, maxXInfinite, maxYInfinite, results;
    if (!children) {
      return point0;
    }
    maxXInfinite = maxYInfinite = false;
    results = [];
    for (k = 0, len = children.length; k < len; k++) {
      child = children[k];

      /*
      firstPassChildren contains no size-circular children
      If location is circular (but size is not):
        - this element's location is assumed to be point0 for child-size calc purposes
        - this element's location layout is done in the second pass.
       */
      if (layoutLocationInSecondPass = child.getPendingLayoutLocationParentCircular()) {
        child._setElementToParentMatrixFromLayout(point0, parentSize);
        finalPassChildrenLocationOnly.push(child);
      }
      layoutElement(child, parentSize, layoutLocationInSecondPass);
      maxXInfinite = isInfiniteResult(child.getPendingMaxXInParentSpace());
      maxYInfinite = isInfiniteResult(child.getPendingMaxYInParentSpace());
      if (maxXInfinite || maxYInfinite) {
        results.push(finalPassChildren.push(child));
      } else if (layoutLocationInSecondPass) {
        results.push(finalPassChildrenLocationOnly.push(child));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  reusableRectForChildrenSizeCalc = new Rectangle;

  computeChildrenSizeWithPadding = function(element, children, currentPadding) {
    var area, b, bMax, child, customComputeChildArea, first, k, l, lMin, len, len1, m, r, rMax, t, tMin;
    if (!((children != null ? children.length : void 0) > 0)) {
      return point0;
    }
    bMax = rMax = 0;
    if (customComputeChildArea = element.getPendingChildArea()) {
      tMin = lMin = 0;
      l = r = t = b = 0;
      first = true;
      for (k = 0, len = children.length; k < len; k++) {
        child = children[k];
        area = customComputeChildArea(child, reusableRectForChildrenSizeCalc);
        l = area.getLeft();
        t = area.getTop();
        r = area.getRight();
        b = area.getBottom();
        if (first) {
          first = false;
          lMin = l;
          tMin = t;
          rMax = r;
          bMax = b;
        } else {
          lMin = min(l, lMin);
          tMin = min(t, tMin);
          rMax = max(r, rMax);
          bMax = max(b, bMax);
        }
      }
      return sizeWithPadding(rMax - lMin, bMax - tMin, currentPadding);
    } else {
      for (m = 0, len1 = children.length; m < len1; m++) {
        child = children[m];
        rMax = max(rMax, child.getPendingMaxXInParentSpace());
        bMax = max(bMax, child.getPendingMaxYInParentSpace());
      }
      return sizeWithPadding(rMax, bMax, currentPadding);
    }
  };

  defaultWidthOfEachLine = function(i, widthOfEachLine) {
    return widthOfEachLine[i];
  };

  alignChildren = function(state, parentSize, childrenSize) {
    var child, childrenAlignment, childrenAlignmentX, childrenAlignmentY, firstChildIndexOfEachLine, firstChildOnLine, firstIndex, flowChildren, i, j, k, l, lastChildIndexOfEachLine, lastIndex, len, offsetX, offsetY, results, width, widthOfEachLine, widthOfEachLineFunction;
    childrenAlignment = state.childrenAlignment, flowChildren = state.flowChildren, firstChildIndexOfEachLine = state.firstChildIndexOfEachLine, lastChildIndexOfEachLine = state.lastChildIndexOfEachLine, widthOfEachLine = state.widthOfEachLine, widthOfEachLineFunction = state.widthOfEachLineFunction;
    widthOfEachLineFunction || (widthOfEachLineFunction = defaultWidthOfEachLine);
    childrenAlignmentX = childrenAlignment.x;
    childrenAlignmentY = childrenAlignment.y;
    results = [];
    for (i = k = 0, len = firstChildIndexOfEachLine.length; k < len; i = ++k) {
      firstIndex = firstChildIndexOfEachLine[i];
      lastIndex = lastChildIndexOfEachLine[i];
      width = widthOfEachLineFunction(i, widthOfEachLine);
      firstChildOnLine = flowChildren[firstIndex];
      if (firstChildOnLine.getPendingLayoutSizeParentCircular() && firstChildOnLine.getPendingSize().getXParentRelative()) {
        width = firstChildOnLine.getPendingCurrentSize().x;
      }
      offsetX = (parentSize.x - width) * childrenAlignmentX;
      offsetY = (parentSize.y - childrenSize.y) * childrenAlignmentY;
      if (!floatEq(offsetX, 0) || !floatEq(offsetY, 0)) {
        results.push((function() {
          var m, ref3, ref4, results1;
          results1 = [];
          for (j = m = ref3 = firstIndex, ref4 = lastIndex; m <= ref4; j = m += 1) {
            child = flowChildren[j];
            l = child.getPendingCurrentLocation();
            results1.push(child._setElementToParentMatrixFromLayoutXY(l.x + offsetX, l.y + offsetY, parentSize));
          }
          return results1;
        })());
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  childIsAllowedToAffectParentSize = function(child) {
    return !child.getPendingLayoutSizeParentCircular() || child._pendingState._size.childrenRelative;
  };

  LayoutTools.layoutElement = layoutElement = function(element, parentSize, skipLocation) {

    /*
    TODO - increase effieciency
    Currently, we will always recurse all the way down any children
    which are children-size-relative regardless on if they (or one of their
    decendents) is actually parent-relative.
    
    Sometimes this is right (see the children relative middlemen tests).
    Often, though, the children really are 100% child-size-relative and 100% ignore
    parent's size.
    
    In that case, we shouldn't re-lay them out.
    
    Is there any way to be smart about that?
    
    Obviously we can let the app dev specify an element is 100% child-size relative in some way.
      Element ignoreParentSize: true
    
    But that's ugly!
     */
    var child, childI, childrenFlowState, childrenLayout, childrenSize, currentMargin, currentPadding, finalLocation, finalPassChildren, finalPassChildrenLocationOnly, finalPassChildrenSizeOnly, finalSize, finalSizeForChildren, firstPassChildren, firstPassSize, firstPassSizeForChildrenConstrained, firstPassSizeForChildrenUnconstrained, k, layoutIsChildrenRelative, len, len1, len2, len3, m, n, o, pendingChildren;
    if (!(element.__layoutPropertiesChanged || !shallowEq(element._lastParentSize, parentSize))) {
      return element.getPendingCurrentSize();
    }
    element._lastParentSize = parentSize;
    element.__layoutPropertiesChanged = false;
    if (!skipLocation) {
      finalLocation = element._layoutLocation(parentSize);
    }
    firstPassSize = element._layoutSize(parentSize, nearInfiniteSize);
    currentPadding = layoutPadding(element, parentSize);
    currentMargin = layoutMargin(element, parentSize, element.getPendingParent());
    firstPassSizeForChildrenUnconstrained = element.getSizeForChildren(true, firstPassSize);
    firstPassSizeForChildrenConstrained = element.getSizeForChildren(true, element._layoutSizeForChildren(parentSize, nearInfiniteSize));
    pendingChildren = element.getPendingChildren();
    firstPassChildren = finalPassChildren = null;
    childrenLayout = element.getPendingChildrenLayout();
    layoutIsChildrenRelative = element.getPendingSize().getChildrenRelative();
    if (childrenLayout || layoutIsChildrenRelative) {
      firstPassChildren = pendingChildren;
      for (childI = k = 0, len = pendingChildren.length; k < len; childI = ++k) {
        child = pendingChildren[childI];
        if (child.getPendingInFlow() && (childrenLayout || childIsAllowedToAffectParentSize(child))) {
          if (finalPassChildren) {
            firstPassChildren.push(child);
          }
        } else {
          if (!finalPassChildren) {
            firstPassChildren = pendingChildren.slice(0, childI);
            finalPassChildren = [];
          }
          finalPassChildren.push(child);
        }
      }
      finalPassChildrenSizeOnly = [];
      finalPassChildrenLocationOnly = [];
      finalPassChildren || (finalPassChildren = []);
    } else {
      finalPassChildren = pendingChildren;
    }
    childrenSize = element.nonChildrenLayoutFirstPass ? childrenSize = currentPadding.addedToSize(element.nonChildrenLayoutFirstPass(firstPassSizeForChildrenConstrained, firstPassSizeForChildrenUnconstrained)) : point0;
    if (firstPassChildren) {
      switch (childrenLayout) {
        case "flow":
          childrenFlowState = layoutChildrenFlow(element, currentPadding, firstPassSizeForChildrenUnconstrained, firstPassSizeForChildrenConstrained, firstPassChildren, finalPassChildrenSizeOnly);
          break;
        case "column":
          layoutChildrenFlex(false, element, currentPadding, firstPassSizeForChildrenConstrained, firstPassChildren, parentSize);
          break;
        case "row":
          layoutChildrenFlex(true, element, currentPadding, firstPassSizeForChildrenConstrained, firstPassChildren, parentSize);
          break;
        default:
          layoutChildren(element, currentPadding, firstPassSizeForChildrenConstrained, firstPassChildren, finalPassChildren, finalPassChildrenLocationOnly);
          null;
      }
      if (layoutIsChildrenRelative || (childrenFlowState != null ? childrenFlowState.childrenAlignment : void 0)) {
        childrenSize = childrenSize.max(computeChildrenSizeWithPadding(element, firstPassChildren, currentPadding));
      }
      finalSize = element._layoutSize(parentSize, childrenSize);
      finalSizeForChildren = element.getSizeForChildren(true, finalSize);
      if (finalPassChildrenSizeOnly) {
        for (m = 0, len1 = finalPassChildrenSizeOnly.length; m < len1; m++) {
          child = finalPassChildrenSizeOnly[m];
          layoutElement(child, finalSizeForChildren, true);
        }
      }
      if (childrenFlowState != null ? childrenFlowState.childrenAlignment : void 0) {
        alignChildren(childrenFlowState, finalSizeForChildren, childrenSize);
      } else {
        for (n = 0, len2 = finalPassChildrenLocationOnly.length; n < len2; n++) {
          child = finalPassChildrenLocationOnly[n];
          child._setElementToParentMatrixFromLayout(child._layoutLocation(finalSizeForChildren), parentSize);
        }
      }
    } else {
      finalSize = firstPassSize;
      finalSizeForChildren = firstPassSizeForChildrenConstrained;
    }
    if (typeof element.nonChildrenLayoutFinalPass === "function") {
      element.nonChildrenLayoutFinalPass(finalSizeForChildren);
    }
    if (finalPassChildren) {
      for (o = 0, len3 = finalPassChildren.length; o < len3; o++) {
        child = finalPassChildren[o];
        layoutElement(child, finalSizeForChildren);
      }
    }
    element._setSizeFromLayout(deinfinitize(finalSize));
    if (!skipLocation) {
      element._setElementToParentMatrixFromLayout(deinfinitize(finalLocation), parentSize);
    }
    return finalSize;
  };

  return StateEpochLayout;

})(BaseClass);


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

var EpochLayout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(54)).addNamespace('EpochLayout', EpochLayout = (function(superClass) {
  extend(EpochLayout, superClass);

  function EpochLayout() {
    return EpochLayout.__super__.constructor.apply(this, arguments);
  }

  return EpochLayout;

})(Neptune.PackageNamespace));


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var StateEpoch, blankOptions, capitalize, compactFlatten, globalEpochCycle, inspect, isFunction, isNumber, isPlainArray, isPlainObject, isString, log, merge, mergeInto, nextTick, plainObjectsDeepEq, propInternalName, propsEq, ref, ref1, shallowEq, shallowPropsEq, stateEpoch,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(77), log = ref.log, merge = ref.merge, mergeInto = ref.mergeInto, capitalize = ref.capitalize, compactFlatten = ref.compactFlatten, isNumber = ref.isNumber, isFunction = ref.isFunction, shallowEq = ref.shallowEq, plainObjectsDeepEq = ref.plainObjectsDeepEq, isString = ref.isString, inspect = ref.inspect, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, nextTick = ref.nextTick, (ref1 = ref.BaseClass, propInternalName = ref1.propInternalName), propsEq = ref.propsEq, shallowPropsEq = ref.shallowPropsEq;

stateEpoch = (StateEpoch = __webpack_require__(37)).stateEpoch;

globalEpochCycle = __webpack_require__(26).globalEpochCycle;

blankOptions = {};

module.exports = function(superClass) {
  var EpochedElementMixin;
  return EpochedElementMixin = (function(superClass1) {

    /*
    
    CONCRETE PROPERTIES
    -------------------
    
    Concrete-properties (non-virtual properties), once declared, take care of many common property tasks.
    For a property "foo":
    
      * @_foo and @_pendingState._foo are initialized on Element-instantiation
        - They are either intialized to default values (which are validated for consistency) or
        - Can be initialized by the instantiating code. Ex: new Element foo:123
      * Defines the following API
        - element.foo       # getter, returns @_foo
        - element.getFoo()  # old-school, alternative getter - faster in some browsers (Safari7 is 100x faster, Safary8 is 3x faster. Chrome is same speed.)
        - element.foo = v   # setter
        - element.setFoo(v) # old-school, alternative setter
        - element.pendingFoo / getPendingFoo() # returns @_pendingState.foo
        - element.fooChanged / getFooChanged() # returns propsEq @foo, @pendingFoo
      * Elements can override the default values for properties by setting:
        - prototype.defaultFoo to something other than undefined
        - Ex:
          class MyElement extends Element
            defaultSize: ps:1
      * Populates @class.metaProperties.foo with things like default values, names, preprocessors, etc...
        (this code is in flux; see below for current implementation)
    
    options:
      default:  # default value set when the Element is created
      setter: (preprocessedNewValue, oldValue, rawNewValue, preprocessAndValidate) ->
        THIS: the Element
        IN:
          preprocessedNewValue: the new value that has been validated and preprocssed
    
          oldValue: the currently set value.
            WARNING: Setting is replacing!
              The oldValue should not impact the newly set value in any
              LOGICALLY IMPORTANT WAY.
    
              Basically, only use oldValue to enhance performance OR trigger change-events;
              the actually-set-value should not be logically the same with or without it.
    
              For an example of how this is used to increase performance, see the
              'children' property. In this example we both enhance performance AND
              we can trigger detailed change-events.
    
          rawNewValue: the exact, unprocessed, unvalidated value of 'foo' passed by the setYourProp(foo) or @yourProp = foo statement.
          preprocessAndValidate: your custom preprocessor and validator are merged into a single function you can use
            as part of your custom setter if desired. A no-op function is provided by default, so this is always a valid function.
    
          preprocessAndValidate: your custom preprocessor and validator are merged into a single function you can use
            as part of your custom setter if desired. A no-op function is provided by default, so this is always a valid function.
        OUT: It should return the value to set in @_pendingState.
        SIDE EFFECTS:
          It should NOT actually set the value in @ or @_pendingState.
          It is best to use setProperty calls for all side-effects. This maintains the epoch
          consistency model: mutations only modify pendingState, not current-state.
    
        TODO:
          Verify and implement:
            Depricate concrete property setters:
              They are obsolete now that we can have postSetters.
              "postSetter" plus "preprocess" covers everything, I think.
    
        Use when:
          a) you need to do update other poperties when this one changes AND/OR
          b) you need to do something different when actually setting the value
             as opposed to simply preprocessing the value.
             NOTE: animations use the preprocessor when initializing their to and from values.
    
      postSetter: (newValue, oldValue, rawNewValue) ->
        THIS: the Element
        IN:
          newValue: the value after it has passed through the preprocessor and/or setter
          oldValue: the (custom-setter-processed) value that was last set
            i.e. the value in @_pendingState before the setter was called
        OUT: ignored
        STATE: @_pendingState has been updated with newValue; getPendingPropertyName() will return newValue
        SIDE EFFECTS:
          It is best to use setProperty calls for all side-effects. This maintains the epoch
          consistency model: mutations only modify pendingState, not current-state.
    
        Use when:
          a) You need to update other properties when this one changes. The simplest example is when
            this property defines default values for other properties that haven't been set yet.
          b) You need to fire off events when this property changes.
    
        This is particularly useful when writing custom Elements which consist of a struture of other
        elements. Often you'll want to update that structure in response to properties being set.
    
       * keyword: preprocessor
      preprocess: (rawValue, baseValue) -> processedValue
        IN:
          rawValue: raw value passed in to setter
          baseValue: a baseline value in case rawValue only partially specifies the final value.
            This is useful for size and location layouts where you may want to specify one dimension,
            but inherit the other dimension.
            toFrom-void Animators pass in the current value as the baseValue when they start. In this
            way you can say: "animators: size: toFrom: w: 0" and whatever the current height is
            will persist.
            Also note, that you can only pass in a baseCalue if you use "preprocessProperty."
            The normal setter will not pass through any baseValue you include.
            The normal setter is designed to fully replace the current value in a pure-functional way.
        THIS: not set
        OUT: normalized value to actually set
    
       * keyword: validator
      validate: (rawValue) -> boolean
        IN: raw value
        THIS: not set
        OUT: true or false
        Return false if the input is invalid which will trigger an exception.
    
    In all cases _elementChanged executes every time the property is set
    .setter takes precidence over .preprocess takes precidence over .validate; you can only have one
    
    VIRTUAL PROPERTIES
    ------------------
    
    Virtual properties are specified with the class method: @virtualProperty
    
    VPs have the same API from the client's perspective, but they don't have any storage in @ or @_pendingState.
    Virtual properties are used as alternative "views" into the Element's state. Ex:
    
       @currentLocation isn't actually stored as a point. It is derived from @elementToParentMatrix and @axis.
    
    As a short-cut, you can supply just a getter function instead of options to define a
    virtual property. See getter below for details. Here is how to use this shortcut:
    
      @virtualProperty
        foo: (pending) -> ...
    
    Virtual property options (when isPlainObject options)
    
      getter: (pending) ->
        REQUIRED
        THIS: the Element
        IN:   pending: true/false
        OUT:  if pending, return the pending value, else the current value
    
      setter: (preprocessedNewValue, rawNewValue, preprocessAndValidate) ->
        OPTIONAL
          If not provided, this virtual property cannot be set.
          Attempting to set this virtual property will be IGNORED
          I.E. attempting to set this property does not trigger errors.
    
        THIS: the Element
        IN:
          preprocessedNewValue: the new value that has been validated and preprocssed
          rawNewValue: the value passed in by the client
          preprocessAndValidate: your custom preprocessor and validator are merged into a single function you can use
            as part of your custom setter if desired. A no-op function is provided by default, so this is always a valid function.
        OUT: ignored
    
      validate: (v) ->
      preprocess: (v) ->
        works the same as the options for concrete-properties
        except they are only used by:
          preprocessAndValidate function passed to the setter
          animations
    
    Virtual property getter-function-only (if the 'options' passed in is actually a function)
    
      If you pass in a function only when defining a virtual property, you are setting the getter.
      Thus you can define a virtual property with just a getter.
    
    Virtual vs Concrete properties:
    
      * Virutal props don't have default values
      * Virtual props don't create property slots in Element instances or their _pendingState, BUT
      * Virtual props can have their setters invoked from initializers
      * preprocessors and validators can be specified
      * getter - you must specify a custom getter, see getter option above
      * setter specification/semantics are a little different. See setter option above
     */

    /*
    propertyInitializerList:
      list of tupples, one per property:
        [externalName, internalName, preprocessor, defaultValue]
    
    metaProperties fields:
      externalName:
      internalName:
      preprocessor:
      defaultValue:
      setterName:
      getterName:
     */
    var _setPropertiesTempVirtualPropSetterNames, _setPropertiesTempVirtualPropValues, minimalPropsIngore;

    extend(EpochedElementMixin, superClass1);

    EpochedElementMixin.extendableProperty({
      propertyInitializerList: [],
      metaProperties: {}
    });


    /*
    Main method for defining properties. Used by concreteProp, virtualProp and others.
     */

    EpochedElementMixin._defineElementProperty = function(externalName, options) {
      var _getter, _setter, capitalizedExternalName, customPreprocessor, customSetter, customValidator, defaultValue, drawAreaProperty, drawProperty, getter, internalName, layoutProperty, metaProperties, pendingGetter, postSetter, preprocessor, setter;
      if (options == null) {
        options = {};
      }
      internalName = propInternalName(externalName);
      customValidator = options.validate;
      customPreprocessor = options.preprocess;
      defaultValue = options["default"];
      preprocessor = customPreprocessor && customValidator ? function(v) {
        if (v == null) {
          v = defaultValue;
        }
        if (!customValidator(v)) {
          throw new Error("invalid value for " + externalName + ": " + (inspect(v)));
        }
        return customPreprocessor(v);
      } : customValidator ? function(v) {
        if (v == null) {
          v = defaultValue;
        }
        if (!customValidator(v)) {
          throw new Error("invalid value for " + externalName + ": " + (inspect(v)));
        }
        return v;
      } : customPreprocessor || function(v) {
        if (v == null) {
          v = defaultValue;
        }
        return v;
      };
      metaProperties = {
        internalName: internalName,
        externalName: externalName,
        preprocessor: preprocessor,
        getterName: this._propGetterName(externalName),
        setterName: this._propSetterName(externalName)
      };
      if (options.virtual) {
        metaProperties.virtual = true;
        _setter = options.setter || function() {};
        _getter = options.getter;
        getter = _getter;
        pendingGetter = function() {
          return _getter.call(this, true);
        };
        setter = function(rawValue) {
          return _setter.call(this, preprocessor(rawValue), rawValue, preprocessor);
        };
      } else {
        metaProperties.defaultValue = defaultValue = preprocessor(defaultValue);
        getter = function(pending) {
          if (pending) {
            return this._pendingState[internalName];
          } else {
            return this[internalName];
          }
        };
        pendingGetter = function() {
          return this._pendingState[internalName];
        };
        layoutProperty = options.layoutProperty, drawProperty = options.drawProperty, drawAreaProperty = options.drawAreaProperty, postSetter = options.postSetter, setter = options.setter;
        setter = (customSetter = setter) ? postSetter ? function(rawNewValue) {
          var newValue, oldValue;
          oldValue = this._pendingState[internalName];
          newValue = this._pendingState[internalName] = customSetter.call(this, preprocessor(rawNewValue), oldValue, rawNewValue, preprocessor);
          this._elementChanged(layoutProperty, drawProperty, drawAreaProperty);
          postSetter.call(this, newValue, oldValue, rawNewValue);
          return newValue;
        } : function(rawNewValue) {
          var newValue, oldValue;
          oldValue = this._pendingState[internalName];
          newValue = preprocessor(rawNewValue);
          newValue = this._pendingState[internalName] = customSetter.call(this, preprocessor(rawNewValue), oldValue, rawNewValue, preprocessor);
          this._elementChanged(layoutProperty, drawProperty, drawAreaProperty);
          return newValue;
        } : postSetter ? function(rawNewValue) {
          var newValue, oldValue;
          oldValue = this._pendingState[internalName];
          newValue = this._pendingState[internalName] = preprocessor(rawNewValue);
          this._elementChanged(layoutProperty, drawProperty, drawAreaProperty);
          postSetter.call(this, newValue, oldValue);
          return newValue;
        } : preprocessor.length > 1 ? function(rawNewValue) {
          var newValue, oldValue;
          oldValue = this._pendingState[internalName];
          newValue = this._pendingState[internalName] = preprocessor(rawNewValue);
          this._elementChanged(layoutProperty, drawProperty, drawAreaProperty);
          return newValue;
        } : function(rawNewValue) {
          var newValue;
          newValue = this._pendingState[internalName] = preprocessor(rawNewValue);
          this._elementChanged(layoutProperty, drawProperty, drawAreaProperty);
          return newValue;
        };
        this.extendPropertyInitializerList().push([internalName, defaultValue, externalName]);
      }
      this.extendMetaProperties(externalName, metaProperties);
      capitalizedExternalName = capitalize(externalName);
      this._addGetter(this.prototype, externalName, getter);
      this._addGetter(this.prototype, "pending" + capitalizedExternalName, pendingGetter);
      this._addGetter(this.prototype, externalName + "Changed", function() {
        return !shallowPropsEq(getter.call(this), pendingGetter.call(this));
      });
      return this._addSetter(this.prototype, externalName, setter);
    };

    EpochedElementMixin.concreteProperty = function(map) {
      var options, prop, results;
      results = [];
      for (prop in map) {
        options = map[prop];
        results.push(this._defineElementProperty(prop, options));
      }
      return results;
    };


    /*
    IN: map from prop names to:
      a) property options object: see 'Virtual property options' above
      b) OR getter function f. Equivelent to (propName: getter: f)
     */

    EpochedElementMixin.virtualProperty = function(map) {
      var options, prop, results;
      results = [];
      for (prop in map) {
        options = map[prop];
        if (isFunction(options)) {
          options = {
            getter: options
          };
        }
        options.virtual = true;
        results.push(this._defineElementProperty(prop, options));
      }
      return results;
    };


    /*
    EFFECT: set each property in propertySet if it is a legitimate property; otherwise it is ignored
     */

    _setPropertiesTempVirtualPropSetterNames = [];

    _setPropertiesTempVirtualPropValues = [];


    /*
    Sets all properties in propertySet
    undefined values and properties without setters are skipped
     */

    EpochedElementMixin.prototype.setProperties = function(props) {
      var i, j, metaProperties, mp, prop, ref2, setterName, value, virtualPropCount;
      metaProperties = this.metaProperties;
      virtualPropCount = 0;
      for (prop in props) {
        value = props[prop];
        if (value !== void 0 && (mp = metaProperties[prop]) && (setterName = mp.setterName)) {
          if (mp.virtual) {
            _setPropertiesTempVirtualPropSetterNames[virtualPropCount] = setterName;
            _setPropertiesTempVirtualPropValues[virtualPropCount++] = value;
          } else {
            this[setterName](value);
          }
        }
      }
      for (i = j = 0, ref2 = virtualPropCount; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
        this[_setPropertiesTempVirtualPropSetterNames[i]](_setPropertiesTempVirtualPropValues[i]);
      }
      return props;
    };


    /*
    EFFECT: set all properties, use propertySet values if present, otherwise use defaults
    
    TODO: this sets @parent and @children, it shouldn't, but they aren't virtual...
    TODO: if this is used much, it would be faster to have a concreteMetaProperties array so we don't have to test mp.virtual
      this "concreteMetaProperties" array would not include parent or children
     */

    EpochedElementMixin.prototype.replaceProperties = function(propertySet) {
      var externalName, metaProperties, mp, name, property;
      metaProperties = this.metaProperties;
      for (property in metaProperties) {
        mp = metaProperties[property];
        if (!(!mp.virtual)) {
          continue;
        }
        externalName = mp.externalName;
        if (typeof this[name = mp.setterName] === "function") {
          this[name](propertySet.hasOwnProperty(externalName) ? propertySet[externalName] : mp.defaultValue);
        }
      }
      return propertySet;
    };

    EpochedElementMixin.prototype.setProperty = function(property, value) {
      var mp, name;
      if (mp = this.metaProperties[property]) {
        return typeof this[name = mp.setterName] === "function" ? this[name](value) : void 0;
      }
    };

    EpochedElementMixin.prototype.preprocessProperty = function(property, value, baseValue) {
      var mp;
      if (mp = this.metaProperties[property]) {
        return mp.preprocessor(value, baseValue);
      }
    };


    /*
    EFFECT: reset one property to its default
     */

    EpochedElementMixin.prototype.resetProperty = function(property) {
      var mp, name;
      if (mp = this.metaProperties[property]) {
        return typeof this[name = mp.setterName] === "function" ? this[name](mp.defaultValue) : void 0;
      }
    };

    EpochedElementMixin.prototype.preprocessProperties = function(propertySet) {
      var metaProperties, mp, property, value;
      metaProperties = this.metaProperties;
      for (property in propertySet) {
        value = propertySet[property];
        if (mp = metaProperties[property]) {
          propertySet[property] = mp.preprocessor(value, this[mp.internalName]);
        }
      }
      return propertySet;
    };

    EpochedElementMixin.prototype.getPendingPropertyValues = function(propertyNames) {
      var j, len, metaProp, property, ret;
      ret = {};
      for (j = 0, len = propertyNames.length; j < len; j++) {
        property = propertyNames[j];
        if (metaProp = this.metaProperties[property]) {
          ret[property] = this._pendingState[metaProp.internalName];
        }
      }
      return ret;
    };

    EpochedElementMixin.prototype.getPropertyValues = function(propertyNames) {
      var j, len, metaProp, property, ret;
      ret = {};
      for (j = 0, len = propertyNames.length; j < len; j++) {
        property = propertyNames[j];
        if (metaProp = this.metaProperties[property]) {
          ret[property] = this[metaProp.internalName];
        }
      }
      return ret;
    };

    minimalPropsIngore = ["children", "parent"];

    EpochedElementMixin.getter({
      props: function() {
        var k, ref2, ret, virtual;
        ret = {};
        ref2 = this.metaProperties;
        for (k in ref2) {
          virtual = ref2[k].virtual;
          ret[k] = this[k];
        }
        return ret;
      },
      concreteProps: function() {
        var internalName, k, ref2, ref3, ret, virtual;
        ret = {};
        ref2 = this.metaProperties;
        for (k in ref2) {
          ref3 = ref2[k], internalName = ref3.internalName, virtual = ref3.virtual;
          if (!virtual) {
            ret[k] = this[internalName];
          }
        }
        return ret;
      },
      virtualProps: function() {
        var k, ref2, ret, virtual;
        ret = {};
        ref2 = this.metaProperties;
        for (k in ref2) {
          virtual = ref2[k].virtual;
          if (virtual) {
            ret[k] = this[k];
          }
        }
        return ret;
      },
      minimalProps: function() {
        var defaultValue, externalName, internalName, k, ref2, ref3, ret, value, virtual;
        ret = {};
        ref2 = this.metaProperties;
        for (k in ref2) {
          ref3 = ref2[k], externalName = ref3.externalName, internalName = ref3.internalName, virtual = ref3.virtual, defaultValue = ref3.defaultValue;
          if (!virtual) {
            if (indexOf.call(minimalPropsIngore, externalName) < 0) {
              if (!propsEq(defaultValue, value = this[internalName])) {
                ret[k] = value;
              }
            }
          }
        }
        return ret;
      }
    });

    EpochedElementMixin.prototype.preprocessForEpoch = function() {};

    EpochedElementMixin.prototype.onNextReady = function(callback, forceEpoch) {
      if (forceEpoch == null) {
        forceEpoch = true;
      }
      return stateEpoch.onNextReady(callback, forceEpoch, this);
    };

    EpochedElementMixin.onNextReady = function(callback, forceEpoch) {
      if (forceEpoch == null) {
        forceEpoch = true;
      }
      return stateEpoch.onNextReady(callback, forceEpoch);
    };

    EpochedElementMixin.prototype.onNextEpoch = function(callback, forceEpoch) {
      if (forceEpoch == null) {
        forceEpoch = true;
      }
      return globalEpochCycle.onNextReady(callback, forceEpoch, this);
    };

    EpochedElementMixin.onNextEpoch = function(callback, forceEpoch) {
      if (forceEpoch == null) {
        forceEpoch = true;
      }
      return globalEpochCycle.onNextReady(callback, forceEpoch);
    };

    EpochedElementMixin.prototype.onIdle = function(callback) {
      return stateEpoch.onNextReady(callback);
    };

    EpochedElementMixin.prototype.getState = function(pending) {
      if (pending == null) {
        pending = false;
      }
      if (pending) {
        return this._pendingState;
      } else {
        return this;
      }
    };

    EpochedElementMixin.prototype.getPendingState = function() {
      return this._pendingState;
    };

    function EpochedElementMixin(options) {
      if (options == null) {
        options = blankOptions;
      }
      EpochedElementMixin.__super__.constructor.apply(this, arguments);
      this._initFields();
      this._initProperties(options);
    }

    EpochedElementMixin.prototype._initFields = function() {
      this._pendingState = {};
      this.__stateEpochCount = 0;
      this.__stateChangeQueued = false;
      this.__layoutPropertiesChanged = false;
      this.__drawAreaChanged = true;
      return this.__drawPropertiesChanged = true;
    };


    /*
    TODO: 2018-4-17 I'll bet that we can get a big speedup by using
    the "_generateSetPropertyDefaults" pattern to:
    
      a)  inline pending state fields
      b)  _applyStateChanges with no loop
    
    RefactorSteps:
    
      0) design "real-world" object creation test
      1) rename @_pendingState to ensure no external dependencies
      2) add postCreate to run _generateSetPropertyDefaults and our
         new _applyStateChanges function
     */

    EpochedElementMixin._generateSetPropertyDefaults = function() {
      var defaultName, defaultOverride, externalName, functionString, i, k, metaProperties, preprocessor, propertyInitializerList, v, value;
      propertyInitializerList = this.getPropertyInitializerList();
      metaProperties = this.getMetaProperties();
      functionString = compactFlatten([
        "(function(options) {", "var _pendingState = this._pendingState;", "var metaProperties = this.metaProperties;", (function() {
          var j, len, ref2, results;
          results = [];
          for (i = j = 0, len = propertyInitializerList.length; j < len; i = ++j) {
            ref2 = propertyInitializerList[i], k = ref2[0], v = ref2[1], externalName = ref2[2];
            value = (defaultOverride = this.prototype[defaultName = "default" + capitalize(externalName)]) !== void 0 ? ((preprocessor = metaProperties[externalName].preprocessor) ? this.prototype[defaultName] = preprocessor(defaultOverride) : void 0, "this." + defaultName) : v === null || v === false || v === true || v === void 0 || isNumber(v) ? v : "metaProperties." + externalName + ".defaultValue;";
            results.push("this." + k + " = _pendingState." + k + " = " + value + ";");
          }
          return results;
        }).call(this), "})"
      ]).join("\n");
      return eval(functionString);
    };

    EpochedElementMixin.prototype._initProperties = function(options) {
      var metaProperties;
      metaProperties = this.metaProperties;
      if (!this.__proto__.hasOwnProperty("_initPropertiesAuto")) {
        this.__proto__._initPropertiesAuto = this["class"]._generateSetPropertyDefaults();
      }
      this._initPropertiesAuto(options);
      this.setProperties(options);
      this._elementChanged(true, true, true);
      return null;
    };

    EpochedElementMixin.prototype._getChangingStateKeys = function() {
      var k, ref2, results, v;
      ref2 = this._pendingState;
      results = [];
      for (k in ref2) {
        v = ref2[k];
        if (!shallowPropsEq(this[k], this._pendingState[k])) {
          results.push(k);
        }
      }
      return results;
    };

    EpochedElementMixin.prototype._logPendingStateChanges = function() {
      var k, newValues, oldValues, ref2, v;
      oldValues = {};
      newValues = {};
      ref2 = this._pendingState;
      for (k in ref2) {
        v = ref2[k];
        if (!(!(k.match(/^__/)) && !plainObjectsDeepEq(v, this[k]))) {
          continue;
        }
        oldValues[k] = this[k];
        newValues[k] = v;
      }
      return log({
        "ElementBase pending state changes": {
          element: this.inspectedName,
          old: oldValues,
          "new": newValues
        }
      });
    };

    EpochedElementMixin.prototype._getIsChangingElement = function() {
      return stateEpoch._isChangingElement(this);
    };

    EpochedElementMixin.prototype._elementChanged = function(layoutPropertyChanged, drawPropertyChanged, drawAreaPropertyChanged) {
      var _pendingState;
      _pendingState = this._pendingState;
      if (layoutPropertyChanged) {
        if (StateEpoch._stateEpochLayoutInProgress) {
          console.error("__layoutPropertiesChanged while _stateEpochLayoutInProgress");
        }
        this.__layoutPropertiesChanged = true;
      }
      if (drawPropertyChanged) {
        this.__drawPropertiesChanged = true;
      }
      if (drawAreaPropertyChanged) {
        this.__drawAreaChanged = true;
      }
      if (!this.__stateChangeQueued) {
        this.__stateChangeQueued = true;
        return stateEpoch._addChangingElement(this);
      }
    };


    /*
    TODO:
      It would probably be faster overall to:
    
        a) move all the __* properties out of _pendingState
          Probably just promote them to the Element itself
          DONE
    
        b) replace _pendingState with a new, empty object after _applyStateChanges
          SBD March-2016: I think this is still a good idea.
            @_pendingState currently contains every property.
            That's a lot of extra work every state epoch!
            The problem is, we currently rely on that in many places!
            One thing to perf-test: We could make an array of the names of props that changed.
              Then, _applyStateChanges could iterate through that array, pulling values out of @_pendingState.
              (in this scenario we would keep @_pendingState fully of all properties, as it currently is)
    
        c) for faster Element creation
          - could we just say the Element "consumes" the props passed to it on creation?
          - then we can alter that props object
          - every prop in the passed-in props object gets run through the preprocessors/validators
          - and the result is assigned back to the props object
          - then the props object BECOMES the first @_pendingState
          SBD March-2016: I'm less sure this makes sense.
    
        d) SBD March-2016
          I have no idea if this would work, but what would be really cool is if new
          elements could directly apply there initial properties rather then putting them through
          the state-epoch pending cycle. This would probalby be a huge savings for object creation,
          which currently is one of out biggest performance problems.
    
          The problem is, new elements still need to go through a StateEpoch for layout...
     */

    EpochedElementMixin.prototype._applyStateChanges = function() {
      this.__stateChangeQueued = false;
      this.__stateEpochCount++;
      return mergeInto(this, this._pendingState);
    };

    return EpochedElementMixin;

  })(superClass);
};


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var EventedBaseMixin, Events, Foundation, StateEpoch, blankOptions, isPlainObject, log,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Events = __webpack_require__(14);

StateEpoch = __webpack_require__(37);

EventedBaseMixin = Events.EventedBaseMixin;

log = Foundation.log, isPlainObject = Foundation.isPlainObject;

blankOptions = {};

module.exports = function(superClass) {
  var EventedElementMixin;
  return EventedElementMixin = (function(superClass1) {
    var defaultEventHandlerPreprocessor, emptyEventHandlers;

    extend(EventedElementMixin, superClass1);

    function EventedElementMixin(options) {
      if (options == null) {
        options = blankOptions;
      }
      EventedElementMixin.__super__.constructor.apply(this, arguments);
      this._initDefaultEventHandlers(options);
    }

    EventedElementMixin.concreteProperty({
      on: {
        "default": {},
        validate: function(v) {
          return isPlainObject(v);
        },
        setter: function(v) {
          return this.preprocessEventHandlers(v);
        }
      }
    });


    /*
    TODO:
    
      I'd like to have a "preprocessProps" function rather than one function which is
      special-cased for event-handlers. I didn't do this with the first pass because
      Element props can be set one at a time. They aren't set in batch like ArtReact.
      But, I realized, they are effectively batch-set in the StateEpoch. Can we run
      preprocessProps at the beginning of the StateEpoch???
     */

    EventedElementMixin.prototype.preprocessEventHandlers = defaultEventHandlerPreprocessor = function(handlerMap) {
      return handlerMap;
    };

    emptyEventHandlers = {};

    EventedElementMixin.prototype._initDefaultEventHandlers = function(options) {
      if (!options.on && this.preprocessEventHandlers !== defaultEventHandlerPreprocessor) {
        return this.setOn(emptyEventHandlers);
      }
    };

    EventedElementMixin.prototype._applyStateChanges = function() {
      if (this.getParentChanged()) {
        this.queueEvent("parentChanged", {
          oldParent: this._parent,
          parent: this._pendingState._parent
        });
      }
      this.queueEvent("ready");
      return EventedElementMixin.__super__._applyStateChanges.apply(this, arguments);
    };


    /*
    NOTE: by checking @_pendingState also, we can receive events triggered in the same
    epoch as the Element's creation - such as "parentChanged." Actual handling
    will be done later, in the eventEpoch, where _hasEventHandler is double-checked.
     */

    EventedElementMixin.prototype._hasEventHandler = function(eventType) {
      var _on, ref;
      return (_on = this._pendingState._on || this._on) && !!(_on[eventType] || ((ref = _on.preprocess) != null ? ref[eventType] : void 0));
    };


    /*
    To respect stateEpochs, events will never be sent to pending event handlers.
    This would only be a concern if @_on changed between the last stateEpoch and
    the current eventEpoch.
     */

    EventedElementMixin.prototype._sendToEventHandler = function(event) {
      var _on, e, handler, preprocessor, processedEvent, ref, type;
      _on = this._on;
      if (_on) {
        type = (processedEvent = event).type;
        if (preprocessor = (ref = _on.preprocess) != null ? ref[type] : void 0) {
          try {
            processedEvent = preprocessor(event);
          } catch (error) {
            e = error;
            processedEvent = null;
            this._handleErrorInHandler(event, preprocessor, e);
          }
        }
        if ((processedEvent != null) && (handler = _on[type])) {
          try {
            return handler(processedEvent);
          } catch (error) {
            e = error;
            return this._handleErrorInHandler(processedEvent, handler, e);
          }
        }
      }
    };

    return EventedElementMixin;

  })(EventedBaseMixin(superClass));
};


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Epoch, Foundation, IdleEpoch, log,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

log = Foundation.log, Epoch = Foundation.Epoch;

module.exports = IdleEpoch = (function(superClass) {
  extend(IdleEpoch, superClass);

  function IdleEpoch() {
    return IdleEpoch.__super__.constructor.apply(this, arguments);
  }

  IdleEpoch.singletonClass();

  IdleEpoch.prototype.queue = function(event) {
    return this.queueItem(event);
  };

  return IdleEpoch;

})(Epoch);


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

var DevTools,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(20)).addNamespace('DevTools', DevTools = (function(superClass) {
  extend(DevTools, superClass);

  function DevTools() {
    return DevTools.__super__.constructor.apply(this, arguments);
  }

  return DevTools;

})(Neptune.PackageNamespace));


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(226);

module.exports.addModules({
  BlurElement: __webpack_require__(419),
  FilterElement: __webpack_require__(122),
  ShadowElement: __webpack_require__(420)
});


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var Filters,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(39)).addNamespace('Filters', Filters = (function(superClass) {
  extend(Filters, superClass);

  function Filters() {
    return Filters.__super__.constructor.apply(this, arguments);
  }

  return Filters;

})(Neptune.PackageNamespace));


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(228);

module.exports.addModules({
  FillElement: __webpack_require__(421),
  OutlineElement: __webpack_require__(422)
});


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

var ShapeChildren,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(39)).addNamespace('ShapeChildren', ShapeChildren = (function(superClass) {
  extend(ShapeChildren, superClass);

  function ShapeChildren() {
    return ShapeChildren.__super__.constructor.apply(this, arguments);
  }

  return ShapeChildren;

})(Neptune.PackageNamespace));


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(230);

module.exports.addModules({
  BitmapElement: __webpack_require__(423),
  RectangleElement: __webpack_require__(424),
  ShapeElement: __webpack_require__(425),
  TextElement: __webpack_require__(426)
});


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

var Shapes,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(39)).addNamespace('Shapes', Shapes = (function(superClass) {
  extend(Shapes, superClass);

  function Shapes() {
    return Shapes.__super__.constructor.apply(this, arguments);
  }

  return Shapes;

})(Neptune.PackageNamespace));


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(232);

module.exports.addModules({
  PagingScrollElement: __webpack_require__(427),
  ScrollElement: __webpack_require__(428)
});


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

var Widgets,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(39)).addNamespace('Widgets', Widgets = (function(superClass) {
  extend(Widgets, superClass);

  function Widgets() {
    return Widgets.__super__.constructor.apply(this, arguments);
  }

  return Widgets;

})(Neptune.PackageNamespace));


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var Events, Foundation, KeyEvent, log,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Events = __webpack_require__(14);


/*
KeyboardEvent Polyfill

We are using the upcoming (as-of-2016) "DOM Keyboard Level 3 Events".
Info:
  https://w3c.github.io/uievents/#interface-KeyboardEvent
  https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent

This polyfill helps the "key" value of KeyboardEvents be populated consistently across browsers.

Current browser support: http://caniuse.com/#search=keyboardevent.key
Alternative polyfill: https://github.com/termi/DOM-Keyboard-Event-Level-3-polyfill
  (not using because it hasn't been touchedin 3 years and is complex)
 */

__webpack_require__(605).polyfill();

log = Foundation.log;

module.exports = KeyEvent = (function(superClass) {
  extend(KeyEvent, superClass);

  function KeyEvent(type, _keyboardEvent) {
    this._keyboardEvent = _keyboardEvent;
    KeyEvent.__super__.constructor.call(this, type, {
      key: this._keyboardEvent.key,
      altKey: this._keyboardEvent.altKey,
      ctrlKey: this._keyboardEvent.ctrlKey,
      shiftKey: this._keyboardEvent.shiftKey,
      metaKey: this._keyboardEvent.metaKey
    });
  }

  return KeyEvent;

})(Events.Event);


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Atomic, Events, Foundation, PointerEvent, arrayize, clone, defineModule, first, inspect, matrix, merge, peek, point, rect, transformedArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Atomic = __webpack_require__(4);

Foundation = __webpack_require__(2);

Events = __webpack_require__(14);

point = Atomic.point, rect = Atomic.rect, matrix = Atomic.matrix;

defineModule = Foundation.defineModule, inspect = Foundation.inspect, clone = Foundation.clone, peek = Foundation.peek, first = Foundation.first, merge = Foundation.merge;

arrayize = function(single, array, defaultArray) {
  if (single) {
    return [single];
  } else {
    return array || defaultArray || [];
  }
};

transformedArray = function(arrayOfPoints, matrix) {
  var i, len, p, results;
  results = [];
  for (i = 0, len = arrayOfPoints.length; i < len; i++) {
    p = arrayOfPoints[i];
    results.push(matrix.transform(p));
  }
  return results;
};

defineModule(module, PointerEvent = (function(superClass) {
  var emptyObject;

  extend(PointerEvent, superClass);

  function PointerEvent(type, pointer, time, props) {
    PointerEvent.__super__.constructor.call(this, type, props, time);
    this.pointer = pointer;
  }

  emptyObject = {};

  PointerEvent.prototype.newEvent = function(options) {
    var e;
    if (options == null) {
      options = emptyObject;
    }
    e = new PointerEvent(options.type || this.type, options.pointer || this.pointer, options.time || this.time);
    e.timeStamp = this.timeStamp;
    e.target = options.target || this.target;
    return e;
  };

  PointerEvent.getter({
    location: function() {
      return this.pointer.locationIn(this.target);
    },
    firstLocation: function() {
      return this.pointer.firstLocationIn(this.target);
    },
    lastLocation: function() {
      return this.pointer.lastLocationIn(this.target);
    },
    absLocation: function() {
      return this.pointer.location;
    },
    absFirstLocation: function() {
      return this.pointer.firstLocation;
    },
    absLastLocation: function() {
      return this.pointer.lastLocation;
    },
    parentLocation: function() {
      return this.pointer.locationIn(this.target.parent);
    },
    parentParentLocation: function() {
      return this.pointer.locationIn(this.target.parent.parent);
    },
    parentFirstLocation: function() {
      return this.pointer.firstLocationIn(this.target.parent);
    },
    parentParentFirstLocation: function() {
      return this.pointer.firstLocationIn(this.target.parent.parent);
    },
    parentLastLocation: function() {
      return this.pointer.lastLocationIn(this.target.parent);
    },
    parentParentLastLocation: function() {
      return this.pointer.lastLocationIn(this.target.parent.parent);
    },
    absDelta: function() {
      return this.pointer.location.sub(this.pointer.lastLocation);
    },
    delta: function() {
      return this.location.sub(this.lastLocation);
    },
    parentDelta: function() {
      return this.pointer.deltaIn(this.target.parent);
    },
    parentParentDelta: function() {
      return this.pointer.deltaIn(this.target.parent.parent);
    },
    absTotalDelta: function() {
      return this.pointer.location.sub(this.pointer.firstLocation);
    },
    totalDelta: function() {
      return this.location.sub(this.firstLocation);
    },
    totalParentDelta: function() {
      return this.pointer.totalDeltaIn(this.target.parent);
    },
    totalParentParentDelta: function() {
      return this.pointer.totalDeltaIn(this.target.parent.parent);
    }
  });

  PointerEvent.prototype.toElementMatrix = function(element) {
    return this.target.getElementToElementMatrix(element);
  };

  PointerEvent.prototype.locationIn = function(element) {
    return this.pointer.locationIn(element);
  };

  PointerEvent.prototype.lastLocationIn = function(element) {
    return this.pointer.lastLocationIn(element);
  };

  PointerEvent.prototype.firstLocationIn = function(element) {
    return this.pointer.firstLocationIn(element);
  };

  return PointerEvent;

})(Events.Event));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(236);

module.exports.addModules({
  GestureRecognizer: __webpack_require__(123),
  KeyEvent: __webpack_require__(233),
  Pointer: __webpack_require__(124),
  PointerEvent: __webpack_require__(234),
  PointerEventManager: __webpack_require__(430)
});


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

var Events,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(20)).addNamespace('Events', Events = (function(superClass) {
  extend(Events, superClass);

  function Events() {
    return Events.__super__.constructor.apply(this, arguments);
  }

  return Events;

})(Neptune.PackageNamespace));


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var StandardImport, merge;

merge = (StandardImport = __webpack_require__(126)).merge;

module.exports = merge(__webpack_require__(38), StandardImport);


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

var File,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(20)).addNamespace('File', File = (function(superClass) {
  extend(File, superClass);

  function File() {
    return File.__super__.constructor.apply(this, arguments);
  }

  return File;

})(Neptune.PackageNamespace));


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var Atomic, Element, Foundation, SynchronizedDomOverlay, float32Eq, inspect, log, merge, point, point1, rect, timeout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Element = __webpack_require__(36);

timeout = Foundation.timeout, log = Foundation.log, merge = Foundation.merge, inspect = Foundation.inspect, float32Eq = Foundation.float32Eq;

rect = Atomic.rect, point1 = Atomic.point1, point = Atomic.point;

module.exports = SynchronizedDomOverlay = (function(superClass) {
  extend(SynchronizedDomOverlay, superClass);

  function SynchronizedDomOverlay(options) {
    if (options == null) {
      options = {};
    }
    this._attachedToCanvasElement = null;
    this._updateQueued = false;
    this.setDomElement(options.domElement);
    SynchronizedDomOverlay.__super__.constructor.apply(this, arguments);
  }

  SynchronizedDomOverlay.getter({
    domElement: function() {
      return this._domElement;
    },
    domElementFocused: function() {
      return global.document.activeElement === this._domElement;
    }
  });

  SynchronizedDomOverlay.setter({
    domElement: function(domElement) {
      this._detachDomElement();
      this._domElement = domElement;
      this._domElement.style.position = "absolute";
      this._domElement.style.top = "0";
      return this.onNextReady((function(_this) {
        return function() {
          return _this._attachDomElement();
        };
      })(this));
    }
  });

  SynchronizedDomOverlay.prototype.preprocessEventHandlers = function(handlerMap) {
    return SynchronizedDomOverlay.__super__.preprocessEventHandlers.call(this, merge(handlerMap, {
      rootElementChanged: (function(_this) {
        return function(e) {
          return _this._rootElementChanged(e);
        };
      })(this)
    }));
  };

  SynchronizedDomOverlay.prototype._rootElementChanged = function(e) {
    return this.onNextReady((function(_this) {
      return function() {
        return _this._attachDomElement();
      };
    })(this));
  };

  SynchronizedDomOverlay.prototype._unregister = function() {
    SynchronizedDomOverlay.__super__._unregister.apply(this, arguments);
    return this._detachDomElement();
  };

  SynchronizedDomOverlay.prototype._queueUpdate = function() {
    if (this._updateQueued || !this._attachedToCanvasElement) {
      return;
    }
    this._updateQueued = true;
    return this.onNextReady((function(_this) {
      return function() {
        _this._updateQueued = false;
        _this._updateDomLayout();
        return _this._queueUpdate();
      };
    })(this), false);
  };

  SynchronizedDomOverlay.prototype._updateDomLayout = function() {
    var m, newCanvasElement, opacity, r, ref, size, sx, sy, x, y;
    if (this._shouldAttachDomElement) {
      if (!(typeof canvasElement !== "undefined" && canvasElement !== null ? (ref = canvasElement.htmlCanvasElement) != null ? ref.parentElement : void 0 : void 0)) {
        timeout(50, (function(_this) {
          return function() {
            return _this._updateDomLayout();
          };
        })(this));
        return null;
      }
      this._shouldAttachDomElement = false;
      canvasElement.htmlCanvasElement.parentElement.appendChild(this._domElement);
      this.queueEvent("domElementAttached");
    }
    if (this._attachedToCanvasElement !== (newCanvasElement = this.getCanvasElement())) {
      this._attachDomElement(newCanvasElement);
    }
    if (!this._attachedToCanvasElement) {
      return;
    }
    m = this.getElementToDocumentMatrix();
    x = m.getLocationX();
    y = m.getLocationY();
    size = this.getPaddedSize();
    sx = m.getScaleX();
    sy = m.getScaleY();
    r = rect(x, y, size.x, size.y).round();
    opacity = this.getAbsOpacity();
    this._domElement.style.opacity = opacity;
    this._domElement.style.display = opacity === 0 ? "none" : "block";
    this._domElement.style.left = r.x + "px";
    this._domElement.style.top = r.y + "px";
    this._domElement.style.width = r.w + "px";
    this._domElement.style.height = r.h + "px";
    return this._domElement.style.transform = !float32Eq(sx, 1) || !float32Eq(sy, 1) ? (this._domElement.style["transform-origin"] = "left top", "scale(" + sx + ", " + sy + ")") : "none";
  };

  SynchronizedDomOverlay.prototype._focusDomElement = function() {
    var ref;
    return (ref = this._domElement) != null ? ref.focus() : void 0;
  };

  SynchronizedDomOverlay.prototype._detachDomElement = function() {
    var ref, ref1;
    if (!this._attachedToCanvasElement) {
      return;
    }
    this._shouldAttachDomElement = false;
    if ((ref = this._domElement) != null) {
      if ((ref1 = ref.parentElement) != null) {
        ref1.removeChild(this._domElement);
      }
    }
    return this._attachedToCanvasElement = null;
  };

  SynchronizedDomOverlay.prototype._attachDomElement = function() {
    var canvasElement;
    if (!this.isRegistered) {
      return;
    }
    canvasElement = this.getCanvasElement();
    if (this._attachedToCanvasElement) {
      if (canvasElement === this._attachedToCanvasElement) {
        return;
      }
      this._detachDomElement();
    }
    if (canvasElement) {
      this._attachedToCanvasElement = canvasElement;
      this._shouldAttachDomElement = true;
      this._updateDomLayout();
      this._queueUpdate();
    }
    return this._layoutPropertyChanged();
  };

  return SynchronizedDomOverlay;

})(Element);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(241);

module.exports.addModules({
  SynchronizedDomOverlay: __webpack_require__(239),
  TextInputElement: __webpack_require__(434)
});


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

var Forms,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(20)).addNamespace('Forms', Forms = (function(superClass) {
  extend(Forms, superClass);

  function Forms() {
    return Forms.__super__.constructor.apply(this, arguments);
  }

  return Forms;

})(Neptune.PackageNamespace));


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var Layout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(20)).addNamespace('Layout', Layout = (function(superClass) {
  extend(Layout, superClass);

  function Layout() {
    return Layout.__super__.constructor.apply(this, arguments);
  }

  return Layout;

})(Neptune.PackageNamespace));


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

var EpochedState,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(442)).addNamespace('EpochedState', EpochedState = (function(superClass) {
  extend(EpochedState, superClass);

  function EpochedState() {
    return EpochedState.__super__.constructor.apply(this, arguments);
  }

  EpochedState.version = __webpack_require__(590).version;

  return EpochedState;

})(Neptune.PackageNamespace));


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryFluxModel, ArtEryQueryFluxModel, CommunicationStatus, FluxModel, Promise, arrayWith, arrayWithElementReplaced, compactFlatten, createWithPostCreate, decapitalize, defineModule, each, eq, fastBind, formattedInspect, inspect, isFunction, isPlainObject, isString, log, merge, missing, models, object, pending, ref, ref1, select, success, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

if (!Neptune.Art.Flux) {
  throw new Error("Neptune.Art.Flux not loaded. Please pre-require Flux or Flux/web_worker.");
}

ref = Neptune.Art.Flux, FluxModel = ref.FluxModel, models = ref.models;

ArtEry = __webpack_require__(55);

ArtEryQueryFluxModel = __webpack_require__(245);

ref1 = Neptune.Art.Foundation, each = ref1.each, log = ref1.log, CommunicationStatus = ref1.CommunicationStatus, select = ref1.select, isString = ref1.isString, isFunction = ref1.isFunction, fastBind = ref1.fastBind, decapitalize = ref1.decapitalize, merge = ref1.merge, Promise = ref1.Promise, eq = ref1.eq, upperCamelCase = ref1.upperCamelCase, arrayWith = ref1.arrayWith, arrayWithElementReplaced = ref1.arrayWithElementReplaced, formattedInspect = ref1.formattedInspect, defineModule = ref1.defineModule, createWithPostCreate = ref1.createWithPostCreate, inspect = ref1.inspect, compactFlatten = ref1.compactFlatten, object = ref1.object, isPlainObject = ref1.isPlainObject;

missing = CommunicationStatus.missing, success = CommunicationStatus.success, pending = CommunicationStatus.pending;

defineModule(module, ArtEryFluxModel = (function(superClass) {
  extend(ArtEryFluxModel, superClass);

  ArtEryFluxModel.abstractClass();


  /*
  ALIASES
    both pipelines and models will have the same set of aliases
    This skips the aliases in pipelines and calls createModel only once
    which will in turn create all the model aliases.
    It's important that all the model aliases are the same model-instance object.
  
  OUT: singleton for new AnonymousArtErtFluxModel class
   */

  ArtEryFluxModel.createModel = function(pipeline) {
    var AnonymousArtErtFluxModel, aliases, hotReloadKey, name;
    aliases = pipeline.aliases;
    name = pipeline.getName();
    if (models[name]) {
      return;
    }
    hotReloadKey = "ArtEryFluxModel:" + name;
    return createWithPostCreate(AnonymousArtErtFluxModel = (function(superClass1) {
      var ucName;

      extend(AnonymousArtErtFluxModel, superClass1);

      function AnonymousArtErtFluxModel() {
        return AnonymousArtErtFluxModel.__super__.constructor.apply(this, arguments);
      }

      AnonymousArtErtFluxModel._name = ucName = upperCamelCase(name);

      if (pipeline.keyFields) {
        AnonymousArtErtFluxModel.keyFields(pipeline.keyFields);
      }

      AnonymousArtErtFluxModel.pipeline(pipeline);

      if (aliases) {
        AnonymousArtErtFluxModel.aliases(aliases);
      }

      AnonymousArtErtFluxModel.getHotReloadKey = function() {
        return hotReloadKey;
      };

      return AnonymousArtErtFluxModel;

    })(this.applyMixins(pipeline, ArtEryFluxModel)));
  };

  ArtEryFluxModel.applyMixins = function(pipeline, BaseClass) {
    var customMixin, i, len, ref2;
    ref2 = compactFlatten(pipeline.getFluxModelMixins());
    for (i = 0, len = ref2.length; i < len; i++) {
      customMixin = ref2[i];
      BaseClass = customMixin(BaseClass);
    }
    return BaseClass;
  };

  ArtEryFluxModel.defineModelsForAllPipelines = function() {
    var name, pipeline, ref2, results;
    ref2 = ArtEry.pipelines;
    results = [];
    for (name in ref2) {
      pipeline = ref2[name];
      if (name === pipeline.getName()) {
        results.push(ArtEryFluxModel.createModel(pipeline));
      }
    }
    return results;
  };

  ArtEryFluxModel.pipeline = function(_pipeline) {
    this._pipeline = _pipeline;
    return this._pipeline;
  };

  ArtEryFluxModel.getter("pipeline");

  function ArtEryFluxModel() {
    ArtEryFluxModel.__super__.constructor.apply(this, arguments);
    this._updateSerializers = {};
    this._pipeline = this["class"]._pipeline;
    this._defineQueryModels();
    this._bindPipelineMethods();
  }

  ArtEryFluxModel.prototype._defineQueryModels = function() {
    return this._queryModels = object(this._pipeline.queries, (function(_this) {
      return function(pipelineQuery) {
        return _this._createQueryModel(pipelineQuery);
      };
    })(this));
  };

  ArtEryFluxModel.prototype._createQueryModel = function(arg) {
    var ArtEryQueryFluxModelChild, options, prototypeProperties, queryName;
    options = arg.options, queryName = arg.queryName;
    prototypeProperties = merge(options, {
      _pipeline: this._pipeline,
      _recordsModel: this,
      query: function(key) {
        return this._pipeline[queryName]({
          key: key,
          props: {
            include: "auto"
          }
        });
      }
    });
    return new (ArtEryQueryFluxModelChild = (function(superClass1) {
      var k, v;

      extend(ArtEryQueryFluxModelChild, superClass1);

      function ArtEryQueryFluxModelChild() {
        return ArtEryQueryFluxModelChild.__super__.constructor.apply(this, arguments);
      }

      ArtEryQueryFluxModelChild._name = upperCamelCase(queryName);

      for (k in prototypeProperties) {
        v = prototypeProperties[k];
        ArtEryQueryFluxModelChild.prototype[k] = v;
      }

      return ArtEryQueryFluxModelChild;

    })(this["class"].applyMixins(this._pipeline, ArtEryQueryFluxModel)));
  };

  ArtEryFluxModel.prototype.loadData = function(key) {
    return this._pipeline.get({
      returnNullIfMissing: true,
      key: key,
      props: {
        include: "auto"
      }
    });
  };


  /*
  TODO: What if the field that changes effects @dataToKeyString???
    Basically, then TWO query results for one query-model need updated - the old version gets a "delete"
    The new version gets the normal update.
  
    We -could- do a fluxStore.get and see if we have a local copy of the single record before we
    replace it. However, we often won't. However again, we may not NEED this often.
  
    Basically, the question becomes how do we get the old data - if we need it and it actually matters.
  
    The ArtEry Pipeline knows its queries - and in theory could know the fields which effect queries.
    DataUpdatesFilter could detect all this before: update. If it detects it, it could GET the old
    record, and then set responseProps.oldData: oldData. Then, DataUpdatesFilter could pass
    oldData into dataUpdated. DONE.
  
    OK - I added the oldData input, and I attempt to get it from the fluxStore if it isn't set.
    I think the code is right for handling the case where we need to update to queries.
  
    TODO: We need to do the Server-Side "fetch the old data if queries-keys will change" outline above.
    TODO: DataUpdatesFilter needs change the protocol to return oldData, too, if needed - there may be more than one oldData per request.
    TODO: DataUpdatesFilter needs to pass in: response.props.oldData[key]
   */

  ArtEryFluxModel.prototype.dataUpdated = function(key, data) {
    var mergedData, oldData, ref2;
    oldData = (ref2 = this.fluxStoreGet(key)) != null ? ref2.data : void 0;
    mergedData = merge(oldData, data);
    this.updateFluxStore(key, function(oldFluxRecord) {
      return merge(oldFluxRecord, {
        data: merge(oldFluxRecord.data, data)
      });
    });
    return each(this._queryModels, (function(_this) {
      return function(queryModel) {
        var oldQueryKey, queryKey;
        oldQueryKey = oldData && queryModel.dataToKeyString(oldData);
        queryKey = queryModel.dataToKeyString(mergedData);
        if (oldQueryKey && oldQueryKey !== queryKey) {
          queryModel.dataDeleted(oldQueryKey, oldData);
        }
        if (queryKey) {
          return queryModel.dataUpdated(queryKey, mergedData);
        }
      };
    })(this));
  };

  ArtEryFluxModel.prototype.dataDeleted = function(key, dataOrKey) {
    this.updateFluxStore(key, {
      status: missing
    });
    return dataOrKey && each(this._queryModels, (function(_this) {
      return function(queryModel) {
        var queryKey;
        queryKey = queryModel.toKeyString(dataOrKey);
        return queryKey && queryModel.dataDeleted(queryKey, dataOrKey);
      };
    })(this));
  };


  /*
  Bind all concrete methods defined on @_pipeline
  and set them on the model prototype
  as long as there isn't already a model-prototype method with that name.
  
  Specifically: create & update are already defined above
    since they need to do extra work to ensure the FluxStore is
    updated properly.
   */

  ArtEryFluxModel.prototype._bindPipelineMethods = function() {
    var abstractPrototype, k, ref2, results, v;
    abstractPrototype = this._pipeline["class"].getAbstractPrototype();
    ref2 = this._pipeline;
    results = [];
    for (k in ref2) {
      v = ref2[k];
      if (!this[k] && !abstractPrototype[k] && isFunction(v)) {
        results.push(this[k] = fastBind(v, this._pipeline));
      }
    }
    return results;
  };

  return ArtEryFluxModel;

})(ArtEry.KeyFieldsMixin(FluxModel)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtEry, ArtEryQueryFluxModel, CommunicationStatus, Flux, FluxModel, Foundation, Promise, arrayWith, arrayWithElementReplaced, arrayWithout, decapitalize, defineModule, eq, formattedInspect, isFunction, isString, log, merge, missing, pending, propsEq, select, success, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Flux = Neptune.Art.Flux;

ArtEry = __webpack_require__(55);

log = Foundation.log, CommunicationStatus = Foundation.CommunicationStatus, select = Foundation.select, isString = Foundation.isString, isFunction = Foundation.isFunction, decapitalize = Foundation.decapitalize, merge = Foundation.merge, Promise = Foundation.Promise, eq = Foundation.eq, upperCamelCase = Foundation.upperCamelCase, arrayWith = Foundation.arrayWith, arrayWithElementReplaced = Foundation.arrayWithElementReplaced, formattedInspect = Foundation.formattedInspect, propsEq = Foundation.propsEq, defineModule = Foundation.defineModule, arrayWithout = Foundation.arrayWithout;

missing = CommunicationStatus.missing, success = CommunicationStatus.success, pending = CommunicationStatus.pending;

FluxModel = Flux.FluxModel;

defineModule(module, ArtEryQueryFluxModel = (function(superClass) {
  extend(ArtEryQueryFluxModel, superClass);

  ArtEryQueryFluxModel.abstractClass();


  /*
  This class is designed to be extended with overrides:
   */

  function ArtEryQueryFluxModel() {
    ArtEryQueryFluxModel.__super__.constructor.call(this, null);
    this.register();
  }

  ArtEryQueryFluxModel.prototype.loadData = function(key) {
    return Promise.resolve(this.query(key, this.pipeline)).then((function(_this) {
      return function(data) {
        return _this.localSort(data);
      };
    })(this));
  };

  ArtEryQueryFluxModel.setter("recordsModel pipeline");

  ArtEryQueryFluxModel.getter("recordsModel pipeline");


  /*
  IN: will be the key (returned from fromFluxKey)
  OUT: array of singleModel records
    OR promise.then (arrayOfRecords) ->
  TODO:
    In the future we may wish to return other things beyond the array of records.
    Example:
      DynamoDb returns data for "getting the next page of records" in addition to the records.
      DynamoDb also returns other interesting stats about the query.
  
    If an array is returned, it will always be records. However, if an object is
    returned, then one of the fields will be records - and will go through the return
    pipeline, but the rest will be left untouched and placed in the FluxRecord's data field.
    Or should they be put in an auxiliary field???
   */

  ArtEryQueryFluxModel.prototype.query = function(key) {
    return [];
  };


  /*
  override for to sort records when updating local query data in response to local record changes
   */

  ArtEryQueryFluxModel.prototype.localSort = function(queryData) {
    return queryData;
  };


  /*
  override for custom merge
  This implementation is a streight-up merge using @recordsModel.dataHasEqualKeys
  
  IN:
    previousQueryData: array of records or null
    updatedRecordData: single record or null
  OUT: return null if nothing changed, else return a new array
   */

  ArtEryQueryFluxModel.prototype.localMerge = function(previousQueryData, updatedRecordData, wasDeleted) {
    var currentRecordData, i, j, len, updatedRecordDataKey;
    if (!(previousQueryData && (updatedRecordData || wasDeleted))) {
      return null;
    }
    if (!((previousQueryData != null ? previousQueryData.length : void 0) > 0)) {
      if (wasDeleted) {
        return [];
      } else {
        return [updatedRecordData];
      }
    }
    updatedRecordDataKey = this.recordsModel.toKeyString(updatedRecordData);
    for (i = j = 0, len = previousQueryData.length; j < len; i = ++j) {
      currentRecordData = previousQueryData[i];
      if (updatedRecordDataKey === this.recordsModel.toKeyString(currentRecordData)) {
        if (wasDeleted) {
          return arrayWithout(previousQueryData, i);
        } else if (propsEq(currentRecordData, updatedRecordData)) {
          log("saved 1 fluxStore update due to no-change check! (model: " + this.name + ", record-key: " + updatedRecordDataKey + ")");
          return null;
        } else {
          return arrayWithElementReplaced(previousQueryData, updatedRecordData, i);
        }
      }
    }
    if (wasDeleted) {
      return null;
    } else {
      return arrayWith(previousQueryData, updatedRecordData);
    }
  };

  ArtEryQueryFluxModel.prototype.localMergeGivenQueryKey = function(queryKey, singleRecordData, wasDeleted) {
    var ref;
    return queryKey && this.localMerge((ref = this.fluxStoreGet(queryKey)) != null ? ref.data : void 0, singleRecordData, wasDeleted);
  };


  /*
  ArtEryFluxModel calls dataUpdated and dataDeleted from its
  dataUpdated and dataDeleted functions, respectively.
   */

  ArtEryQueryFluxModel.prototype.dataUpdated = function(queryKey, singleRecordData) {
    var mergeResult;
    if (mergeResult = this.localMergeGivenQueryKey(queryKey, singleRecordData)) {
      return this.updateFluxStore(queryKey, {
        data: this.localSort(mergeResult)
      });
    }
  };

  ArtEryQueryFluxModel.prototype.dataDeleted = function(queryKey, singleRecordData) {
    var mergeResult;
    if (mergeResult = this.localMergeGivenQueryKey(queryKey, singleRecordData, true)) {
      return this.updateFluxStore(queryKey, {
        data: this.localSort(mergeResult)
      });
    }
  };

  return ArtEryQueryFluxModel;

})(FluxModel));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var DataUpdatesFilter, Filter, Validator, deepMerge, defineModule, each, formattedInspect, isFunction, log, m, merge, objectHasKeys, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), each = ref.each, formattedInspect = ref.formattedInspect, deepMerge = ref.deepMerge, merge = ref.merge, defineModule = ref.defineModule, log = ref.log, Validator = ref.Validator, m = ref.m, isFunction = ref.isFunction, objectHasKeys = ref.objectHasKeys;

Filter = __webpack_require__(21);


/*
A) Populate context.dataUpdates
B) if Neptune.Art.Flux is defined, and this is the root request or resposne
   Perform 'local updates'
 */


/*
TODO:
  Eventually we will want a way to say that some record updates should not be returned client-side.
  First pass
    - data has already gone through the after-pipeline, so any after-filters can removed fields
      the current user can't see. TODO: create privacy filters
    - if data is empty, then don't add it to updates. Nothing to add anyway. DONE
 */

defineModule(module, DataUpdatesFilter = (function(superClass) {
  var getUpdatedUpdates;

  extend(DataUpdatesFilter, superClass);

  DataUpdatesFilter.location("both");

  function DataUpdatesFilter() {
    DataUpdatesFilter.__super__.constructor.apply(this, arguments);
    this.group = "outter";
  }

  getUpdatedUpdates = function(response, fields) {
    var base, field, key, obj, obj1, pipelineName, responseData, type;
    key = response.key, type = response.type, responseData = response.responseData;
    field = (function() {
      if (response.isRootRequest && type === "get") {
        return "dataUpdates";
      } else {
        switch (type) {
          case "create":
          case "update":
            return "dataUpdates";
          case "delete":
            return "dataDeletes";
        }
      }
    })();
    if (field && (responseData || key)) {
      pipelineName = response.pipelineName;
      responseData || (responseData = (typeof (base = response.pipeline).toKeyObject === "function" ? base.toKeyObject(key || responseData) : void 0) || {});
      key || (key = response.pipeline.toKeyString(responseData));
      fields[field] = deepMerge(fields[field], (
        obj = {},
        obj["" + pipelineName] = (
          obj1 = {},
          obj1["" + key] = responseData,
          obj1
        ),
        obj
      ));
    }
    return fields;
  };

  DataUpdatesFilter.after({
    all: function(response) {
      var dataDeletes, dataUpdates, ref1;
      if (response.isRootRequest) {
        if (response.location !== "server" && Neptune.Art.Flux) {
          this.applyFluxUpdates(response);
        }
        if (response.location !== "client") {
          ref1 = response.context, dataUpdates = ref1.dataUpdates, dataDeletes = ref1.dataDeletes;
          return response["with"]({
            props: merge(response.responseProps, {
              dataUpdates: dataUpdates,
              dataDeletes: dataDeletes
            })
          });
        } else {
          return response;
        }
      } else {
        this.addUpdatesToResponse(response);
        return response;
      }
    }
  });

  DataUpdatesFilter.prototype.applyFluxUpdates = function(response) {
    var context, dataDeletes, dataDeletesByKey, dataUpdates, dataUpdatesByKey, model, models, pipelineName, ref1, ref2, ref3, responseProps, results;
    responseProps = response.responseProps, context = response.context;
    dataUpdates = merge(context.dataUpdates, responseProps.dataUpdates);
    dataDeletes = merge(context.dataDeletes, responseProps.dataDeletes);
    ref1 = getUpdatedUpdates(response, {
      dataUpdates: dataUpdates,
      dataDeletes: dataDeletes
    }), dataUpdates = ref1.dataUpdates, dataDeletes = ref1.dataDeletes;
    models = Neptune.Art.Flux.models;
    for (pipelineName in dataUpdates) {
      dataUpdatesByKey = dataUpdates[pipelineName];
      if (isFunction((ref2 = (model = models[pipelineName])) != null ? ref2.dataUpdated : void 0)) {
        each(dataUpdatesByKey, function(data, key) {
          return model.dataUpdated(key, data);
        });
      }
    }
    results = [];
    for (pipelineName in dataDeletes) {
      dataDeletesByKey = dataDeletes[pipelineName];
      if (isFunction((ref3 = (model = models[pipelineName])) != null ? ref3.dataDeleted : void 0)) {
        results.push(each(dataDeletesByKey, function(data, key) {
          return model.dataDeleted(key, data);
        }));
      }
    }
    return results;
  };

  DataUpdatesFilter.prototype.addUpdatesToResponse = function(response) {
    return getUpdatedUpdates(response, response.context);
  };

  return DataUpdatesFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Filter, LinkFieldsFilter, Promise, array, defineModule, each, formattedInspect, isPlainArray, isPlainObject, isString, log, merge, missing, networkFailure, normalizeFieldProps, ref, ref1, shallowClone, timeout, wordsArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), timeout = ref.timeout, array = ref.array, timeout = ref.timeout, isPlainObject = ref.isPlainObject, formattedInspect = ref.formattedInspect, each = ref.each, wordsArray = ref.wordsArray, log = ref.log, defineModule = ref.defineModule, merge = ref.merge, isString = ref.isString, shallowClone = ref.shallowClone, isPlainArray = ref.isPlainArray, Promise = ref.Promise;

Filter = __webpack_require__(21);

normalizeFieldProps = __webpack_require__(33).normalizeFieldProps;

ref1 = __webpack_require__(19), missing = ref1.missing, networkFailure = ref1.networkFailure;

defineModule(module, LinkFieldsFilter = (function(superClass) {
  var booleanProps;

  extend(LinkFieldsFilter, superClass);

  LinkFieldsFilter.location("server");


  /*
  IN:
    fields:
       * object mapping the linked fields (not the ID fields for those linked fileds)
       * EX:
      user:
           * any art-validation legal field description
           * Additional options:
          autoCreate:   true/false
            if set, when request-type == "create"
              if this field is set with an object without and id
                then it will FIRST create the linked-to-object
                then it will set the id-field with the linked-to-object
  
            if this field is set with an object WITH an id
              (I think this applies to both create and update request-types)
              will automatically set the id-field to the matching id
  
          pipelineName: string
            override the default pipelineName
            default: field-name (in this example: 'user')
  
          include: true/false
            if true, then when returning instances of this object, it will also
            fetch the linked field's object. In this case, it will set 'user' to
            the value returned from: pipelines.user.get userId
            (This is how it is actually fetched: request.cachedGet 'user', userId)
   */

  function LinkFieldsFilter(options) {
    var fieldName, fieldProps, fields, props, ref2;
    fields = {};
    this._linkFields = LinkFieldsFilter.normalizeLinkFields(options.fields);
    ref2 = this._linkFields;
    for (fieldName in ref2) {
      fieldProps = ref2[fieldName];
      props = merge(fieldProps, {
        fieldType: "trimmedString"
      });
      delete props.idFieldName;
      fields[fieldProps.idFieldName] = normalizeFieldProps(props);
    }
    LinkFieldsFilter.__super__.constructor.call(this, merge(options, {
      fields: fields
    }));
  }

  LinkFieldsFilter.prototype.preprocessRequest = function(request) {
    var data, pipeline, postIncludeLinkedFieldData, processedData, ref2, session, type;
    type = request.type, pipeline = request.pipeline, data = (ref2 = request.data) != null ? ref2 : {}, session = request.session;

    /*
    Pass includedData from the requestProps to the ultimate responseProps.
    IncludedData is removed from 'data' so it isn't writen in this pipeline's record, but instead,
    if autoCreate/vivifiy is true, it is written to its own pipeline and linked in.
    
    postIncludeLinkedFieldData allows us to return the includedData in the response without
    re-reading the data back with additional requests.
     */
    postIncludeLinkedFieldData = null;
    processedData = merge(data);
    return Promise.all(array(this._linkFields, {
      when: function(arg, fieldName) {
        var idFieldName;
        idFieldName = arg.idFieldName;
        return !data[idFieldName] && data[fieldName];
      },
      "with": (function(_this) {
        return function(arg, fieldName, __, linkedFieldData) {
          var autoCreate, idFieldName, pipelineName;
          idFieldName = arg.idFieldName, autoCreate = arg.autoCreate, pipelineName = arg.pipelineName;
          return Promise.then(function() {
            if (linkedFieldData.id) {
              return linkedFieldData;
            } else if (autoCreate) {
              return request.subrequest(pipelineName, "create", {
                data: linkedFieldData
              });
            } else {
              throw new Error("New record-data provided for " + fieldName + ", but autoCreate is not enabled for this field. " + fieldName + ": " + (formattedInspect(linkedFieldData)));
            }
          }).then(function(linkedFieldData) {
            (postIncludeLinkedFieldData || (postIncludeLinkedFieldData = {}))[fieldName] = linkedFieldData;
            processedData[idFieldName] = linkedFieldData.id;
            return delete processedData[fieldName];
          });
        };
      })(this)
    })).then(function() {
      return request["with"]({
        data: processedData,
        props: merge(request.props, postIncludeLinkedFieldData && {
          postIncludeLinkedFieldData: postIncludeLinkedFieldData
        })
      });
    });
  };

  booleanProps = wordsArray("link required include autoCreate");

  LinkFieldsFilter.normalizeLinkFields = function(linkFields) {
    var lf;
    return each(linkFields, lf = {}, function(fieldProps, fieldName) {
      var autoCreate, include, link, props, ref2, required;
      ref2 = normalizeFieldProps(fieldProps), link = ref2.link, include = ref2.include, required = ref2.required, autoCreate = ref2.autoCreate;
      if (link) {
        lf[fieldName] = props = {
          pipelineName: isString(link) ? link : fieldName,
          idFieldName: fieldName + "Id"
        };
        if (autoCreate) {
          props.autoCreate = true;
        }
        if (include) {
          props.include = true;
        }
        if (required) {
          return props.required = true;
        }
      }
    });
  };

  LinkFieldsFilter.prototype.includeLinkedFields = function(response, data) {
    var fieldName, id, idFieldName, include, linkedData, pipelineName, postIncludeLinkedFieldData, promises, ref2, requestData, requestIncludeProp;
    requestData = response.requestData, (ref2 = response.requestProps, postIncludeLinkedFieldData = ref2.postIncludeLinkedFieldData);
    requestIncludeProp = response.rootRequest.props.include !== false && response.requestProps.include !== false;
    linkedData = shallowClone(data);
    promises = (function() {
      var ref3, ref4, results;
      ref3 = this._linkFields;
      results = [];
      for (fieldName in ref3) {
        ref4 = ref3[fieldName], idFieldName = ref4.idFieldName, pipelineName = ref4.pipelineName, include = ref4.include;
        if (include && (id = linkedData[idFieldName])) {
          results.push((function(_this) {
            return function(id, fieldName, idFieldName, pipelineName, include) {
              var attemptGetLinkedField;
              return Promise.then(attemptGetLinkedField = function() {
                var linkData;
                if (linkData = (requestData != null ? requestData[fieldName] : void 0) || (postIncludeLinkedFieldData != null ? postIncludeLinkedFieldData[fieldName] : void 0)) {
                  return merge({
                    id: id
                  }, linkData);
                } else if (requestIncludeProp) {
                  return response.cachedGet(pipelineName, id);
                }
              }).then(function(value) {
                if (value != null) {
                  return linkedData[fieldName] = value;
                }
              })["catch"](function(response) {
                if (response.status !== missing) {
                  log.error("LinkFieldsFilter: error including " + fieldName + ". " + idFieldName + ": " + id + ". pipelineName: " + pipelineName + ". Error: " + response, response.error);
                }
                return null;
              });
            };
          })(this)(id, fieldName, idFieldName, pipelineName, include));
        }
      }
      return results;
    }).call(this);
    return Promise.all(promises).then(function() {
      return linkedData;
    });
  };

  LinkFieldsFilter.before({
    create: function(request) {
      return this.preprocessRequest(request).then((function(_this) {
        return function(request) {
          return _this._validate("validateCreate", request);
        };
      })(this));
    },
    update: function(request) {
      return this.preprocessRequest(request).then((function(_this) {
        return function(request) {
          return _this._validate("validateUpdate", request);
        };
      })(this));
    }
  });

  LinkFieldsFilter.after({
    all: function(response) {
      if (response.type === "delete") {
        return response;
      }
      return response.withTransformedRecords((function(_this) {
        return function(record) {
          return _this.includeLinkedFields(response, record);
        };
      })(this));
    }
  });

  return LinkFieldsFilter;

})(__webpack_require__(129)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Filter, TimestampFilter, Validator, defineModule, log, m, ref, toSeconds,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, Validator = ref.Validator, m = ref.m, toSeconds = ref.toSeconds;

Filter = __webpack_require__(21);

defineModule(module, TimestampFilter = (function(superClass) {
  extend(TimestampFilter, superClass);

  function TimestampFilter() {
    TimestampFilter.__super__.constructor.apply(this, arguments);
    this.group = "outter";
  }

  TimestampFilter.before({
    create: function(request) {
      var now;
      return request.withMergedData(m({
        createdAt: toSeconds(now = Date.now()),
        updatedAt: toSeconds(now)
      }, request.originatedOnServer ? request.data : void 0));
    },
    update: function(request) {
      return request.withMergedData({
        updatedAt: toSeconds(Date.now())
      }, request.originatedOnServer ? request.data : void 0);
    }
  });

  TimestampFilter.fields({
    createdAt: "secondsTimestamp",
    updatedAt: "secondsTimestamp"
  });

  return TimestampFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var AfterEventsFilter, DataUpdatesFilter, LinkFieldsFilter, TimestampFilter, Tools, UniqueIdFilter, UserOwnedFilter, ValidationFilter, Validator, defineModule, hasProperties, isFunction, isString, log, normalizeFieldProps, objectWithout, present, ref;

ref = __webpack_require__(2), present = ref.present, defineModule = ref.defineModule, log = ref.log, isString = ref.isString, isFunction = ref.isFunction, Validator = ref.Validator, hasProperties = ref.hasProperties, objectWithout = ref.objectWithout;

UniqueIdFilter = __webpack_require__(250);

TimestampFilter = __webpack_require__(248);

ValidationFilter = __webpack_require__(129);

LinkFieldsFilter = __webpack_require__(247);

UserOwnedFilter = __webpack_require__(251);

AfterEventsFilter = __webpack_require__(128);

DataUpdatesFilter = __webpack_require__(246);

normalizeFieldProps = Validator.normalizeFieldProps;

defineModule(module, Tools = (function() {
  function Tools() {}


  /*
  TODO: I want to refactor "userOwned":
  
    Instead of:
      userOwned: true
  
    I want to specify the owner-field as:
      user: "owner"
  
    That allows the field-name to be customized, but
    more importantly, it makes it look like all the
    other field defs (consistency).
  
    Last, if we treat it as any other field-declaration keyword, we can do:
      user: "include owner"
   */

  Tools.createDatabaseFilters = function(fields, PipelineClass) {
    var addValidationFilter, id, k, link, linkFields, otherFields, uniqueIdProps, userOwned, v;
    if (fields == null) {
      fields = {};
    }
    id = fields.id, userOwned = fields.userOwned;
    if (userOwned) {
      fields.user = "required link";
      if (isString(userOwned)) {
        log.error("DEPRICATED");
        fields.user = fields.user + " " + userOwned;
      }
      fields = objectWithout(fields, "userOwned");
    }
    if (id) {
      uniqueIdProps = id;
      fields = objectWithout(fields, "id");
    }
    linkFields = {};
    otherFields = {};
    addValidationFilter = false;
    for (k in fields) {
      v = fields[k];
      link = (v = normalizeFieldProps(v)).link;
      if (link) {
        linkFields[k] = v;
        otherFields[k] = "object";
      } else {
        addValidationFilter = true;
        otherFields[k] = v;
      }
    }
    return [
      hasProperties(linkFields) ? new LinkFieldsFilter({
        fields: linkFields
      }) : void 0, addValidationFilter ? new ValidationFilter({
        fields: otherFields,
        exclusive: true
      }) : void 0, new AfterEventsFilter, new DataUpdatesFilter, !(present(PipelineClass != null ? PipelineClass._keyFieldsString : void 0) && PipelineClass._keyFieldsString !== "id") ? new UniqueIdFilter(uniqueIdProps) : void 0, new TimestampFilter, userOwned ? new UserOwnedFilter(userOwned) : void 0
    ];
  };

  return Tools;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Crypto, FieldTypes, Filter, UniqueIdFilter, Uuid, ceil, defineModule, isString, log, randomBase62Character, randomString, ref, secret,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), randomBase62Character = ref.randomBase62Character, ceil = ref.ceil, defineModule = ref.defineModule, log = ref.log, randomString = ref.randomString, isString = ref.isString;

Filter = __webpack_require__(21);

Uuid = __webpack_require__(351);

Crypto = __webpack_require__(337);

FieldTypes = __webpack_require__(33).FieldTypes;

secret = randomString();

defineModule(module, UniqueIdFilter = (function(superClass) {

  /*
  choosing bits:
  
    bitsCalc = (maximumExpectedRecordCount, probabilityOfCollisions) ->
      ceil log(maximumExpectedRecordCount / probabilityOfCollisions) / log 2
  
    maximumExpectedRecordCount = 10 ** 12   # 1 trillion
    probabilityOfCollisions = 10 ** -9      # 1 in a billion (9-sigma)
  
    default = bitsCalc 10 ** 12, 10 ** -9   # == 70
  
  NOTE: probabilityOfCollisions means probabilityOfCollisions when you have
    maximumExpectedRecordCount records. The probabily goes down proportionally
    for smaller record counts.
  
  What if I pick bits too small? Greate news!
  
    With backends that accept strings as IDs (like DynamoDb), you can
    always increase the bits later, as your record-set gets bigger.
  
    The new Ids' length will be different from the old ids, and therefor,
    are guaranteed not to collide with them.
   */
  var log2_62, uuid;

  extend(UniqueIdFilter, superClass);

  log2_62 = Math.log(62) / Math.log(2);

  function UniqueIdFilter(options) {
    UniqueIdFilter.__super__.constructor.apply(this, arguments);
    this.bits = (options != null ? options.bits : void 0) || 70;
    if (!(this.bits <= 256)) {
      throw new Error("too many bits: " + this.bits + ". max = 256");
    }
    this.numChars = ceil(this.bits / log2_62);
    this.group = "outter";
  }

  UniqueIdFilter.uuid = uuid = function() {
    return Uuid.v4();
  };


  /*
  Returns a base-62 string consisting of characters: [a-zA-Z0-9]
   */

  UniqueIdFilter.getter({
    compactUniqueId: function() {
      return Crypto.createHmac('sha256', secret).update(uuid()).digest('base64').slice(0, this.numChars).replace(/[\/+=]/g, randomBase62Character);
    }
  });

  UniqueIdFilter.before({
    create: function(request) {
      return request.withMergedData({
        id: (function() {
          var ref1, ref2;
          if (request.originatedOnServer) {
            return ((ref1 = request.data) != null ? ref1.id : void 0) || this.compactUniqueId;
          } else {
            if ((ref2 = request.data) != null ? ref2.id : void 0) {
              throw new Error("specifying an ID for create is not allowed without request.originatedOnServer");
            }
            return this.compactUniqueId;
          }
        }).call(this)
      });
    }
  });

  UniqueIdFilter.fields({
    id: FieldTypes.id
  });

  return UniqueIdFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Filter, Promise, UserOwnedFilter, Validator, defineModule, each, isPlainObject, isString, log, object, ref, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), log = ref.log, object = ref.object, w = ref.w, defineModule = ref.defineModule, isPlainObject = ref.isPlainObject, isString = ref.isString, each = ref.each, Promise = ref.Promise;

Validator = __webpack_require__(33).Validator;

Filter = __webpack_require__(21);

defineModule(module, UserOwnedFilter = (function(superClass) {
  var expandPossiblyLinkedFields, isOwner, normallyPublicFields, ownerOnlyFilter, ownershipInfo, requireCanSetFields;

  extend(UserOwnedFilter, superClass);

  UserOwnedFilter.isOwner = isOwner = function(request, data) {
    var userId;
    userId = request.session.userId;
    data || (data = request.data);
    return userId && userId === (data != null ? data.userId : void 0);
  };

  UserOwnedFilter.ownershipInfo = ownershipInfo = function(request, data) {
    var userId;
    userId = request.session.userId;
    data || (data = request.data);
    return "(you are " + userId + ", record owner is " + (data != null ? data.userId : void 0) + ")";
  };

  function UserOwnedFilter(options) {
    var ref1;
    UserOwnedFilter.__super__.constructor.apply(this, arguments);
    ref1 = options || {}, this.userUpdatableFields = ref1.userUpdatableFields, this.userCreatableFields = ref1.userCreatableFields, this.publicFields = ref1.publicFields;
    this.group = "outter";
  }

  UserOwnedFilter.getter("userUpdatableFields userCreatableFields publicFields");

  normallyPublicFields = w("id userId createdAt updatedAt");

  expandPossiblyLinkedFields = function(fields) {
    var i, len, name, root, value;
    for (value = i = 0, len = fields.length; i < len; value = ++i) {
      name = fields[value];
      if (!(name.match(/Id$/))) {
        continue;
      }
      root = name.split(/Id$/)[0];
      if (fields[root] == null) {
        fields[root] = value;
      }
    }
    return fields;
  };

  UserOwnedFilter.setter({
    publicFields: function(fieldString) {
      var pfs;
      if (fieldString === true) {
        return this._publicFields = true;
      }
      this._publicFields = pfs = isPlainObject(fieldString) ? fieldString : isString(fieldString) ? object(w(fieldString), {
        "with": function() {
          return true;
        }
      }) : {};
      each(normallyPublicFields, function(field) {
        if (pfs[field] !== false) {
          return pfs[field] = true;
        }
      });
      return expandPossiblyLinkedFields(pfs);
    },
    userUpdatableFields: function(fieldString) {
      return this._userUpdatableFields = expandPossiblyLinkedFields(isPlainObject(fieldString) ? fieldString : isString(fieldString) ? object(w(fieldString), {
        "with": function() {
          return true;
        }
      }) : {});
    },
    userCreatableFields: function(fieldString) {
      this._userCreatableFields = expandPossiblyLinkedFields(isPlainObject(fieldString) ? fieldString : isString(fieldString) ? object(w(fieldString), {
        "with": function() {
          return true;
        }
      }) : {});
      return this._userCreatableFields.userId = true;
    }
  });

  UserOwnedFilter.prototype.requireCanSetFields = requireCanSetFields = function(request, allowedFields) {
    var k, ref1, v;
    if (!request.originatedOnServer) {
      ref1 = request.data;
      for (k in ref1) {
        v = ref1[k];
        if (!allowedFields[k]) {
          return Promise.resolve(request.clientFailureNotAuthorized("not allowed to " + request.type + " field: " + k + ". allowedFields: " + (Object.keys(allowedFields).join(', '))));
        }
      }
    }
    return Promise.resolve(request);
  };

  UserOwnedFilter.before({
    create: function(request) {
      var ref1;
      return request.withMergedData({
        userId: ((ref1 = request.data) != null ? ref1.userId : void 0) || request.session.userId
      }).then(function(requestWithUserId) {
        return requestWithUserId.requireServerOriginOr(isOwner(requestWithUserId), "to create a record you do not own " + (ownershipInfo(request)));
      }).then((function(_this) {
        return function(request) {
          return requireCanSetFields(request, _this.userCreatableFields);
        };
      })(this));
    },
    update: ownerOnlyFilter = function(request) {
      var key, ref1;
      key = request.key;
      return request.requireServerOriginOr(!((ref1 = request.data) != null ? ref1.userId : void 0) || isOwner(request), "to change a record's owner " + (ownershipInfo(request))).then(function() {
        if (request.originatedOnServer) {
          return request;
        } else {
          return request.cachedGet(request.pipelineName, key).then(function(currentRecord) {
            return request.requireServerOriginOr(isOwner(request, currentRecord), "to update a record you do not own " + (ownershipInfo(request)));
          });
        }
      }).then((function(_this) {
        return function(request) {
          return requireCanSetFields(request, _this.userUpdatableFields);
        };
      })(this));
    },
    "delete": ownerOnlyFilter
  });

  UserOwnedFilter.after({
    all: function(response) {
      var allowedFields, userId;
      if (response.originatedOnServer || this.publicFields === true) {
        return response;
      }
      userId = response.session.userId;
      allowedFields = this.publicFields;
      return response.withTransformedRecords({
        when: function(record) {
          return response.pipeline.isRecord(record) && record.userId !== userId;
        },
        "with": function(record) {
          var filteredRecord, keyCount;
          keyCount = 0;
          filteredRecord = object(record, {
            when: function(v, k) {
              return allowedFields[k];
            },
            "with": function(v, k) {
              keyCount++;
              return v;
            }
          });
          if (keyCount > 0) {
            return filteredRecord;
          }
        }
      });
    }
  });

  return UserOwnedFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var Filters,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(41)).addNamespace('Filters', Filters = (function(superClass) {
  extend(Filters, superClass);

  function Filters() {
    return Filters.__super__.constructor.apply(this, arguments);
  }

  return Filters;

})(Neptune.PackageNamespace));


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var array, defineModule, each, formattedInspect, isPlainArray, isPlainObject, isString, log, object, present, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(2), defineModule = ref.defineModule, log = ref.log, present = ref.present, isPlainArray = ref.isPlainArray, isString = ref.isString, isPlainObject = ref.isPlainObject, formattedInspect = ref.formattedInspect, array = ref.array, object = ref.object, each = ref.each;


/*
@primaryKey and @keyFields are synonymous
Usage:

  class MyModel extends KeyFieldsMixin Pipeline # or FluxModel or whatever
     * 1 key
    @primaryKey "foo"
    @keyFields "foo"
    @keyFields ["foo"]

     * 2 keys
    @keyFields "foo/bar"
    @keyFields ["foo", "bar"]

     * 3 keys
    @keyFields "foo/bar/baz"   # compound key with 3 fields
    @keyFields ["foo", "bar', "baz"]

     * Default:
     * @keyFields "id"

Note that order matters. @keyFields is a lists of strings. Forward slash (/) is
used as a delimiter, so it shouldn't be in the names of your key-fields. Ideally
each key field name should match: /[-._a-zA-Z0-9]+/
 */

defineModule(module, function() {
  return function(superClass) {
    var KeyFieldsMixin;
    return KeyFieldsMixin = (function(superClass1) {
      var defaultKeyFieldsString, keyFields;

      extend(KeyFieldsMixin, superClass1);

      function KeyFieldsMixin() {
        return KeyFieldsMixin.__super__.constructor.apply(this, arguments);
      }

      KeyFieldsMixin.getKeyFields = function() {
        return this._keyFields;
      };

      KeyFieldsMixin.getKeyFieldsString = function() {
        return this._keyFieldsString;
      };

      KeyFieldsMixin.primaryKey = keyFields = function(a) {
        if (isString(a)) {
          return this._keyFields = (this._keyFieldsString = a).split("/");
        } else if (isPlainArray(a)) {
          return this._keyFieldsString = (this._keyFields = a).join("/");
        } else {
          throw new Error("invalid value: " + (formattedInspect(a)));
        }
      };

      KeyFieldsMixin.keyFields = keyFields;

      KeyFieldsMixin.getter({
        keyFieldsString: function() {
          return this["class"]._keyFieldsString;
        },
        keyFields: function() {
          return this["class"]._keyFields;
        }
      });

      KeyFieldsMixin.prototype.isRecord = function(data) {
        var j, keyField, len, ref1;
        if (isPlainObject(data)) {
          ref1 = this.keyFields;
          for (j = 0, len = ref1.length; j < len; j++) {
            keyField = ref1[j];
            if (data[keyField] == null) {
              return false;
            }
          }
          return true;
        }
      };

      KeyFieldsMixin.prototype.dataToKeyString = function(a) {
        this.validateKey(a);
        return array(this.keyFields, function(field) {
          return a[field];
        }).join("/");
      };

      KeyFieldsMixin.prototype.toKeyObject = function(a) {
        keyFields = this.keyFields;
        return this.validateKey(isPlainObject(a) ? object(this.keyFields, function(v) {
          return a[v];
        }) : isString(a) ? object(a.split("/"), {
          key: function(v, i) {
            return keyFields[i];
          }
        }) : {});
      };

      KeyFieldsMixin.prototype.dataWithoutKeyFields = function(data) {
        return data && object(data, {
          when: (function(_this) {
            return function(v, k) {
              return !(indexOf.call(_this.keyFields, k) >= 0);
            };
          })(this)
        });
      };

      KeyFieldsMixin.prototype.validateKey = function(key) {
        keyFields = this.keyFields;
        each(keyFields, (function(_this) {
          return function(field) {
            if (!present(key[field])) {
              throw new Error((_this["class"].getName()) + " missing key field(s): " + (formattedInspect({
                missing: field,
                keyFields: keyFields,
                key: key
              })));
            }
          };
        })(this));
        return key;
      };

      KeyFieldsMixin._keyFieldsString = defaultKeyFieldsString = "id";

      KeyFieldsMixin._keyFields = [defaultKeyFieldsString];

      return KeyFieldsMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Filter, Filters, Pipeline, PipelineQuery, PipelineRegistry, Promise, Request, Response, Session, arrayToTruthMap, compactFlatten, config, currentSecond, decapitalize, defineModule, each, escapeRegExp, formattedInspect, inspect, inspectedObjectLiteral, isClass, isFunction, isPlainArray, isPlainObject, isString, log, lowerCamelCase, merge, mergeInto, missing, normalizeFieldProps, object, peek, plainObjectsDeepEq, pushIfNotPresent, ref, ref1, reverseForEach, success, toDate, w,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(1), each = ref.each, object = ref.object, compactFlatten = ref.compactFlatten, BaseObject = ref.BaseObject, reverseForEach = ref.reverseForEach, Promise = ref.Promise, log = ref.log, isPlainObject = ref.isPlainObject, inspect = ref.inspect, isString = ref.isString, isClass = ref.isClass, isFunction = ref.isFunction, inspect = ref.inspect, CommunicationStatus = ref.CommunicationStatus, merge = ref.merge, isPlainArray = ref.isPlainArray, decapitalize = ref.decapitalize, defineModule = ref.defineModule, mergeInto = ref.mergeInto, arrayToTruthMap = ref.arrayToTruthMap, lowerCamelCase = ref.lowerCamelCase, peek = ref.peek, inspectedObjectLiteral = ref.inspectedObjectLiteral, escapeRegExp = ref.escapeRegExp, formattedInspect = ref.formattedInspect, pushIfNotPresent = ref.pushIfNotPresent, w = ref.w, currentSecond = ref.currentSecond, toDate = ref.toDate, plainObjectsDeepEq = ref.plainObjectsDeepEq;

normalizeFieldProps = __webpack_require__(33).normalizeFieldProps;

ref1 = __webpack_require__(19), success = ref1.success, missing = ref1.missing;

Response = __webpack_require__(132);

Request = __webpack_require__(81);

Filter = __webpack_require__(21);

Session = __webpack_require__(133);

config = __webpack_require__(27).config;

Filters = __webpack_require__(80);

PipelineQuery = __webpack_require__(255);

PipelineRegistry = __webpack_require__(130);


/*
TODO:
  Factor out all flux-related stuff into:
  class FluxReadyPipeline extends Pipeline

  DONT put it in Flux/
    WHY? Server-side, we won't include Flux/
 */

defineModule(module, Pipeline = (function(superClass) {
  var instantiateFilter, mostRecentSessionUpdatedAt, noOptions, preprocessFilter;

  extend(Pipeline, superClass);

  Pipeline.register = function() {
    this.singletonClass();
    return PipelineRegistry.register(this);
  };

  Pipeline.abstractClass();

  Pipeline.postCreateConcreteClass = function(arg) {
    var hotReloaded, ref2;
    hotReloaded = arg.hotReloaded;
    if (!hotReloaded) {
      this.register();
    }
    this._defineQueryHandlers();
    this._defineClientHandlerMethods();
    this._initFields();
    if ((ref2 = Neptune.Art.Ery.Flux) != null) {
      ref2.ArtEryFluxModel.createModel(this.getSingleton());
    }
    return Pipeline.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
  };

  Pipeline.instantiateFilter = instantiateFilter = function(filter) {
    if (isClass(filter)) {
      return new filter;
    } else if (isFunction(filter)) {
      return filter(this);
    } else if (filter instanceof Filter) {
      return filter;
    } else if (isPlainObject(filter)) {
      return new Filter(filter);
    } else {
      throw "invalid filter: " + (inspect(filter)) + " " + (filter instanceof Filter);
    }
  };

  Pipeline.getAliases = function() {
    return this._aliases || {};
  };

  Pipeline.addDatabaseFilters = function(options) {
    return this.filter(Filters.createDatabaseFilters(options, this));
  };

  Pipeline.prototype.toKeyString = function(key) {
    if (key == null) {
      return key;
    }
    if (isString(key)) {
      return key;
    } else if (this.dataToKeyString && isPlainObject(key)) {
      return this.dataToKeyString(key);
    } else {
      throw new Error("override toKeyString or dataToKeyString for non-string-keys like: " + (formattedInspect(key)));
    }
  };

  Pipeline.prototype.isRecord = function(data) {
    return data != null ? data.id : void 0;
  };

  Pipeline.extendableProperty({
    queries: {},
    filters: [],
    handlers: {},
    clientApiMethodList: [],
    fields: {},
    fluxModelMixins: [],
    publicRequestTypes: {}
  });

  Pipeline.publicRequestTypes = function(v) {
    return this.extendPublicRequestTypes(object(w(v), function() {
      return true;
    }));
  };


  /*
  @fluxModelMixin adds a mixin to fluxModelMixins
  
  When createing FluxModels for this pipeline (via ArtEryFluxModel.createModel for example),
  both the records model and each query-model will get these mixins.
  
  Example:
    class MyPipeline extends Pipeline
      @fluxModelMixin FluxModelMixinA
      @fluxModelMixin FluxModelMixinB
  
     * this action
    ArtEryFluxModel.defineModelsForAllPipelines()
  
     * defines this model:
    class MyPipeline extends FluxModelMixinB FluxModelMixinA ArtEryFluxModel
   */

  Pipeline.fluxModelMixin = function(mixin) {
    return this.extendFluxModelMixins(mixin);
  };


  /*
  define a single filter OR an array of filters to define.
  
  NOTE: the order of filter definitions matter:
    last-defined filters FIRST in the before-filter sequence
    last-defined filters LAST in the after-filter sequence
  
    Example request processing sequence:
  
      filterDefinedLast.beforeFilter
        filterDefinedSecond.beforeFilter
          filterDefinedFirst.beforeFilter
            handler
          filterDefinedFirst.afterFilter
        filterDefinedSecond.afterFilter
      filterDefinedLast.afterFilter
  
  IN:
    name: "myFilter"                    # only used for debug purposes
    location: "server"/"client"/"both"  # where the filter will be applied
    before: map:
      requestType: (request) ->
        OUT one of these (or a promise returning one of these):
          request
          - the same request if nothing was filtered
          - a new request with the new, filtered values
  
          response in the form of:
          - new Response
          - null        >> request.missing()
          - string      >> request.success data: message: string
          - plainObject >> request.success data: plainObject
          - plainArray  >> request.success data: plainArray
          NOTE, if a response is returned, it shortcircuits the handler and all other
            filters. The response is returned directly to the caller.
  
    after: map:
      requestType: (response) ->
        OUT: same or new response
           NOTE: all after-filters are applied if the handler generated the first response object
           UNLESS there is an error, in which case the error is returned directly.
   */

  Pipeline.filter = function(filter) {
    return this.extendFilters(preprocessFilter(filter));
  };


  /*
  add one or more handlers
  
  IN map:
    requestType: (request) ->
      IN: ArtEry.Request instance
      OUT:
        ArtEry.Response instance
      OR
        plain data which will be wrapped up in an ArtEry.Response instance
  
  @handler and @handlers are aliases.
   */

  Pipeline.handler = Pipeline.extendHandlers;

  Pipeline.handlers = Pipeline.extendHandlers;

  Pipeline.remoteServer = function(_remoteServer) {
    this._remoteServer = _remoteServer;
  };

  Pipeline.apiRoot = function(_apiRoot) {
    this._apiRoot = _apiRoot;
  };

  Pipeline.tableNamePrefix = function(_tableNamePrefix) {
    this._tableNamePrefix = _tableNamePrefix;
  };


  /*
  declare a query - used by ArtEryFlux
  
  IN: map:
    queryName: map:
      class properties for anonymous subclass of ArtEryQueryFluxModel
  
  queryName is used as both the ArtFlux model-name AND the ArtEry request-type:
    Example:
       * invoke query
      myPipeline.myQueryName key: queryKey
  
       * subscribe to Model in FluxComponent
      @subscriptions
        myQueryName: queryKey
   */

  Pipeline.query = function(map) {
    return this.extendQueries(object(map, function(options, queryName) {
      return new PipelineQuery(queryName, options);
    }));
  };


  /*
  aliases
  
  INPUT: zero or more strings or arrays of strings
    - arbitrary nesting of arrays is OK
    - nulls are OK, they are ignored
  OUTPUT: null
  
  NOTE: @aliases can only be called once
  
  example:
    class Post extends Pipeline
      @aliases "chapterPost"
  
  purpose:
    - used by ArtEryFluxComponent to make model aliases
      (see FluxModel.aliases)
   */

  Pipeline.aliases = function() {
    var map;
    this._aliases = each(arguments, map = {}, function(v, k) {
      return map[lowerCamelCase(v)] = true;
    });
    return this;
  };

  function Pipeline(_options) {
    this._options = _options != null ? _options : {};
    this.getPrefixedTableName = bind(this.getPrefixedTableName, this);
    Pipeline.__super__.constructor.apply(this, arguments);
  }

  Pipeline.prototype.getPrefixedTableName = function(tableName) {
    return "" + this.tableNamePrefix + tableName;
  };

  Pipeline.classGetter({
    pipelineName: function() {
      return this._pipelineName || decapitalize(this.getName());
    }
  });

  Pipeline.prototype.getLogName = function(requestType) {
    return requestType + "-handler";
  };

  Pipeline.getter("options", {
    pipelineName: function() {
      return this["class"].getPipelineName();
    },
    tableNamePrefix: function() {
      return this["class"]._tableNamePrefix || config.tableNamePrefix;
    },
    tableName: function() {
      return this.getPrefixedTableName(this.name);
    },
    normalizedFields: function() {
      var k, nf, ref2, v;
      nf = {};
      ref2 = this.fields;
      for (k in ref2) {
        v = ref2[k];
        nf[k] = normalizeFieldProps(v);
      }
      return nf;
    },
    name: function() {
      return this._name || (this._name = this._options.name || decapitalize(this["class"].getName()));
    },
    session: function() {
      return this._session || (this._session = this._options.session || Session.singleton);
    },
    handlerRequestTypesMap: function(into) {
      if (into == null) {
        into = {};
      }
      mergeInto(into, this.handlers);
      return into;
    },
    filterRequestTypesMap: function(into) {
      var filter, i, len, ref2;
      if (into == null) {
        into = {};
      }
      ref2 = this.filters;
      for (i = 0, len = ref2.length; i < len; i++) {
        filter = ref2[i];
        mergeInto(into, filter.beforeFilters);
      }
      return into;
    },
    requestTypesMap: function(into) {
      if (into == null) {
        into = {};
      }
      return this.getHandlerRequestTypesMap(this.getFilterRequestTypesMap(into));
    },
    requestTypes: function() {
      return Object.keys(this.requestTypesMap);
    },
    aliases: function() {
      return Object.keys(this["class"].getAliases());
    },
    inspectedObjects: function() {
      return inspectedObjectLiteral(this.name);
    },
    isRemoteClient: function() {
      return !!this.remoteServer;
    },
    apiRoot: function() {
      return this["class"]._apiRoot || config._apiRoot;
    },
    remoteServer: function() {
      return this["class"]._remoteServer || config.remoteServer;
    },
    location: function() {
      if (this.remoteServer && config.location !== "server") {
        return "client";
      } else {
        return config.location;
      }
    },
    restPath: function() {
      return this._restPath || (this._restPath = "/" + config.apiRoot + "/" + this.name);
    },
    restPathRegex: function() {
      return this._restPathRegex || (this._restPathRegex = RegExp("^" + (escapeRegExp(this.restPath)) + "(?:-([a-z0-9_]+))?(?:\\/([^?]+))?(?=\\?|$)", "i"));
    },
    groupedFilters: function() {
      return this._groupedFilters || (this._groupedFilters = Pipeline.groupFilters(this.filters));
    },
    beforeFilters: function() {
      return this._beforeFilters || (this._beforeFilters = this.groupedFilters.slice().reverse());
    },
    afterFilters: function() {
      return this.groupedFilters;
    },
    status: function() {
      return "OK";
    },
    filterChain: function() {
      return this._filterChain || (this._filterChain = compactFlatten([this, this.groupedFilters]).reverse());
    }
  });

  Pipeline.groupFilters = function(filters) {
    var filter, i, j, l, len, len1, len2, priority, priorityLevels, ref2, sortedFilters;
    priorityLevels = [];
    for (i = 0, len = filters.length; i < len; i++) {
      priority = filters[i].priority;
      pushIfNotPresent(priorityLevels, priority);
    }
    sortedFilters = [];
    ref2 = priorityLevels.sort(function(a, b) {
      return a - b;
    });
    for (j = 0, len1 = ref2.length; j < len1; j++) {
      priorityLevels = ref2[j];
      for (l = 0, len2 = filters.length; l < len2; l++) {
        filter = filters[l];
        if (priorityLevels === filter.priority) {
          sortedFilters.push(filter);
        }
      }
    }
    return sortedFilters;
  };

  Pipeline.prototype.getBeforeFilters = function(request) {
    var filter, i, len, ref2, results;
    ref2 = this.beforeFilters;
    results = [];
    for (i = 0, len = ref2.length; i < len; i++) {
      filter = ref2[i];
      if (filter.getBeforeFilter(request)) {
        results.push(filter);
      }
    }
    return results;
  };

  Pipeline.prototype.getAfterFilters = function(request) {
    var filter, i, len, ref2, results;
    ref2 = this.afterFilters;
    results = [];
    for (i = 0, len = ref2.length; i < len; i++) {
      filter = ref2[i];
      if (filter.getAfterFilter(request)) {
        results.push(filter);
      }
    }
    return results;
  };

  Pipeline.prototype.createRequest = function(type, options) {
    if (isString(options)) {
      options = {
        key: options
      };
    }
    return Promise.resolve(options.session || this.session.loadedDataPromise).then((function(_this) {
      return function(sessionData) {
        return new Request(merge(options, {
          type: type,
          pipeline: _this,
          session: sessionData
        }));
      };
    })(this));
  };

  Pipeline.prototype.getRequestProcessingReport = function(location) {
    if (location == null) {
      location = this.location;
    }
    return object(this.requestTypes, (function(_this) {
      return function(requestType) {
        var filter;
        return compactFlatten([
          (function() {
            var i, len, ref2, results;
            ref2 = this.getBeforeFilters({
              requestType: requestType,
              location: location
            });
            results = [];
            for (i = 0, len = ref2.length; i < len; i++) {
              filter = ref2[i];
              results.push(inspectedObjectLiteral(filter.getName()));
            }
            return results;
          }).call(_this), inspectedObjectLiteral(location === "client" ? "[remote request]" : "[local handler]"), (function() {
            var i, len, ref2, results;
            ref2 = this.getAfterFilters({
              requestType: requestType,
              location: location
            });
            results = [];
            for (i = 0, len = ref2.length; i < len; i++) {
              filter = ref2[i];
              results.push(inspectedObjectLiteral(filter.getName()));
            }
            return results;
          }).call(_this)
        ]);
      };
    })(this));
  };

  Pipeline.getter({
    pipelineReport: function(processingLocation) {
      var out;
      out = {
        tableName: this.tableName,
        fields: object(this.fields, function(fieldProps) {
          return each(Object.keys(fieldProps).sort(), out = {}, function(k) {
            var v;
            v = fieldProps[k];
            if (!isFunction(v)) {
              return out[k] = v;
            }
          });
        })
      };
      if (processingLocation) {
        out[processingLocation + "Processing"] = this.getRequestProcessingReport("client");
      } else {
        out.clientSideRequestProcessing = this.getRequestProcessingReport("client");
        out.serverSideRequestProcessing = this.getRequestProcessingReport("server");
        out.serverlessDevelopmentRequestProcessing = this.getRequestProcessingReport("both");
      }
      return out;
    },
    apiReport: function(options) {
      var publicOnly, server;
      if (options == null) {
        options = {};
      }
      server = options.server, publicOnly = options.publicOnly;
      return object(this.requestTypes, {
        when: publicOnly && (function(_this) {
          return function(type) {
            return _this.getPublicRequestTypes()[type];
          };
        })(this),
        "with": (function(_this) {
          return function(type) {
            var method, obj, ref2, url;
            ref2 = Request.getRestClientParamsForArtEryRequest({
              server: _this.remoteServer || server,
              type: type,
              restPath: _this.restPath
            }), method = ref2.method, url = ref2.url;
            return (
              obj = {},
              obj["" + (method.toLocaleUpperCase())] = url,
              obj
            );
          };
        })(this)
      });
    }
  });

  Pipeline.prototype.handleRequest = function(request) {
    if (request.isResponse) {
      throw new Error("HARD DEPRICATED");
    }
    if (this.location === "client" && this.remoteServer) {
      return request.sendRemoteRequest(this.remoteServer);
    } else {
      return this.applyHandler(request, this.handlers[request.type]).then((function(_this) {
        return function(response) {
          if (!response.isResponse) {
            return response.failure(_this.pipelineName + "." + request.type + " request was not handled");
          } else {
            return response;
          }
        };
      })(this));
    }
  };

  preprocessFilter = function(filter) {
    var f, i, len, results;
    if (isPlainArray(filter)) {
      results = [];
      for (i = 0, len = filter.length; i < len; i++) {
        f = filter[i];
        if (f) {
          results.push(instantiateFilter(f));
        }
      }
      return results;
    } else {
      return instantiateFilter(filter);
    }
  };


  /*
  query handler-functions: (request) -> response or any other value allowed for handlers
   */

  Pipeline._defineQueryHandlers = function() {
    var k, pipelineQuery, ref2, results;
    ref2 = this.getQueries();
    results = [];
    for (k in ref2) {
      pipelineQuery = ref2[k];
      if (!(pipelineQuery instanceof PipelineQuery)) {
        throw new Error("pipelineQuery not a PipelineQuery");
      }
      if (!isFunction(pipelineQuery.query)) {
        throw new Error("pipelineQuery has no query");
      }
      results.push(this.extendHandlers(k, pipelineQuery.query));
    }
    return results;
  };

  Pipeline.prototype._normalizeRequest = function(request) {
    if (isPlainObject(request)) {
      return new Request(merge(request, {
        pipeline: this
      }));
    } else {
      return request;
    }
  };

  Pipeline.prototype._processRequest = function(request) {
    var startTime;
    startTime = currentSecond();
    return this.filterChain[0].handleRequest(request, this.filterChain, 0).then(function(response) {
      if (!response.isResponse) {
        log.error({
          "not response!": response
        });
      }
      return response;
    });
  };


  /*
  IN:
    type: request type string
    options:
       * see: response.toPromise options
       * (copied from toPromise)
      returnNullIfMissing: true [default: false]
        if status == missing
          if returnNullIfMissing
            promise.resolve null
          else
            promise.reject new RequestError
  
      returnResponse: true [default: false]
      returnResponseObject: true (alias)
        if true, the response object is returned, otherwise, just the data field is returned.
  
       * see: new Request options
      #...
  
  OUT: response.toPromise options
    (SEE Response#toPromise for valid options)
  
    With no options, this means:
    promise.then (response.data) ->
       * status == success
  
    promise.catch (errorWithInfo) ->
      {response} = errorWithInfo.info
       * status != success
   */

  noOptions = {};

  Pipeline.prototype._processClientRequest = function(type, options) {
    var requestStartTime;
    if (options == null) {
      options = noOptions;
    }
    if (isString(options)) {
      options = {
        key: options
      };
    }
    requestStartTime = currentSecond();
    return this.createRequest(type, options).then((function(_this) {
      return function(request) {
        return _this._processRequest(request);
      };
    })(this)).then((function(_this) {
      return function(response) {
        return _this._processResponseSession(response, requestStartTime);
      };
    })(this)).then((function(_this) {
      return function(response) {
        return response.toPromise(options);
      };
    })(this));
  };


  /*
  mostRecentSessionUpdatedAt ensures we don't update the session out of order
  RULE: the current session reflects the response from the most recently INITIATED request.
  In other words, if a request stalls, takes a long time to update, and comes back with
  a session update AFTER some other session updates from more recently-initiated requests,
  that session-update is ignored.
  keywords: update session
  
  ALTERNATIVES CONSIDERED
  - could use a server-side timestamp to ensure no out-of-order session updates
    SUBOPTION A: order by time server RECEIVED the request
    SUBOPTION B: order by time server COMPLETED the request
    I decided this made less sense. It's really the order the user initiated
    events that matters. If a user initiates a log-in or log-out request AFTER
    some other slow request, the log-in/log-out should take precidence.
    Extreme example: user logs in, which takes forever, then initiates a log-out,
      if the log-in returns AFTER the log-out, it should be ignored.
   */

  mostRecentSessionUpdatedAt = 0;

  Pipeline.prototype._processResponseSession = function(response, requestStartTime) {
    var currentSession, message, responseSession;
    responseSession = response.responseSession;
    if (responseSession) {
      currentSession = this.session.data;
      message = requestStartTime > mostRecentSessionUpdatedAt ? (mostRecentSessionUpdatedAt = requestStartTime, this.session.data = responseSession, "updated") : "out-of-order update blocked";
    }
    return response;
  };

  Pipeline._defineClientRequestMethod = function(requestType) {
    var base;
    if (indexOf.call(this.getClientApiMethodList(), requestType) < 0) {
      this.extendClientApiMethodList(requestType);
    }
    return (base = this.prototype)[requestType] || (base[requestType] = function(options) {
      return this._processClientRequest(requestType, options);
    });
  };

  Pipeline._defineClientHandlerMethods = function() {
    var handler, name, ref2, results;
    ref2 = this.getHandlers();
    results = [];
    for (name in ref2) {
      handler = ref2[name];
      results.push(this._defineClientRequestMethod(name));
    }
    return results;
  };

  Pipeline._initFields = function() {
    var filter, i, len, ref2, results;
    ref2 = this.getFilters();
    results = [];
    for (i = 0, len = ref2.length; i < len; i++) {
      filter = ref2[i];
      results.push(this.extendFields(filter.fields));
    }
    return results;
  };

  return Pipeline;

})(__webpack_require__(131)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, PipelineQuery, defineModule, formattedInspect, isFunction, isPlainObject, isString, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), defineModule = ref.defineModule, isPlainObject = ref.isPlainObject, log = ref.log, BaseObject = ref.BaseObject, formattedInspect = ref.formattedInspect, isString = ref.isString, isFunction = ref.isFunction;

defineModule(module, PipelineQuery = (function(superClass) {
  extend(PipelineQuery, superClass);

  function PipelineQuery(queryName, options1) {
    var k, ref1, v;
    this.queryName = queryName;
    this.options = options1;
    if (isFunction(this.options)) {
      this.options = {
        query: this.options
      };
    }
    ref1 = this.options;
    for (k in ref1) {
      v = ref1[k];
      this[k] = v;
    }
    if (!(isFunction(this.query) && this.query.length > 0)) {
      throw new Error("query handler-function with at least one argument required. options: " + (formattedInspect(options)));
    }
  }

  PipelineQuery.getter({
    name: function() {
      return this.queryName;
    }
  });

  PipelineQuery.prototype.toKeyString = function(v) {
    if (v == null) {
      return null;
    }
    if (isPlainObject(v) && this.dataToKeyString) {
      return this.dataToKeyString(v);
    } else if (isString(v)) {
      return v;
    } else {
      throw new Error("PipelineQuery: invalid key: " + (formattedInspect(v)));
    }
  };

  return PipelineQuery;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var EpochClass, EventEpoch, defineModule, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log;

EpochClass = __webpack_require__(127).EpochClass;

defineModule(module, EventEpoch = (function(superClass) {
  extend(EventEpoch, superClass);

  function EventEpoch() {
    return EventEpoch.__super__.constructor.apply(this, arguments);
  }

  EventEpoch.singletonClass();

  EventEpoch.prototype.queue = function(event) {
    return this.queueItem(event);
  };

  EventEpoch.prototype.logEvent = function(name, id) {};

  return EventEpoch;

})(EpochClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {
/*

TODO:
  handlEvent alternate signature:
    (type, functionReturningEventElement) ->

  The function would only be invoked if there are actually event handlers for the specified type.
 */
var BaseClass, Event, EventManager, Log, arrayWith, clone, defineModule, inspect, isFunction, nextTick, rawErrorLog, ref, throwErrorOutOfStack,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, Log = ref.Log, nextTick = ref.nextTick, isFunction = ref.isFunction, inspect = ref.inspect, clone = ref.clone, arrayWith = ref.arrayWith, throwErrorOutOfStack = ref.throwErrorOutOfStack;

BaseClass = __webpack_require__(6).BaseClass;

Event = __webpack_require__(134);

rawErrorLog = Log.rawErrorLog;

defineModule(module, EventManager = (function(superClass) {
  extend(EventManager, superClass);

  function EventManager(parent) {
    this.parent = parent;
    this.eventHandlers = {};
  }

  EventManager.prototype.hasHandler = function(type) {
    var handlers;
    return !!((handlers = this.eventHandlers[type]) && handlers.length > 0);
  };

  EventManager.prototype.on = function(handlerMap) {
    var action, results, type;
    results = [];
    for (type in handlerMap) {
      action = handlerMap[type];
      if (!(action)) {
        continue;
      }
      if (!isFunction(action)) {
        throw new Error("EventManager: action is not a function for " + (inspect(type)) + " event handler. (action: " + (inspect(action)) + ", parent: " + (inspect(this.parent)) + ")");
      }
      results.push(this.eventHandlers[type] = arrayWith(this.eventHandlers[type], {
        action: action,
        oneTime: false
      }));
    }
    return results;
  };

  EventManager.prototype.removeListeners = function(handlerMap) {
    var action, beforeCount, count, handler, handlers, type;
    count = 0;
    for (type in handlerMap) {
      action = handlerMap[type];
      if (!(handlers = this.eventHandlers[type])) {
        continue;
      }
      beforeCount = handlers.length;
      this.eventHandlers[type] = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = handlers.length; i < len; i++) {
          handler = handlers[i];
          if (handler.action !== action) {
            results.push(handler);
          }
        }
        return results;
      })();
      count = beforeCount - this.eventHandlers[type].length;
    }
    return count;
  };

  EventManager.prototype.onNext = function(handlerMap) {
    var action, base, results, type;
    results = [];
    for (type in handlerMap) {
      action = handlerMap[type];
      if ((base = this.eventHandlers)[type] == null) {
        base[type] = [];
      }
      results.push(this.eventHandlers[type].push({
        action: action,
        oneTime: true
      }));
    }
    return results;
  };

  EventManager.prototype.countOneTimeHandlersFor = function(eventType) {
    var count, handler, handlers, i, len;
    count = 0;
    if (handlers = this.eventHandlers[eventType]) {
      for (i = 0, len = handlers.length; i < len; i++) {
        handler = handlers[i];
        if (handler.oneTime) {
          count++;
        }
      }
    }
    return count;
  };

  EventManager.prototype.handleEvent = function(event) {
    if (typeof event === "string") {
      event = new Event(event);
    }
    return this.sendToHandlers(event.type, event);
  };

  EventManager.prototype.handleEvents = function(events) {
    var event, i, len, results;
    results = [];
    for (i = 0, len = events.length; i < len; i++) {
      event = events[i];
      results.push(this.handleEvent(event));
    }
    return results;
  };

  EventManager.prototype.sendToHandlers = function(eventType, event) {
    var action, error, firedOneTimeHandler, handler, handlers, i, len;
    handlers = this.eventHandlers[eventType];
    if (!(handlers && handlers.length > 0)) {
      return;
    }
    firedOneTimeHandler = false;
    for (i = 0, len = handlers.length; i < len; i++) {
      handler = handlers[i];
      try {
        if (handler.oneTime) {
          handler.remove = firedOneTimeHandler = true;
        }
        action = handler.action;
        action(event);
      } catch (error1) {
        error = error1;
        this.handleErrorInHandler(handler, event, error);
      }
    }
    if (firedOneTimeHandler) {
      return this.eventHandlers[event.type] = (function() {
        var j, len1, ref1, results;
        ref1 = this.eventHandlers[eventType];
        results = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          handler = ref1[j];
          if (!handler.remove) {
            results.push(handler);
          }
        }
        return results;
      }).call(this);
    }
  };

  EventManager.prototype.handleErrorInHandler = function(handler, event, error) {
    if (event.type === "eventException") {
      rawErrorLog("exception in eventException handler.\nEvent:" + (inspect(event, 1)) + ".\n\nError:\n" + error.stack);
      return throwErrorOutOfStack(error);
    } else if (this.eventHandlers["eventException"]) {
      return this.handleEvent(new Event("eventException", {
        event: clone(event),
        exception: error,
        handler: handler
      }));
    } else {
      rawErrorLog("exception in handler AND no eventException handler. Error:");
      rawErrorLog(error);
      rawErrorLog("Event: " + (inspect(event, 1)));
      rawErrorLog("Stack:\n" + error.stack);
      return throwErrorOutOfStack(error);
    }
  };

  return EventManager;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Event, defineModule, eventEpoch, inspect, isFunction, isPlainObject, isString, log, ref, throwErrorOutOfStack,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, isString = ref.isString, isFunction = ref.isFunction, log = ref.log, isPlainObject = ref.isPlainObject, inspect = ref.inspect, throwErrorOutOfStack = ref.throwErrorOutOfStack;

Event = __webpack_require__(134);

eventEpoch = __webpack_require__(256).eventEpoch;


/*
to be used as a mixin via BaseObject's @include method

If this class is included directly, you must also implement the methods
  listed in "TO IMPLEMENT" below.
 */

defineModule(module, function() {
  return function(superClass) {
    var EventedBaseMixin;
    return EventedBaseMixin = (function(superClass1) {
      var typeFromEventOrType;

      extend(EventedBaseMixin, superClass1);

      function EventedBaseMixin() {
        return EventedBaseMixin.__super__.constructor.apply(this, arguments);
      }

      EventedBaseMixin.typeFromEventOrType = typeFromEventOrType = function(eventOrType) {
        return eventOrType && (eventOrType.type || eventOrType);
      };


      /*
      EFFECT: Queues an event to be handled next eventEpoch
      IN:
        eventOrType can be:
         * an instanceof Event or
         * a string representing the "type" of the event
            (a new Event will be created)
      
        eventPropertiesOrCreator can be:
         * null: only if eventOrType is an instanceof Event
         * Object: properties passed into: new Event eventOrType, eventPropertiesOrCreator
         * Function: returns null (indicating a noop) or a new instanceof Event
      
      OUT:
        true:   The event was queued.
        false:  There is no handler for the event. The event was ignored (discarded).
       */

      EventedBaseMixin.prototype.queueEvent = function(eventOrType, eventPropertiesOrCreator) {
        var eventType;
        eventType = typeFromEventOrType(eventOrType);
        if (eventType && this._hasEventHandler(eventType)) {
          eventEpoch.queue((function(_this) {
            return function() {
              return _this.handleEvent(eventOrType, eventPropertiesOrCreator);
            };
          })(this));
          return true;
        } else {
          return false;
        }
      };


      /*
      EFFECT:
        If there is no handler for the specified event-type:
          returns immediately without further processing.
        else
          event is normalized and handled immediately
      
      IN: SEE: normalizeEvent
      
      OUT: true if the event was actually handled
      
      IMPORTANT: This should only be called during an eventEpoch.
        This means:
          Usually, just don't call this directly. Use @queueEvent.
          If you need to call this directly, only do it from within an event handler.
        Examples reasons to call directly:
          - to do custom event routing
          - send a new event triggered from the first
       */

      EventedBaseMixin.prototype.handleEvent = function(eventOrType, eventPropertiesOrCreator) {
        var e, event, eventType;
        eventType = typeFromEventOrType(eventOrType);
        if (!(eventType && this._hasEventHandler(eventType) && (event = this.normalizeEvent(eventOrType, eventPropertiesOrCreator)))) {
          return false;
        }
        event.target = this;
        try {
          this._sendToEventHandler(event);
        } catch (error1) {
          e = error1;
          this._handleErrorInHandler(event, "unknown", e);
        }
        event.target = null;
        return true;
      };


      /*
      IN:
        (event)
          event: Event instance
      
        OR
      
        (eventType, eventPropertiesOrCreator)
          eventType: string
      
          eventPropertiesOrCreator:
            function, invoked immediately:
              () ->
                OUT:
                  event instance
                  OR
                  plain object - passed to Event constructor
            OR
              plain object - passed to Event constructor
            OR
              null
      
      OUT: Event instance or null
       */

      EventedBaseMixin.prototype.normalizeEvent = function(eventOrType, eventPropertiesOrCreator) {
        var e, eventCreator, eventType;
        if (eventOrType instanceof Event) {
          return eventOrType;
        } else {
          if (!isString(eventType = eventOrType)) {
            throw new Error("expected event or event-type-string");
          }
          if (isFunction(eventCreator = eventPropertiesOrCreator)) {
            e = eventCreator();
            switch (false) {
              case !(e instanceof Event):
                return e;
              case !isPlainObject(e):
                return new Event(eventType, e);
              case e == null:
                throw new Error("expecting event or plain-object");
                break;
              default:
                return null;
            }
          } else {
            return new Event(eventType, eventPropertiesOrCreator);
          }
        }
      };


      /*
      inputs: eventType is a string
      outputs: true if there is a handler for the specified type
       */

      EventedBaseMixin.prototype._hasEventHandler = function(eventType) {
        throw new Error("must implement");
      };


      /*
      inputs: an Event object with event.target set to @
      output: ignored
      
      - Called exclusively from handleEvent. Don't call manually.
      - This is where the event handler is actually called.
      - Only called during an eventEpoch.
      - Only called if @_hasEventHandler returned true for event.type
       */

      EventedBaseMixin.prototype._sendToEventHandler = function(event) {
        throw new Error("must implement");
      };

      EventedBaseMixin.prototype._handleErrorInHandler = function(event, handler, error) {
        console.log("EventedObjectBase: exception in handler. Error:", error);
        console.log("Event: " + (inspect(event, 1)));
        console.log("Handler:", handler);
        console.log("Stack:", error.stack);
        return throwErrorOutOfStack(error);
      };

      return EventedBaseMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var EventManager, EventedBaseMixin, defineModule, isFunction, isPlainObject, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, isFunction = ref.isFunction, log = ref.log, isPlainObject = ref.isPlainObject;

EventManager = __webpack_require__(257);

EventedBaseMixin = __webpack_require__(258);

defineModule(module, function() {
  return function(superClass) {
    var EventedMixin;
    return EventedMixin = (function(superClass1) {
      extend(EventedMixin, superClass1);

      function EventedMixin() {
        EventedMixin.__super__.constructor.apply(this, arguments);
        this._eventManager = null;
      }

      EventedMixin.getter({
        eventManager: function() {
          return this._eventManager || (this._eventManager = new EventManager(this));
        }
      });

      EventedMixin.prototype.on = function(handlerMap) {
        return this.eventManager.on(this.preprocessEventHandlers(handlerMap));
      };

      EventedMixin.prototype.onNext = function(handlerMap) {
        return this.eventManager.onNext(handlerMap);
      };

      EventedMixin.prototype.clearEventHandlers = function() {
        return this._eventManager = null;
      };

      EventedMixin.prototype.removeListeners = function(handlerMap) {
        var ref1;
        return (ref1 = this._eventManager) != null ? ref1.removeListeners(handlerMap) : void 0;
      };

      EventedMixin.prototype.preprocessEventHandlers = function(handlerMap) {
        return handlerMap;
      };

      EventedMixin.prototype._sendToEventHandler = function(event) {
        var ref1;
        return (ref1 = this._eventManager) != null ? ref1.handleEvent(event) : void 0;
      };

      EventedMixin.prototype._hasEventHandler = function(eventType) {
        var ref1;
        return (ref1 = this._eventManager) != null ? ref1.hasHandler(eventType) : void 0;
      };

      return EventedMixin;

    })(EventedBaseMixin(superClass));
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

var Events,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(456)).addNamespace('Events', Events = (function(superClass) {
  extend(Events, superClass);

  function Events() {
    return Events.__super__.constructor.apply(this, arguments);
  }

  Events.version = __webpack_require__(592).version;

  return Events;

})(Neptune.PackageNamespace));


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, Component, FluxComponent, FluxCore, FluxSubscriptionsMixin, Foundation, ModelRegistry, Validator, compactFlatten, createComponentFactory, defineModule, formattedInspect, globalCount, inspect, isFunction, isPlainObject, isString, log, mergeInfo, nextTick, pending, ref, rubyFalse, rubyTrue, success, time,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

FluxCore = __webpack_require__(84);

ref = Neptune.Art.React, Component = ref.Component, createComponentFactory = ref.createComponentFactory;

defineModule = Foundation.defineModule, BaseObject = Foundation.BaseObject, nextTick = Foundation.nextTick, mergeInfo = Foundation.mergeInfo, log = Foundation.log, isPlainObject = Foundation.isPlainObject, isString = Foundation.isString, isFunction = Foundation.isFunction, inspect = Foundation.inspect, time = Foundation.time, globalCount = Foundation.globalCount, rubyTrue = Foundation.rubyTrue, rubyFalse = Foundation.rubyFalse, compactFlatten = Foundation.compactFlatten, Validator = Foundation.Validator, formattedInspect = Foundation.formattedInspect, defineModule = Foundation.defineModule, CommunicationStatus = Foundation.CommunicationStatus;

ModelRegistry = FluxCore.ModelRegistry, FluxSubscriptionsMixin = FluxCore.FluxSubscriptionsMixin;

pending = CommunicationStatus.pending, success = CommunicationStatus.success;


/*
FluxComponent

Declarative (automatic) Flux Subscription support:
- @subscriptions declaration method

TODO: _prepareSubscription should be triggered via createWithPostCreate rather than with each component creation
 */

defineModule(module, FluxComponent = (function(superClass) {
  var normalizeSubscriptionOptions, subscriptionValidator;

  extend(FluxComponent, superClass);

  FluxComponent.abstractClass();

  FluxComponent.prototype._componentDidHotReload = function() {
    this.unsubscribeAll();
    this._updateAllSubscriptions();
    return FluxComponent.__super__._componentDidHotReload.apply(this, arguments);
  };

  FluxComponent.postCreateConcreteClass = function(arg1) {
    var hotReloaded;
    hotReloaded = arg1.hotReloaded;
    if (this.prototype.subscriptions) {
      this.subscriptions(this.prototype.subscriptions);
    }
    this._subscriptionsPrepared = false;
    if (hotReloaded) {
      this._prepareSubscriptions();
    }
    return FluxComponent.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
  };

  function FluxComponent() {
    FluxComponent.__super__.constructor.apply(this, arguments);
    this["class"]._prepareSubscriptions();
  }

  FluxComponent.subscriptions = function() {
    var arg, fn, fn1, i, j, len, len1, ref1, ref2, stateField, subscriptionMap, subscriptionName, subscriptionNames, value;
    ref1 = compactFlatten(arguments);
    for (i = 0, len = ref1.length; i < len; i++) {
      arg = ref1[i];
      if (isPlainObject(subscriptionMap = arg)) {
        fn = (function(_this) {
          return function(stateField, value) {
            return _this._addSubscription(stateField, value);
          };
        })(this);
        for (stateField in subscriptionMap) {
          value = subscriptionMap[stateField];
          fn(stateField, value);
        }
      } else if (isString(subscriptionNames = arg)) {
        ref2 = subscriptionNames.match(/[_a-z][._a-z0-9]*/gi);
        fn1 = (function(_this) {
          return function(subscriptionName) {
            var _, matches, modelName, subscriptionNameId;
            if (matches = subscriptionName.match(/([_a-z0-9]+)\.([_a-z0-9]+)/i)) {
              _ = matches[0], modelName = matches[1], stateField = matches[2];
              return _this._addSubscription(stateField, {
                model: modelName
              });
            } else {
              subscriptionNameId = subscriptionName + "Id";
              return _this._addSubscription(subscriptionName, {
                key: function(props) {
                  var ref3;
                  return ((ref3 = props[subscriptionName]) != null ? ref3.id : void 0) || props[subscriptionNameId];
                }
              });
            }
          };
        })(this);
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          subscriptionName = ref2[j];
          fn1(subscriptionName);
        }
      }
    }
    return null;
  };

  FluxComponent.prototype._preprocessProps = function(newProps) {
    this._updateAllSubscriptions(newProps = FluxComponent.__super__._preprocessProps.apply(this, arguments));
    return newProps;
  };

  FluxComponent.prototype.componentWillUnmount = function() {
    FluxComponent.__super__.componentWillUnmount.apply(this, arguments);
    return this.unsubscribeAll();
  };

  FluxComponent.extendableProperty({
    subscriptionProperties: {}
  });

  subscriptionValidator = new Validator({
    stateField: "present string",
    model: {
      required: {
        validate: function(v) {
          return isFunction(v) || isString(v);
        }
      }
    },
    key: {
      required: {
        validate: function(v) {
          return v !== "undefined";
        }
      }
    }
  });

  FluxComponent._normalizeSubscriptionOptions = normalizeSubscriptionOptions = function(stateField, subscriptionOptions) {
    var key, model;
    if (isPlainObject(subscriptionOptions)) {
      key = subscriptionOptions.key, model = subscriptionOptions.model;
      return {
        stateField: stateField,
        model: model || stateField,
        key: subscriptionOptions.hasOwnProperty("key") ? key : stateField
      };
    } else {
      return {
        stateField: stateField,
        model: stateField,
        key: subscriptionOptions
      };
    }
  };

  FluxComponent._addSubscription = function(stateField, subscriptionOptions) {
    var existingGetters, failureInfoField, progressField, statusField;
    subscriptionOptions = normalizeSubscriptionOptions(stateField, subscriptionOptions);
    subscriptionValidator.validate(subscriptionOptions);
    if (this.getSubscriptionProperties()[stateField]) {
      throw new Error("subscription already defined for: " + (formattedInspect({
        stateField: stateField
      })));
    }
    this.extendSubscriptionProperties(stateField, subscriptionOptions);
    existingGetters = /element/;
    if (!stateField.match(existingGetters)) {
      this.addGetter(stateField, function() {
        return this.state[stateField];
      });
      this.addGetter((statusField = stateField + "Status"), function() {
        return this.state[statusField];
      });
      this.addGetter((progressField = stateField + "Progress"), function() {
        return this.state[progressField];
      });
      return this.addGetter((failureInfoField = stateField + "FailureInfo"), function() {
        return this.state[failureInfoField];
      });
    }
  };

  FluxComponent._prepareSubscription = function(subscription) {
    var error, key, model, modelName, stateField;
    stateField = subscription.stateField, model = subscription.model, key = subscription.key;
    if (!model) {
      throw new Error("no model specified in subscription: " + (inspect({
        stateField: stateField,
        model: model,
        "class": this.name,
        subscription: subscription
      })));
    }
    if (isString(model)) {
      modelName = model;
      model = ModelRegistry.models[modelName];
      if (!model) {
        console.error(error = (this.getName()) + "::subscriptions() model '" + modelName + "' not registered (component = " + (this.getNamespacePath()) + ")");
        throw new Error(error);
      }
    }
    subscription.model = model;
    return subscription.keyFunction = isFunction(key) ? key : function() {
      return key;
    };
  };

  FluxComponent._prepareSubscriptions = function() {
    var ref1, results, stateField, subscription;
    if (this._subscriptionsPrepared) {
      return;
    }
    this._subscriptionsPrepared = true;
    ref1 = this.getSubscriptionProperties();
    results = [];
    for (stateField in ref1) {
      subscription = ref1[stateField];
      results.push(this._prepareSubscription(subscription));
    }
    return results;
  };

  FluxComponent.prototype._toFluxKey = function(stateField, key, model, props) {
    var ref1;
    if (key == null) {
      key = (ref1 = props[stateField]) != null ? ref1.id : void 0;
    }
    if (key != null) {
      return model.toKeyString(key);
    } else {
      return null;
    }
  };

  FluxComponent.prototype._updateSubscription = function(stateField, key, model, props) {
    var initialData;
    return this.subscribe(stateField, model.modelName, key, {
      stateField: stateField,
      initialFluxRecord: (initialData = props[stateField]) ? {
        status: success,
        data: initialData
      } : void 0
    });
  };

  FluxComponent.prototype._updateAllSubscriptions = function(props) {
    var error, key, keyFunction, model, ref1, stateField, subscriptionProps;
    if (props == null) {
      props = this.props;
    }
    ref1 = this["class"].getSubscriptionProperties();
    for (stateField in ref1) {
      subscriptionProps = ref1[stateField];
      keyFunction = subscriptionProps.keyFunction, model = subscriptionProps.model;
      model = (function() {
        try {
          if (isFunction(model)) {
            return model(props);
          } else {
            return model;
          }
        } catch (error1) {
          error = error1;
          log({
            "UpdateSubscription modelFunction error": {
              FluxComponent: this,
              stateField: stateField,
              model: model,
              subscriptionProps: subscriptionProps,
              error: error
            }
          });
          return null;
        }
      }).call(this);
      if (isString(model)) {
        if (!(model = this.models[model])) {
          console.error("Could not find model named " + (inspect(model)) + " for subscription in component " + this.inspectedName);
        }
      }
      if (model) {
        key = (function() {
          try {
            return keyFunction(props);
          } catch (error1) {
            error = error1;
            log({
              "UpdateSubscription keyFunction error": {
                FluxComponent: this,
                stateField: stateField,
                model: model,
                subscriptionProps: subscriptionProps,
                error: error
              }
            });
            return null;
          }
        }).call(this);
        this._updateSubscription(stateField, key, model, props);
      }
    }
    return null;
  };

  return FluxComponent;

})(FluxSubscriptionsMixin(Component)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var React,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(56)).addNamespace('React', React = (function(superClass) {
  extend(React, superClass);

  function React() {
    return React.__super__.constructor.apply(this, arguments);
  }

  return React;

})(Neptune.PackageNamespace));


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, Epoch, FluxEntry, Unique, _fluxStore, clone, defineModule, failure, floatEq, getFluxStore, inspect, isFailure, isPlainObject, isSuccess, log, merge, min, networkFailure, pending, propsEq, pushIfNotPresent, ref, ref1, removeFirstMatch, serverFailure, shallowClone, success, timeoutAt, toSeconds,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), log = ref.log, merge = ref.merge, removeFirstMatch = ref.removeFirstMatch, pushIfNotPresent = ref.pushIfNotPresent, Epoch = ref.Epoch, shallowClone = ref.shallowClone, inspect = ref.inspect, Unique = ref.Unique, clone = ref.clone, isPlainObject = ref.isPlainObject, propsEq = ref.propsEq, defineModule = ref.defineModule, timeoutAt = ref.timeoutAt, min = ref.min, toSeconds = ref.toSeconds, floatEq = ref.floatEq;

BaseObject = __webpack_require__(6).BaseObject;

ref1 = __webpack_require__(19), pending = ref1.pending, success = ref1.success, failure = ref1.failure, isSuccess = ref1.isSuccess, isFailure = ref1.isFailure, networkFailure = ref1.networkFailure, serverFailure = ref1.serverFailure;

_fluxStore = null;

getFluxStore = function() {
  return _fluxStore != null ? _fluxStore : _fluxStore = Neptune.Art.Flux.fluxStore;
};

defineModule(module, FluxEntry = (function(superClass) {
  var memoryLeakFreeReloader, retryExponent, warnCantSetField, warnUnsettableFields;

  extend(FluxEntry, superClass);

  FluxEntry.warnCantSetField = warnCantSetField = function(newFluxRecord, oldFluxRecord, field) {
    var newValue, oldValue;
    newValue = newFluxRecord[field];
    oldValue = oldFluxRecord != null ? oldFluxRecord[field] : void 0;
    if (newFluxRecord.hasOwnProperty(field) && newValue !== oldValue) {
      return console.warn(FluxEntry.namespacePath + ": Do not put/post the '" + field + "' field (new value == " + (inspect(newValue)) + ", old value == " + (inspect(oldValue)) + "). Ignored.");
    }
  };

  FluxEntry.warnUnsettableFields = warnUnsettableFields = function(newFluxRecord, oldFluxRecord) {
    warnCantSetField(newFluxRecord, oldFluxRecord, "key");
    return warnCantSetField(newFluxRecord, oldFluxRecord, "modelName");
  };

  function FluxEntry(modelName, key) {
    FluxEntry.__super__.constructor.apply(this, arguments);
    this._model = Neptune.Art.Flux.models[modelName];
    this._autoReload = this._model.autoReloadEnabled;
    this._updatedAt = this._createdAt = toSeconds();
    this._reloadAt = this._lastSuccessfulLoadAt = null;
    this._tryCount = 0;
    this._fluxRecord = {
      key: key,
      modelName: modelName,
      status: pending,
      updateAt: new Date
    };
    this._subscribers = [];
    this._previousFluxRecord = null;
  }

  FluxEntry.property("createdAt updatedAt reloadAt lastSuccessfulLoadAt tryCount");

  FluxEntry.getter("previousFluxRecord fluxRecord subscribers model autoReload", {
    dataChanged: function() {
      var ref2, ref3;
      return !propsEq((ref2 = this._fluxRecord) != null ? ref2.data : void 0, (ref3 = this._previousFluxRecord) != null ? ref3.data : void 0);
    },
    fluxRecordChanged: function() {
      return !propsEq(this._fluxRecord, this._previousFluxRecord);
    },
    subscriberCount: function() {
      return this._subscribers.length;
    },
    key: function() {
      return this._fluxRecord.key;
    },
    modelName: function() {
      return this._fluxRecord.modelName;
    },
    status: function() {
      return this._fluxRecord.status;
    },
    reloadAt: function() {
      return this._fluxRecord.reloadAt;
    }
  });

  FluxEntry.setter({
    fluxRecord: function(newFluxRecord) {
      var key, modelName, now, oldFluxRecord, ref2;
      if (!isPlainObject(newFluxRecord)) {
        throw new Error("fluxRecord must be an object");
      }
      warnUnsettableFields(newFluxRecord, oldFluxRecord = this._fluxRecord);
      ref2 = this._fluxRecord, key = ref2.key, modelName = ref2.modelName;
      this._fluxRecord = newFluxRecord;
      newFluxRecord.key = key;
      newFluxRecord.modelName = modelName;
      if (newFluxRecord.status == null) {
        newFluxRecord.status = pending;
      }
      newFluxRecord.createdAt = this._createdAt;
      newFluxRecord.updatedAt = this._updatedAt = now = toSeconds();
      if (this._autoReload) {
        return this._updateAutoReloadFields();
      }
    }
  });

  FluxEntry.prototype._updateAutoReloadFields = function() {
    var reloadDelta;
    reloadDelta = (function() {
      if (isSuccess(this.status)) {
        this.lastSuccessfulLoadAt = this._updatedAt;
        this.tryCount = 1;
        return this.model.getStaleDataReloadSeconds();
      } else if (isFailure(this.status)) {
        this.tryCount += 1;
        switch (this.status) {
          case networkFailure:
            return this.nextNetworkFailureRetryDelay;
          case serverFailure:
          case failure:
            return this.nextServerFailureRetryDelay;
        }
      }
    }).call(this);
    this._fluxRecord.lastSuccessfulLoadAt = this.lastSuccessfulLoadAt;
    this._fluxRecord.tryCount = this.tryCount;
    return this.reloadAt = reloadDelta > 0 ? this._updatedAt + reloadDelta : null;
  };

  FluxEntry.prototype.reload = function() {
    return this.model.reload(this.key);
  };

  FluxEntry.setter({
    reloadAt: function(reloadAt) {
      var delta, key, maxRange, minRange, modelName, now, oldDelta, rangePerterbation, ref2;
      if (0 < reloadAt) {
        delta = reloadAt - (now = toSeconds());
        rangePerterbation = delta < 80 ? 0 : 15;
        minRange = delta - rangePerterbation;
        maxRange = delta + rangePerterbation;
        if (!(this._reloadAt && (oldDelta = this._reloadAt - now) > minRange && oldDelta < maxRange)) {
          this._reloadAt = reloadAt = now + minRange + (maxRange - minRange) * Math.random();
          ref2 = this, modelName = ref2.modelName, key = ref2.key;
          memoryLeakFreeReloader(modelName, key, reloadAt);
        }
        return this._fluxRecord.reloadAt = this._reloadAt;
      }
    }
  });

  memoryLeakFreeReloader = function(modelName, key, reloadAt) {
    return timeoutAt(reloadAt, function() {
      var entry;
      if (entry = getFluxStore()._getEntry(modelName, key)) {
        if (floatEq(reloadAt, entry.reloadAt)) {
          return entry.reload();
        }
      }
    });
  };

  retryExponent = 2;

  FluxEntry.getter({
    age: function() {
      var now;
      now = toSeconds();
      return {
        reload: now - this.reloadAt | 0,
        created: now - this.createdAt | 0,
        updated: now - this.updatedAt | 0,
        lastSuccessfulLoad: now - this.lastSuccessfulLoadAt | 0
      };
    },
    nextNetworkFailureRetryDelay: function() {
      var m, ref2;
      if (0 < (m = this.model.getMinNetworkFailureReloadSeconds())) {
        return min(m * Math.pow((ref2 = this.tryCount) != null ? ref2 : 1, retryExponent), this.model.getMaxNetworkFailureReloadSeconds());
      }
    },
    nextServerFailureRetryDelay: function() {
      var m, ref2;
      if (0 < (m = this.model.getMinServerFailureReloadSeconds())) {
        return min(m * Math.pow((ref2 = this.tryCount) != null ? ref2 : 1, retryExponent), this.model.getMaxServerFailureReloadSeconds());
      }
    }
  });

  FluxEntry.getter({
    plainStructure: function() {
      return {
        fluxRecord: this._fluxRecord,
        subscribers: this._subscribers
      };
    },
    hasSubscribers: function() {
      return this._subscribers.length > 0;
    }
  });

  FluxEntry.prototype._merge = function(src) {
    if (!isPlainObject(src)) {
      throw new Error("fluxRecord must be an object");
    }
    this._fluxRecord = src._fluxRecord;
    return this._subscribers = this._subscribers.concat(src._subscribers);
  };

  FluxEntry.prototype._notifySubscribers = function() {
    var i, len, ref2, subscriber;
    if (!this._previousFluxRecord) {
      return;
    }
    ref2 = this._subscribers;
    for (i = 0, len = ref2.length; i < len; i++) {
      subscriber = ref2[i];
      subscriber(this._fluxRecord, this._previousFluxRecord);
    }
    return this._previousFluxRecord = null;
  };

  FluxEntry.prototype._updateFluxRecord = function(updateFunction) {
    this._previousFluxRecord || (this._previousFluxRecord = this._fluxRecord);
    this.setFluxRecord((typeof updateFunction === "function" ? updateFunction(this._fluxRecord) : void 0) || {});
    if (propsEq(this._fluxRecord, this._previousFluxRecord)) {
      return this._previousFluxRecord = null;
    }
  };

  FluxEntry.prototype._subscribe = function(subscriber) {
    return pushIfNotPresent(this._subscribers, subscriber);
  };

  FluxEntry.prototype._unsubscribe = function(subscriber) {
    return removeFirstMatch(this._subscribers, subscriber);
  };

  return FluxEntry;

})(BaseObject));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var Core,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(56)).addNamespace('Core', Core = (function(superClass) {
  extend(Core, superClass);

  function Core() {
    return Core.__super__.constructor.apply(this, arguments);
  }

  return Core;

})(Neptune.PackageNamespace));


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ApplicationState, BaseObject, FluxCore, FluxModel, FluxStore, JsonStore, Promise, StateFieldsMixin, Unique, clone, defineModule, each, eq, failure, fluxStore, formattedInspect, isPlainObject, isString, jsonStore, log, lowerCamelCase, merge, mergeInto, missing, neq, object, pending, propsEq, ref, ref1, success, timeout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

FluxCore = __webpack_require__(84);

ref = __webpack_require__(1), lowerCamelCase = ref.lowerCamelCase, timeout = ref.timeout, object = ref.object, each = ref.each, clone = ref.clone, BaseObject = ref.BaseObject, log = ref.log, isString = ref.isString, isPlainObject = ref.isPlainObject, merge = ref.merge, propsEq = ref.propsEq, mergeInto = ref.mergeInto, Unique = ref.Unique, defineModule = ref.defineModule, Promise = ref.Promise, formattedInspect = ref.formattedInspect, eq = ref.eq, neq = ref.neq;

FluxStore = FluxCore.FluxStore, FluxModel = FluxCore.FluxModel;

fluxStore = FluxStore.fluxStore;

ref1 = __webpack_require__(19), pending = ref1.pending, success = ref1.success, failure = ref1.failure, missing = ref1.missing;

StateFieldsMixin = __webpack_require__(491);

JsonStore = __webpack_require__(2).JsonStore;

jsonStore = JsonStore.jsonStore;


/*
A state-store with the same state API as React Components:
  setState: (map) -> or (key, value) -> # => null
  getInitialState: -> # => {}
  @state: {} # the current State

NOTE: Components should never access @state. Instead, they should subscribe to state changes:
Example:
  createComponentFactory class Top extends FluxComponent
    @subscriptions
      showingWelcome: model: "ozAppState"

  showWelcome: ->
    @model.ozAppState.showWelcome()

Usage:
  Inherit, register and optionally override getInitalState.
  Note: Each time you inherit creates a new model and a different collection state
  NOTE: @register immeidately instantiates the OzAppState singleton - which will
    immediately call getInitialState.
    Therefor, call @register AFTER defining getInitialState.

Example:
  class OzAppState extends ApplicationState

    getInitialState: ->
      showingWelcome: true

    @register()

    showWelcome: -> @setState "showingWelcome", true
    hideWelcome: -> @setState "showingWelcome", false

NEW:
  You can how subscribe to the entire state of the model by subscribing to its own name:

  Example:
     * using the model above, you can subscribe to its entire state as follows:

    class MyComponent extends FluxComponent
      @subscriptions "ozAppState.ozAppState"

      render: ->
        TextElement text: "showingWelcome: #{@ozAppState.showingWelcome}"
 */

defineModule(module, ApplicationState = (function(superClass) {
  extend(ApplicationState, superClass);

  ApplicationState.abstractClass();

  ApplicationState.persistant = function() {
    return this._persistant = true;
  };

  ApplicationState.postCreateConcreteClass = function(arg) {
    var classModuleState, currentState, hotReloaded, hotUpdatedFromClass, liveClass, liveInstance, mergedState, newDefaultState, ret, stateDelta;
    hotReloaded = arg.hotReloaded, classModuleState = arg.classModuleState;
    ret = ApplicationState.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
    if (hotReloaded) {
      liveClass = classModuleState.liveClass, hotUpdatedFromClass = classModuleState.hotUpdatedFromClass;
      liveInstance = liveClass.getSingleton();
      newDefaultState = (new hotUpdatedFromClass).state;
      currentState = liveInstance.state;
      mergedState = merge(newDefaultState, currentState);
      stateDelta = object(mergedState, {
        when: function(v, k) {
          return currentState[k] !== v;
        }
      });
      log({
        "Flux.ApplicationState: model hot-reloaded": {
          model: liveInstance.name,
          stateDelta: stateDelta
        }
      });
      timeout(0, (function(_this) {
        return function() {
          return liveInstance.setState(stateDelta);
        };
      })(this));
    }
    return ret;
  };

  function ApplicationState() {
    ApplicationState.__super__.constructor.apply(this, arguments);
    this._updateAllState(this.state = this._getInitialState());
  }


  /*
  provided for consistency with React Components
  To use: override
  But, using @stateFields works just as well and also declares field getter / setters.
   */

  ApplicationState.prototype.getInitialState = function() {
    return {};
  };


  /*
  option 1:
    IN: plainObject state-map
    AFFECT: set many states
    OUT: state-map
  
  option 2:
    IN: key, value
    AFFECT: set one state
    OUT: key
   */

  ApplicationState.prototype.setState = function(key, value) {
    var k, map, v;
    if (isPlainObject(map = key)) {
      for (k in map) {
        v = map[k];
        if (!(!propsEq(this.state[k], v))) {
          continue;
        }
        this.state[k] = v;
        this.load(k);
      }
    } else if (isString(key) && !propsEq(this.state[key], value)) {
      this.state[key] = value;
      this.load(key);
    }
    this._updateAllState();
    this._saveToLocalStorage();
    return key;
  };

  ApplicationState.prototype.removeState = function(key) {
    var ret;
    this._removeFromFluxStore(key);
    ret = this.state[key];
    delete this.state[key];
    this._saveToLocalStorage();
    return ret;
  };


  /*
  Removes all values in @state.
  All entries currently in FluxStore become: state: missing
   */

  ApplicationState.prototype.clearState = function() {
    var k, ref2, v;
    ref2 = this.state;
    for (k in ref2) {
      v = ref2[k];
      this._removeFromFluxStore(k);
    }
    this.state = {};
    return this._saveToLocalStorage();
  };

  ApplicationState.prototype.resetState = function() {
    return this.replaceState(this._getInitialState(false));
  };


  /*
  Replace all state with newState.
  Logically equivelent to:
    @clearState()
    @setState newState
   */

  ApplicationState.prototype.replaceState = function(newState) {
    var k, ref2, v;
    ref2 = this.state;
    for (k in ref2) {
      v = ref2[k];
      if (!newState.hasOwnProperty(k)) {
        this._removeFromFluxStore(k);
        delete this.state[k];
      }
    }
    return this.setState(newState);
  };

  ApplicationState.prototype.load = function(key, callback) {
    var fluxRecord;
    fluxRecord = key === this.name ? {
      status: success,
      data: this.savableState
    } : this.state.hasOwnProperty(key) ? {
      status: success,
      data: this.state[key]
    } : {
      status: missing
    };
    this.updateFluxStore(key, fluxRecord);
    callback && fluxStore.onNextReady(function() {
      return callback(fluxRecord);
    });
    return fluxRecord;
  };

  ApplicationState.prototype._removeFromFluxStore = function(key) {
    return this.updateFluxStore(key, {
      status: missing
    });
  };

  ApplicationState.prototype._loadFromLocalStorage = function() {
    if (this["class"]._persistant) {
      return Promise.then((function(_this) {
        return function() {
          return jsonStore.getItem(_this.localStorageKey);
        };
      })(this)).then((function(_this) {
        return function(loadedState) {
          if (loadedState && neq(loadedState, _this.state)) {
            log("ApplicationState " + formattedInspect({
              loaded: {
                old: _this.state,
                "new": loadedState
              }
            }));
            return _this.replaceState(loadedState);
          }
        };
      })(this));
    }
  };

  ApplicationState.prototype._updateAllState = function() {
    this.load(this.name);
    return this.state;
  };

  ApplicationState.getter({
    savableState: function() {
      return merge(this.state);
    },
    localStorageKey: function() {
      return "ApplicationState:" + this.name;
    }
  });

  ApplicationState.prototype._saveToLocalStorage = function(state) {
    if (state == null) {
      state = this.state;
    }
    if (this["class"]._persistant) {
      return Promise.then((function(_this) {
        return function() {
          return jsonStore.setItem(_this.localStorageKey, _this.savableState);
        };
      })(this));
    }
  };

  ApplicationState.prototype._getInitialState = function(loadFromLocalStorage) {
    if (loadFromLocalStorage == null) {
      loadFromLocalStorage = true;
    }
    if (loadFromLocalStorage) {
      this._loadFromLocalStorage();
    }
    return merge(this.getInitialState(), this.getStateFields());
  };

  return ApplicationState;

})(StateFieldsMixin(FluxModel)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

var Models,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(56)).addNamespace('Models', Models = (function(superClass) {
  extend(Models, superClass);

  function Models() {
    return Models.__super__.constructor.apply(this, arguments);
  }

  return Models;

})(Neptune.PackageNamespace));


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {


/*
To customize how an object shows up in the DOM console, add
getInspectedObjects member method. For more info, see base_object.coffee
 */
var Atomic, BaseObject, Color, Console, Div, Foundation, Img, InspectedObjectLiteral, Li, Pre, Promise, Span, ToolBar, Ul, clone, colorRegExp, containsImages, containsPromises, createWithPostCreate, deepAll, deepEach, deepMap, domConsoleId, escapeJavascriptString, findColorRegExp, flatten, hasProperties, htmlEscape, imgToDom, insertBetweenEveryElement, inspect, inspectLean, isArray, isFunction, isHTMLImageElement, isNumber, isPlainArray, isPlainObject, isString, merge, nextTick, objectKeyCount, packageLogArgs, point, point0, ref, ref1, resolveImages, rgbColor, timeout, toInspectedObjects,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

if (self.document) {
  __webpack_require__(625);
}

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

ToolBar = __webpack_require__(271);

rgbColor = Atomic.rgbColor, Color = Atomic.Color, point = Atomic.point, point0 = Atomic.point0;

BaseObject = Foundation.BaseObject, inspect = Foundation.inspect, clone = Foundation.clone, merge = Foundation.merge, nextTick = Foundation.nextTick, timeout = Foundation.timeout, flatten = Foundation.flatten, isArray = Foundation.isArray, isString = Foundation.isString, isFunction = Foundation.isFunction, isNumber = Foundation.isNumber, createWithPostCreate = Foundation.createWithPostCreate, colorRegExp = Foundation.colorRegExp, Promise = Foundation.Promise, containsPromises = Foundation.containsPromises, deepAll = Foundation.deepAll, toInspectedObjects = Foundation.toInspectedObjects, isPlainArray = Foundation.isPlainArray, isPlainObject = Foundation.isPlainObject, hasProperties = Foundation.hasProperties, objectKeyCount = Foundation.objectKeyCount, InspectedObjectLiteral = Foundation.InspectedObjectLiteral, deepEach = Foundation.deepEach, deepMap = Foundation.deepMap, inspectLean = Foundation.inspectLean, escapeJavascriptString = Foundation.escapeJavascriptString, findColorRegExp = Foundation.findColorRegExp;

ref = __webpack_require__(268), containsImages = ref.containsImages, resolveImages = ref.resolveImages, isHTMLImageElement = ref.isHTMLImageElement, imgToDom = ref.imgToDom;

ref1 = Foundation.Browser.DomElementFactories, Div = ref1.Div, Pre = ref1.Pre, Span = ref1.Span, Img = ref1.Img, Li = ref1.Li, Ul = ref1.Ul;

htmlEscape = function(str) {
  return str;
};

insertBetweenEveryElement = function(array, el) {
  var first, j, len, res, v;
  res = [];
  first = true;
  for (j = 0, len = array.length; j < len; j++) {
    v = array[j];
    if (first) {
      first = false;
    } else {
      res.push(el);
    }
    res.push(v);
  }
  return res;
};

domConsoleId = 'artDomConsole';

packageLogArgs = function(args) {
  if (args.length === 1) {
    return args[0];
  } else {
    return args;
  }
};

module.exports = createWithPostCreate(Console = (function(superClass) {
  var isColor, literalToDomHelper, logCount, logSerializer, noOptions, toggleCollapsable;

  extend(Console, superClass);

  Console.singletonClass();

  Console.postCreate = function() {
    self.domConsole = this.singleton;
    return Console.__super__.constructor.postCreate.apply(this, arguments);
  };

  function Console() {
    window.domConsole = this;
    this._width = 500;
    this.initDom();
  }

  Console.prototype.reset = function() {
    return this.domContainer.innerHTML = "";
  };

  Console.prototype.hide = function() {
    return this.domConsoleParent.style.display = "none";
  };

  Console.prototype.show = function() {
    return this.domConsoleParent.style.display = "block";
  };

  Console.prototype.increaseWidth = function() {
    return this.width += 25;
  };

  Console.prototype.decreaseWidth = function() {
    return this.width -= 25;
  };

  Console.getter({
    shown: function() {
      return this.domContainer.style.display === "block";
    }
  });

  toggleCollapsable = function(el) {
    var child, j, len, ref2;
    ref2 = el.parentElement.children;
    for (j = 0, len = ref2.length; j < len; j++) {
      child = ref2[j];
      child.style.display = "block";
    }
    return el.style.display = "none";
  };

  Console.setter({
    width: function(w) {
      this._width = w;
      return this.domConsoleParent.style.width = w + "px";
    }
  });

  Console.getter("width");

  Console.prototype.initDom = function() {
    var bodyChildren, child, delay, fixMochaStats, maxAttempts, mocha;
    mocha = document.getElementById("mocha");
    bodyChildren = (function() {
      var j, len, ref2, results;
      ref2 = document.body.childNodes;
      results = [];
      for (j = 0, len = ref2.length; j < len; j++) {
        child = ref2[j];
        results.push(child);
      }
      return results;
    })();
    document.body.appendChild(Div(null, Div({
      style: {
        display: "flex",
        flexDirection: "row",
        position: "fixed",
        left: "0",
        right: "0",
        top: "0",
        bottom: "0"
      }
    }, Div({
      id: domConsoleId + "Area",
      style: {
        flex: "1 1 auto",
        overflow: "scroll"
      }
    }, bodyChildren), this.domConsoleParent = Div({
      style: {
        overflow: "auto",
        backgroundColor: "white",
        top: "0",
        bottom: "0",
        paddingTop: "25px",
        flex: "0 0 auto",
        width: this._width + "px",
        borderLeft: "1px solid #aaa"
      }
    }, this.domContainer = Div({
      "class": "domConsole",
      style: {
        padding: "5px"
      },
      on: {
        click: (function(_this) {
          return function(arg) {
            var results, target;
            target = arg.target;
            results = [];
            while (target) {
              if (target.className.match("collapsable")) {
                toggleCollapsable(target);
                break;
              }
              results.push(target = target.parentElement);
            }
            return results;
          };
        })(this)
      }
    }))), ToolBar()));
    if (mocha) {
      maxAttempts = 8;
      delay = 125 / 2;
      fixMochaStats = function() {
        var ms;
        if (!maxAttempts--) {
          console.log("domConsoleMocha fixMochaStats... giving up; sorry for the ugly screen");
          return;
        }
        delay *= 2;
        if (ms = document.getElementById("mocha-stats")) {
          return ms.style.position = "relative";
        } else {
          console.log("domConsoleMocha fixMochaStats... (waiting " + delay + "ms for #mocha-stats div to appear: " + maxAttempts + ")");
          return timeout(delay, fixMochaStats);
        }
      };
      return timeout(delay, fixMochaStats);
    }
  };

  Console.prototype.appendLog = function(domElement) {
    this.domContainer.appendChild(Div({
      "class": "logLine"
    }, domElement));
    return nextTick((function(_this) {
      return function() {
        return _this.domConsoleParent.scrollTop = _this.domConsoleParent.scrollHeight;
      };
    })(this));
  };

  Console.prototype.log = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    this.logCore(packageLogArgs(args));
    return args[args.length - 1];
  };

  Console.prototype.logF = function(options) {
    this.logCore(options.log, null, null, options);
    return options.log;
  };

  Console.prototype.format = function(domEl, options) {
    var backgroundColor, label, labelColor;
    label = options.label, labelColor = options.labelColor, backgroundColor = options.backgroundColor;
    if (label) {
      domEl = Div({
        style: {
          backgroundColor: backgroundColor
        }
      }, Div(label, {
        style: {
          color: labelColor,
          fontWeight: "bold"
        }
      }), Div({
        style: {
          paddingLeft: "10px"
        }
      }, domEl));
    }
    return domEl;
  };

  Console.prototype.arrayKidsToDomArray = function(arrayOfInspectedObjects, Factory, options, addCommasAndBrackets) {
    var child, i, kids;
    options.maxDepth--;
    kids = (function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = arrayOfInspectedObjects.length; j < len; i = ++j) {
        child = arrayOfInspectedObjects[i];
        if (i > 50) {
          break;
        }
        if (i === 50) {
          results.push(Factory({
            "class": "value"
          }, "array length: " + arrayOfInspectedObjects.length + " (showing the first " + i + ")"));
        } else {
          results.push(Factory({
            "class": "value"
          }, this.toDom(child, options)));
        }
      }
      return results;
    }).call(this);
    options.maxDepth++;
    if (addCommasAndBrackets) {
      kids = this.addCommasAndBrackets(kids, "[", "]");
    }
    return kids;
  };

  Console.prototype.arrayToDomBasic = function(arrayOfInspectedObjects, options) {
    var l;
    if (options.maxDepth === 0) {
      return Span({
        "class": "array maxdepth " + options["class"]
      }, arrayOfInspectedObjects.length === 0 ? "[]" : arrayOfInspectedObjects.length <= 5 && (l = inspectLean(arrayOfInspectedObjects)).length <= 30 ? "[" + l + "]" : "[... " + arrayOfInspectedObjects.length + "]");
    }
    return Span({
      "class": "array " + options["class"]
    }, this.arrayKidsToDomArray(arrayOfInspectedObjects, Span, options, true));
  };

  Console.prototype.arrayToDom = function(arrayOfInspectedObjects, options) {
    if (options.treeView) {
      return this.arrayToDomTreeView(arrayOfInspectedObjects, options);
    } else {
      return this.arrayToDomBasic(arrayOfInspectedObjects, options);
    }
  };

  Console.prototype.addCommasAndBrackets = function(kids, leftBracket, rightBracket, typeName) {
    var i, j, kid, len;
    for (i = j = 0, len = kids.length; j < len; i = ++j) {
      kid = kids[i];
      if (i + 1 < kids.length) {
        kid.appendChild(Span(", "));
      }
    }
    return flatten(leftBracket, typeName, kids, rightBracket);
  };

  Console.prototype.mapKidsToDomArray = function(inspectedObject, Factory, options, addCommasAndBrackets) {
    var k, kids, v;
    options.maxDepth--;
    kids = (function() {
      var results;
      results = [];
      for (k in inspectedObject) {
        v = inspectedObject[k];
        results.push(Factory(null, Span({
          "class": "key"
        }, k + ": "), Span({
          "class": "value"
        }, this.toDom(v, options))));
      }
      return results;
    }).call(this);
    options.maxDepth++;
    if (addCommasAndBrackets) {
      return this.addCommasAndBrackets(kids, "{", "}");
    } else {
      return kids;
    }
  };

  Console.prototype.objectToDomBasic = function(inspectedObject, options) {
    var inside, l, length;
    if (options.maxDepth === 0) {
      length = objectKeyCount(inspectedObject);
      inside = length === 0 ? "" : length <= 5 ? (l = inspectLean(inspectedObject)).length <= 40 ? l : Object.keys(inspectedObject).join(' ') : "" + length;
      return Span({
        "class": "object maxdepth " + options["class"]
      }, "{" + inside + "}");
    }
    return Span({
      "class": "object"
    }, this.mapKidsToDomArray(inspectedObject, Span, options, true));
  };

  Console.prototype.treeViewCollapsable = function(collapsablePair, options) {
    collapsablePair[options.collapsed ? 0 : 1].style.display = "none";
    return collapsablePair;
  };

  Console.prototype.arrayToDomTreeView = function(arrayOfInspectedObjects, options) {
    if (arrayOfInspectedObjects.length === 0) {
      return Span({
        "class": "array"
      }, "[]");
    }
    return this.treeViewCollapsable([
      Ul({
        "class": "array collapsable open"
      }, this.arrayKidsToDomArray(arrayOfInspectedObjects, Li, options)), Ul({
        "class": "array collapsable closed"
      }, this.arrayToDomBasic(arrayOfInspectedObjects, merge(options, {
        maxDepth: 1,
        treeView: false
      })))
    ], options);
  };

  Console.prototype.objectToDomTreeView = function(inspectedObject, options) {
    if (!hasProperties(inspectedObject)) {
      return Span({
        "class": "object"
      }, "{}");
    }
    return this.treeViewCollapsable([
      Ul({
        "class": "object collapsable open"
      }, this.mapKidsToDomArray(inspectedObject, Li, options)), Ul({
        "class": "object collapsable closed"
      }, this.objectToDomBasic(inspectedObject, merge(options, {
        maxDepth: 1,
        treeView: false
      })))
    ], options);
  };

  Console.prototype.objectToDom = function(inspectedObject, options) {
    if (options.treeView) {
      return this.objectToDomTreeView(inspectedObject, options);
    } else {
      return this.objectToDomBasic(inspectedObject, options);
    }
  };

  literalToDomHelper = function(classes, literalString) {
    var Factory;
    Factory = literalString.match(/\s\s+|\n/) ? Pre : Span;
    return Factory({
      "class": classes
    }, literalString);
  };

  Console.prototype.literalToDom = function(inspectedObject) {
    return literalToDomHelper("literal", isString(inspectedObject) ? escapeJavascriptString(inspectedObject) : "" + inspectedObject);
  };

  Console.prototype.errorLiteralToDom = function(inspectedObject) {
    return literalToDomHelper("errorLiteral", inspectedObject.toString());
  };

  Console.prototype.warningLiteralToDom = function(inspectedObject) {
    return literalToDomHelper("warningLiteral", inspectedObject.toString());
  };

  Console.prototype.colorToDom = function(clr) {
    var c, clrString, displayString, ref2;
    displayString = isString(clrString = clr) ? ((ref2 = clr.match(findColorRegExp), c = ref2[0], ref2), clr = rgbColor(c), clrString) : clr.toString();
    return Span({
      "class": "inspected",
      style: {
        backgroundColor: clr,
        padding: "0 5px",
        color: clr.perceptualLightness < .8 && clr.a > .25 ? 'white' : 'black'
      }
    }, "" + displayString);
  };

  isColor = function(obj) {
    return (obj instanceof Color) || (isString(obj) && colorRegExp.test(obj));
  };

  Console.prototype.toDom = function(inspectedObject, options) {
    if (options == null) {
      options = {};
    }
    if (inspectedObject == null) {
      return this.literalToDom(inspectedObject);
    } else if (inspectedObject instanceof InspectedObjectLiteral) {
      if (isColor(inspectedObject.literal)) {
        return this.colorToDom(inspectedObject.literal);
      } else if (inspectedObject.isError) {
        console.error(inspectedObject.literal);
        return this.errorLiteralToDom(inspectedObject.literal);
      } else if (inspectedObject.isWarning) {
        console.warn(inspectedObject.literal);
        return this.warningLiteralToDom(inspectedObject.literal);
      } else {
        return literalToDomHelper("literal", inspectedObject.literal);
      }
    } else if (isHTMLImageElement(inspectedObject)) {
      return imgToDom(inspectedObject);
    } else if (isColor(inspectedObject)) {
      return this.colorToDom(inspectedObject);
    } else if (isPlainArray(inspectedObject)) {
      return this.arrayToDom(inspectedObject, options);
    } else if (isPlainObject(inspectedObject)) {
      return this.objectToDom(inspectedObject, options);
    } else {
      return this.literalToDom(inspectedObject);
    }
  };

  logSerializer = new Promise.Serializer;

  logCount = 1;

  noOptions = {};

  Console.prototype.logCore = function(m, callStack, options) {
    var formatSystemMessage, hasPromises, localLogCount, ret;
    if (options == null) {
      options = noOptions;
    }
    formatSystemMessage = function(params) {
      var failure, pending, success, warning;
      success = params.success, failure = params.failure, pending = params.pending, warning = params.warning;
      return {
        backgroundColor: (function() {
          switch (false) {
            case !failure:
              return "#fee";
            case !warning:
              return "#ffe";
          }
        })(),
        labelColor: (function() {
          switch (false) {
            case !success:
              return "green";
            case !failure:
              return "#a00";
            case !pending:
              return "blue";
            case !warning:
              return "#aa0";
          }
        })(),
        label: (success || failure || pending || warning) + ": (log #" + localLogCount + ")"
      };
    };
    localLogCount = logCount;
    if (hasPromises = containsPromises(m)) {
      options = merge(options, formatSystemMessage({
        pending: "RESOLVING PROMISES"
      }));
    }
    if (options.isError) {
      options = merge(options, formatSystemMessage({
        failure: "ERROR"
      }));
    }
    if (options.isWarning) {
      options = merge(options, formatSystemMessage({
        warning: "WARNING"
      }));
    }
    ret = logSerializer.then((function(_this) {
      return function() {
        var maxDepth;
        options.treeView = true;
        maxDepth = options.maxDepth;
        if (!isNumber(maxDepth)) {
          maxDepth = 20;
        }
        if (typeof m === "string" && !colorRegExp.test(m)) {
          return _this.appendLog(_this.format(Pre(m), options));
        } else {
          return Promise.then(function() {
            var inspected;
            if (containsImages(inspected = toInspectedObjects(m))) {
              return resolveImages(inspected);
            } else {
              return inspected;
            }
          }).then(function(inspected) {
            var domEl;
            domEl = _this.toDom(inspected, options);
            return _this.appendLog(_this.format(domEl, options));
          });
        }
      };
    })(this));
    logSerializer["catch"](function(e) {
      return console.error("Error in DomConsole.Console", e);
    });
    if (hasPromises) {
      deepAll(m, function(promiseResult) {
        return {
          'promise.then': promiseResult
        };
      }).then((function(_this) {
        return function(resolvedM) {
          return _this.logCore(resolvedM, callStack, merge(options, formatSystemMessage({
            success: "ALL PROMISES RESOLVED"
          })));
        };
      })(this))["catch"]((function(_this) {
        return function(rejected) {
          return _this.logCore(rejected, callStack, merge(options, formatSystemMessage({
            failure: "ONE OR MORE PROMISES WERE REJECTED"
          })));
        };
      })(this));
    }
    logCount++;
    return ret;
  };

  return Console;

})(BaseObject));


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var Atomic, Foundation, Images, Img, Promise, deepAll, deepEach, deepMap, defineModule, devicePixelRatio, isFunction, point, point0, ref;

ref = Neptune.Art, Foundation = ref.Foundation, Atomic = ref.Atomic;

deepAll = Foundation.deepAll, deepMap = Foundation.deepMap, isFunction = Foundation.isFunction, defineModule = Foundation.defineModule, deepEach = Foundation.deepEach, Promise = Foundation.Promise;

Img = Foundation.Browser.DomElementFactories.Img;

point = Atomic.point, point0 = Atomic.point0;

devicePixelRatio = Foundation.Browser.Dom.getDevicePixelRatio();

defineModule(module, Images = (function() {
  var isHTMLImageElement, isImage;

  function Images() {}

  Images.isHTMLImageElement = isHTMLImageElement = global.HTMLImageElement ? function(obj) {
    return obj instanceof HTMLImageElement;
  } : function() {
    return false;
  };

  Images.isImage = isImage = function(o) {
    return o && (isFunction(o.toImage)) || isHTMLImageElement(o);
  };

  Images.containsImages = function(plainStructure) {
    var foundImages;
    foundImages = false;
    deepEach(plainStructure, function(v) {
      return foundImages || (foundImages = isImage(v));
    });
    return foundImages;
  };

  Images.resolveImages = function(plainStructure) {
    return deepAll(deepMap(plainStructure, function(element) {
      if (!isImage(element)) {
        return element;
      }
      return Promise.then(function() {
        if (isHTMLImageElement(element)) {
          return element;
        } else {
          return element.toImage();
        }
      }).then(function(htmlImageElement) {
        htmlImageElement;
        if (htmlImageElement.complete) {
          return htmlImageElement;
        } else {
          return new Promise(function(resolve) {
            return htmlImageElement.onload = function() {
              return resolve(htmlImageElement);
            };
          });
        }
      });
    }));
  };

  Images.imgToDom = function(image) {
    var maxImageDisplaySize, minImageDisplaySize, scale, size;
    minImageDisplaySize = point(32);
    maxImageDisplaySize = point(1024, 512).mul(devicePixelRatio);
    size = point(image.width, image.height);
    scale = 1 / devicePixelRatio;
    if (!size.gte(minImageDisplaySize)) {
      scale *= Math.ceil(minImageDisplaySize.div(size).min());
    } else if (!size.lt(maxImageDisplaySize)) {
      scale *= maxImageDisplaySize.div(size).min();
    }
    return Img({
      src: image.src
    }, size.gt(point0) ? {
      style: {
        width: (image.naturalWidth * scale | 0) + "px",
        height: (image.naturalHeight * scale | 0) + "px",
        "image-rendering": "pixelated"
      }
    } : void 0);
  };

  return Images;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(270);

module.exports.addModules({
  Component: __webpack_require__(470)
});


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

var PseudoReact,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(85)).addNamespace('PseudoReact', PseudoReact = (function(superClass) {
  extend(PseudoReact, superClass);

  function PseudoReact() {
    return PseudoReact.__super__.constructor.apply(this, arguments);
  }

  return PseudoReact;

})(Neptune.PackageNamespace));


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {
/*
To customize how an object shows up in the DOM console, add
getInspectedObjects member method. For more info, see base_object.coffee
 */
var A, BaseObject, Component, Div, DomConsole, Foundation, ToolBar, defineModule, ref, wordsArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

DomConsole = __webpack_require__(85);

Component = __webpack_require__(269).Component;

BaseObject = Foundation.BaseObject, defineModule = Foundation.defineModule, wordsArray = Foundation.wordsArray;

ref = Foundation.Browser.DomElementFactories, Div = ref.Div, A = ref.A;

defineModule(module, ToolBar = (function(superClass) {
  extend(ToolBar, superClass);

  function ToolBar() {
    return ToolBar.__super__.constructor.apply(this, arguments);
  }

  ToolBar.prototype.render = function() {
    var action, shown;
    shown = this.state.shown;
    return Div({
      style: {
        position: "fixed",
        top: 0,
        right: 0,
        display: "flex",
        flexDirection: "row",
        borderBottom: "1px solid #aaa",
        borderLeft: "1px solid #aaa",
        fontSize: "10px",
        fontFamily: "Arial",
        justifyContent: "flex-end",
        backgroundColor: "#f7f3df"
      }
    }, Div({
      style: {
        margin: "5px"
      }
    }, "Art.Foundation.DomConsole"), (function() {
      var i, len, ref1, results;
      ref1 = ["reset", "show", "hide", "increaseWidth", "decreaseWidth"];
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        action = ref1[i];
        results.push((function(_this) {
          return function(action) {
            return Div({
              style: {
                margin: "5px"
              }
            }, A({
              href: "#",
              on: {
                click: function() {
                  return DomConsole[action]();
                }
              }
            }, action));
          };
        })(this)(action));
      }
      return results;
    }).call(this));
  };

  return ToolBar;

})(Component));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

var Webpack,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(273)).addNamespace('Webpack', Webpack = (function(superClass) {
  extend(Webpack, superClass);

  function Webpack() {
    return Webpack.__super__.constructor.apply(this, arguments);
  }

  return Webpack;

})(Neptune.PackageNamespace));


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

var DevTools,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(87)).addNamespace('DevTools', DevTools = (function(superClass) {
  extend(DevTools, superClass);

  function DevTools() {
    return DevTools.__super__.constructor.apply(this, arguments);
  }

  return DevTools;

})(Neptune.PackageNamespace));

__webpack_require__(85);

__webpack_require__(272);


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(389);


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

var Dom, DomElementFactories, isString;

DomElementFactories = __webpack_require__(276);

isString = __webpack_require__(1).isString;

module.exports = Dom = (function() {
  function Dom() {}

  Dom.createElementFromHtml = function(html) {
    var div;
    div = document.createElement('div');
    div.innerHTML = html;
    return div.firstChild;
  };

  Dom.createDomElementFactories = DomElementFactories.createDomElementFactories;

  Dom.getDevicePixelRatio = function() {
    return ((self.devicePixelRatio != null) && self.devicePixelRatio) || 1;
  };

  Dom.zIndex = function(target, setZIndex) {
    var element, value;
    if (!(target instanceof HTMLElement)) {
      target = document.getElementById(target);
    }
    if (setZIndex !== void 0) {
      return target.style.zIndex = setZIndex;
    }
    element = target;
    while (element && element !== document) {
      switch (element.style.position) {
        case "absolute":
        case "relative":
        case "fixed":
          value = parseInt(element.style.zIndex);
          if (value < 0 || value > 0) {
            return value;
          }
      }
      element = element.parentElement;
    }
    return 0;
  };

  Dom.domElementOffset = function(element) {
    var body, box, clientLeft, clientTop, documentElement, e, left, scrollLeft, scrollTop, top;
    try {
      box = element.getBoundingClientRect();
    } catch (error) {
      e = error;
      return {
        top: 0,
        left: 0
      };
    }
    body = document.body, documentElement = document.documentElement;
    scrollTop = window.pageYOffset || documentElement.scrollTop || body.scrollTop;
    scrollLeft = window.pageXOffset || documentElement.scrollLeft || body.scrollLeft;
    clientTop = documentElement.clientTop || body.clientTop || 0;
    clientLeft = documentElement.clientLeft || body.clientLeft || 0;
    top = box.top + scrollTop - clientTop;
    left = box.left + scrollLeft - clientLeft;
    return {
      top: Math.round(top),
      left: Math.round(left)
    };
  };

  return Dom;

})();


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var DomElementFactories, supportLibs,
  slice = [].slice;

supportLibs = [__webpack_require__(1), __webpack_require__(136)];


/*
DomElementFactories allows for Art.React-style creation of DOM elements.

 * HOW TO LOAD:
 * -- IF: you are already using Art.Foundation
Foundation = require 'art-foundation'
{DomElementFactories} = Foundation.Browser

 * -- IF: You have the Art.Foundation NPM but only want DomElementFactories:
DomElementFactories = require 'art-foundation/dom_element_factories'

 * -- IF: You just have dom_element_factories.js
 * first, load it prior via a <script> tag, then:
 * window.DomElementFactories will be set.

Usage:

{Div, Span, B, Em} = DomElementFactories

mySharedTextStyle =
  style:
    fontSize: "16pt"
    color: "#444"
    fontFamily: "Times"

Div
  class: "foo"
  id:    "123"

Span
  class: "dude"
  "This is some really"
  B "bold"
  "text."
  "Also, here is some"
  Em "emphasized"
  "text."

Span mySharedTextStyle,
  internalHTML: "Or you can do <b>this</b> and <em>this</em>."

Div mySharedTextStyle,
  style:
    bottom:          0
    height:          "50px"
    left:            "100px"
    right:           "100px"
    position:        "fixed"
    backgroundColor: "white"
    textAlign:       "center"
  "Styles are easy, too."

VERSION HISTORY:
  1.1.1 - added H2-H6
  1.1.0 - new-lines in text-children become <BR> tags
  1.0.0 - initial
 */

module.exports = DomElementFactories = (function() {
  var isPlainObject, isString, j, k, len, mergeInto, ref, supportLib, v;

  function DomElementFactories() {}

  DomElementFactories.version = "1.1.1";

  DomElementFactories.src = "https://github.com/imikimi/art-foundation";

  for (j = 0, len = supportLibs.length; j < len; j++) {
    supportLib = supportLibs[j];
    for (k in supportLib) {
      v = supportLib[k];
      if (supportLib.hasOwnProperty(k) && k.match(/^[^_]/)) {
        DomElementFactories[k] = v;
      }
    }
  }

  DomElementFactories.isString = isString = function(obj) {
    return typeof obj === "string";
  };

  DomElementFactories.isPlainObject = isPlainObject = function(obj) {
    return obj.constructor === Object;
  };

  DomElementFactories.mergeInto = mergeInto = function(into, source) {
    if (into == null) {
      into = {};
    }
    for (k in source) {
      v = source[k];
      into[k] = v;
    }
    return into;
  };

  DomElementFactories.setDomElementProp = function(element, prop, value, oldValue) {
    var clearStyle, setStyle, style;
    switch (prop) {
      case "class":
        return element.className = value || "";
      case "id":
        return element.id = value || "";
      case "innerHTML":
        return element.innerHTML = value || "";
      case "on":
        if (!isPlainObject(value)) {
          throw new Error("object expected for 'on' property");
        }
        setStyle = function(eventType, newEventListener) {
          return element.addEventListener(eventType, newEventListener);
        };
        clearStyle = function(eventType, oldEventListener) {
          return element.removeEventListner(eventType, oldEventListener);
        };
        return DomElementFactories.objectDiff(value, oldValue, setStyle, clearStyle, setStyle);
      case "style":
        if (!isPlainObject(value)) {
          throw new Error("object expected for 'style' property");
        }
        style = element.style;
        setStyle = function(k, v) {
          return style[k] = v;
        };
        clearStyle = function(k) {
          return style[k] = "";
        };
        return DomElementFactories.objectDiff(value, oldValue, setStyle, clearStyle, setStyle);
      default:
        return element.setAttribute(prop, value);
    }
  };

  DomElementFactories.setDomElementProps = function(element, props) {
    var results;
    results = [];
    for (k in props) {
      v = props[k];
      results.push(this.setDomElementProp(element, k, v));
    }
    return results;
  };

  DomElementFactories.setDomElementChildren = function(element, children) {
    var child, i, l, len1, message, ref, ref1, ref2, results, text;
    results = [];
    for (l = 0, len1 = children.length; l < len1; l++) {
      child = children[l];
      if (isString(child)) {
        results.push((function() {
          var len2, m, ref, results1;
          ref = child.split("\n");
          results1 = [];
          for (i = m = 0, len2 = ref.length; m < len2; i = ++m) {
            text = ref[i];
            if (i > 0) {
              element.appendChild(document.createElement("br"));
            }
            results1.push(element.appendChild(document.createTextNode(text)));
          }
          return results1;
        })());
      } else {
        if (!(child instanceof Node)) {
          message = "DomElementFactory:" + nodeName + ": Child is not a string or instance of Node. Child: " + child;
          (typeof Neptune !== "undefined" && Neptune !== null ? (ref = Neptune.Art) != null ? (ref1 = ref.Foundation) != null ? (ref2 = ref1.log) != null ? typeof ref2.error === "function" ? ref2.error(message, child) : void 0 : void 0 : void 0 : void 0 : void 0) || console.log(message, child);
          throw new Error(message);
        }
        results.push(element.appendChild(child));
      }
    }
    return results;
  };


  /*
  IN: any combination of arrays and strings
  OUT: All element-names found in all strings are used to generate dom-element-factory-functions
    for elements with those names.
    The output is a plain Object where they keys are the upperCamelCase version of the element-names
    passed in. The values are the element-factories.
   */

  DomElementFactories.createDomElementFactories = function() {
    var list;
    list = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return DomElementFactories.createObjectTreeFactories({
      mergePropsInto: function(into, source) {
        var results;
        results = [];
        for (k in source) {
          v = source[k];
          results.push(into[k] = k === "style" ? mergeInto(into[k], v) : v);
        }
        return results;
      }
    }, list, function(nodeName, props, children) {
      var element;
      element = document.createElement(nodeName);
      DomElementFactories.setDomElementProps(element, props);
      DomElementFactories.setDomElementChildren(element, children);
      return element;
    });
  };

  DomElementFactories.allDomElementNames = "A Abbr Acronym Address Applet Area Article Aside Audio B Base BaseFont Bdi Bdo Big BlockQuote Body Br Button Canvas Caption Center Cite Code Col ColGroup DataList Dd Del Details Dfn Dialog Dir Div Dl Dt Em Embed FieldSet FigCaption Figure Font Footer Form Frame FrameSet H1 H2 H3 H4 H5 H6 Head Header Hr Html I IFrame Img Input Ins Kbd KeyGen Label Legend Li Link Main Map Mark Menu MenuItem Meta Meter Nav NoFrames NoScript Object Ol OptGroup Option Output P Param Pre Progress Q Rp Rt Ruby S Samp Script Section Select Small Source Span Strike Strong Style Sub Summary Sup Table TBody Td TextArea TFoot Th THead Time Title Tr Track Tt U Ul Var Video Wbr";

  ref = DomElementFactories.createDomElementFactories(DomElementFactories.allDomElementNames);
  for (k in ref) {
    v = ref[k];
    DomElementFactories[k] = v;
  }

  return DomElementFactories;

})();


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

var Browser,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(87)).addNamespace('Browser', Browser = (function(superClass) {
  extend(Browser, superClass);

  function Browser() {
    return Browser.__super__.constructor.apply(this, arguments);
  }

  return Browser;

})(Neptune.PackageNamespace));


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var Promise, defineModule, isWebWorker, log, objectKeyCount, ref, workerRpc;

ref = __webpack_require__(1), defineModule = ref.defineModule, Promise = ref.Promise, log = ref.log, objectKeyCount = ref.objectKeyCount;

isWebWorker = __webpack_require__(86).isWebWorker;

workerRpc = __webpack_require__(282).workerRpc;


/*
AsyncLocalStorage defines a consistent API for localStorage across web-workers and the main thread.

API:
  AsyncLocalStorage.
    getItem:    (path)        -> promise.then -> item at path
    setItem:    (path, value) -> promise.then -> success
    removeItem: (path)        -> promise.then -> success
    clear:                    -> promise.then -> success
 */

defineModule(module, function() {
  var AsyncLocalStorage, LocalStorageShimForNode, localStorage;
  localStorage = global.localStorage;
  localStorage || (localStorage = LocalStorageShimForNode = (function() {
    function LocalStorageShimForNode() {}

    LocalStorageShimForNode.store = {};

    LocalStorageShimForNode.getItem = function(k) {
      return LocalStorageShimForNode.store[k];
    };

    LocalStorageShimForNode.setItem = function(k, v) {
      return LocalStorageShimForNode.store[k] = v;
    };

    LocalStorageShimForNode.removeItem = function(k) {
      return delete LocalStorageShimForNode.store[k];
    };

    LocalStorageShimForNode.clear = function() {
      return LocalStorageShimForNode.store = {};
    };

    LocalStorageShimForNode.key = function(i) {
      return Object.keys(LocalStorageShimForNode.store)[i];
    };

    LocalStorageShimForNode.getLength = function() {
      return objectKeyCount(LocalStorageShimForNode.store);
    };

    return LocalStorageShimForNode;

  })());
  if (isWebWorker) {
    return workerRpc.bindWithPromises({
      localStorage: ["getItem", "setItem", "removeItem", "clear", "key"]
    });
  } else {
    workerRpc.register({
      localStorage: localStorage
    });
    return AsyncLocalStorage = (function() {
      function AsyncLocalStorage() {}

      AsyncLocalStorage.getItem = function(path) {
        return Promise.then(function() {
          return localStorage.getItem(path);
        });
      };

      AsyncLocalStorage.setItem = function(path, value) {
        return Promise.then(function() {
          return localStorage.setItem(path, value);
        });
      };

      AsyncLocalStorage.removeItem = function(path) {
        return Promise.then(function() {
          return localStorage.removeItem(path);
        });
      };

      AsyncLocalStorage.clear = function() {
        return Promise.then(function() {
          return localStorage.clear();
        });
      };

      AsyncLocalStorage.key = function(index) {
        return Promise.then(function() {
          return localStorage.key(index);
        });
      };

      AsyncLocalStorage.getLength = function() {
        return Promise.then(function() {
          return localStorage.length;
        });
      };

      return AsyncLocalStorage;

    })();
  }
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

var GlobalCounts, StandardLib, currentSecond, isPlainObject, log;

StandardLib = __webpack_require__(1);

isPlainObject = StandardLib.isPlainObject, currentSecond = StandardLib.currentSecond, log = StandardLib.log;

module.exports = GlobalCounts = (function() {
  var globalTime;

  function GlobalCounts() {}

  GlobalCounts.globalCounts = {};

  globalTime = null;

  GlobalCounts.resetGlobalCounts = function() {
    globalTime = currentSecond();
    return GlobalCounts.globalCounts = {};
  };

  GlobalCounts.globalCount = function(name, amount) {
    var k, last, results, v;
    if (amount == null) {
      amount = 1;
    }
    if (isPlainObject(amount)) {
      if (last = GlobalCounts.globalCounts[name]) {
        results = [];
        for (k in amount) {
          v = amount[k];
          results.push(last[k] += v);
        }
        return results;
      } else {
        return GlobalCounts.globalCounts[name] = amount;
      }
    } else {
      return GlobalCounts.globalCounts[name] = (GlobalCounts.globalCounts[name] || 0) + amount;
    }
  };

  GlobalCounts.countStep = function() {
    var nextTime;
    nextTime = currentSecond();
    if (nextTime - globalTime > .002) {
      log.error("GlobalCounts gap");
    }
    globalTime = nextTime;
    return GlobalCounts.globalCount("step");
  };

  return GlobalCounts;

})();


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, ProgressAdapter, Promise, StandardLib, isArray, isFunction, isNumber, log, max, min,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(1);

ClassSystem = __webpack_require__(6);

BaseObject = ClassSystem.BaseObject;

isNumber = StandardLib.isNumber, isFunction = StandardLib.isFunction, isArray = StandardLib.isArray, log = StandardLib.log, max = StandardLib.max, min = StandardLib.min, Promise = StandardLib.Promise;

module.exports = ProgressAdapter = (function(superClass) {
  extend(ProgressAdapter, superClass);


  /*
  IN:
    stepWeights can be a positive integer or an aray of positive, real numbers.
  
      integer N: specifies progress will be made in N even steps from 0 to 1
  
      array of numbers A: specifies progress will be made in A.length steps which
        may not be even. Each step has its own "weight."
  
        Example: stepWeights = [850, 50, 100]
        Will become:
          steps:
            0: 0.00 to 0.85
            1: 0.85 to 0.90
            2: 0.90 to 1.00
  
        Example: stepWeights = [1, 2, 1]
        Will become:
          steps:
            0: 0.00 to 0.25
            1: 0.25 to 0.75
            2: 0.75 to 1.00
  
    progressCallback: progressCallback is a function which is invoked with a number
      between 0 and 1. It is invoked immediatly with 0, then it is invoked by makeProgress()
      and makeProgressCallback()(). It always increments or stays the same. It will
      never go backwards.
   */

  function ProgressAdapter(stepWeights, progressCallback1) {
    this.stepWeights = stepWeights;
    this.progressCallback = progressCallback1;
    if (!(isFunction(this.progressCallback) && (isArray(this.stepWeights) || isNumber(this.stepWeights)))) {
      throw new Error("invalid params");
    }
    this._currentStep = 0;
    this._generateSteps();
    this._currentProgress = 0;
    this._warningCount = 0;
    this.setCurrentProgress(0);
  }

  ProgressAdapter.getter("steps currentStep currentProgress warningCount", {
    currentProgressPercent: function() {
      return (this._currentProgress * 100 | 0) + "%";
    },
    currentProgressBase: function() {
      if (this._currentStep <= 0) {
        return 0;
      } else if (this._currentStep >= this._steps.length) {
        return 1;
      } else {
        return this._steps[this._currentStep];
      }
    }
  });

  ProgressAdapter.setter({
    currentProgress: function(p) {
      return typeof this.progressCallback === "function" ? this.progressCallback(min(1, this._currentProgress = max(p, this._currentProgress))) : void 0;
    }
  });

  ProgressAdapter.prototype.makeProgress = function() {
    this._currentStep++;
    if (this._currentStep > this._steps.length) {
      this._warningCount++;
      console.warn("ProgressAdapter: makeProgress/Callback called too many times!", {
        currentStep: this._currentStep,
        steps: this._steps,
        stepWeights: this.stepWeights
      });
    }
    return this.setCurrentProgress(this.currentProgressBase);
  };

  ProgressAdapter.prototype.makeProgressCallback = function() {
    var rangeEnd, rangeStart;
    this._finishLastProgress();
    rangeStart = this.currentProgressBase;
    this._currentStep++;
    rangeEnd = this.currentProgressBase;
    return (function(_this) {
      return function(progress) {
        return _this.setCurrentProgress(rangeStart + (rangeEnd - rangeStart) * progress);
      };
    })(this);
  };

  ProgressAdapter.prototype._finishLastProgress = function() {
    var progress;
    if (this._currentProgress < (progress = this.currentProgressBase)) {
      return this.setCurrentProgress(progress);
    }
  };

  ProgressAdapter.prototype._executePromiseSequence = function(sequence, lastResult, index, resolve) {
    if (index >= sequence.length) {
      this._finishLastProgress();
      return resolve(lastResult);
    }
    return Promise.resolve(sequence[index](lastResult, this.makeProgressCallback())).then((function(_this) {
      return function(nextResult) {
        return _this._executePromiseSequence(sequence, nextResult, index + 1, resolve);
      };
    })(this));
  };

  ProgressAdapter.prototype.executePromiseSequence = function(sequence) {
    return new Promise((function(_this) {
      return function(resolve) {
        return _this._executePromiseSequence(sequence, null, 0, resolve);
      };
    })(this));
  };


  /*
  IN: (progressCallback, promiseSequence) ->
     * stepWeights implicitly == promiseSequence.length
  IN: (progressCallback, stepWeights, promiseSequence) ->
   */

  ProgressAdapter.executePromiseSequence = function(progressCallback, a, b) {
    var pa, sequence, weights;
    if (b) {
      weights = a;
      sequence = b;
    } else {
      sequence = a;
      weights = sequence.length;
    }
    pa = new ProgressAdapter(weights, progressCallback);
    return pa.executePromiseSequence(sequence);
  };

  ProgressAdapter.prototype._generateSteps = function() {
    var i, j, len, numSteps, ref, s, step, total, w;
    if (isNumber(numSteps = this.stepWeights)) {
      return this._steps = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = numSteps; j < ref; i = j += 1) {
          results.push(i / numSteps);
        }
        return results;
      })();
    } else {
      total = 0;
      ref = this.stepWeights;
      for (j = 0, len = ref.length; j < len; j++) {
        w = ref[j];
        total += w;
      }
      step = 0;
      return this._steps = (function() {
        var k, len1, ref1, results;
        ref1 = this.stepWeights;
        results = [];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          w = ref1[k];
          s = step;
          step += w / total;
          results.push(s);
        }
        return results;
      }).call(this);
    }
  };

  return ProgressAdapter;

})(BaseObject);


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, SingleObjectTransaction, StandardLib, cloneByStructure, eq, inspect, removeFirstMatch, rubyTrue,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

StandardLib = __webpack_require__(1);

ClassSystem = __webpack_require__(6);

cloneByStructure = StandardLib.cloneByStructure, removeFirstMatch = StandardLib.removeFirstMatch, eq = StandardLib.eq, inspect = StandardLib.inspect, rubyTrue = StandardLib.rubyTrue;

BaseObject = ClassSystem.BaseObject;

module.exports = SingleObjectTransaction = (function(superClass) {
  var setValues;

  extend(SingleObjectTransaction, superClass);

  function SingleObjectTransaction(a) {
    var options;
    SingleObjectTransaction.__super__.constructor.apply(this, arguments);
    this.object = (function() {
      if (a.constructor === Array) {
        if (a.length !== 2) {
          throw new Error("new SingleObjectTransaction: expected length-2 array like: [obj, optionsMap]");
        }
        this.options = a[1];
        return a[0];
      } else {
        this.options = {};
        return a;
      }
    }).call(this);
    if (this.object == null) {
      throw new Error("object must not be null or undefined");
    }
    this.props = [];
    this.from = {};
    options = this.options;
    if (options.properties) {
      this.addProperties(options.properties);
    }
    if (options.property) {
      this.addProp(options.property);
    }
    if (options.from) {
      this.addFromValues(options.from);
    }
    if (options.to) {
      this.addToValues(options.to);
    }
  }

  SingleObjectTransaction.prototype.toString = function() {
    return (inspect(this.object, 0)) + " from:" + (inspect(this.from, 1)) + " to:" + (inspect(this.to, 1));
  };

  SingleObjectTransaction.prototype.inspect = function(inspector) {
    var i, k, len, ref, results;
    if (!inspector) {
      return ClassSystem.Inspect.inspect(this);
    }
    inspector.put(this.object.classPathName + ":");
    ref = this.props;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      inspector.put("\n    " + k + ": ");
      if (rubyTrue(this.from && this.from[k])) {
        inspector.inspect(this.from[k], 1);
      }
      inspector.put(" ... ");
      if (rubyTrue(this.to && this.to[k])) {
        results.push(inspector.inspect(this.to[k], 1));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  SingleObjectTransaction.getter({
    properties: function() {
      return this.props;
    },
    hasToValues: function() {
      return !!this.to;
    },
    valuesChanged: function() {
      var fromValue, k, ref, toValue;
      ref = this.from;
      for (k in ref) {
        fromValue = ref[k];
        toValue = this.to[k];
        if (!eq(fromValue, toValue)) {
          return true;
        }
      }
      return false;
    }
  });

  SingleObjectTransaction.prototype.addFromValues = function(from) {
    var base, k, v;
    for (k in from) {
      v = from[k];
      this.addProp(k);
      this.from[k] = v;
    }
    return typeof (base = this.object).preprocessProperties === "function" ? base.preprocessProperties(this.from) : void 0;
  };

  SingleObjectTransaction.prototype.addToValues = function(to) {
    var base, k, v;
    this.to || (this.to = {});
    for (k in to) {
      v = to[k];
      this.addProp(k);
      this.to[k] = v;
    }
    return typeof (base = this.object).preprocessProperties === "function" ? base.preprocessProperties(this.to) : void 0;
  };

  SingleObjectTransaction.prototype.addProperties = function(props) {
    var i, len, prop, results, results1, v;
    if (props.constructor === Array) {
      results = [];
      for (i = 0, len = props.length; i < len; i++) {
        prop = props[i];
        results.push(this.addProp(prop));
      }
      return results;
    } else {
      results1 = [];
      for (prop in props) {
        v = props[prop];
        results1.push(this.addProp(prop));
      }
      return results1;
    }
  };

  SingleObjectTransaction.prototype.addProp = function(propName) {
    if (indexOf.call(this.props, propName) < 0) {
      return this.props.push(propName);
    }
  };

  SingleObjectTransaction.prototype.deleteProp = function(propName) {
    removeFirstMatch(this.props, propName);
    delete this.from[propName];
    return delete this.to[propName];
  };

  SingleObjectTransaction.prototype.saveValues = function(saveTo) {
    var getterName, i, len, metaProperties, prop, ref, ref1, value;
    this.clearOptimizations();
    metaProperties = this.object.metaProperties;
    ref = this.props;
    for (i = 0, len = ref.length; i < len; i++) {
      prop = ref[i];
      if (!saveTo.hasOwnProperty(prop)) {
        value = saveTo[prop] = cloneByStructure((getterName = metaProperties != null ? (ref1 = metaProperties[prop]) != null ? ref1.getterName : void 0 : void 0) ? this.object[getterName]() : this.object[prop]);
      }
    }
    return null;
  };

  SingleObjectTransaction.prototype.saveFromValues = function() {
    return this.saveValues(this.from || (this.from = {}));
  };

  SingleObjectTransaction.prototype.saveToValues = function() {
    return this.saveValues(this.to || (this.to = {}));
  };

  SingleObjectTransaction._setValues = setValues = function(o, values, f) {
    var metaProperties, prop, ref, setterName, v;
    metaProperties = o.metaProperties;
    for (prop in values) {
      v = values[prop];
      if (f) {
        v = f(prop, v);
      }
      if (setterName = metaProperties != null ? (ref = metaProperties[prop]) != null ? ref.setterName : void 0 : void 0) {
        o[setterName](v);
      } else {
        o[prop] = v;
      }
    }
    return null;
  };

  SingleObjectTransaction.prototype.rollBack = function() {
    return setValues(this.object, this.from);
  };

  SingleObjectTransaction.prototype.rollForward = function() {
    return setValues(this.object, this.to);
  };

  SingleObjectTransaction.prototype.clearOptimizations = function() {
    return this.numberDeltas = this.interpolateToObjects = null;
  };

  SingleObjectTransaction.prototype.optimizeInterpolation = function() {
    var field, from, ref, results, to;
    this.numberDeltas = {};
    this.interpolateToObjects = {};
    this.nonInterpolatingFields = {
      to: {},
      from: {}
    };
    ref = this.from;
    results = [];
    for (field in ref) {
      from = ref[field];
      to = this.to[field];
      if (typeof from === "number") {
        results.push(this.numberDeltas[field] = to - from);
      } else if (typeof (from != null ? from.interpolate : void 0) === "function") {
        results.push(this.interpolateToObjects[field] = to);
      } else {
        this.nonInterpolatingFields.from[field] = from;
        results.push(this.nonInterpolatingFields.to[field] = to);
      }
    }
    return results;
  };

  SingleObjectTransaction.prototype.interpolateNumberFields = function(p) {
    return setValues(this.object, this.numberDeltas, (function(_this) {
      return function(field, delta) {
        return _this.from[field] + delta * p;
      };
    })(this));
  };

  SingleObjectTransaction.prototype.interpolateObjectFields = function(p) {
    var e;
    try {
      return setValues(this.object, this.interpolateToObjects, (function(_this) {
        return function(field, toObject) {
          return _this.from[field].interpolate(toObject, p);
        };
      })(this));
    } catch (error) {
      e = error;
      this.log("Art.Foundation.Transaction#interpolateObjectFields(p=" + p + "): error " + e + " deltas: " + (inspect(this.interpolateToObjects)) + " from:   " + (inspect(this.from)) + " to:     " + (inspect(this.to)));
      throw e;
    }
  };

  SingleObjectTransaction.prototype.setNonInterpolatingFields = function(p) {
    return setValues(this.object, this.nonInterpolatingFields[p >= 1 ? "to" : "from"]);
  };

  SingleObjectTransaction.prototype.interpolate = function(p) {
    if (!this.numberDeltas) {
      this.optimizeInterpolation();
    }
    this.interpolateNumberFields(p);
    this.interpolateObjectFields(p);
    return this.setNonInterpolatingFields(p);
  };

  SingleObjectTransaction.getter({
    noChanges: function() {
      return this.props.length === 0;
    }
  });

  SingleObjectTransaction.prototype.optimizeProperties = function() {
    var i, len, prop, ref, results;
    this.clearOptimizations();
    ref = this.props;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      prop = ref[i];
      if (!this.from.hasOwnProperty(prop) || !this.to.hasOwnProperty(prop) || eq(this.from[prop], this.to[prop])) {
        results.push(this.deleteProp(prop));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  return SingleObjectTransaction;

})(BaseObject);


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, Promise, StandardLib, WebWorker, WorkerRpc, debugPrefix, isFunction, isPlainArray, isString, isWebWorker, log, mergeInto,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

StandardLib = __webpack_require__(1);

ClassSystem = __webpack_require__(6);

WebWorker = __webpack_require__(86);

Promise = StandardLib.Promise, log = StandardLib.log, isPlainArray = StandardLib.isPlainArray, isFunction = StandardLib.isFunction, isString = StandardLib.isString, mergeInto = StandardLib.mergeInto;

BaseObject = ClassSystem.BaseObject;

isWebWorker = WebWorker.isWebWorker;


/*
WorkerRPC has two modes: singleton and instanced.

SINGLETON:
  Including WorkerRPC automatically creates the singleton instance.
  In a worker, the singleton automatically binds to the worker's self.onmessage and starts listenting.
  In workers or the browser, any handler registered with the singleton will be available to respond
  to any message received by the singleton OR ANY OTHER INSTANCE of WorkerRPC in that thread.
  You can think of the singleton as the global registry for handlers.

In practice:
  In browser:
     * to register all your handlers, call this one or more times:
    WorkerRpc.register ...

     * call for each each worker you want to listen for RPC calls from,
     * and bind any remote procedures you want to be able to invoke on that specific worker-thread
    aBoundWorker = new WorkerRpc worker,
      bind: ...
      bindWithPromises: ...

     * to make remote-procedure-calls to the worker:
     * NOTE: if registered with bindWithPromises, will return a promise for the RPC's result.
    aBoundWorker.MyWorkerNamespace.myWorkerFunction ...

  In worker:
     * to register all your handlers, call this one or more times:
    WorkerRpc.register ...

     * bind any remote procedures you want to be able to invoke on the browser-thread
    WorkerRpc.bind ...
    WorkerRpc.bindWithPromises ...

NOTES:
  registered functions are invoked with @/this set to the namespace. That way you can invoke
  callback functions you previously bound back to the specific worker that invoked the
  function with: @MyWorkerNamespace.myWorkerFunction()

Real world example:

  Suppose you want to access the localStorage object on the browser thread from your worker.
  The 6 lines of code below create the 'self.asyncLocalStorage' object which works just like
  'localStorage' except it returns Art.Foundation.Promises for the function results.

  browser: (before starting the worker)
    {WorkerRpc} = Art.Foundation
    WorkerRpc.register localStorage: localStorage
    new WorkerRpc workerSourcePath

  worker:
    {workerRpc} = Art.Foundation.WorkerRpc
    workerRpc.bindWithPromises localStorage: ["getItem", "setItem", "removeItem", "clear"]
    self.asyncLocalStorage = workerRpc.localStorage

  SBD: Isn't that nice! So streamlined!

General examples:

Usage with no return value expected:
  browser thread:

    new WorkerRpc (new Worker workerUrl),
      register:
        MyMainNamespace:
          doWork: (a) -> ...

  worker thread:

    {MyMainNamespace} = new WorkerRpc self,
      bind:
        MyMainNamespace: ["doWork"]

    MyMainNamespace.doWork myStructuredData

Usage with promises:

  browser thread:

    new WorkerRpc (new Worker workerUrl),
      register:
        MyMainNamespace:
          concatStrings: (a, b) ->
            a + b
             * equivelent to: Promise.resolve a + b
             * if the result is not a Promse, Promise.resolve(result) is automatically applied

  worker thread:

    {MyMainNamespace} = new WorkerRpc self,
      bindWithPromises:
        MyMainNamespace: ["concatStrings"]

    MyMainNamespace.concatStrings "hi ", "Shane"
    .then (result) ->
       * result == "hi Shane"

Usage with arbitrary response messages:

  Sometimes you want a handle to the workerRpc instance for the thread that just send
  you the message inside your registered response functions. You can access that
  via the global: WorkerRpc.lastMessageReceivedFrom.

  browser thread:

    new WorkerRpc (new Worker workerUrl),
      register:
        MyMainNamespace:
          doWorkAndRespond: (key) ->
            count == 0
            invokeThreeTimes =>
              count++
              WorkerRpc.lastMessageReceivedFrom.MyWorkerNamespace.respond key, count

  worker thread:

    {MyMainNamespace} = new WorkerRpc self,
      register:
        MyWorkerNamespace:
          respond: (key, count) -> console.log "MyWorkerNamespace#respond: #{key} #{count}"
      bind:
        MyMainNamespace: ["doWorkAndRespond"]

    MyMainNamespace.doWorkAndRespond "myKey"

Usage - add to global registery:

  WorkerRpc.register
    MyGlobalClass:
      doSomethingNoMatterWhoCalls: ->
        ...
 */

debugPrefix = isWebWorker ? "WorkerRpc(worker)" : "WorkerRpc(browser)";

module.exports = WorkerRpc = (function(superClass) {
  var workerRpcChannelIdString;

  extend(WorkerRpc, superClass);

  WorkerRpc.singletonClass();

  WorkerRpc.workerRpcChannelIdString = workerRpcChannelIdString = "Art.Foundation.WorkerRpcChannel";

  WorkerRpc.register = function(toRegister) {
    return WorkerRpc.singleton.register(toRegister);
  };

  WorkerRpc.bind = function(toBind) {
    return WorkerRpc.singleton._bind(toBind, false);
  };

  WorkerRpc.bindWithPromises = function(toBind) {
    return WorkerRpc.singleton._bind(toBind, true);
  };


  /*
  INPUT:
    thread:
      must implement onmessage= and postMessage or be null
      In a webworker, this gets set to self if it is null.
    options:
      bind: map # invokes: @bind map
      bindWithPromises: map # invokes: @bindWithPromises map
   */

  function WorkerRpc(thread, options) {
    if (isString(thread)) {
      log("WorkerRpc starting worker: " + thread);
      thread = new Worker(thread);
      log("WorkerRpc starting worker: " + thread + ", started?:", thread);
    }
    if (!(thread || self === self.window)) {
      thread = self;
    }
    this._reset();
    this._bindOnmessage(this._thread = thread);
    if (options) {
      this._applyOptions(options);
    }
  }

  WorkerRpc.prototype.register = function(toRegister) {
    var functionMap, namespaceName;
    if (!toRegister) {
      return;
    }
    for (namespaceName in toRegister) {
      functionMap = toRegister[namespaceName];
      if (this._registry.hasOwnProperty(namespaceName)) {
        mergeInto(this._registry[namespaceName], functionMap);
      } else {
        this._registry[namespaceName] = functionMap;
      }
    }
    return this._registry;
  };


  /*
  Creates functions to make specific remote-procedure-calls.
  
  IN:
    toBind: map to arrays of strings
      Each key in the map specifies a namespace.
      The array of strings specify the names of each RPC you want to be able to invoke.
  
  For a given namespaceName and functionName, this binds the function so you can
  invoke it as follows:
    @myNamespaceName.myFunctionName()
  
  The created functions are one-way. They return null as soon as the message has been sent
  to the remote thread. If you want the results, see @bindWithPromises
   */

  WorkerRpc.prototype.bind = function(toBind) {
    return this._bind(toBind, false);
  };


  /*
  Same as @bind except each function created will return a promise which will return
  the results return from the remote procedure call when they are ready.
   */

  WorkerRpc.prototype.bindWithPromises = function(toBind) {
    return this._bind(toBind, true);
  };

  WorkerRpc.prototype._bind = function(toBind, withPromises) {
    var functionName, functionNames, i, len, namespace, namespaceName, ref;
    if (!isFunction((ref = this._thread) != null ? ref.postMessage : void 0)) {
      throw new Error("@_thread.postMessage required for remote requests");
    }
    if (!toBind) {
      return;
    }
    namespace = null;
    for (namespaceName in toBind) {
      functionNames = toBind[namespaceName];
      if (!this.hasOwnProperty(namespaceName)) {
        this[namespaceName] = {};
      }
      namespace = this[namespaceName];
      for (i = 0, len = functionNames.length; i < len; i++) {
        functionName = functionNames[i];
        namespace[functionName] = withPromises ? this._newRemoteRequestFunctionWithPromise(namespaceName, functionName) : this._newRemoteRequestFunction(namespaceName, functionName);
      }
    }
    return namespace;
  };

  WorkerRpc.prototype._reset = function() {
    return this._registry = {
      promiseCallback: {
        success: (function(_this) {
          return function(promiseId, result) {
            return WorkerRpc._resolvePromise(promiseId, result);
          };
        })(this),
        error: (function(_this) {
          return function(promiseId, error) {
            return WorkerRpc._rejectPromise(promiseId, error);
          };
        })(this)
      }
    };
  };

  WorkerRpc.prototype._applyOptions = function(arg) {
    var bind, bindWithPromises, register;
    register = arg.register, bind = arg.bind, bindWithPromises = arg.bindWithPromises;
    this.register(register);
    this.bind(bind);
    this.bindWithPromises(bindWithPromises);
    return this;
  };

  WorkerRpc.prototype._send = function(namespaceName, functionName, promiseId, args) {
    return this._thread.postMessage([workerRpcChannelIdString, namespaceName, functionName, promiseId, args]);
  };

  WorkerRpc.prototype._newRemoteRequestFunctionWithPromise = function(namespaceName, functionName) {
    return (function(_this) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return WorkerRpc._bindPromise(function(promiseId) {
          return _this._send(namespaceName, functionName, promiseId, args);
        });
      };
    })(this);
  };

  WorkerRpc.prototype._newRemoteRequestFunction = function(namespaceName, functionName) {
    return (function(_this) {
      return function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return _this._send(namespaceName, functionName, null, args);
      };
    })(this);
  };

  WorkerRpc.prototype._bindOnmessage = function(thread) {
    var handler;
    if (!thread) {
      return;
    }
    handler = (function(_this) {
      return function(arg) {
        var args, data, functionName, namespaceName, promiseId, testWorkerRpcChannelIdString;
        data = arg.data;
        if (!isPlainArray(data)) {
          return;
        }
        testWorkerRpcChannelIdString = data[0], namespaceName = data[1], functionName = data[2], promiseId = data[3], args = data[4];
        if (testWorkerRpcChannelIdString !== workerRpcChannelIdString) {
          return;
        }
        return _this._invokeLocalFunction(namespaceName, functionName, promiseId, args);
      };
    })(this);
    if (thread.addEventListener) {
      return thread.addEventListener('message', handler);
    } else {
      return thread.onmessage = handler;
    }
  };

  WorkerRpc.prototype._invokeLocalFunction = function(namespaceName, functionName, promiseId, args) {
    var localFunction, namespace, singleton;
    if (!((namespace = this._registry[namespaceName]) && (localFunction = namespace[functionName]))) {
      singleton = WorkerRpc.singleton;
      if (this !== singleton && (namespace = singleton._registry[namespaceName])) {
        localFunction = namespace[functionName];
      }
    }
    if (!localFunction) {
      console.warn(debugPrefix + "_onmessage: could not find: '" + namespaceName + "." + functionName + "'\n\nnamespaces: " + (Object.keys(this._registry).join(', ')) + "\nglobal namespaces: " + (singleton === this ? "(same)" : Object.keys(singleton._registry).join(', ')));
    }
    if (localFunction) {
      WorkerRpc.lastMessageReceivedFrom = this;
      return this._resolveOrRejectRemotePromise(promiseId, localFunction.apply(namespace, args));
    }
  };

  WorkerRpc.prototype._resolveOrRejectRemotePromise = function(promiseId, result) {
    if (promiseId == null) {
      return;
    }
    return Promise.resolve(result).then((function(_this) {
      return function(result) {
        return _this._send("promiseCallback", "success", null, [promiseId, result], function(error) {
          return _this._send("promiseCallback", "error", null, [promiseId, error]);
        });
      };
    })(this));
  };


  /*
  IN:   f: (promiseId) -> ignored
  OUT:  promise
  
  Creates a new promise, addes it to @_promises with a unique id, and invokes f, passing in
  the promise's id.
   */

  WorkerRpc._promises = {};

  WorkerRpc._nextPromiseId = 0;

  WorkerRpc._bindPromise = function(f) {
    var promise, promiseId;
    this._promises[promiseId = this._nextPromiseId++] = promise = Promise.newExternallyResolvable();
    f(promiseId);
    return promise;
  };

  WorkerRpc._resolvePromise = function(promiseId, result) {
    var ref;
    if ((ref = this._promises[promiseId]) != null) {
      ref.resolve(result);
    }
    return delete this._promises[promiseId];
  };

  WorkerRpc._rejectPromise = function(promiseId, error) {
    var ref;
    if ((ref = this._promises[promiseId]) != null) {
      ref.reject(error);
    }
    return delete this._promises[promiseId];
  };

  return WorkerRpc;

})(BaseObject);


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(284);

module.exports.includeInNamespace(__webpack_require__(485)).addModules({
  Analytics: __webpack_require__(480),
  AsyncLocalStorage: __webpack_require__(278),
  BatchLoader: __webpack_require__(481),
  GlobalCounts: __webpack_require__(279),
  InstanceFunctionBindingMixin: __webpack_require__(482),
  JsonStore: __webpack_require__(483),
  ProgressAdapter: __webpack_require__(280),
  SingleObjectTransaction: __webpack_require__(281),
  Stat: __webpack_require__(484),
  Transaction: __webpack_require__(486),
  WebWorker: __webpack_require__(86),
  WorkerRpc: __webpack_require__(282)
});


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

var Tools,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(87)).addNamespace('Tools', Tools = (function(superClass) {
  extend(Tools, superClass);

  function Tools() {
    return Tools.__super__.constructor.apply(this, arguments);
  }

  return Tools;

})(Neptune.PackageNamespace));


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(497);


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var defineModule, each, isPlainObject, log, merge, mergeInto, object, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, object = ref.object, each = ref.each, isPlainObject = ref.isPlainObject, merge = ref.merge, mergeInto = ref.mergeInto;

defineModule(module, function() {
  return function(superClass) {
    var PropFieldsMixin;
    return PropFieldsMixin = (function(superClass1) {
      var normalizePropFieldValue, sf;

      extend(PropFieldsMixin, superClass1);

      function PropFieldsMixin() {
        return PropFieldsMixin.__super__.constructor.apply(this, arguments);
      }

      normalizePropFieldValue = function(name, value) {
        return {
          "default": value
        };
      };

      PropFieldsMixin.extendableProperty({
        propFields: null,
        extend: function(extendedValue, addPropFields) {
          return mergeInto(extendedValue != null ? extendedValue : {}, addPropFields);
        }
      });


      /*
      Declare prop fields you intend to use.
      IN: fields
        map from field names to:
          default-values
      
      FUTURE-NOTE:
        If we decide we want more options than just 'default-values',
        we can add a new declarator: @propFieldsWithOptions
        where the map-to-values must all be options objects.
      
      EFFECTS:
        used to define getters for @prop
       */

      PropFieldsMixin.propFields = sf = function(fields) {
        this.extendPropFields(fields);
        return each(fields, (function(_this) {
          return function(defaultValue, field) {
            return _this.addGetter(field, function() {
              return this.props[field];
            });
          };
        })(this));
      };

      PropFieldsMixin.propField = sf;

      PropFieldsMixin.prototype._preprocessProps = function(props) {
        var k, out, propFields, v;
        if (propFields = this.getPropFields()) {
          out = {};
          for (k in propFields) {
            v = propFields[k];
            out[k] = v;
          }
          for (k in props) {
            v = props[k];
            out[k] = v;
          }
          return out;
        } else {
          return props;
        }
      };

      return PropFieldsMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {


/*
This current iteration of clone relies on some singleton variables shared across all invocations of clone.
This is fine as long as javascript stays single-threaded.
It also introduces a little bit of uglyness initializing clonedMap necessitating the "top" variable.

FUTURE
A potentially better solution would be to create a new closer each time clone is called at the top-most level,
but when recursing, pass in a new function bound to that closure which is different from the global clone function.

populateClone would need to take an additional argument - the clone function to use for recursive cloning.
 */
var Clone, Map, Unique, byProperties, byStructure, clonedMap, inspect, topObject, uniquePropertyName;

Map = __webpack_require__(94);

Unique = __webpack_require__(151);

inspect = __webpack_require__(30).inspect;

uniquePropertyName = Unique.PropertyName;

clonedMap = null;

byStructure = false;

byProperties = false;

topObject = null;

module.exports = Clone = (function() {
  var clone, cloneArray, cloneByProperties, cloneByStructure, cloneObject, emptyClone;

  function Clone() {}

  cloneArray = function(array) {
    var clonedArray, i, index, len, value;
    clonedMap.set(array, clonedArray = array.slice());
    for (index = i = 0, len = clonedArray.length; i < len; index = ++i) {
      value = clonedArray[index];
      clonedArray[index] = clone(value);
    }
    return clonedArray;
  };

  cloneObject = function(obj) {
    var clonedObject, k, v;
    clonedMap.set(obj, clonedObject = emptyClone(obj));
    if ((obj !== topObject || !byProperties) && obj.populateClone) {
      obj.populateClone(clonedObject);
    } else {
      for (k in obj) {
        v = obj[k];
        clonedObject[k] = clone(v);
      }
    }
    return clonedObject;
  };

  Clone.emptyClone = emptyClone = function(obj) {
    if (obj.constructor === Array) {
      return [];
    } else {
      return Object.create(Object.getPrototypeOf(obj));
    }
  };

  Clone.clone = clone = function(obj, mode) {
    var clonedObject, got;
    switch (mode) {
      case "byStructure":
        byStructure = true;
        break;
      case "byProperties":
        byProperties = true;
    }
    if (obj === null || obj === void 0 || typeof obj !== "object") {
      return obj;
    }
    if (byStructure && (obj.constructor !== Array && obj.constructor !== Object)) {
      return obj;
    }
    if (clonedMap) {
      if (got = clonedMap.get(obj)) {
        return got;
      }
    } else {
      topObject = obj;
      clonedMap = new Map;
    }
    clonedObject = obj.constructor === Array ? cloneArray(obj) : cloneObject(obj);
    if (topObject === obj) {
      byStructure = false;
      byProperties = false;
      topObject = null;
      clonedMap = null;
    }
    return clonedObject;
  };

  Clone.cloneByProperties = cloneByProperties = function(obj) {
    return clone(obj, "byProperties");
  };

  Clone.cloneByStructure = cloneByStructure = function(obj) {
    return clone(obj, "byStructure");
  };

  return Clone;

})();


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

var Merge, compactFlatten, isPlainObject;

compactFlatten = __webpack_require__(90).compactFlatten;

isPlainObject = __webpack_require__(43).isPlainObject;

module.exports = Merge = (function() {
  var deepMerge, merge, mergeInto, pureMerge;

  function Merge() {}


  /*
  
  merge "flattens" its arguments and then adds all keys from all objects in
  the list into a new object which is returned.
  
  return: new object
  
  The first object's keys are added first. If two or more objects have the same
  keys, the value set in the result is the last object's in the list with that key.
   */

  Merge.merge = merge = function() {
    return mergeInto({}, arguments);
  };


  /*
  The same as 'merge' with one difference:
  
  Instead of a new object, all objects are merged into the first object in the list.
  
  return: first object in the flattened list
  return: null if no source objects
   */

  Merge.mergeInto = mergeInto = function() {
    var j, k, len, result, source, sources, v;
    sources = compactFlatten(arguments);
    if (sources.length === 0) {
      return null;
    }
    result = sources[0] || {};
    for (j = 0, len = sources.length; j < len; j++) {
      source = sources[j];
      if (source !== result) {
        for (k in source) {
          v = source[k];
          if (v !== void 0) {
            result[k] = v;
          }
        }
      }
    }
    return result;
  };


  /*
  Just like mergeInfo except only merge into the result object
  UNLESS 'result' already has that property with a non-undefined value.
  
  if
    mergeInfo a, b is just like merge a, b except it modifies and returns a instead of returning a new object
  then
    mergeIntoUnless b, a is just like merge a, b except it modifies and returns b instead of returning a new object
  
  Note: mergeIntoUnless a, b, c, d, e, f is like merge f, e, d, c, b, a
   */

  Merge.mergeIntoUnless = function() {
    var i, j, k, ref, result, source, sources, v;
    sources = compactFlatten(arguments);
    if (sources.length === 0) {
      return null;
    }
    result = sources[0] || {};
    for (i = j = 1, ref = sources.length; j < ref; i = j += 1) {
      source = sources[i];
      for (k in source) {
        v = source[k];
        if (result[k] === void 0) {
          result[k] = v;
        }
      }
    }
    return result;
  };

  Merge.deepMerge = deepMerge = function() {
    var k, list, out, v, val;
    list = compactFlatten(arguments);
    out = merge(list);
    for (k in out) {
      v = out[k];
      if (isPlainObject(v)) {
        out[k] = deepMerge((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = list.length; j < len; j++) {
            val = list[j];
            results.push(val[k]);
          }
          return results;
        })());
      }
    }
    return out;
  };

  Merge.hasAllProps = function(o1, o2) {
    var k, v;
    for (k in o1) {
      v = o1[k];
      if (!o2.hasOwnProperty(k)) {
        return false;
      }
    }
    return true;
  };

  Merge.pureMerge = pureMerge = function() {
    var j, last, len, source, sources;
    sources = compactFlatten(arguments);
    if (sources.length === 0) {
      return null;
    }
    if (sources.length === 1) {
      return sources[0];
    }
    last = sources[sources.length - 1];
    for (j = 0, len = sources.length; j < len; j++) {
      source = sources[j];
      if (source !== last) {
        if (!Merge.hasAllProps(source, last)) {
          return Merge.merge(sources);
        }
      }
    }
    return last;
  };


  /*
  I might consider adding "o" - which works like Object-Tree constructors:
    First, it compact-flattens args
    Second, it gathers up and merges all plain-objects in its arguments list
    Last, all remaining items get added to the "children" list
  The question is, what does it return? Options:
  
    OPTION: If only plain-objects after compact-flatten, just return the merged object ELSE:
  
  Options if both objects and non-object values are present:
    a. return compactFlatten [plainObject, nonObjectValues]
    b. return merge plainObject, children: nonObjectValues
    c. return new MClass plainObject, nonObjectValues
      class MClass extends BaseObject
        @properties "props children"
        constructor: (@props, @children) ->
   */

  Merge.m = pureMerge;

  return Merge;

})();


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

var StringCase, compactFlatten;

compactFlatten = __webpack_require__(90).compactFlatten;

module.exports = StringCase = (function() {
  var getCodeWords;

  function StringCase() {}

  StringCase.getCodeWords = getCodeWords = function(str) {
    var _words, word, words;
    if (!(_words = str != null ? str.match(/[a-zA-Z][a-zA-Z0-9]*|[0-9]+/g) : void 0)) {
      return [];
    }
    words = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = _words.length; i < len; i++) {
        word = _words[i];
        results.push(word.match(/(?:[A-Z]{2,}(?![a-z]))|[A-Z][a-z0-9]*|[a-z0-9]+/g));
      }
      return results;
    })();
    return compactFlatten(words);
  };

  StringCase.codeWords = getCodeWords;

  StringCase.lowerCase = function(str) {
    return str != null ? str.toLocaleLowerCase() : void 0;
  };

  StringCase.upperCase = function(str) {
    return str != null ? str.toLocaleUpperCase() : void 0;
  };

  StringCase.capitalize = function(str) {
    return StringCase.upperCase(str.charAt(0)) + str.slice(1);
  };

  StringCase.decapitalize = function(str) {
    return StringCase.lowerCase(str.charAt(0)) + str.slice(1);
  };

  StringCase.getLowerCaseCodeWords = function(str) {
    var i, len, ref, results, word;
    ref = StringCase.getCodeWords(str);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      word = ref[i];
      results.push(StringCase.lowerCase(word));
    }
    return results;
  };

  StringCase.getCapitalizedCodeWords = function(str) {
    var i, len, ref, results, word;
    ref = StringCase.getCodeWords(str);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      word = ref[i];
      results.push(StringCase.capitalize(StringCase.lowerCase(word)));
    }
    return results;
  };

  StringCase.upperCamelCase = function(str, joiner) {
    var word;
    if (joiner == null) {
      joiner = "";
    }
    return ((function() {
      var i, len, ref, results;
      ref = this.getLowerCaseCodeWords(str);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        word = ref[i];
        results.push(this.capitalize(word));
      }
      return results;
    }).call(StringCase)).join(joiner);
  };

  StringCase.lowerCamelCase = function(str, joiner) {
    if (joiner == null) {
      joiner = "";
    }
    return StringCase.decapitalize(StringCase.upperCamelCase(str, joiner));
  };

  StringCase.snakeCase = function(str) {
    return (StringCase.getLowerCaseCodeWords(str)).join("_");
  };

  StringCase.dashCase = function(str) {
    return (StringCase.getLowerCaseCodeWords(str)).join("-");
  };

  StringCase.capitalizedDashCase = function(str) {
    return (StringCase.getCapitalizedCodeWords(str)).join("-");
  };

  return StringCase;

})();


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

var Core,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(152)).addNamespace('Core', Core = (function(superClass) {
  extend(Core, superClass);

  function Core() {
    return Core.__super__.constructor.apply(this, arguments);
  }

  return Core;

})(Neptune.PackageNamespace));


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ErrorWithInfo, defineModule, formattedInspect, isFunction, mergeInto, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

defineModule = __webpack_require__(42).defineModule;

formattedInspect = __webpack_require__(30).formattedInspect;

ref = __webpack_require__(16), mergeInto = ref.mergeInto, isFunction = ref.isFunction;

defineModule(module, ErrorWithInfo = (function(superClass) {
  extend(ErrorWithInfo, superClass);

  function ErrorWithInfo(message, info, name) {
    this.info = info;
    this.name = name;
    ErrorWithInfo.__super__.constructor.apply(this, arguments);
    this.name || (this.name = "ErrorWithInfo");
    mergeInto(this, this.info);
    this.message = message;
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = (new Error).stack;
    }
  }

  ErrorWithInfo.prototype.toString = function() {
    return [
      "ErrorWithInfo: " + this.message, formattedInspect({
        info: this.info
      })
    ].join("\n\n");
  };

  return ErrorWithInfo;

})(Error));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 292 */
/***/ (function(module, exports) {

var Function;

module.exports = Function = (function() {
  function Function() {}

  Function.fastBind = function(fn, _this) {
    switch (fn.length) {
      case 0:
        return function() {
          return fn.call(_this);
        };
      case 1:
        return function(a) {
          return fn.call(_this, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(_this, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(_this, a, b, c);
        };
      case 4:
        return function(a, b, c, d) {
          return fn.call(_this, a, b, c, d);
        };
      case 5:
        return function(a, b, c, d, e) {
          return fn.call(_this, a, b, c, d, e);
        };
      case 6:
        return function(a, b, c, d, e, f) {
          return fn.call(_this, a, b, c, d, e, f);
        };
      case 7:
        return function(a, b, c, d, e, f, g) {
          return fn.call(_this, a, b, c, d, e, f, g);
        };
      case 8:
        return function(a, b, c, d, e, f, g, h) {
          return fn.call(_this, a, b, c, d, e, f, g, h);
        };
      case 9:
        return function(a, b, c, d, e, f, g, h, i) {
          return fn.call(_this, a, b, c, d, e, f, g, h, i);
        };
      case 10:
        return function(a, b, c, d, e, f, g, h, i, j) {
          return fn.call(_this, a, b, c, d, e, f, g, h, i, j);
        };
      default:
        return function() {
          return fn.apply(_this, arguments);
        };
    }
  };

  return Function;

})();


/*
PERFORMANCE 2017-09-22
  Faster with normal bind:
    Chrome: 4x
    Edge: 2x
  Faster with fastBind
    FF: 7.8x faster
    Safari:
      OSX:  12.4x
      iOS:  11x
  Android:
    S8 Samsung browser: fastBindFaster: 6.5
    S8: normalBindFaster: 4x
 */


/*
TODO:

The above options are not hot-reload compatible. However, this alternative would be:

  name = fn.name
  -> _this[name].apply _this, arguments

I need to perf-test this. Or, I need to finally start using a global "debug" mode that could use this
in debug mode and the faster(?), non hot-reload options in production mode.
 */


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var FormattedInspect, alignTabs, ansiRegex, ansiSafeStringLength, colorNames, colorizeFunctions, escapeForBlockString, escapeJavascriptString, formattedInspectArray, formattedInspectObject, formattedInspectRecursive, formattedInspectString, identity, indentLength, indentString, inspect, isFunction, isNumber, isPlainArray, isPlainObject, isString, max, newLineWithIndentString, object, objectKeyCount, pad, passThroughColorizeFunctions, postWhitespaceFormatting, ref, ref1, stripAnsi, stripTrailingWhitespace, toInspectedObjects, w;

ref = __webpack_require__(12), isString = ref.isString, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, isFunction = ref.isFunction, isNumber = ref.isNumber;

max = Math.max;

ref1 = __webpack_require__(32), pad = ref1.pad, stripTrailingWhitespace = ref1.stripTrailingWhitespace, escapeJavascriptString = ref1.escapeJavascriptString;

inspect = __webpack_require__(148).inspect;

objectKeyCount = __webpack_require__(59).objectKeyCount;

toInspectedObjects = __webpack_require__(147).toInspectedObjects;

w = __webpack_require__(57).w;

object = __webpack_require__(93).object;

indentString = '  ';

indentLength = indentString.length;

newLineWithIndentString = "\n" + indentString;

formattedInspectObject = function(m, maxLineLength, options) {
  var colorize, finalInspectedValues, forceMultilineOutput, index, inspected, inspectedLength, inspectedValues, k, key, keyCount, objectStart, shouldBeOnOwnLine, v, value;
  colorize = options.colorize;
  inspectedLength = 0;
  forceMultilineOutput = false;
  shouldBeOnOwnLine = false;
  keyCount = 0;
  inspectedValues = (function() {
    var results;
    results = [];
    for (key in m) {
      value = m[key];
      keyCount++;
      inspected = formattedInspectRecursive(value, maxLineLength - indentLength, options);
      if (inspected.match(/\n/)) {
        inspected = inspected.match(/^\[\]/) ? "" + inspected : newLineWithIndentString + inspected.replace(/\n/g, newLineWithIndentString);
        if (!/\n\s*$/.test(inspected)) {
          inspected += "\n";
        }
      } else if (ansiSafeStringLength(inspected) > maxLineLength - (key.length + 2)) {
        inspected = "" + newLineWithIndentString + inspected + "\n";
      }
      if (!/^[-~!@\#$%^&*_+=|\\<>?\/.$\w\u007f-\uffff]+$/.test(key)) {
        key = inspect(key);
      }
      inspectedLength += ansiSafeStringLength(inspected) + key.length + 2;
      forceMultilineOutput || (forceMultilineOutput = shouldBeOnOwnLine);
      shouldBeOnOwnLine = inspected.length > 100 || !inspected.match(/^([^,:]|\(.*\)|\{.*\}|\".*\"|\'.*\'|\[.*\])*$/);
      results.push([key, inspected, value]);
    }
    return results;
  })();
  objectStart = "{}";
  objectStart = colorize.grey(objectStart);
  if (keyCount === 0) {
    return objectStart;
  } else {
    index = 0;
    finalInspectedValues = (function() {
      var j, len, ref2, results;
      results = [];
      for (j = 0, len = inspectedValues.length; j < len; j++) {
        ref2 = inspectedValues[j], k = ref2[0], v = ref2[1], value = ref2[2];
        key = k + ":";
        key = colorize.blue(key);
        results.push(key + "\t" + v);
      }
      return results;
    })();
    return finalInspectedValues.join(!forceMultilineOutput && maxLineLength >= inspectedLength + (inspectedValues.length - 1) * 2 ? ",\t" : "\n");
  }
};

formattedInspectArray = function(m, maxLineLength, options) {
  var arrayStart, colorize, i, inspected, inspectedHasNewlines, inspectedValues, inspectedValuesContainNewlines, j, lastWasArray, lastWasObject, len, lengthOfCommas, lengthOfInspectedValues, lengthOfStartBrackets, objectStart, objectsMustBeExplicit, oneLinerOk, value;
  colorize = options.colorize;
  lengthOfInspectedValues = 0;
  lastWasObject = false;
  lastWasArray = false;
  objectsMustBeExplicit = false;
  oneLinerOk = true;
  inspectedValuesContainNewlines = false;
  for (i = j = 0, len = m.length; j < len; i = ++j) {
    value = m[i];
    if (isPlainObject(value)) {
      if (i < m.length - 1) {
        oneLinerOk = false;
      }
      if (lastWasObject) {
        objectsMustBeExplicit = true;
      }
      lastWasObject = true;
    } else {
      lastWasObject = false;
    }
  }
  inspectedValues = (function() {
    var l, len1, results;
    results = [];
    for (l = 0, len1 = m.length; l < len1; l++) {
      value = m[l];
      if (lastWasArray) {
        oneLinerOk = false;
      }
      if (isPlainArray(value)) {
        lastWasArray = true;
      }
      inspected = formattedInspectRecursive(value, maxLineLength - indentLength, options);
      inspectedHasNewlines = /\n/.test(inspected);
      if (objectsMustBeExplicit && isPlainObject(value)) {
        objectStart = "{}";
        objectStart = colorize.grey(objectStart);
        inspected = inspectedHasNewlines ? "" + objectStart + newLineWithIndentString + (inspected.replace(/\n/g, newLineWithIndentString)) : objectStart + " " + inspected;
      }
      if (inspectedHasNewlines) {
        oneLinerOk = false;
        inspected = inspected.replace(/\n/g, newLineWithIndentString);
        if (!/\n\s*$/.test(inspected)) {
          inspected += "\n";
        }
      }
      lengthOfInspectedValues += ansiSafeStringLength(inspected);
      results.push(inspected);
    }
    return results;
  })();
  lengthOfCommas = (inspectedValues.length - 1) * 2;
  lengthOfStartBrackets = 3;
  arrayStart = "[]";
  arrayStart = colorize.grey(arrayStart);
  if (oneLinerOk && maxLineLength >= lengthOfStartBrackets + lengthOfCommas + lengthOfInspectedValues) {
    if (inspectedValues.length === 0) {
      return arrayStart;
    } else {
      return arrayStart + " " + (inspectedValues.join(",\t"));
    }
  } else {
    return arrayStart + "\n  " + (inspectedValues.join("\n  "));
  }
};

escapeForBlockString = (function(_this) {
  return function(str) {
    return String(str).replace(/[\\\0\b\f\r\t\v\u001b\u2028\u2029]/g, function(x) {
      switch (x) {
        case '\\':
          return '\\\\';
        case '\0':
          return "\\0";
        case '\b':
          return "\\b";
        case '\f':
          return "\\f";
        case '\r':
          return "\\r";
        case '\t':
          return "\\t";
        case '\v':
          return "\\v";
        case '\u2028':
          return "\\u2028";
        case '\u2029':
          return "\\u2029";
        case '\u001b':
          return '\\u001b';
      }
    });
  };
})(this);

formattedInspectString = function(m, options) {
  var out;
  out = m.match(/\n/) && !m.match(/\ (\n|$)/) ? ('"""' + newLineWithIndentString + escapeForBlockString(m).replace(/\n/g, newLineWithIndentString)).replace(/\ +\n/g, '\n') : escapeJavascriptString(m);
  return options.colorize.green(out);
};

formattedInspectRecursive = function(m, maxLineLength, options) {
  if (isPlainObject(m)) {
    return formattedInspectObject(m, maxLineLength, options);
  } else if (isPlainArray(m)) {
    return formattedInspectArray(m, maxLineLength, options);
  } else if (isString(m)) {
    return formattedInspectString(m, options);
  } else {
    return options.colorize.yellow(inspect(m));
  }
};


/*
TODO:

  special mode for a chunk of lines that all have this pattern:

    /^\s*([a-z]:\t)*[^\t]+$/

  Example:
    hi: there: my: friends: "my value"
    somethingElseIThough: indexAllMyThings: withThis: "foo"

  Currently that becomes:
    hi:                   there:            my:       friends: "my value"
    somethingElseIThough: indexAllMyThings: withThis: "foo"

  Which is pretty awkward. I want:
    hi: there: my: friends:                           "my value"
    somethingElseIThough: indexAllMyThings: withThis: "foo"

  Basically, replace all but the last tab with a space.

  But only if ALL lines in a chunk are this pattern.

  CounterExample:
    properties:
      autoTags:          type: "text", analyzer: "standard"
      autoText:          type: "text", analyzer: "english"
      updatedAt:         type: "long"
      createdAt:         type: "long"
      title:             type: "text", analyzer: "english"
      userId:            type: "keyword"
      lastPostCreatedAt: type: "long"
      lastPostId:        type: "keyword"
      lastChapterPostId: type: "keyword"
      postCount:         type: "integer"
      followerCount:     type: "integer"
      activityCount:     type: "long"
      messageCount:      type: "long"
      isProfileTopic:    type: "boolean"
      private:           type: "boolean"

  Should NOT look like this:
    properties:
      autoTags:                type: "text", analyzer: "standard"
      autoText:                type: "text", analyzer: "english"
      updatedAt: type:         "long"
      createdAt: type:         "long"
      title:                   type: "text", analyzer: "english"
      userId: type:            "keyword"
      lastPostCreatedAt: type: "long"
      lastPostId: type:        "keyword"
      lastChapterPostId: type: "keyword"
      postCount: type:         "integer"
      followerCount: type:     "integer"
      activityCount: type:     "long"
      messageCount: type:      "long"
      isProfileTopic: type:    "boolean"
      private: type:           "boolean"
 */

alignTabs = function(linesString, maxLineLength) {
  var alignedLines, el, elLength, elements, expandAmount, i, j, l, len, len1, line, lines, maxColumnSizes, maxColumnWidth, r, spaceAvailable, tabStops;
  if (maxLineLength == null) {
    maxLineLength = 10000;
  }
  tabStops = 1;
  lines = linesString.split("\n");
  maxColumnSizes = [];
  maxColumnWidth = maxLineLength / 2;
  for (j = 0, len = lines.length; j < len; j++) {
    line = lines[j];
    if ((elements = line.split("\t")).length > 1) {
      for (i = l = 0, len1 = elements.length; l < len1; i = ++l) {
        el = elements[i];
        if (!(i < elements.length - 1 && (i === 0 || ansiSafeStringLength(el) < maxColumnWidth))) {
          continue;
        }
        if (maxColumnSizes.length === i) {
          maxColumnSizes.push(0);
        }
        maxColumnSizes[i] = max(maxColumnSizes[i], ansiSafeStringLength(el) + 1);
      }
    }
  }
  alignedLines = (function() {
    var len2, n, results;
    results = [];
    for (n = 0, len2 = lines.length; n < len2; n++) {
      line = lines[n];
      spaceAvailable = maxLineLength - ansiSafeStringLength(line);
      elements = line.split("\t");
      r = (function() {
        var len3, o, results1;
        if (elements.length > 1) {
          results1 = [];
          for (i = o = 0, len3 = elements.length; o < len3; i = ++o) {
            el = elements[i];
            elLength = ansiSafeStringLength(el);
            if (i === elements.length - 1) {
              results1.push(el);
            } else if ((maxColumnSizes[i] != null) && (expandAmount = maxColumnSizes[i] - elLength - 1) <= spaceAvailable) {
              spaceAvailable -= expandAmount;
              results1.push(el + pad('', maxColumnSizes[i] - elLength));
            } else {
              spaceAvailable = 0;
              results1.push(el + " ");
            }
          }
          return results1;
        } else {
          return elements;
        }
      })();
      results.push(r.join(""));
    }
    return results;
  })();
  return alignedLines.join("\n");
};

ansiRegex = /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;

stripAnsi = function(str) {
  if (ansiRegex.test(str)) {
    return str.replace(ansiRegex, '');
  } else {
    return str;
  }
};

ansiSafeStringLength = function(str) {
  if (!isString(str)) {
    throw new Error("not string");
  }
  if (ansiRegex.test(str)) {
    str = str.replace(ansiRegex, '');
  }
  return str.length;
};

postWhitespaceFormatting = function(maxLineLength, string) {
  var alignTabsInSameIndentGroup, indent, j, lastIndent, len, line, outLines, ref2, sameIndentGroup;
  lastIndent = 0;
  sameIndentGroup = [];
  outLines = [];
  alignTabsInSameIndentGroup = function() {
    var str;
    if (!(0 < sameIndentGroup.length)) {
      return;
    }
    str = sameIndentGroup.join("\n");
    sameIndentGroup = [];
    return outLines.push(alignTabs(str, maxLineLength));
  };
  ref2 = string.split("\n");
  for (j = 0, len = ref2.length; j < len; j++) {
    line = ref2[j];
    line = line.replace(/\s+$/g, '');
    if (lastIndent !== (indent = ansiSafeStringLength(line.match(/^ *-?/)[0]))) {
      alignTabsInSameIndentGroup();
    }
    sameIndentGroup.push(line);
    lastIndent = indent;
  }
  alignTabsInSameIndentGroup();
  return outLines.join('\n');
};

colorNames = w("red yellow green blue grey");

colorizeFunctions = object(colorNames, function(c) {
  return function(str) {
    var ref2;
    return (ref2 = str[c]) != null ? ref2 : str;
  };
});

identity = function(s) {
  return s;
};

passThroughColorizeFunctions = object(colorNames, function() {
  return identity;
});

module.exports = FormattedInspect = (function() {
  function FormattedInspect() {}

  FormattedInspect.ansiRegex = ansiRegex;

  FormattedInspect.stripAnsi = stripAnsi;

  FormattedInspect.ansiSafeStringLength = ansiSafeStringLength;

  FormattedInspect.alignTabs = alignTabs;

  FormattedInspect.formattedInspectString = formattedInspectString;

  FormattedInspect.formattedInspect = function(toInspect, options) {
    var error, maxLineLength, out, ref2, ref3;
    if (options == null) {
      options = {};
    }
    try {
      if (isNumber(options)) {
        options = {
          maxLineLength: options
        };
      } else {
        if (!isPlainObject(options)) {
          console.error({
            invalid: {
              options: options
            }
          });
          throw new Error("invalid options object type: " + (typeof options));
        }
      }
      if (options.maxLineLength == null) {
        options.maxLineLength = ((ref2 = global.process) != null ? (ref3 = ref2.stdout) != null ? ref3.columns : void 0 : void 0) || 80;
      }
      maxLineLength = options.maxLineLength;
      options.colorize = options.color ? colorizeFunctions : passThroughColorizeFunctions;
      return out = postWhitespaceFormatting(maxLineLength, formattedInspectRecursive(toInspectedObjects(toInspect), maxLineLength, options)).replace(/\n\n$/, "\n");
    } catch (error1) {
      error = error1;
      console.error(out = "Error in formattedInspect", {
        error: error,
        toInspect: toInspect,
        options: options
      });
      return out;
    }
  };

  return FormattedInspect;

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(295);

module.exports.addModules({
  Array: __webpack_require__(513),
  Core: __webpack_require__(514),
  Object: __webpack_require__(515),
  String: __webpack_require__(516)
});


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

var Inspected,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(92)).addNamespace('Inspected', Inspected = (function(superClass) {
  extend(Inspected, superClass);

  function Inspected() {
    return Inspected.__super__.constructor.apply(this, arguments);
  }

  return Inspected;

})(Neptune.PackageNamespace));


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

var PlainObjects, deepMap, hasKeys, inspectedObjectLiteral, isClass, isFunction, isPlainArray, isPlainObject, ref;

ref = __webpack_require__(12), deepMap = ref.deepMap, hasKeys = ref.hasKeys, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject, isFunction = ref.isFunction, isClass = ref.isClass;

inspectedObjectLiteral = __webpack_require__(91).inspectedObjectLiteral;

module.exports = PlainObjects = (function() {
  var toPlainObjects;

  function PlainObjects() {}

  PlainObjects.toPlainObjects = toPlainObjects = function(m) {
    var functionString, oldm, out, reducedFunctionString;
    if (m == null) {
      return m;
    }
    oldm = m;
    if (out = typeof m.getPlainObjects === "function" ? m.getPlainObjects() : void 0) {
      return out;
    } else if (isPlainObject(m) || isPlainArray(m)) {
      return deepMap(m, function(v) {
        return toPlainObjects(v);
      });
    } else if (isClass(m)) {
      return inspectedObjectLiteral("<" + (m.getName()) + ">");
    } else if (isFunction(m)) {
      functionString = "" + m;
      reducedFunctionString = functionString.replace(/\s+/g, ' ').replace(/^function (\([^)]*\))/, "$1 ->").replace(/^\(\)\s*/, '');
      return inspectedObjectLiteral(reducedFunctionString.length < 80 ? reducedFunctionString : functionString.slice(0, 5 * 80));
    } else {
      return m;
    }
  };

  return PlainObjects;

})();


/***/ }),
/* 297 */
/***/ (function(module, exports) {

var MapExtensions;

module.exports = MapExtensions = (function() {
  function MapExtensions() {}

  MapExtensions.iteratorToArray = function(iterator) {
    var obj, out;
    out = [];
    while (!(obj = iterator.next()).done) {
      out.push(obj.value);
    }
    return out;
  };

  MapExtensions.mapToKeysArray = function(map) {
    return MapExtensions.iteratorToArray(map.keys());
  };

  MapExtensions.mapToValuesArray = function(map) {
    return MapExtensions.iteratorToArray(map.values());
  };

  return MapExtensions;

})();


/***/ }),
/* 298 */
/***/ (function(module, exports) {

var ObjectDiff;

module.exports = ObjectDiff = (function() {
  var defaultEq;

  function ObjectDiff() {}

  defaultEq = function(a, b) {
    return a === b;
  };


  /*
  SBD this has been thouroughly benchmarked on Safari and Chrome as of 2015-11-06
  This is as fast as I could make it.
  
  IN:
    newObj:   the changed-to object   (must be set)
    oldObj:   the changed-from object (default: {})
    added:    (key, newValue) -> null
              called for each key in newObj that was not in oldObj
    removed:  (key, oldValue) -> null
              called for each key in oldObj that is not in newObj
    changed:  (key, newValue, oldValue) -> null
              called for each key in both where the value changed
    noChange: (key, value) -> null
              called for each key in both where the value stayed the same
    eqTester: (a, b) -> true if a is equal to b
              DEFAULT: use javascript ===
              provided for custom concepts of equality
    oldObjKeyCount: null or a the number of keys in oldObj
      This last field provides an opportunity for further performance improvement.
      If you have previously computed the number of keys in oldObj, pass it in.
      Counting the number of keys in an object can be slow. If we know the number
      of keys this routine can be more efficient.
  
      NOTE that this function returns the key-count of the new object. That way if you
      are calling objecfDiff several times over a sequence of object changes, can you keep
      the results from this function, you already have the oldObjKeyCount for the next call.
  
  OUT: newObjKeyCount - number of keys in the new object
   */

  ObjectDiff.objectDiff = function(newObj, oldObj, added, removed, changed, noChange, eqTester, oldObjKeyCount) {
    var k, newObjKeyCount, newValue, oldObjKeyCountIsAtLeast, oldValue;
    if (eqTester == null) {
      eqTester = defaultEq;
    }
    newObjKeyCount = 0;
    if (!oldObj) {
      for (k in newObj) {
        newValue = newObj[k];
        newObjKeyCount++;
        added(k, newValue);
      }
      return newObjKeyCount;
    }
    oldObjKeyCountIsAtLeast = 0;
    for (k in newObj) {
      newValue = newObj[k];
      newObjKeyCount++;
      if (typeof (oldValue = oldObj[k]) !== "undefined" || oldObj.hasOwnProperty(k)) {
        oldObjKeyCountIsAtLeast++;
        if (!eqTester(newValue, oldValue)) {
          changed(k, newValue, oldValue);
        } else {
          if (typeof noChange === "function") {
            noChange(k, newValue);
          }
        }
      } else {
        added(k, newValue);
      }
    }
    if (!(oldObjKeyCount != null) || oldObjKeyCountIsAtLeast !== oldObjKeyCount) {
      for (k in oldObj) {
        if (!(typeof newObj[k] !== "undefined" || newObj.hasOwnProperty(k))) {
          removed(k, oldObj[k]);
        }
      }
    }
    return newObjKeyCount;
  };


  /*
  IN:
    newObj, oldObj, eqTester >> see above
  OUT:
    no changes: null
    otherwise:
      added:    key: addedItem
      removed:  key: removedItem
      changed:  key: {oldItem, newItem}
   */

  ObjectDiff.objectDiffReport = function(newObj, oldObj, eqTester) {
    var added, changed, different, removed;
    added = {};
    removed = {};
    changed = {};
    different = null;
    ObjectDiff.objectDiff(newObj, oldObj, function(key, addedItem) {
      different = true;
      return added[key] = addedItem;
    }, function(key, removedItem) {
      different = true;
      return removed[key] = removedItem;
    }, function(key, newItem, oldItem) {
      different = true;
      return changed[key] = {
        oldItem: oldItem,
        newItem: newItem
      };
    }, null, eqTester);
    return different && {
      added: added,
      removed: removed,
      changed: changed
    };
  };

  return ObjectDiff;

})();


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

var Promise, PromisedFileReader;

Promise = __webpack_require__(45);

module.exports = PromisedFileReader = (function() {
  function PromisedFileReader() {}

  PromisedFileReader.readFileAsDataUrl = function(file) {
    return new Promise(function(resolve, reject) {
      var reader;
      reader = new FileReader;
      reader.readAsDataURL(file);
      reader.onload = (function(_this) {
        return function(e) {
          return resolve(e.target.result);
        };
      })(this);
      return reader.onerror = (function(_this) {
        return function(e) {
          return reject(error);
        };
      })(this);
    });
  };

  PromisedFileReader.readFileAsArrayBuffer = function(file) {
    return new Promise(function(resolve, reject) {
      var reader;
      reader = new FileReader;
      reader.readAsArrayBuffer(file);
      reader.onload = (function(_this) {
        return function(e) {
          return resolve(e.target.result);
        };
      })(this);
      return reader.onerror = (function(_this) {
        return function(e) {
          return reject(error);
        };
      })(this);
    });
  };

  return PromisedFileReader;

})();


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

var ReschedulableTimer, currentSecond, timeout;

currentSecond = __webpack_require__(150).currentSecond;

timeout = __webpack_require__(143).timeout;

module.exports = ReschedulableTimer = (function() {
  function ReschedulableTimer() {
    this._currentScheduleNumber = 0;
  }


  /*
  every time you call timeout it effectively cancels all previously pending timeouts
  leaving only this, new timeout active.
  
  In actuality, the repvious timeouts complete at some point, but their 'actions' are skipped.
   */

  ReschedulableTimer.prototype.timeout = function(ms, action) {
    var thisScheduleNumber;
    thisScheduleNumber = this._currentScheduleNumber += 1;
    return timeout(ms, (function(_this) {
      return function() {
        if (_this._currentScheduleNumber === thisScheduleNumber) {
          return action();
        }
      };
    })(this));
  };

  return ReschedulableTimer;

})();


/***/ }),
/* 301 */
/***/ (function(module, exports) {

var Ruby,
  hasProp = {}.hasOwnProperty;

module.exports = Ruby = (function() {
  var rubyTrue;

  function Ruby() {}

  Ruby.rubyTrue = rubyTrue = function(a) {
    return a !== void 0 && a !== null && a !== false;
  };

  Ruby.rubyFalse = function(a) {
    return a === void 0 || a === null || a === false;
  };

  Ruby.rubyOr = function(a, b) {
    var i, len;
    if (arguments.length === 2) {
      if (rubyTrue(a)) {
        return a;
      } else {
        return b;
      }
    } else {
      for (i = 0, len = arguments.length; i < len; i++) {
        a = arguments[i];
        if (rubyTrue(a)) {
          break;
        }
      }
      return a;
    }
  };

  Ruby.rubyAnd = function(a, b) {
    var i, len;
    if (arguments.length === 2) {
      if (rubyTrue(a)) {
        return b;
      } else {
        return a;
      }
    } else {
      for (i = 0, len = arguments.length; i < len; i++) {
        a = arguments[i];
        if (!rubyTrue(a)) {
          break;
        }
      }
      return a;
    }
  };

  Ruby.reopenInstanceProps = function(klass, instanceProps) {
    var k, results, v;
    results = [];
    for (k in instanceProps) {
      if (!hasProp.call(instanceProps, k)) continue;
      v = instanceProps[k];
      results.push(klass.prototype[k] = v);
    }
    return results;
  };

  Ruby.reopenClassProps = function(klass, classProps) {
    var k, results, v;
    results = [];
    for (k in classProps) {
      if (!hasProp.call(classProps, k)) continue;
      v = classProps[k];
      results.push(klass[k] = v);
    }
    return results;
  };

  return Ruby;

})();


/***/ }),
/* 302 */
/***/ (function(module, exports) {


/*
This current iteration of clone relies on some singleton variables shared across all invocations of clone.
This is fine as long as javascript stays single-threaded.
It also introduces a little bit of uglyness initializing clonedMap necessitating the "top" variable.

FUTURE
A potentially better solution would be to create a new closer each time clone is called at the top-most level,
but when recursing, pass in a new function bound to that closure which is different from the global clone function.

populateClone would need to take an additional argument - the clone function to use for recursive cloning.
 */
var ShallowClone;

module.exports = ShallowClone = (function() {
  function ShallowClone() {}

  ShallowClone.extendClone = function(obj) {
    if (obj.constructor === Array) {
      return obj.slice();
    } else {
      return Object.create(obj);
    }
  };

  ShallowClone.shallowClone = function(obj) {
    var k, ret, v;
    if (!obj) {
      return obj;
    }
    if (obj.constructor === Array) {
      return obj.slice();
    } else {
      ret = {};
      for (k in obj) {
        v = obj[k];
        ret[k] = v;
      }
      return ret;
    }
  };

  return ShallowClone;

})();


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, ClassSystem, CommunicationStatus, Ery, Foundation, RestClient, StandardLib, isNode, merge, ref;

ref = __webpack_require__(1), merge = ref.merge, isNode = ref.isNode;

module.exports = merge(Foundation, Foundation = __webpack_require__(2), ClassSystem = __webpack_require__(6), Atomic = __webpack_require__(4), Ery = __webpack_require__(55), CommunicationStatus = __webpack_require__(19), RestClient = __webpack_require__(142), StandardLib = __webpack_require__(1), {
  Foundation: Foundation,
  StandardLib: StandardLib,
  Atomic: Atomic,
  Ery: Ery,
  CommunicationStatus: CommunicationStatus,
  RestClient: RestClient
});


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {
/*
#TODO

refactor to an object you create
if either tight or tight0 are requested, calculate both
for textual, have two areas:
  textualArea - the current area we compute based on font-size and glyph width
  textualDrawArea - a pessimistic, but always true, area that covers all pixels
    since we have no concrete information on this, we'll just make it something like 2x textualArea - or more
 */
var BaseClass, Bitmap, Rectangle, TextLayoutFragment, allIndexes, ceil, clone, defineModule, eachMatch, floor, inspect, isObject, isString, log, logL, max, merge, min, point, point0, present, rect, ref, ref1,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

floor = Math.floor, ceil = Math.ceil;

ref = __webpack_require__(1), defineModule = ref.defineModule, merge = ref.merge, log = ref.log, logL = ref.logL, inspect = ref.inspect, max = ref.max, min = ref.min, isObject = ref.isObject, isString = ref.isString, allIndexes = ref.allIndexes, eachMatch = ref.eachMatch, clone = ref.clone, present = ref.present;

BaseClass = __webpack_require__(6).BaseClass;

Bitmap = __webpack_require__(11).Bitmap;

ref1 = __webpack_require__(4), point = ref1.point, rect = ref1.rect, point0 = ref1.point0, Rectangle = ref1.Rectangle;

TextLayoutFragment = __webpack_require__(305);

defineModule(module, function() {
  var Metrics, alphaChannelOffset, pixelStep, tightThreshold;
  alphaChannelOffset = 3;
  pixelStep = 4;
  tightThreshold = 127;
  return Metrics = (function(superClass) {
    var blankString, defaultFontOptions, noBreaksWrapIndex, tempRectangleToCapturePessimisticDrawArea, toFontCss;

    extend(Metrics, superClass);

    function Metrics() {
      return Metrics.__super__.constructor.apply(this, arguments);
    }

    Metrics.defaultFontSizeProportionalDrawAreaPadding = .45;

    Metrics.defaultFontOptions = defaultFontOptions = {
      fontStyle: 'normal',
      fontVariant: 'normal',
      fontWeight: 'normal',
      fontSize: 16,
      fontFamily: 'Times'
    };

    Metrics.toFontCss = toFontCss = function(fontOptions) {
      return (fontOptions.fontStyle || 'normal') + " " + (fontOptions.fontVariant || 'normal') + " " + (fontOptions.fontWeight || 'normal') + " " + (fontOptions.fontSize || 16) + "px " + (fontOptions.fontFamily || 'Times') + ", Times";
    };

    Metrics.normalizeFontOptions = function(fontOptions) {
      fontOptions.fontStyle || (fontOptions.fontStyle = defaultFontOptions.fontStyle);
      fontOptions.fontVariant || (fontOptions.fontVariant = defaultFontOptions.fontVariant);
      fontOptions.fontWeight || (fontOptions.fontWeight = defaultFontOptions.fontWeight);
      fontOptions.fontSize || (fontOptions.fontSize = defaultFontOptions.fontSize);
      fontOptions.fontFamily || (fontOptions.fontFamily = defaultFontOptions.fontFamily);
      return fontOptions;
    };

    Metrics.get = function(text, fontOptions, layoutMode, fontCss) {
      if (fontOptions == null) {
        fontOptions = {};
      }
      switch (layoutMode) {
        case null:
        case void 0:
        case "textual":
          return this._getTextualFontMetrics(text, fontOptions, null, fontCss);
        case "textualBaseline":
          return this._getTextualFontMetrics(text, fontOptions, null, fontCss, false);
        case "tight":
          return this._getTightFontMetrics(text, 0, fontOptions, fontCss);
        case "tight0":
          return this._getTightFontMetrics(text, 0, fontOptions, fontCss);
        default:
          throw new Error("invalid layoutMode: " + (inspect(layoutMode)));
      }
    };

    Metrics.getWidth = function(text, fontOptions, fontCss) {
      var context;
      context = Metrics.getScratchCanvasBitmap().context;
      context.font = fontCss || toFontCss(fontOptions);
      return context.measureText(text).width;
    };

    Metrics._wrapOnce = function(context, text, wordWrapWidth) {
      if (context.measureText(text).width <= wordWrapWidth) {
        return [text, null];
      }
    };

    Metrics._noBreaksWrapIndex = noBreaksWrapIndex = function(context, text, wordWrapWidth) {
      var left, leftPixelWidth, leftSlice, m, right, sliced, width;
      left = 0;
      leftPixelWidth = 0;
      leftSlice = null;
      right = text.length;
      while (right - left > 1) {
        m = (left + right) / 2 | 0;
        if ((width = context.measureText(sliced = text.slice(0, m)).width) > wordWrapWidth) {
          right = m;
        } else {
          leftSlice = sliced;
          leftPixelWidth = width;
          left = m;
        }
      }
      if (!leftSlice) {
        leftSlice = text.slice(0, 1);
        leftPixelWidth = context.measureText(leftSlice).width;
      }
      return [leftPixelWidth, leftSlice];
    };

    blankString = "";

    Metrics.wrap = function(text, fontOptions, wordWrapWidth, fontCss, layoutMode) {
      var areaIncludesDescender, context, line, linePixelWidth, lines, nextLine, ref2, trailingSpace, trailingSpacePixelWidth;
      if (layoutMode == null) {
        layoutMode = "textual";
      }
      if (text === "") {
        return [this._getTextualFontMetrics("", fontOptions, 0, fontCss)];
      }
      if (wordWrapWidth < 0) {
        wordWrapWidth = 0;
      }
      areaIncludesDescender = layoutMode === "textual";
      context = this.getScratchCanvasBitmap().context;
      context.font = fontCss;
      linePixelWidth = 0;
      lines = [];
      line = blankString;
      trailingSpace = blankString;
      trailingSpacePixelWidth = 0;
      nextLine = (function(_this) {
        return function() {
          if (linePixelWidth > 0) {
            lines.push(_this._getTextualFontMetrics(line, fontOptions, linePixelWidth, fontCss, areaIncludesDescender));
            line = blankString;
            linePixelWidth = 0;
            trailingSpace = blankString;
            return trailingSpacePixelWidth = 0;
          }
        };
      })(this);
      eachMatch(text, /(\s*[^-\s]+-*|\s*-+)(\s*)/g, function(result) {
        var _, firstHalfText, pixelWidth, ref2, space, whiteSpaceLength, whiteSpacePixelWidth, word, wordLength, wordPixelWidth, wordStart;
        wordStart = result.index;
        _ = result[0], word = result[1], space = result[2];
        wordLength = word.length;
        whiteSpaceLength = space.length;
        whiteSpacePixelWidth = context.measureText(space).width;
        wordPixelWidth = context.measureText(word).width;
        if (wordPixelWidth > wordWrapWidth) {
          while (wordPixelWidth > wordWrapWidth) {
            nextLine();
            ref2 = noBreaksWrapIndex(context, word, wordWrapWidth), pixelWidth = ref2[0], firstHalfText = ref2[1];
            line = firstHalfText;
            linePixelWidth = pixelWidth;
            word = word.slice(firstHalfText.length, word.length);
            wordPixelWidth = context.measureText(word).width;
          }
          nextLine();
          line = word;
          linePixelWidth = wordPixelWidth;
        } else if (trailingSpacePixelWidth + linePixelWidth + wordPixelWidth > wordWrapWidth) {
          nextLine();
          line = word;
          linePixelWidth = wordPixelWidth;
        } else {
          line += trailingSpace + word;
          linePixelWidth += trailingSpacePixelWidth + wordPixelWidth;
        }
        trailingSpace = space;
        return trailingSpacePixelWidth = whiteSpacePixelWidth;
      });
      nextLine();
      if ((ref2 = lines[0]) != null) {
        ref2.firstFragment = true;
      }
      return lines;
    };

    Metrics._tightFontMetricCache = {};

    Metrics._getTightFontMetrics = function(text, tightThreshold, fontOptions, fontCss) {
      var base, previousResult, tightFontMetricCacheKey, upScale;
      if (!present(text)) {
        return new TextLayoutFragment(text, fontOptions);
      }
      tightFontMetricCacheKey = text + ":" + tightThreshold + ":" + (fontCss || (fontCss = toFontCss(fontOptions)));
      previousResult = (base = this._tightFontMetricCache)[tightFontMetricCacheKey] || (base[tightFontMetricCacheKey] = text.length <= 3 ? (upScale = 2, fontOptions = merge(fontOptions, {
        fontSize: fontOptions.fontSize * upScale
      }), fontCss = toFontCss(fontOptions), this._generateTightFontMetrics(text, tightThreshold, fontOptions, fontCss).mul(1 / upScale)) : this._generateTightFontMetrics(text, tightThreshold, fontOptions, fontCss));
      return previousResult.clone();
    };

    tempRectangleToCapturePessimisticDrawArea = new Rectangle;

    Metrics._generateTightFontMetrics = function(text, tightThreshold, fontOptions, fontCss) {
      var area, ascender, bottom, data, descender, layoutH, layoutW, left, location, padding, ref2, ref3, ref4, ref5, right, scratchBitmap, size, textOffsetX, textOffsetY, top;
      padding = Metrics.defaultFontSizeProportionalDrawAreaPadding * 2;
      ref2 = this.renderTextToScratchBitmap(text, fontOptions, padding), scratchBitmap = ref2[0], size = ref2[1], location = ref2[2];
      data = scratchBitmap.context.getImageData(0, 0, size.x, size.y).data;
      ref3 = scratchBitmap.getAutoCropRectangle(tightThreshold), left = ref3.left, right = ref3.right, top = ref3.top, bottom = ref3.bottom;
      while (left === 0 || top === 0 || right === size.x || bottom === size.y) {
        this.log("Art.Text.Metrics#_generateTightFontMetrics: " + (inspect(fontOptions, 1)) + ", padding: " + padding + " too small. scratchBitmap.size: " + scratchBitmap.size);
        padding *= 2;
        ref4 = this.renderTextToScratchBitmap(text, fontOptions, padding), scratchBitmap = ref4[0], size = ref4[1], location = ref4[2];
        ref5 = scratchBitmap.getAutoCropRectangle(tightThreshold), left = ref5.left, right = ref5.right, top = ref5.top, bottom = ref5.bottom;
      }
      top--;
      left--;
      textOffsetX = location.x - left;
      textOffsetY = location.y - top;
      layoutW = right - left + 1;
      layoutH = bottom - top + 1;
      area = rect(left - location.x, top - location.y, right - left + 1, bottom - top + 1);
      ascender = location.y - top + 1;
      descender = bottom - location.y;
      return new TextLayoutFragment(text, fontOptions, ascender, descender, textOffsetX, textOffsetY, layoutW, layoutH, 0, 0, layoutW, layoutH);
    };

    Metrics._getTextualFontMetrics = function(text, fontOptions, alreadyComputedTextWidth, fontCss, areaIncludesDescender) {
      var area, ascender, descender, fontSize, width;
      if (areaIncludesDescender == null) {
        areaIncludesDescender = true;
      }
      fontSize = fontOptions.fontSize - 0;
      ascender = .75 * fontSize;
      descender = .25 * fontSize;
      width = alreadyComputedTextWidth != null ? alreadyComputedTextWidth : this.getWidth(text, fontOptions, fontCss);
      area = rect(0, descender - fontSize, width, fontSize - (areaIncludesDescender ? 0 : descender));
      this.pessimisticDrawArea(width, fontOptions, tempRectangleToCapturePessimisticDrawArea);
      return new TextLayoutFragment(text, fontOptions, ascender, descender, -area.x, -area.y, area.w, area.h, tempRectangleToCapturePessimisticDrawArea.x, tempRectangleToCapturePessimisticDrawArea.y, tempRectangleToCapturePessimisticDrawArea.w, tempRectangleToCapturePessimisticDrawArea.h);
    };

    Metrics.classGetter({
      scratchCanvasBitmap: function() {
        return this._scratchCanvasBitmap || (this._scratchCanvasBitmap = new Bitmap(point(10, 10)));
      }
    });

    Metrics.pessimisticDrawArea = function(textWidth, fontOptions, intoRectangle, increasedFontSizeProportionalDrawAreaPadding) {
      var floatX, floatY, fontSize, h, padding, w, x, y;
      fontSize = fontOptions.fontSize;
      padding = fontSize * (increasedFontSizeProportionalDrawAreaPadding || fontOptions.padding || Metrics.defaultFontSizeProportionalDrawAreaPadding);
      x = Math.floor(floatX = -padding);
      y = Math.floor(floatY = -padding);
      w = Math.ceil(floatX + textWidth + padding * 2) - x;
      h = Math.ceil(floatY + fontSize + padding * 2) - y;
      if (intoRectangle) {
        intoRectangle.x = x;
        intoRectangle.y = y;
        intoRectangle.w = w;
        intoRectangle.h = h;
        return intoRectangle;
      } else {
        return rect(x, y, w, h);
      }
    };

    Metrics._scratchBitmap = null;

    Metrics.renderTextToScratchBitmap = function(text, fontOptions, padding) {
      var context, drawArea, ref2, scratchBitmapSize, size, x, y;
      drawArea = this.pessimisticDrawArea(this.getWidth(text, fontOptions), fontOptions, null, padding);
      size = drawArea.size.size;
      scratchBitmapSize = ((ref2 = this._scratchBitmap) != null ? ref2.size : void 0) || point0;
      if (!scratchBitmapSize.gt(size)) {
        this._scratchBitmap = new Bitmap(scratchBitmapSize.max(size));
      } else {
        this._scratchBitmap.clear();
      }
      context = this._scratchBitmap.context;
      context.textAlign = 'left';
      context.textBaseline = 'alphabetic';
      context.font = toFontCss(fontOptions);
      context.fillText(text, x = -drawArea.x, y = -drawArea.y + fontOptions.fontSize * 3 / 4);
      return [this._scratchBitmap, size, point(x, y)];
    };

    Metrics.debug = function(area, bitmap, location, options) {
      var image;
      image = new Bitmap(bitmap.size);
      image.clear("white");
      image.drawRectangle(location, area, "#ddf");
      image.drawRectangle(location, rect(area.location.x, 0, area.size.x, 1), "red");
      image.drawRectangle(location, rect(0, area.location.y, 1, area.size.y), "green");
      image.drawBitmap(point(), bitmap);
      return this.log(image, {
        layoutMode: options.layoutMode
      });
    };

    return Metrics;

  })(BaseClass);
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {
/*
#TODO

refactor to an object you create
if either tight or tight0 are requested, calculate both
for textual, have two areas:
  textualArea - the current area we compute based on font-size and glyph width
  textualDrawArea - a pessimistic, but always true, area that covers all pixels
    since we have no concrete information on this, we'll just make it something like 2x textualArea - or more
 */
var BaseClass, TextLayoutFragment, defineModule, inspect, log, point, point0, rect, ref, ref1,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), log = ref.log, inspect = ref.inspect, defineModule = ref.defineModule;

BaseClass = __webpack_require__(6).BaseClass;

ref1 = __webpack_require__(4), point = ref1.point, rect = ref1.rect, point0 = ref1.point0;

defineModule(module, TextLayoutFragment = (function(superClass) {
  extend(TextLayoutFragment, superClass);

  function TextLayoutFragment(text, font, ascender, descender, textOffsetX, textOffsetY, layoutW, layoutH, drawAreaX, drawAreaY, drawAreaW, drawAreaH) {
    this.text = text;
    this.font = font;
    this.ascender = ascender != null ? ascender : 0;
    this.descender = descender != null ? descender : 0;
    this.textOffsetX = textOffsetX != null ? textOffsetX : 0;
    this.textOffsetY = textOffsetY != null ? textOffsetY : 0;
    this.layoutW = layoutW != null ? layoutW : 0;
    this.layoutH = layoutH != null ? layoutH : 0;
    this.drawAreaX = drawAreaX != null ? drawAreaX : 0;
    this.drawAreaY = drawAreaY != null ? drawAreaY : 0;
    this.drawAreaW = drawAreaW != null ? drawAreaW : 0;
    this.drawAreaH = drawAreaH != null ? drawAreaH : 0;
    this.firstFragment = false;
    this.layoutX = this.layoutY = 0;
    this.alignmentOffsetX = 0;
    this.alignmentOffsetY = 0;
  }

  TextLayoutFragment.getter({
    inspectedObjects: function() {
      return [this.text, this.font, this.ascender, this.descender, this.textOffsetX, this.textOffsetY, this.layoutW, this.layoutH, this.drawAreaX, this.drawAreaY, this.drawAreaW, this.drawAreaH];
    }
  });

  TextLayoutFragment.prototype.toString = function() {
    return inspect(this.toPlainObject());
  };

  TextLayoutFragment.prototype.mul = function(x) {
    return new TextLayoutFragment(this.text, this.font, x * this.ascender, x * this.descender, x * this.textOffsetX, x * this.textOffsetY, x * this.layoutW, x * this.layoutH, x * this.drawAreaX, x * this.drawAreaY, x * this.drawAreaW, x * this.drawAreaH);
  };

  TextLayoutFragment.prototype.toPlainObject = function() {
    return {
      text: this.text,
      font: this.font,
      ascender: this.ascender,
      descender: this.descender,
      textOffsetX: this.textOffsetX,
      textOffsetY: this.textOffsetY,
      layoutX: this.layoutX,
      layoutY: this.layoutY,
      layoutW: this.layoutW,
      layoutH: this.layoutH,
      drawAreaX: this.drawAreaX,
      drawAreaY: this.drawAreaY,
      drawAreaW: this.drawAreaW,
      drawAreaH: this.drawAreaH,
      alignmentOffsetX: this.alignmentOffsetX,
      alignmentOffsetY: this.alignmentOffsetY
    };
  };

  TextLayoutFragment.prototype.clone = function() {
    return new TextLayoutFragment(this.text, this.font, this.ascender, this.descender, this.textOffsetX, this.textOffsetY, this.layoutW, this.layoutH, this.drawAreaX, this.drawAreaY, this.drawAreaW, this.drawAreaH);
  };

  TextLayoutFragment.prototype.move = function(x, y) {
    this.moveX(x);
    return this.moveY(y);
  };

  TextLayoutFragment.prototype.moveX = function(x) {
    this.layoutX += x;
    return this.drawAreaX += x;
  };

  TextLayoutFragment.prototype.moveY = function(y) {
    this.layoutY += y;
    return this.drawAreaY += y;
  };

  TextLayoutFragment.prototype.setLayoutLocationFrom = function(fragment) {
    this.layoutX = fragment.layoutX;
    this.layoutY = fragment.layoutY;
    this.drawAreaX = fragment.drawAreaX;
    return this.drawAreaY = fragment.drawAreaY;
  };

  TextLayoutFragment.getter({
    left: function() {
      return this.getAlignedLayoutX();
    },
    top: function() {
      return this.getAlignedLayoutY();
    },
    bottom: function() {
      return this.getAlignedLayoutY() + this.layoutH;
    },
    right: function() {
      return this.getAlignedLayoutX() + this.layoutW;
    },
    alignedLayoutX: function() {
      return this.layoutX + this.alignmentOffsetX;
    },
    alignedLayoutY: function() {
      return this.layoutY + this.alignmentOffsetY;
    },
    alignedDrawAreaX: function() {
      return this.drawAreaX + this.alignmentOffsetX;
    },
    alignedDrawAreaY: function() {
      return this.drawAreaY + this.alignmentOffsetY;
    },
    layoutArea: function() {
      return rect(this.layoutX, this.layoutY, this.layoutW, this.layoutH);
    },
    alignedLayoutArea: function() {
      return rect(this.getAlignedLayoutX(), this.getAlignedLayoutY(), this.layoutW, this.layoutH);
    },
    alignedDrawArea: function() {
      return rect(this.getAlignedDrawAreaX(), this.getAlignedDrawAreaY(), this.drawAreaW, this.drawAreaH);
    },
    alignedDrawAreaLeft: function() {
      return this.getAlignedDrawAreaX();
    },
    alignedDrawAreaTop: function() {
      return this.getAlignedDrawAreaY();
    },
    alignedDrawAreaRight: function() {
      return this.getAlignedDrawAreaX() + this.drawAreaW;
    },
    alignedDrawAreaBottom: function() {
      return this.getAlignedDrawAreaY() + this.drawAreaH;
    },
    area: function() {
      console.error("TextLayoutFragment.area is DEPRICATED. Use: TextLayoutFragment#layoutArea");
      return rect(this.layoutX - this.textOffsetX, this.layoutY - this.textOffsetY, this.layoutW, this.layoutH);
    },
    textX: function() {
      return this.layoutX + this.textOffsetX + this.alignmentOffsetX;
    },
    textY: function() {
      return this.layoutY + this.textOffsetY + this.alignmentOffsetY;
    }
  });

  return TextLayoutFragment;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

var DataTypes, FieldTypes, anyDataType, arrayDataType, booleanDataType, dateDataType, emailRegexp, functionDataType, isDate, isHexColor, isId, isNumber, isString, jsonDataType, k, log, numberDataType, objectDataType, ref, ref1, stringDataType, toDate, toLowerCase, toMilliseconds, toSeconds, urlRegexp, v, validStatus;

ref = __webpack_require__(1), isString = ref.isString, isNumber = ref.isNumber, isDate = ref.isDate, isHexColor = ref.isHexColor, toMilliseconds = ref.toMilliseconds, toDate = ref.toDate, toSeconds = ref.toSeconds, toLowerCase = ref.toLowerCase, emailRegexp = ref.emailRegexp, urlRegexp = ref.urlRegexp, log = ref.log;

ref1 = DataTypes = __webpack_require__(96), booleanDataType = ref1.booleanDataType, numberDataType = ref1.numberDataType, stringDataType = ref1.stringDataType, objectDataType = ref1.objectDataType, arrayDataType = ref1.arrayDataType, functionDataType = ref1.functionDataType, dateDataType = ref1.dateDataType, anyDataType = ref1.anyDataType, jsonDataType = ref1.jsonDataType;

validStatus = __webpack_require__(19).validStatus;

isId = function(v) {
  return isString(v) && v.match(/^[-_a-z0-9]{1,100}$/i);
};

isHexColor = function(v) {
  return /^#([a-f0-9]{3})|([a-f0-9]{6})/i.test("" + v);
};


/*
standard FieldType props:
  validate: (v) -> true/false
  preprocess: (v1) -> v2
  required: true/false
  dataType: one of @DataTypes, default: 'string'

You can add your own, too, but they are ignored by this class.
 */

module.exports = FieldTypes = {
  boolean: {
    dataType: booleanDataType
  },
  number: {
    dataType: numberDataType
  },
  string: {
    dataType: stringDataType
  },
  object: {
    dataType: objectDataType
  },
  array: {
    dataType: arrayDataType
  },
  any: {
    dataType: anyDataType
  },
  json: {
    dataType: jsonDataType
  },
  count: {
    dataType: numberDataType,
    "default": 0
  },
  id: {
    required: true,
    validate: function(v) {
      return isId(v);
    }
  },
  date: {
    validate: function(v) {
      return isString(v) || (v instanceof Date);
    },
    preprocess: function(v) {
      if (isString(v)) {
        return new Date(v);
      } else {
        return v;
      }
    },
    dataType: dateDataType
  },
  timestamp: {
    dataType: numberDataType,
    validate: function(v) {
      return isNumber(v) || isDate(v);
    },
    preprocess: toMilliseconds,
    decode: toDate
  },
  secondsTimestamp: {
    dataType: numberDataType,
    validate: function(v) {
      return isNumber(v) || isDate(v);
    },
    preprocess: toSeconds,
    decode: toDate
  },
  color: {
    validate: function(v) {
      return isHexColor(v);
    },
    preprocess: function(v) {
      return "" + v;
    }
  },
  email: {
    validate: function(v) {
      return isString(v) && v.trim().match(emailRegexp);
    },
    preprocess: function(v) {
      return v.trim().toLowerCase();
    }
  },
  url: {
    validate: function(v) {
      return isString(v) && v.match(urlRegexp);
    },
    preprocess: function(v) {
      return normalizeUrl(v);
    }
  },
  communicationStatus: {
    validate: function(v) {
      return validStatus(v);
    }
  },
  trimmedString: {
    validate: function(v) {
      return isString(v);
    },
    preprocess: function(v) {
      v = v.trim();
      return v.length > 0 && v;
    },
    maxLength: 1024
  },
  "function": {
    dataType: functionDataType
  }
};

for (k in FieldTypes) {
  v = FieldTypes[k];
  v.fieldType = k;
  v.dataType || (v.dataType = stringDataType);
  v.validate || (v.validate = DataTypes[v.dataType].validate);
}


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, DataTypes, ErrorWithInfo, FieldTypes, Promise, Validator, array, arrayDataType, booleanDataType, clone, dateDataType, emailRegexp, formattedInspect, functionDataType, isDate, isPlainArray, isPlainObject, isString, log, merge, mergeIntoUnless, numberDataType, object, objectDataType, present, pushIfNotPresent, ref, ref1, select, shallowClone, stringDataType, toDate, toMilliseconds, toSeconds, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), merge = ref.merge, log = ref.log, BaseClass = ref.BaseClass, shallowClone = ref.shallowClone, isString = ref.isString, isPlainObject = ref.isPlainObject, isPlainArray = ref.isPlainArray, Promise = ref.Promise, formattedInspect = ref.formattedInspect, present = ref.present, select = ref.select, emailRegexp = ref.emailRegexp, mergeIntoUnless = ref.mergeIntoUnless, w = ref.w, clone = ref.clone, ErrorWithInfo = ref.ErrorWithInfo, array = ref.array, object = ref.object, isDate = ref.isDate, pushIfNotPresent = ref.pushIfNotPresent, toDate = ref.toDate, toMilliseconds = ref.toMilliseconds, toSeconds = ref.toSeconds;

ref1 = __webpack_require__(96), booleanDataType = ref1.booleanDataType, numberDataType = ref1.numberDataType, stringDataType = ref1.stringDataType, objectDataType = ref1.objectDataType, arrayDataType = ref1.arrayDataType, functionDataType = ref1.functionDataType, dateDataType = ref1.dateDataType;

FieldTypes = __webpack_require__(306);

BaseClass = __webpack_require__(6).BaseClass;

DataTypes = __webpack_require__(96);


/*
CONCEPTS:

  Each field can have up to three custom functions:

    validate: (v) -> true/false

      Validate is evaludated first. If it returns a false value, validation fails.

      NOTE: Return false for validation failures, DO NOT THROUGH ERRORS

    preprocess: (v1) -> v2

      Preprocess can arbitrarily transform the input value to any output value.

      The output-value is what is passed back after successful validation.

      NOTE: preprocessors should NOT throw validation-related errors

    postValidate: (v) -> true/false

      Post-validate is evaludated last. It works the same as validate, but
      sometimes it's easy to normalize the input first with 'preprocess' and
      THEN validate it.

USAGE:
  new Validator validatorFieldsProps, options

    IN:
      validatorFieldsProps:
        plain object with zero or more field-validations defined:
          fieldName: fieldProps
      options:
        exclusive: true/false
          if true, only fields listed in validatorFieldsProps are allowed.

        context: String
          String to attached to errors for clarity.

    fieldProps:
      string or plainObject
      string: selects fieldProps from one of the standard @FieldTypes (see below)
      plainObject: (all fields are optional)

        validate: (v) -> true/false
          whenever this field is included in an update OR create operation,
            validate() must return true
          NOTE: validate is evaluated BEFORE preprocess

        preprocess: (v1, forCreate) -> v2
          whenever this field is included in an update OR create operation,
            after validation succeeds,
            value = preprocess value
          NOTE: validate is evaluated BEFORE preprocess

        required: true/false/string
          if true/string
            when creating records, this field must be included
          if string
            fieldProps = merge fieldProps, FieldTypes[string]

        present: true/false
          if true
            when creating records, this field must be include and 'present' (see Art.Foundation.present)

        fieldType: string
          fieldProps = merge FieldTypes[string], fieldProps

        dataType: string
          sepecify which of the standard Json data-types this field contains
          This is not used by Validator itself, but is available for clients to reflect on field-types.
          Must be one of the values in: DataTypes

        instanceof: class
          in addition to passing validate(), if present, the value must also be an instance of the
          specified class

EXAMPLES:
  new
 */

module.exports = Validator = (function(superClass) {
  var fieldPropsWithGeneratedPostValidator, normalizeDepricatedProps, normalizeFieldProps, normalizeFieldTypeProp, normalizeInstanceOfProp, normalizePlainObjectProps, validateCreate, validateUpdate;

  extend(Validator, superClass);

  normalizeInstanceOfProp = function(ft) {
    var _instanceof, validate;
    if (_instanceof = ft["instanceof"]) {
      validate = ft.validate;
      return merge(ft, {
        validate: function(v) {
          return (v instanceof _instanceof) && (!validate || validate(v));
        }
      });
    } else {
      return ft;
    }
  };

  normalizePlainObjectProps = function(ft) {
    var k, out, subObject, v;
    out = null;
    for (k in ft) {
      v = ft[k];
      if (k !== "fields") {
        if (isPlainObject(subObject = v)) {
          if (!out) {
            out = shallowClone(ft);
          }
          out[k] = true;
          mergeIntoUnless(out, normalizePlainObjectProps(subObject));
        }
      }
    }
    return out || ft;
  };

  normalizeDepricatedProps = function(ft) {
    if (ft.requiredPresent) {
      throw new Error("DEPRICATED: requiredPresent. Use: present: true");
    }
    if (isString(ft.required)) {
      throw new Error("DEPRICATED: required can no longer specifiy the field-type. Use: required: fieldType: myFieldTypeString OR 'required myFieldTypeString'");
    }
    if (isString(ft.present)) {
      throw new Error("DEPRICATED: present can no longer specifiy the field-type. Use: present: fieldType: myFieldTypeString OR 'present myFieldTypeString'");
    }
    return ft;
  };

  normalizeFieldTypeProp = function(ft) {
    var fieldType, fields;
    fieldType = ft.fieldType, fields = ft.fields;
    if (fields) {
      fieldType || (fieldType = "object");
    }
    if (fieldType) {
      return merge(normalizeFieldProps(fieldType), ft);
    } else {
      return ft;
    }
  };

  Validator.normalizeFields = function(fields) {
    return object(fields, normalizeFieldProps);
  };

  Validator.normalizeFieldProps = normalizeFieldProps = function(ft) {
    var fieldProps, ftArray, processed, string, strings, subFt;
    fieldProps = (function() {
      var i, len, ref2;
      if (isPlainObject(ft)) {
        return normalizeFieldTypeProp(normalizeInstanceOfProp(normalizeDepricatedProps(normalizePlainObjectProps(ft))));
      } else if (isPlainArray(ftArray = ft)) {
        processed = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = ftArray.length; i < len; i++) {
            ft = ftArray[i];
            results.push(normalizeFieldProps(ft));
          }
          return results;
        })();
        return merge.apply(null, processed);
      } else if (isString(strings = ft)) {
        ft = {};
        ref2 = w(strings);
        for (i = 0, len = ref2.length; i < len; i++) {
          string = ref2[i];
          if (subFt = FieldTypes[string]) {
            ft.fieldType = string;
            mergeIntoUnless(ft, subFt);
          } else {
            ft[string] = true;
          }
        }
        return ft;
      } else if (ft === true) {
        return FieldTypes.any;
      } else {
        throw new Error("fieldType must be a string or plainObject. Was: " + (formattedInspect(ft)));
      }
    })();
    return fieldPropsWithGeneratedPostValidator(merge(FieldTypes[fieldProps.fieldType], fieldProps));
  };

  fieldPropsWithGeneratedPostValidator = function(fieldProps) {
    var fields, maxLength, minLength, postValidate, validator;
    postValidate = fieldProps.postValidate, maxLength = fieldProps.maxLength, minLength = fieldProps.minLength, fields = fieldProps.fields;
    if ((maxLength != null) || (minLength != null) || (fields != null)) {
      if (fields) {
        validator = new Validator(fields, {
          exclusive: true
        });
        fieldProps.preprocess = function(value, forCreate) {
          return validator.preprocessFields(value, forCreate);
        };
      }
      fieldProps.postValidate = function(value, fieldName, fields) {
        if (postValidate) {
          if (!postValidate(value, fieldName, fields)) {
            return false;
          }
        }
        if (value != null) {
          if ((maxLength != null) && value.length > maxLength) {
            return false;
          }
          if ((minLength != null) && value.length < minLength) {
            return false;
          }
          try {
            if (validator != null) {
              validator.validate(value);
            }
            return true;
          } catch (error1) {
            return false;
          }
        } else {
          return true;
        }
      };
    }
    return fieldProps;
  };

  function Validator(fieldDeclarationMap, options) {
    this._fieldProps = {};
    this._requiredFields = [];
    this.addFields(fieldDeclarationMap);
    if (options) {
      this.exclusive = options.exclusive, this.context = options.context;
    }
  }

  Validator.property("exclusive");

  Validator.prototype.addFields = function(fieldDeclarationMap) {
    var field, fieldOptions;
    for (field in fieldDeclarationMap) {
      fieldOptions = fieldDeclarationMap[field];
      fieldOptions = this._addField(field, fieldOptions);
      if (fieldOptions.required || fieldOptions.present) {
        pushIfNotPresent(this._requiredFields, field);
      }
    }
    return null;
  };

  Validator.getter({
    inspectedObjects: function() {
      return {
        Validator: this._fieldProps
      };
    }
  });

  Validator.prototype.preCreate = function(fields, options) {
    log.error("Validator.preCreate is DEPRICATED. Use .validate or .validateCreate");
    return Promise.resolve(fields).then((function(_this) {
      return function(fields) {
        return _this.preCreateSync(fields, options);
      };
    })(this));
  };

  Validator.prototype.preUpdate = function(fields, options) {
    log.error("Validator.preUpdate is DEPRICATED. Use .validateUpdate");
    return Promise.resolve(fields).then((function(_this) {
      return function(fields) {
        return _this.preUpdateSync(fields, options);
      };
    })(this));
  };

  Validator.prototype.validateSync = function() {
    throw new Error("DEPRICATED: use validate");
  };

  Validator.prototype.preCreateSync = function(fields, options) {
    if (fields == null) {
      fields = {};
    }
    log.error("preCreateSync is DEPRICATED. use .validateCreate or just .validate");
    return this.validateCreate(fields, options);
  };

  Validator.prototype.preUpdateSync = function(fields, options) {
    if (fields == null) {
      fields = {};
    }
    log.error("preUpdateSync is DEPRICATED. use validateUpdate");
    return this.validateUpdate(fields, options);
  };


  /*
  IN:
    fields: - the object to check
    options:
      context: string - included in validation errors for reference
      logErrors: false - if true, will log.error errors
  
  OUT: preprocessed fields - if they pass, otherwise error is thrown
  
  NOTE: missing fields are errors
   */

  Validator.prototype.validateCreate = validateCreate = function(fields, options) {
    var error, out, processedFields;
    if (fields == null) {
      fields = {};
    }
    processedFields = null;
    out = (function() {
      try {
        return this.requiredFieldsPresent(fields) && this.presentFieldsValid(fields) && this.postValidateFields(processedFields = this.preprocessFields(fields, true));
      } catch (error1) {
        error = error1;
        return log.error({
          Validator: {
            error_in: {
              validateCreate: {
                fields: fields,
                options: options,
                "this": this,
                error: error
              }
            }
          }
        });
      }
    }).call(this);
    return out || this._throwError(fields, processedFields, options, true);
  };

  Validator.prototype.validate = validateCreate;


  /*
  IN:
    fields: - the object to check
    options:
      context: string - included in validation errors for reference
      logErrors: false - if true, will log.error errors
  
  OUT: preprocessed fields - if they pass, otherwise error is thrown
  
  NOTE: missing fields are ignored
   */

  Validator.prototype.validateUpdate = validateUpdate = function(fields, options) {
    var error, out, processedFields;
    if (fields == null) {
      fields = {};
    }
    out = (function() {
      try {
        return this.presentFieldsValid(fields) && this.postValidateFields(processedFields = this.preprocessFields(fields));
      } catch (error1) {
        error = error1;
        return log.error({
          Validator: {
            error_in: {
              validateUpdate: {
                fields: fields,
                options: options,
                "this": this,
                error: error
              }
            }
          }
        });
      }
    }).call(this);
    return out || this._throwError(fields, processedFields, options);
  };

  Validator.prototype._throwError = function(fields, processedFields, options, forCreate) {
    var errors, info, message, messageFields, ref2;
    info = {
      errors: errors = {}
    };
    messageFields = [];
    array(this.invalidFields(fields), messageFields, (function(_this) {
      return function(f) {
        errors[f] = "invalid";
        if (_this.exclusive && !_this._fieldProps[f]) {
          return "unexpected '" + f + "' field";
        } else {
          return "invalid " + f;
        }
      };
    })(this));
    array(this.postInvalidFields(processedFields), messageFields, (function(_this) {
      return function(f) {
        errors[f] = "invalid";
        return "invalid processed " + f;
      };
    })(this));
    forCreate && array(this.missingFields(fields), messageFields, function(f) {
      errors[f] = "missing";
      return "missing " + f;
    });
    message = ((ref2 = options != null ? options.context : void 0) != null ? ref2 : this.context) + " " + (forCreate ? 'Create' : 'Update') + "-Validation failed. Invalid fields: " + (messageFields.join(', '));
    info.fields = fields;
    throw new ErrorWithInfo(message.trim(), info);
  };

  Validator.prototype.presentFieldPostValid = function(fields, fieldName, value) {
    var fieldProps, postValidate;
    if (fieldProps = this._fieldProps[fieldName]) {
      postValidate = fieldProps.postValidate;
      return !postValidate || (value == null) || value === null || value === void 0 || postValidate(value, fieldName, fields);
    } else {
      return true;
    }
  };

  Validator.prototype.presentFieldValid = function(fields, fieldName, value) {
    var fieldProps, validate;
    if (fieldProps = this._fieldProps[fieldName]) {
      validate = fieldProps.validate;
      if (fieldProps.present && !present(value)) {
        return false;
      }
      return !validate || (value == null) || value === null || value === void 0 || validate(value, fieldName, fields);
    } else {
      return !this.exclusive;
    }
  };

  Validator.prototype.requiredFieldPresent = function(fields, fieldName) {
    var fieldProps;
    if (!(fieldProps = this._fieldProps[fieldName])) {
      return true;
    }
    if (fieldProps.required && (fields[fieldName] == null)) {
      return false;
    }
    if (fieldProps.present && !present(fields[fieldName])) {
      return false;
    }
    return true;
  };

  Validator.prototype.presentFieldsValid = function(fields) {
    var fieldName, fieldValue;
    for (fieldName in fields) {
      fieldValue = fields[fieldName];
      if (!this.presentFieldValid(fields, fieldName, fieldValue)) {
        return false;
      }
    }
    return true;
  };

  Validator.prototype.requiredFieldsPresent = function(fields) {
    var fieldName, fieldValue, ref2;
    ref2 = this._fieldProps;
    for (fieldName in ref2) {
      fieldValue = ref2[fieldName];
      if (!this.requiredFieldPresent(fields, fieldName)) {
        return false;
      }
    }
    return true;
  };

  Validator.prototype.postValidateFields = function(fields) {
    var fieldName, fieldValue;
    for (fieldName in fields) {
      fieldValue = fields[fieldName];
      if (!this.presentFieldPostValid(fields, fieldName, fieldValue)) {
        return false;
      }
    }
    return fields;
  };

  Validator.prototype.preprocessFields = function(fields, applyDefaults) {
    var fieldName, oldValue, preprocess, processedFields, props, value;
    processedFields = null;
    if (applyDefaults) {
      fields || (fields = {});
    }
    fields && (function() {
      var ref2, results;
      ref2 = this._fieldProps;
      results = [];
      for (fieldName in ref2) {
        props = ref2[fieldName];
        preprocess = props.preprocess;
        value = void 0 !== (oldValue = fields[fieldName]) ? oldValue : applyDefaults && props["default"];
        if (preprocess && (value != null)) {
          value = preprocess(value, applyDefaults);
        }
        if (value !== oldValue) {
          processedFields || (processedFields = shallowClone(fields));
          results.push(processedFields[fieldName] = value);
        } else {
          results.push(void 0);
        }
      }
      return results;
    }).call(this);
    return processedFields || fields || {};
  };

  Validator.prototype.invalidFields = function(fields) {
    var k, results, v;
    results = [];
    for (k in fields) {
      v = fields[k];
      if (!this.presentFieldValid(fields, k, v)) {
        results.push(k);
      }
    }
    return results;
  };

  Validator.prototype.postInvalidFields = function(fields) {
    var k, results, v;
    results = [];
    for (k in fields) {
      v = fields[k];
      if (!this.presentFieldPostValid(fields, k, v)) {
        results.push(k);
      }
    }
    return results;
  };

  Validator.prototype.missingFields = function(fields) {
    var i, k, len, ref2, results;
    ref2 = this._requiredFields;
    results = [];
    for (i = 0, len = ref2.length; i < len; i++) {
      k = ref2[i];
      if (!this.requiredFieldPresent(fields, k)) {
        results.push(k);
      }
    }
    return results;
  };

  Validator.prototype._addField = function(field, options) {
    return this._fieldProps[field] = normalizeFieldProps(options);
  };

  return Validator;

})(BaseClass);


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(534);


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, Binary, WriteStream, XbdDictionary, binary, inspect, log, ref, stream,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), log = ref.log, inspect = ref.inspect;

Binary = __webpack_require__(2).Binary;

binary = Binary.binary, WriteStream = Binary.WriteStream, stream = Binary.stream;

BaseClass = __webpack_require__(6).BaseClass;

module.exports = XbdDictionary = (function(superClass) {
  extend(XbdDictionary, superClass);

  XbdDictionary.parse = function(stream, name) {
    var encodedDictionary, i, len, lengths, strings;
    encodedDictionary = stream.readAsiString();
    lengths = (function() {
      var j, ref1, results;
      results = [];
      for (i = j = 0, ref1 = encodedDictionary.readAsi(); 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        results.push(encodedDictionary.readAsi());
      }
      return results;
    })();
    strings = (function() {
      var j, len1, results;
      results = [];
      for (j = 0, len1 = lengths.length; j < len1; j++) {
        len = lengths[j];
        results.push(encodedDictionary.read(len));
      }
      return results;
    })();
    return new XbdDictionary(strings, name);
  };

  function XbdDictionary(strings1, name1) {
    this.strings = strings1;
    this.name = name1;
  }


  /*
  IN: string: any legal input to binary()
  OUT: index/id for string
  EFFECT:
    string = binary string
    strings was added OR, if already present, nothing changed
   */

  XbdDictionary.prototype.add = function(string) {
    var index;
    string = binary(string);
    if (0 <= (index = this._indexOf(string))) {
      return index;
    } else {
      this.strings.push(string);
      return this.strings.length;
    }
  };


  /*
  IN: string: any legal input to binary()
    NOTE: string is converted to a BinaryString for comparisions
  OUT: returns index of first match in @strings
   */

  XbdDictionary.prototype.get = function(string) {
    var index;
    string = binary(string);
    if (0 <= (index = this._indexOf(string))) {
      return index;
    } else {
      throw new Error("string not found in dictionary: " + (inspect(string)));
    }
  };

  XbdDictionary.prototype.readString = function(stream) {
    var id, string;
    id = stream.readAsi();
    string = this.strings[id];
    if (!string) {
      throw "string id(" + id + ") not in " + this.name + " dictionary. keys = '" + (Object.keys(this.strings)) + "'";
    }
    return string;
  };

  XbdDictionary.getter({
    binaryStringPromise: function() {
      var j, k, len1, len2, normalizedStrings, s, string, writeStream;
      writeStream = new WriteStream;
      normalizedStrings = this._getNormalizeStrings();
      writeStream.writeAsi(normalizedStrings.length);
      for (j = 0, len1 = normalizedStrings.length; j < len1; j++) {
        s = normalizedStrings[j];
        writeStream.writeAsi(s.length);
      }
      for (k = 0, len2 = normalizedStrings.length; k < len2; k++) {
        string = normalizedStrings[k];
        writeStream.write(string);
      }
      return writeStream.binaryStringPromise;
    }
  });

  XbdDictionary.prototype.writeWithPromise = function(writeStream) {
    return this.binaryStringPromise.then(function(binaryString) {
      return writeStream.writeAsiString(binaryString);
    });
  };

  XbdDictionary.prototype._getNormalizeStrings = function() {
    var j, len1, ref1, results, s;
    ref1 = this.strings;
    results = [];
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      s = ref1[j];
      results.push(binary(s));
    }
    return results;
  };

  XbdDictionary.prototype._indexOf = function(binaryString) {
    var i, j, len1, ref1, s;
    ref1 = this.strings;
    for (i = j = 0, len1 = ref1.length; j < len1; i = ++j) {
      s = ref1[i];
      if (s.eq(binaryString)) {
        return i;
      }
    }
    return -1;
  };

  return XbdDictionary;

})(BaseClass);


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, Binary, Foundation, WriteStream, Xbd, XbdDictionary, XbdTag, binary, countKeys, createObjectTreeFactories, inspect, isFunction, log, plainObjectsDeepEq, ref, stream, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Xbd = __webpack_require__(154);

XbdDictionary = __webpack_require__(309);

ref = __webpack_require__(1), isFunction = ref.isFunction, log = ref.log, countKeys = ref.countKeys, upperCamelCase = ref.upperCamelCase, plainObjectsDeepEq = ref.plainObjectsDeepEq, inspect = ref.inspect;

Binary = __webpack_require__(2).Binary;

BaseClass = __webpack_require__(6).BaseClass;

createObjectTreeFactories = __webpack_require__(136).createObjectTreeFactories;

binary = Binary.binary, stream = Binary.stream, WriteStream = Binary.WriteStream;

module.exports = XbdTag = (function(superClass) {
  var indentString, writeXbdHeader, xbdHeader;

  extend(XbdTag, superClass);


  /*
  IN:
    tagNames: string or array of strings which is compactFlattened
      every string is split into tag-names with this pattern: /[a-z0-9_]+/ig
    factoryNameSuffix: DEFAULT: 'Tag'
      Optional suffix for the names of the factories returned.
      Factor names are upperCamelCased from the tag-names and then the suffix is appended.
  OUT:
    map from upperCamelCase(tag-names) to:
      -> XbdTag
      IN:
        any sequence:
          plainObjects (which are merged into attrs)
          XbdTags (which become sub-tags)
          or arrays which are flattened
  
      OUT: XbdTag
  
  Example:
    {MyTag, TagA, TagB} = createTagFactories "myTag tagA tagB"
    rootTag = MyTag
      foo: "bar"
      TagA()
      TagA foo: "far"
      TagB fab: "bar"
   */

  XbdTag.createTagFactories = function(tagNames, factoryNameSuffix) {
    if (factoryNameSuffix == null) {
      factoryNameSuffix = 'Tag';
    }
    return createObjectTreeFactories({
      suffix: factoryNameSuffix
    }, tagNames, function(tagName, attrs, subTags) {
      return new XbdTag(tagName, attrs, subTags);
    });
  };

  XbdTag.fromXbd = function(input) {
    var header;
    input = stream(input);
    header = input.read(xbdHeader.length);
    return XbdTag._parse(input, XbdDictionary.parse(input, "tag names"), XbdDictionary.parse(input, "attribute names"), XbdDictionary.parse(input, "attribute values"));
  };


  /*
  IN:
    name: string
    attrs: map of keys to string/binary-string values
    tags: array of sub-tags
   */

  function XbdTag(name1, attrs1, tags1) {
    this.name = name1;
    this.attrs = attrs1 != null ? attrs1 : {};
    this.tags = tags1 != null ? tags1 : [];
  }

  XbdTag.prototype.inspect = function() {
    return this.toXml('  ');
  };

  XbdTag.prototype.eq = function(b) {
    return b && plainObjectsDeepEq(this.plainObjects, b.plainObjects);
  };


  /*
  toXbd
  IN:  inputs are for internal use. Pass in 0 args.
  OUT: promise.then (xbdBinaryString) ->
  
  Example:
  
    myRootTag.toXbd()
    .then (binaryString) ->
      binaryString.utf8Array # do something with it
   */

  XbdTag.prototype.toXbd = function() {
    var attrNamesDictionary, attrValuesDictionary, ref1, tagNamesDictionary, writeStream;
    ref1 = this, tagNamesDictionary = ref1.tagNamesDictionary, attrNamesDictionary = ref1.attrNamesDictionary, attrValuesDictionary = ref1.attrValuesDictionary;
    writeXbdHeader(writeStream = new WriteStream);
    return tagNamesDictionary.writeWithPromise(writeStream).then(function() {
      return attrNamesDictionary.writeWithPromise(writeStream);
    }).then(function() {
      return attrValuesDictionary.writeWithPromise(writeStream);
    }).then((function(_this) {
      return function() {
        return _this._getBinaryStringPromise(tagNamesDictionary, attrNamesDictionary, attrValuesDictionary);
      };
    })(this)).then(function(binaryString) {
      writeStream.writeAsiString(binaryString);
      return writeStream.binaryStringPromise;
    });
  };

  XbdTag.prototype.tag = function(name) {
    var i, len, ref1, tag;
    ref1 = this.tags;
    for (i = 0, len = ref1.length; i < len; i++) {
      tag = ref1[i];
      if (tag.name === name) {
        return tag;
      }
    }
    return null;
  };

  XbdTag.prototype.toString = function() {
    return this.toXml("  ");
  };

  XbdTag.prototype.toPlainObjects = function() {
    var attrs, i, k, len, out, ref1, ref2, tag, v;
    out = [this.name];
    if (0 < countKeys(this.attrs)) {
      attrs = {};
      ref1 = this.attrs;
      for (k in ref1) {
        v = ref1[k];
        attrs[k] = v.toString();
      }
      out.push(attrs);
    }
    if (this.tags.length > 0) {
      ref2 = this.tags;
      for (i = 0, len = ref2.length; i < len; i++) {
        tag = ref2[i];
        out.push(tag.toPlainObjects());
      }
    }
    return out;
  };

  XbdTag.prototype.toXml = function(indent) {
    var attr_xml;
    if (indent == null) {
      indent = "";
    }
    attr_xml = "";
    if (this.attrs && (attr_xml = this._attributesXml())) {
      attr_xml = " " + attr_xml;
    }
    if (this.tags.length === 0) {
      return "<" + this.name + attr_xml + "/>";
    } else {
      return "<" + this.name + attr_xml + ">\n" + (this._tagsXml(indent)) + "\n</" + this.name + ">";
    }
  };

  XbdTag.getter({
    xbdPromise: function() {
      return this.toXbd();
    },
    xml: function() {
      return this.toXml();
    },
    plainObjects: function() {
      return this.toPlainObjects();
    },
    tagNamesDictionary: function(dictionary) {
      var i, len, ref1, tag;
      if (dictionary == null) {
        dictionary = new XbdDictionary([], 'tag names');
      }
      dictionary.add(this.name);
      ref1 = this.tags;
      for (i = 0, len = ref1.length; i < len; i++) {
        tag = ref1[i];
        tag.getTagNamesDictionary(dictionary);
      }
      return dictionary;
    },
    attrNamesDictionary: function(dictionary) {
      var i, k, len, ref1, ref2, tag, v;
      if (dictionary == null) {
        dictionary = new XbdDictionary([], 'attribute names');
      }
      ref1 = this.attrs;
      for (k in ref1) {
        v = ref1[k];
        dictionary.add(k);
      }
      ref2 = this.tags;
      for (i = 0, len = ref2.length; i < len; i++) {
        tag = ref2[i];
        tag.getAttrNamesDictionary(dictionary);
      }
      return dictionary;
    },
    attrValuesDictionary: function(dictionary) {
      var i, k, len, ref1, ref2, tag, v;
      if (dictionary == null) {
        dictionary = new XbdDictionary([], 'attribute values');
      }
      ref1 = this.attrs;
      for (k in ref1) {
        v = ref1[k];
        dictionary.add(v);
      }
      ref2 = this.tags;
      for (i = 0, len = ref2.length; i < len; i++) {
        tag = ref2[i];
        tag.getAttrValuesDictionary(dictionary);
      }
      return dictionary;
    }
  });

  xbdHeader = "SBDXML\x01\x00";

  writeXbdHeader = function(writeStream) {
    writeStream.write("SBDXML");
    return writeStream.write([1, 0]);
  };

  indentString = function(str, indentStr) {
    return indentStr + str.split("\n").join("\n" + indentStr);
  };

  XbdTag.prototype._attributesXml = function() {
    var k, out, v;
    out = (function() {
      var ref1, results;
      ref1 = this.attrs;
      results = [];
      for (k in ref1) {
        v = ref1[k];
        results.push(k + "='" + v + "'");
      }
      return results;
    }).call(this);
    return out.join(" ");
  };

  XbdTag.prototype._tagsXml = function(indent) {
    var out;
    out = this.tags.map(function(tag) {
      return tag.toXml(indent);
    });
    return indentString(out.join("\n"), indent);
  };

  XbdTag.prototype._getAttributesBinaryStringPromise = function(attrNamesDictionary, attrValuesDictionary) {
    var name, ref1, value, writeStream;
    writeStream = new WriteStream;
    ref1 = this.attrs;
    for (name in ref1) {
      value = ref1[name];
      writeStream.writeAsi(attrNamesDictionary.get(name));
      writeStream.writeAsi(attrValuesDictionary.get(value));
    }
    return writeStream.binaryStringPromise;
  };

  XbdTag.prototype._writeSubTagsWithPromise = function(writeStream, tagNamesDictionary, attrNamesDictionary, attrValuesDictionary) {
    var index, processNext;
    index = 0;
    processNext = (function(_this) {
      return function() {
        var ref1, tag;
        if (tag = (ref1 = _this.tags) != null ? ref1[index++] : void 0) {
          return tag._getBinaryStringPromise(tagNamesDictionary, attrNamesDictionary, attrValuesDictionary).then(function(binaryString) {
            writeStream.writeAsiString(binaryString);
            return processNext();
          });
        } else {
          return Promise.resolve();
        }
      };
    })(this);
    return processNext();
  };

  XbdTag.prototype._getBinaryStringPromise = function(tagNamesDictionary, attrNamesDictionary, attrValuesDictionary) {
    var writeStream;
    writeStream = new WriteStream;
    writeStream.writeAsi(tagNamesDictionary.get(this.name));
    return this._getAttributesBinaryStringPromise(attrNamesDictionary, attrValuesDictionary).then((function(_this) {
      return function(attributesBinaryString) {
        writeStream.writeAsiString(attributesBinaryString);
        return _this._writeSubTagsWithPromise(writeStream, tagNamesDictionary, attrNamesDictionary, attrValuesDictionary);
      };
    })(this)).then(function() {
      return writeStream.binaryStringPromise;
    });
  };

  XbdTag._parse = function(stream, tagsd, attrsd, valuesd) {
    var attrData, attrs, n, name, name1, subTag, tagData, tags, v;
    tagData = stream.readAsiString();
    name = tagsd.readString(tagData).toString();
    attrData = tagData.readAsiString();
    attrs = null;
    while (!attrData.done()) {
      if (!attrs) {
        attrs = {};
      }
      n = attrsd.readString(attrData).toString();
      v = valuesd.readString(attrData);
      attrs[n] = v;
    }
    tags = [];
    while (!tagData.done()) {
      subTag = XbdTag._parse(tagData, tagsd, attrsd, valuesd);
      tags.push(subTag);
      tags[name1 = subTag.name] || (tags[name1] = subTag);
    }
    return new XbdTag(name, attrs, tags);
  };

  return XbdTag;

})(BaseClass);


/***/ }),
/* 311 */
/***/ (function(module, exports) {

var ArrayCompactFlatten, arraySlice, doFlattenInternal, flattenIfNeeded, isArguments, isArrayOrArguments, isPlainArray, keepAll, keepUnlessNullOrUndefined, needsFlatteningOrCompacting;

arraySlice = Array.prototype.slice;

isArguments = function(o) {
  return o && (typeof o.callee === "function") && (typeof o.length === "number");
};

isPlainArray = (function(_this) {
  return function(o) {
    return (o != null) && o.constructor === Array;
  };
})(this);

isArrayOrArguments = function(o) {
  return o && (isPlainArray(o) || isArguments(o));
};

doFlattenInternal = function(array, keepTester, output) {
  var a, i, len;
  output || (output = []);
  for (i = 0, len = array.length; i < len; i++) {
    a = array[i];
    if (isArrayOrArguments(a)) {
      flattenIfNeeded(a, keepTester, output);
    } else if (keepTester(a)) {
      output.push(a);
    }
  }
  return output;
};

needsFlatteningOrCompacting = function(array, keepTester) {
  var a, i, len;
  for (i = 0, len = array.length; i < len; i++) {
    a = array[i];
    if (isArrayOrArguments(a) || !keepTester(a)) {
      return true;
    }
  }
  return false;
};

flattenIfNeeded = function(array, keepTester, output) {
  var i, len, v;
  if (needsFlatteningOrCompacting(array, keepTester)) {
    return doFlattenInternal(array, keepTester, output);
  } else if (output) {
    for (i = 0, len = array.length; i < len; i++) {
      v = array[i];
      output.push(v);
    }
    return output;
  } else if (array.constructor !== Array) {
    return arraySlice.call(array);
  } else {
    return array;
  }
};

keepAll = function() {
  return true;
};

keepUnlessNullOrUndefined = function(a) {
  return a !== null && a !== void 0;
};

module.exports = ArrayCompactFlatten = (function() {
  function ArrayCompactFlatten() {}

  ArrayCompactFlatten.isPlainArray = isPlainArray;

  ArrayCompactFlatten.compact = function(array, keepTester) {
    var a, i, len;
    if (keepTester == null) {
      keepTester = keepUnlessNullOrUndefined;
    }
    for (i = 0, len = array.length; i < len; i++) {
      a = array[i];
      if (!keepTester(a)) {
        return (function() {
          var j, len1, results;
          results = [];
          for (j = 0, len1 = array.length; j < len1; j++) {
            a = array[j];
            if (keepTester(a)) {
              results.push(a);
            }
          }
          return results;
        })();
      }
    }
    return array;
  };

  ArrayCompactFlatten.flatten = function(firstArg) {
    return flattenIfNeeded(arguments.length === 1 ? isArrayOrArguments(firstArg) ? firstArg : [firstArg] : arguments, keepAll);
  };

  ArrayCompactFlatten.compactFlatten = function(array, keepTester) {
    if (keepTester == null) {
      keepTester = keepUnlessNullOrUndefined;
    }
    return flattenIfNeeded(array, keepTester);
  };

  return ArrayCompactFlatten;

})();


/***/ }),
/* 312 */
/***/ (function(module, exports) {

var isNonNegativeInt;

isNonNegativeInt = function(x) {
  return ((x | 0) === x) && x >= 0;
};

module.exports = {
  isArrayIterable: function(source) {
    return source && isNonNegativeInt(source.length) && source.constructor !== Object;
  }
};


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {


/*
TODO: Make NN ugifly-mangler friendly. In order to do that, we need
to stop using the function.name attribute.

OLD:
  I think we can do that with one change: addNamespace needs to
  change to take a name argument: @addNamespace: (name, namespace) ->

NEW:
  Ok, that's done. Now I need to revisit the mangler issue.
  Did this fix it?
 */
var ArtStandardLibCore, Namespace, isClass, isExtendedClass, isFunction, isPlainArray, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(510), isClass = ref.isClass, isFunction = ref.isFunction, isPlainArray = ref.isPlainArray, isExtendedClass = ref.isExtendedClass;

ArtStandardLibCore = null;

module.exports = Namespace = (function() {
  var excludedPropNames, isPathedNamespace;

  function Namespace() {}

  Namespace.isNamespace = function(klass) {
    return (klass != null ? klass.prototype : void 0) instanceof Namespace;
  };

  Namespace.allNamespaces = {};

  Namespace.getAllNamespacePaths = function() {
    return Object.keys(Namespace.allNamespaces).sort();
  };

  Namespace.toString = function() {
    return this.namespacePath;
  };

  Namespace.inspect = function() {
    return this.namespacePath;
  };

  Namespace.namespacePath = "Neptune.Namespace";

  Namespace.namespace = null;

  Namespace.namespaces = {};

  Namespace.modules = {};

  Namespace.getNamespacePath = function() {
    return this.namespacePath;
  };

  Namespace.getNamespaceNames = function() {
    return Object.keys(this.namespaces).sort();
  };

  Namespace.getModuleNames = function() {
    return Object.keys(this.modules).sort();
  };

  Namespace.getNeptuneLib = function() {
    return ArtStandardLibCore || (ArtStandardLibCore = __webpack_require__(509));
  };

  Namespace.getInspectedObjects = function(includeModules) {
    var name, namespace, obj;
    if (includeModules == null) {
      includeModules = true;
    }
    return (
      obj = {},
      obj["" + this.namespacePath] = this.getNeptuneLib().merge(this.version ? {
        version: this.version
      } : void 0, (function() {
        var ref1, results;
        ref1 = this.namespaces;
        results = [];
        for (name in ref1) {
          namespace = ref1[name];
          results.push(namespace.getInspectedObjects(includeModules));
        }
        return results;
      }).call(this), includeModules && this.getModuleNames().length > 0 ? {
        modules: this.getModuleNames().join(', ')
      } : void 0),
      obj
    );
  };

  Namespace.getVersions = function() {
    var key, out, recurse, ref1, subnamespace;
    out = {};
    if (this === Neptune) {
      out.NeptuneNamespacesRuntime = this.version;
    }
    ref1 = this.namespaces;
    for (key in ref1) {
      subnamespace = ref1[key];
      if (0 < Object.keys(recurse = subnamespace.getVersions()).length) {
        out[key] = recurse;
      }
      if (subnamespace.version != null) {
        out[key] || (out[key] = subnamespace.version);
      }
    }
    return out;
  };


  /*
  IN:
    "Foo" -> vivifies @Foo
    "Foo.Bar" ->  vivifies @Foo.Bar
    OR: ["Foo", "Bar", "Baz"] ->  vivifies @Foo.Bar.Baz
   */

  Namespace.vivifySubnamespace = function(name) {
    var PathedNamespace, base, j, len, namespace, path;
    if (isPathedNamespace(name)) {
      name = name.split('.');
    }
    if (isPlainArray(path = name)) {
      namespace = this;
      for (j = 0, len = path.length; j < len; j++) {
        name = path[j];
        namespace = namespace.vivifySubnamespace(name);
      }
      return namespace;
    } else {
      return (base = this.namespaces)[name] || (base[name] = this[name] = PathedNamespace = (function(superClass) {
        extend(PathedNamespace, superClass);

        function PathedNamespace() {
          return PathedNamespace.__super__.constructor.apply(this, arguments);
        }

        return PathedNamespace;

      })(Namespace._init(name, this)));
    }
  };

  Namespace.isPathedNamespace = isPathedNamespace = function(name) {
    return /\./.test(name);
  };

  Namespace.addVersionedNamespace = function(name, namespace) {
    var version, versions;
    if (!namespace) {
      return;
    }
    if (!(versions = (this.versionedNamespaces || (this.versionedNamespaces = {}))[name])) {
      versions = this.versionedNamespaces[name] = {};
      this.addVersionedNamespace(name, this.namespaces[name]);
    }
    version = namespace.version;
    console.warn(("NN: adding " + this.namespacePath + ".versionedNamespaces." + name + "['" + version + "']") + (namespace === this.namespaces[name] ? " (default)" : ""));
    if (version == null) {
      throw new Error("expecting namespace '" + name + "' in '" + this.namespacePath + "'' to have a version");
    }
    if (versions[version]) {
      console.warn("NN: versionedNamespace " + name + " already added for version " + version + ". Not added again.");
    } else {
      versions[version] = namespace;
    }
    return namespace;
  };

  Namespace.addNamespace = function(name, namespace) {
    var existingNamespace, j, path, ref1;
    if (isPathedNamespace(name)) {
      ref1 = name.split("."), path = 2 <= ref1.length ? slice.call(ref1, 0, j = ref1.length - 1) : (j = 0, []), name = ref1[j++];
      this.vivifySubnamespace(path).addNamespace(name, namespace);
    } else if (existingNamespace = this.namespaces[name]) {
      if (!((namespace.prototype instanceof Neptune.PackageNamespace) && (existingNamespace.prototype instanceof Neptune.PackageNamespace))) {
        throw new Error("PathedNamespace vs PackageNamespaces conflict for: " + this.namespacePath + "." + name + "'.");
      }
      this.addVersionedNamespace(name, namespace);
    } else {
      this.allNamespaces[namespace.namespacePath] = this.namespaces[name] = this[name] = namespace._init(name, this);
    }
    return namespace;
  };

  Namespace.addModules = function(map) {
    var modName, module, name;
    for (name in map) {
      module = map[name];
      this._setChildNamespaceProps(name, module);
      if (isExtendedClass(module) && name !== (modName = module.getName())) {
        console.warn("NN: module name (" + this.namespacePath + "." + name + ") does not match module.exports.getName(): " + modName);
      }
      if (!name.match(/^-/)) {
        this.modules[name] = this[name] = module;
      }
    }
    return this;
  };


  /*
  IN: any combination of objects or arrays
    object: all properties in the object are added to the namespace
  
    array: [fromObject, property names as one or more strings]
      for propName in every sub-string in args matching: /[0-9a-z_]+/ig
        @_addToNamespace propName, fromObject
  
      Each string is parsed to find everything that matches: /[0-9a-z_]+/ig
      All resulting property names are concated into a one list.
      Every property in fromObject that matches one of the property-names is added to the namespace.
   */

  Namespace.includeInNamespace = function() {
    var arg, args, fromObject, i, j, k, l, len, len1, propName, ref1, ref2, v;
    args = arguments.length === 1 && isPlainArray(arguments[0]) ? arguments[0] : arguments;
    for (j = 0, len = args.length; j < len; j++) {
      arg = args[j];
      if (arg != null) {
        if (isPlainArray(arg)) {
          fromObject = arg[0];
          for (i = k = 1, ref1 = arg.length; 1 <= ref1 ? k < ref1 : k > ref1; i = 1 <= ref1 ? ++k : --k) {
            ref2 = arg[i].match(/[0-9a-z_]+/ig);
            for (l = 0, len1 = ref2.length; l < len1; l++) {
              propName = ref2[l];
              this._addToNamespace(propName, fromObject);
            }
          }
        } else {
          for (propName in arg) {
            v = arg[propName];
            this._addToNamespace(propName, arg);
          }
        }
      }
    }
    return this;
  };


  /*
  Every child of a namespace gets these properties:
  
    namespace:      pointer to the parent namespace
    namespacePath:  string path from global to child
  
  NOTE: only modules which return a class or function
    get their namespace-props set.
   */

  Namespace._setChildNamespaceProps = function(name, child) {
    if (isFunction(child) || isClass(child)) {
      if (isFunction(child["class"])) {
        this._setChildNamespaceProps(name, child["class"]);
      }
      child.namespace = this;
      return child.namespacePath = this.namespacePath + "." + name;
    }
  };


  /*
  CoffeeScript classes copy all class props when inheriting,
  but some props need to be unique to each instance. This
  function initializes those props.
   */

  Namespace._init = function(name, namespace1) {
    var ref1;
    this.namespace = namespace1;
    this._name = name;
    this.modules = {};
    this.namespaces = {};
    this.versionedNamespaces = null;
    if ((ref1 = this.namespace) != null) {
      ref1._setChildNamespaceProps(name, this);
    }
    return this;
  };

  excludedPropNames = ["__super__", "_name", "version"].concat(Object.keys(Namespace));


  /*
  Helper for includeInNamespace.
  Add anything to the namespace.
  
  IN:
    propName:   property name to  value will be assigned to in the namespace (string)
    addingFrom: object
      used for reporting errors if attempting to overwrite an
      existing item.
  
  EFFECT:
    Only adds value if @[propName] is not already set.
    Otherwise, reports error and continues.
  
  OUT: value
   */

  Namespace._addToNamespace = function(propName, addingFrom) {
    var addingFromString, ref1, value;
    value = addingFrom[propName];
    if (propName === "inspect" && (value != null ? value.length : void 0) > 0) {
      return this[propName] = value;
    }
    if (indexOf.call(excludedPropNames, propName) >= 0) {
      return;
    }
    if (value == null) {
      return;
    }
    if (this[propName]) {
      if (this[propName] !== value) {
        addingFromString = addingFrom.namespacePath || addingFrom.propName || (Object.keys(addingFrom)).join(', ');
        console.error(this.namespacePath + " already has key: " + propName + ". Adding from: " + addingFromString);
      }
      this[propName];
    } else {
      this[propName] = value;
    }
    if (propName === 'version') {
      return (ref1 = this.namespace.versionedNamespaces) != null ? ref1[this.getName()][value] = this : void 0;
    }
  };

  return Namespace;

})();


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(315);

module.exports.addModules({
  Affirmations: __webpack_require__(168),
  App: __webpack_require__(356),
  CategoryButton: __webpack_require__(105),
  NeedsDashboard: __webpack_require__(169),
  SearchBar: __webpack_require__(170),
  SetStatusWidget: __webpack_require__(171),
  ShowMenu: __webpack_require__(106),
  ShowPath: __webpack_require__(172),
  TabButton: __webpack_require__(49)
});


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

var Components,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(97)).addNamespace('Components', Components = (function(superClass) {
  extend(Components, superClass);

  function Components() {
    return Components.__super__.constructor.apply(this, arguments);
  }

  return Components;

})(Neptune.PackageNamespace));


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

var Models,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(97)).addNamespace('Models', Models = (function(superClass) {
  extend(Models, superClass);

  function Models() {
    return Models.__super__.constructor.apply(this, arguments);
  }

  return Models;

})(Neptune.PackageNamespace));


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

var Data,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(98)).addNamespace('Data', Data = (function(superClass) {
  extend(Data, superClass);

  function Data() {
    return Data.__super__.constructor.apply(this, arguments);
  }

  return Data;

})(Neptune.PackageNamespace));


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(319);

module.exports.addModules({
  Affirmation: __webpack_require__(364),
  AffirmationDay: __webpack_require__(365)
});


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

var Pipelines,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(98)).addNamespace('Pipelines', Pipelines = (function(superClass) {
  extend(Pipelines, superClass);

  function Pipelines() {
    return Pipelines.__super__.constructor.apply(this, arguments);
  }

  return Pipelines;

})(Neptune.PackageNamespace));


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(7)
var Legacy = __webpack_require__(550)
var Base = __webpack_require__(25)
var Buffer = __webpack_require__(47).Buffer
var md5 = __webpack_require__(99)
var RIPEMD160 = __webpack_require__(161)

var sha = __webpack_require__(162)

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

(function(global) {
  'use strict';

  var dateFormat = (function() {
      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g;
      var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
      var timezoneClip = /[^-+\dA-Z]/g;
  
      // Regexes and supporting functions are cached through closure
      return function (date, mask, utc, gmt) {
  
        // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
        if (arguments.length === 1 && kindOf(date) === 'string' && !/\d/.test(date)) {
          mask = date;
          date = undefined;
        }
  
        date = date || new Date;
  
        if(!(date instanceof Date)) {
          date = new Date(date);
        }
  
        if (isNaN(date)) {
          throw TypeError('Invalid date');
        }
  
        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);
  
        // Allow setting the utc/gmt argument via the mask
        var maskSlice = mask.slice(0, 4);
        if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
          mask = mask.slice(4);
          utc = true;
          if (maskSlice === 'GMT:') {
            gmt = true;
          }
        }
  
        var _ = utc ? 'getUTC' : 'get';
        var d = date[_ + 'Date']();
        var D = date[_ + 'Day']();
        var m = date[_ + 'Month']();
        var y = date[_ + 'FullYear']();
        var H = date[_ + 'Hours']();
        var M = date[_ + 'Minutes']();
        var s = date[_ + 'Seconds']();
        var L = date[_ + 'Milliseconds']();
        var o = utc ? 0 : date.getTimezoneOffset();
        var W = getWeek(date);
        var N = getDayOfWeek(date);
        var flags = {
          d:    d,
          dd:   pad(d),
          ddd:  dateFormat.i18n.dayNames[D],
          dddd: dateFormat.i18n.dayNames[D + 7],
          m:    m + 1,
          mm:   pad(m + 1),
          mmm:  dateFormat.i18n.monthNames[m],
          mmmm: dateFormat.i18n.monthNames[m + 12],
          yy:   String(y).slice(2),
          yyyy: y,
          h:    H % 12 || 12,
          hh:   pad(H % 12 || 12),
          H:    H,
          HH:   pad(H),
          M:    M,
          MM:   pad(M),
          s:    s,
          ss:   pad(s),
          l:    pad(L, 3),
          L:    pad(Math.round(L / 10)),
          t:    H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],
          tt:   H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],
          T:    H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],
          TT:   H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],
          Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
          o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
          S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
          W:    W,
          N:    N
        };
  
        return mask.replace(token, function (match) {
          if (match in flags) {
            return flags[match];
          }
          return match.slice(1, match.length - 1);
        });
      };
    })();

  dateFormat.masks = {
    'default':               'ddd mmm dd yyyy HH:MM:ss',
    'shortDate':             'm/d/yy',
    'mediumDate':            'mmm d, yyyy',
    'longDate':              'mmmm d, yyyy',
    'fullDate':              'dddd, mmmm d, yyyy',
    'shortTime':             'h:MM TT',
    'mediumTime':            'h:MM:ss TT',
    'longTime':              'h:MM:ss TT Z',
    'isoDate':               'yyyy-mm-dd',
    'isoTime':               'HH:MM:ss',
    'isoDateTime':           'yyyy-mm-dd\'T\'HH:MM:sso',
    'isoUtcDateTime':        'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
    'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'
  };

  // Internationalization strings
  dateFormat.i18n = {
    dayNames: [
      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
    ],
    monthNames: [
      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
    ],
    timeNames: [
      'a', 'p', 'am', 'pm', 'A', 'P', 'AM', 'PM'
    ]
  };

function pad(val, len) {
  val = String(val);
  len = len || 2;
  while (val.length < len) {
    val = '0' + val;
  }
  return val;
}

/**
 * Get the ISO 8601 week number
 * Based on comments from
 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
 *
 * @param  {Object} `date`
 * @return {Number}
 */
function getWeek(date) {
  // Remove time components of date
  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

  // Change date to Thursday same week
  targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);

  // Take January 4th as it is always in week 1 (see ISO 8601)
  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

  // Change date to Thursday same week
  firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

  // Check if daylight-saving-time-switch occurred and correct for it
  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
  targetThursday.setHours(targetThursday.getHours() - ds);

  // Number of weeks between target Thursday and first Thursday
  var weekDiff = (targetThursday - firstThursday) / (86400000*7);
  return 1 + Math.floor(weekDiff);
}

/**
 * Get ISO-8601 numeric representation of the day of the week
 * 1 (for Monday) through 7 (for Sunday)
 * 
 * @param  {Object} `date`
 * @return {Number}
 */
function getDayOfWeek(date) {
  var dow = date.getDay();
  if(dow === 0) {
    dow = 7;
  }
  return dow;
}

/**
 * kind-of shortcut
 * @param  {*} val
 * @return {String}
 */
function kindOf(val) {
  if (val === null) {
    return 'null';
  }

  if (val === undefined) {
    return 'undefined';
  }

  if (typeof val !== 'object') {
    return typeof val;
  }

  if (Array.isArray(val)) {
    return 'array';
  }

  return {}.toString.call(val)
    .slice(8, -1).toLowerCase();
};



  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return dateFormat;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports === 'object') {
    module.exports = dateFormat;
  } else {
    global.dateFormat = dateFormat;
  }
})(this);


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = false;

// Only Node.JS has a process variable that is of [[Class]] process
try {
 module.exports = Object.prototype.toString.call(global.process) === '[object process]' 
} catch(e) {}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

var randomBytes = __webpack_require__(63);
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = __webpack_require__(10);
var TWENTYFOUR = new BN(24);
var MillerRabin = __webpack_require__(335);
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(22);
var common = __webpack_require__(62);
var shaCommon = __webpack_require__(326);
var assert = __webpack_require__(15);

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(22);
var common = __webpack_require__(62);
var assert = __webpack_require__(15);

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(22);
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),
/* 327 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 328 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-foundation":"git://github.com/imikimi/art-foundation.git","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.2","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.2.1","commander":"^2.15.1","css-loader":"^0.28.4","dateformat":"^3.0.3","detect-node":"^2.0.3","fs-extra":"^5.0.0","glob":"^7.1.2","glob-promise":"^3.4.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"atomic data-types such as Color, Point, Rectangle and Matrix","license":"ISC","name":"art-atomic","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.17.0"}

/***/ }),
/* 329 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-canvas":"git://github.com/imikimi/art-canvas.git","art-class-system":"*","art-config":"*","art-events":"*","art-foundation":"git://github.com/imikimi/art-foundation.git","art-standard-lib":"*","art-testbench":"*","art-text":"git://github.com/imikimi/art-text.git","art-xbd":"git://github.com/imikimi/art-xbd.git","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.2","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.2.1","commander":"^2.15.1","css-loader":"^0.28.4","dateformat":"^3.0.3","detect-node":"^2.0.3","fs-extra":"^5.0.0","glob":"^7.1.2","glob-promise":"^3.4.0","javascript-detect-element-resize":"^0.5.3","json-loader":"^0.5.4","keyboardevent-key-polyfill":"^1.0.2","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"The ArtEngine is a layout, rendering and event engine for creating user interfaces in HTML5 Canvas elements.","license":"ISC","name":"art-engine","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress"},"version":"3.2.3"}

/***/ }),
/* 330 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-events":"git://github.com/imikimi/art-events.git","art-express-server":"git://github.com/imikimi/art-express-server.git","art-flux":"git://github.com/imikimi/art-flux.git","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.2","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.2.1","commander":"^2.15.1","compress":"^0.99.0","css-loader":"^0.28.4","dateformat":"^3.0.3","detect-node":"^2.0.3","express":"^4.14.0","fs-extra":"^5.0.0","glob":"^7.1.2","glob-promise":"^3.4.0","json-loader":"^0.5.4","jsonwebtoken":"^7.2.1","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","throng":"^4.0.0","uuid":"^3.2.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"A pipelined business-logic framework for cloud-backed data. ArtEry conceptially allows you to write apps 100% as client-code, but with the security and performance of cloud-code.","license":"ISC","name":"art-ery","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress","testServer":"caf ./TestServer.caf"},"version":"1.87.0"}

/***/ }),
/* 331 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-foundation":"git://github.com/imikimi/art-foundation.git","art-react":"git://github.com/imikimi/art-react.git","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"license":"ISC","name":"art-flux","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress"},"version":"1.20.2"}

/***/ }),
/* 332 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-communication-status":"*","art-config":"*","art-epoched-state":"*","art-object-tree-factory":"*","art-rest-client":"*","art-standard-lib":"*","art-testbench":"*","art-validation":"*","atob":"^2.0.3","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.2","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.2.1","commander":"^2.15.1","css-loader":"^0.28.4","dateformat":"^3.0.3","detect-node":"^2.0.3","fs-extra":"^5.0.0","glob":"^7.1.2","glob-promise":"^3.4.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Foundation classes for the Art framework. Javascript extensions.","license":"ISC","name":"art-foundation","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress"},"version":"1.81.3"}

/***/ }),
/* 333 */
/***/ (function(module, exports) {

module.exports = {"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}}

/***/ }),
/* 334 */
/***/ (function(module, exports) {

module.exports = {"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"}

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

var bn = __webpack_require__(10);
var brorand = __webpack_require__(182);

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._rand = function _rand(n) {
  var len = n.bitLength();
  var buf = this.rand.generate(Math.ceil(len / 8));

  // Set low bits
  buf[0] |= 3;

  // Mask high bits
  var mask = len & 0x7;
  if (mask !== 0)
    buf[buf.length - 1] >>= 7 - mask;

  return new bn(buf);
}

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._rand(n2);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._rand(n2);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = __webpack_require__(63)
exports.createHash = exports.Hash = __webpack_require__(61)
exports.createHmac = exports.Hmac = __webpack_require__(320)

var algos = __webpack_require__(382)
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = __webpack_require__(338)
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = __webpack_require__(379)

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = __webpack_require__(558)

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = __webpack_require__(383)

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = __webpack_require__(548)

var publicEncrypt = __webpack_require__(610)

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {


exports.pbkdf2 = __webpack_require__(609)

exports.pbkdf2Sync = __webpack_require__(341)


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var defaultEncoding
/* istanbul ignore next */
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}
module.exports = defaultEncoding

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23)))

/***/ }),
/* 340 */
/***/ (function(module, exports) {

var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs
module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

var md5 = __webpack_require__(99)
var rmd160 = __webpack_require__(161)
var sha = __webpack_require__(162)

var checkParameters = __webpack_require__(340)
var defaultEncoding = __webpack_require__(339)
var Buffer = __webpack_require__(47).Buffer
var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  checkParameters(iterations, keylen)

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(61);
module.exports = function (seed, len) {
  var t = new Buffer('');
  var  i = 0, c;
  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
  }
  return t.slice(0, len);
};

function i2ops(c) {
  var out = new Buffer(4);
  out.writeUInt32BE(c,0);
  return out;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var bn = __webpack_require__(10);
function withPublic(paddedMsg, key) {
  return new Buffer(paddedMsg
    .toRed(bn.mont(key.modulus))
    .redPow(new bn(key.publicExponent))
    .fromRed()
    .toArray());
}

module.exports = withPublic;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 344 */
/***/ (function(module, exports) {

module.exports = function xor(a, b) {
  var len = a.length;
  var i = -1;
  while (++i < len) {
    a[i] ^= b[i];
  }
  return a
};

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var processNextTick = __webpack_require__(104);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(327);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(156).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(348);
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = __webpack_require__(159).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(60);
util.inherits = __webpack_require__(7);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(635);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(616);
var destroyImpl = __webpack_require__(347);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(34);

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(164).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(34);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(164).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(23)))

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(34);

/*<replacement>*/
var util = __webpack_require__(60);
util.inherits = __webpack_require__(7);
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var processNextTick = __webpack_require__(104);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(156).EventEmitter;


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(7)
var Hash = __webpack_require__(48)

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var inherits = __webpack_require__(7)
var Hash = __webpack_require__(48)

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(629);
var v4 = __webpack_require__(630);

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),
/* 352 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;


/***/ }),
/* 353 */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));
if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(98);

module.exports.includeInNamespace(__webpack_require__(363)).addModules({
  StandardImport: __webpack_require__(107)
});

__webpack_require__(547);

__webpack_require__(24);

__webpack_require__(318);


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    [
      "KeyFieldsMixin",
      "UpdateAfterMixin",
      "Pipeline",
      "pipelines",
      "log",
      "withSort",
      "compare",
      "merge"
    ],
    [global, __webpack_require__(167)],
    (
      KeyFieldsMixin,
      UpdateAfterMixin,
      Pipeline,
      pipelines,
      log,
      withSort,
      compare,
      merge
    ) => {
      let IndexedDb, globalIndexDb, getGlobalIndexDb, IndexedDbPipeline;
      IndexedDb = __webpack_require__(583);
      globalIndexDb = null;
      getGlobalIndexDb = function() {
        let dbVersion, dbName;
        if (!globalIndexDb) {
          dbVersion = 0;
          dbName = null;
          Caf.each2(
            pipelines,
            pipeline => {
              dbVersion += pipeline.dbVersion || 1;
              return dbName || (dbName = pipeline.dbName);
            },
            pipeline => pipeline instanceof IndexedDbPipeline
          );
          globalIndexDb = new IndexedDb(
            dbName || (dbName = "IndexedDbPipeline")
          );
          globalIndexDb.setVersion(dbVersion);
          Caf.each2(
            pipelines,
            pipeline => {
              let name, _indexes, keyType, indexes;
              ({ name } = pipeline);
              ({ _indexes } = pipeline.class);
              keyType = { keyPath: "id" };
              indexes = _indexes
                ? Caf.array(_indexes, (indexKey, queryModelName) => {
                    let selectBy, orderBy;
                    [selectBy, orderBy] = indexKey.split("/");
                    return {
                      name: queryModelName,
                      keyPath: [selectBy, orderBy],
                      options: { unique: false }
                    };
                  })
                : undefined;
              log({
                addObjectStore: { dbVersion, dbName, name, keyType, indexes }
              });
              return globalIndexDb.addObjectStore({
                dbVersion,
                dbName,
                name,
                keyType,
                indexes
              });
            },
            pipeline => pipeline instanceof IndexedDbPipeline
          );
          globalIndexDb = globalIndexDb.build();
        }
        return globalIndexDb;
      };
      return (IndexedDbPipeline = Caf.defClass(
        class IndexedDbPipeline extends KeyFieldsMixin(
          UpdateAfterMixin(Pipeline)
        ) {},
        function(IndexedDbPipeline, classSuper, instanceSuper) {
          this.abstractClass();
          this.getter({
            objectStore: function() {
              return (
                this._objectStore ||
                (this._objectStore = getGlobalIndexDb()[this.pipelineName])
              );
            }
          });
          this.indexes = function(indexes) {
            this._indexes = indexes;
            return this.query(this._getAutoDefinedQueries(indexes));
          };
          this._getAutoDefinedQueries = function(indexes) {
            let queries;
            queries = {};
            Caf.each2(indexes, (indexKey, queryModelName) => {
              let selectBy, orderBy, whereClause;
              [selectBy, orderBy] = indexKey.split("/");
              whereClause = {};
              return (queries[queryModelName] = {
                query: request => {
                  let key;
                  ({ key } = request);
                  return request.pipeline.objectStore
                    .getAll()
                    .then(items =>
                      Caf.array(items, null, item => item[selectBy] === key)
                    );
                },
                dataToKeyString: data => data[selectBy],
                localSort: queryData =>
                  withSort(queryData, (a, b) => {
                    let ret;
                    return 0 === (ret = compare(a[orderBy], b[orderBy]))
                      ? compare(a.id, b.id)
                      : ret;
                  })
              });
            });
            return queries;
          };
          this.handlers({
            get: function(request) {
              return this.objectStore.get(request.key);
            },
            getAll: function(request) {
              return this.objectStore.getAll();
            },
            create: function(request) {
              return this.objectStore
                .add(request.data)
                .then(() => request.data);
            },
            update: function(request) {
              return this.objectStore.get(request.key).then(oldData => {
                let newData;
                return this.objectStore
                  .put((newData = merge(oldData, request.data)))
                  .then(() => newData);
              });
            },
            delete: function(request) {
              return this.objectStore
                .get(request.key)
                .then(oldData =>
                  this.objectStore.delete(request.key).then(() => oldData)
                );
            }
          });
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    [
      "FluxComponent",
      "dataNodes",
      "log",
      "CanvasElement",
      "Element",
      "EmojiMap"
    ],
    [global, __webpack_require__(18), __webpack_require__(24)],
    (FluxComponent, dataNodes, log, CanvasElement, Element, EmojiMap) => {
      let App;
      return (App = Caf.defClass(class App extends FluxComponent {}, function(
        App,
        classSuper,
        instanceSuper
      ) {
        this.subscriptions(
          "navState.keyPath",
          "navState.currentTab",
          "navState.selectedKey",
          "navState.searchResults"
        );
        this.prototype.render = function() {
          let showSetStatus, cafBase;
          showSetStatus =
            Caf.exists((cafBase = dataNodes[this.selectedKey])) &&
            cafBase.description;
          log({ currentTab: this.currentTab, keyPath: this.keyPath });
          return CanvasElement(
            {
              canvasId: "artCanvas",
              childrenLayout: "column",
              on: {
                ready: ({ target }) =>
                  (this.models.viewState.deviceSize = target.currentSize)
              }
            },
            Element(
              { draw: "#f9f9f9" },
              Element(
                { key: "status", size: { ww: 1, hh: 1, h: -110 } },
                showSetStatus
                  ? __webpack_require__(171)({ key: this.selectedKey })
                  : this.keyPath[0] === "needs"
                    ? __webpack_require__(169)()
                    : undefined
              ),
              Element(
                {
                  size: { ww: 1, hch: 1 },
                  axis: "bottomLeft",
                  location: { yh: 1 },
                  childrenLayout: "column",
                  draw: "white"
                },
                (() => {
                  switch (this.currentTab) {
                    case "search":
                      return [
                        __webpack_require__(106)({ keys: this.searchResults }),
                        __webpack_require__(170)()
                      ];
                    case "affirmations":
                      return __webpack_require__(168)();
                    default:
                      return [
                        this.keyPath.length > 0
                          ? __webpack_require__(172)()
                          : undefined,
                        !showSetStatus && this.selectedKey
                          ? __webpack_require__(106)({ key: this.selectedKey })
                          : undefined
                      ];
                  }
                })(),
                Element(
                  {
                    size: { ww: 1, h: 70 },
                    padding: 5,
                    childrenLayout: "row",
                    childrenAlignment: "centerCenter"
                  },
                  Caf.array(["needs", "emotions"], key =>
                    __webpack_require__(49)({
                      style: "tab",
                      subtext: key,
                      emoji: EmojiMap[key],
                      action: () => this.models.navState.selectKey(key),
                      size: { ps: 1 }
                    })
                  ),
                  __webpack_require__(49)({
                    style: "tab",
                    subtext: "affirmations",
                    emoji: "",
                    action: this.models.navState.showAffirmations,
                    size: { ps: 1 }
                  }),
                  __webpack_require__(49)({
                    style: "tab",
                    subtext: "about",
                    emoji: EmojiMap.about,
                    action: () => this.models.navState.selectKey("about"),
                    size: { ps: 1 }
                  }),
                  __webpack_require__(49)({
                    style: "tab",
                    subtext: "search",
                    emoji: "",
                    action: this.models.navState.toggleSearchVisible,
                    size: { ps: 1 }
                  })
                )
              )
            )
          );
        };
      }));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["FullScreenApp"],
    [global, __webpack_require__(17)],
    FullScreenApp => {
      __webpack_require__(318);
      return FullScreenApp.init({
        title: "Needs and Emotions",
        meta: { "apple-mobile-web-app-status-bar-style": "default" },
        link: { "apple-touch-icon": { href: "assets/needs256.png" } }
      })
        .then(function() {
          return __webpack_require__(55).sendInitializeRequestToAllPipelines();
        })
        .then(function() {
          return __webpack_require__(314)
            .App()
            .instantiateAsTopComponent();
        });
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["ApplicationState", "Array", "peek", "compactFlatten", "escapeRegExp"],
    [global, __webpack_require__(17)],
    (ApplicationState, Array, peek, compactFlatten, escapeRegExp) => {
      let dataNodes, NavState;
      ({ dataNodes } = __webpack_require__(24));
      return (NavState = Caf.defClass(
        class NavState extends ApplicationState {},
        function(NavState, classSuper, instanceSuper) {
          let searchNodes;
          this.stateFields({
            selectedKey: "about",
            keyPath: ["about"],
            currentTab: null,
            searchResults: [],
            searchQuery: null
          });
          this.prototype.selectKey = function(key) {
            let depth, node, keyPath;
            this.clearCurrentTab();
            ({ depth } = node = __webpack_require__(24).dataNodes[key]);
            if (this.keyPath[depth] === key) {
              keyPath = this.keyPath.slice(
                0,
                depth + (this.keyPath.length - 1 === depth ? 0 : 1)
              );
            } else {
              keyPath = new Array(depth + 1);
              while ((Caf.exists(node) && node.depth) >= 0) {
                keyPath[node.depth] = node.key;
                node = dataNodes[node.parentKey];
              }
            }
            return this.setKeyPath(keyPath);
          };
          this.prototype.setKeyPath = function(keyPath) {
            this.setState({ selectedKey: peek(keyPath), keyPath });
            return keyPath;
          };
          this.prototype.clearSelectedKey = function() {
            return this.setState({ selectedKey: null, keyPath: [] });
          };
          this.prototype.toggleSearchVisible = function() {
            return this.currentTab === "search"
              ? (this.currentTab = null)
              : ((this.currentTab = "search"), this.clearSelectedKey());
          };
          this.prototype.showAffirmations = function() {
            return (this.currentTab = "affirmations");
          };
          searchNodes = function(regexps) {
            return Caf.array(dataNodes, (v, k) => {
              let toTest, matchedAll;
              toTest = `${Caf.toString(k)} ${Caf.toString(v.description)}`;
              matchedAll = true;
              Caf.each2(
                regexps,
                reg => (!reg.test(toTest) ? (matchedAll = false) : undefined)
              );
              return matchedAll ? k : undefined;
            });
          };
          this.prototype.search = function(query) {
            this.searchQuery = query;
            return (this.searchResults =
              query.length > 1
                ? compactFlatten(
                    searchNodes(
                      Caf.array(query.split(/\s+/), term =>
                        RegExp(`${Caf.toString(escapeRegExp(term))}`, "i")
                      )
                    )
                  )
                : []);
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["ApplicationState", "bound"],
    [global, __webpack_require__(17)],
    (ApplicationState, bound) => {
      let Status;
      return (Status = Caf.defClass(
        class Status extends ApplicationState {},
        function(Status, classSuper, instanceSuper) {
          this.persistant();
          this.prototype.set = function(key, status) {
            return this.setState(key, bound(1, (status + 0.5) | 0, 5));
          };
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["ApplicationState"],
    [global, __webpack_require__(17)],
    ApplicationState => {
      let ViewState;
      return (ViewState = Caf.defClass(
        class ViewState extends ApplicationState {},
        function(ViewState, classSuper, instanceSuper) {
          this.stateFields({ deviceSize: null });
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["isPlainObject", "isString", "w"],
    [global, __webpack_require__(17)],
    (isPlainObject, isString, w) => {
      let normalizeEmotions;
      normalizeEmotions = function(emotionTree) {
        return Caf.object(
          emotionTree,
          val =>
            isPlainObject(val)
              ? normalizeEmotions(val)
              : isString(val)
                ? w(val)
                    .sort()
                    .join(", ")
                : val
        );
      };
      return {
        dataNodes: __webpack_require__(177).flatten({
          core: {
            needs: __webpack_require__(174),
            emotions: {
              pleasurable: normalizeEmotions(__webpack_require__(176)),
              painful: normalizeEmotions(__webpack_require__(175))
            },
            about: `Needs & Emotions v${Caf.toString(
              __webpack_require__(102).version
            )}\n\nShane Brinkman-Davis Delamore\nshanebdavis@gmail.com`
          }
        })
      };
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return { needs: "", emotions: "", selected: "", about: "" };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return {
    package: __webpack_require__(102),
    version: __webpack_require__(102).version
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["IndexedDbPipeline"],
    [global, __webpack_require__(107)],
    IndexedDbPipeline => {
      let Affirmation;
      return (Affirmation = Caf.defClass(
        class Affirmation extends IndexedDbPipeline {},
        function(Affirmation, classSuper, instanceSuper) {
          this.prototype.dbName = "SbdSelfImprovementApp";
          this.addDatabaseFilters({
            text: "required trimmedString",
            lastWorkedAt: "timestamp",
            lastRemindedAt: "timestamp",
            count: "count",
            objectionCount: "count"
          });
          this.query({
            allAffirmations: {
              query: function(request) {
                return request
                  .subrequest("Affirmation", "getAll")
                  .then(affirmations =>
                    affirmations.sort((a, b) => b.updatedAt - a.updatedAt)
                  );
              },
              dataToKeyString: function() {
                return "all";
              }
            }
          });
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {
let Caf = __webpack_require__(8);
Caf.defMod(module, () => {
  return Caf.importInvoke(
    ["IndexedDbPipeline"],
    [global, __webpack_require__(107)],
    IndexedDbPipeline => {
      let AffirmationDay;
      return (AffirmationDay = Caf.defClass(
        class AffirmationDay extends IndexedDbPipeline {},
        function(AffirmationDay, classSuper, instanceSuper) {
          this.prototype.dbName = "SbdSelfImprovementApp";
          this.indexes({
            affirmationDayByAffirmation: "affirmationId/createdAt"
          });
          this.addDatabaseFilters({
            affirmation: "required link",
            count: "count",
            objectionCount: "count"
          });
        }
      ));
    }
  );
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

var asn1 = __webpack_require__(50);
var inherits = __webpack_require__(7);

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = __webpack_require__(631).runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

var Reporter = __webpack_require__(51).Reporter;
var EncoderBuffer = __webpack_require__(51).EncoderBuffer;
var DecoderBuffer = __webpack_require__(51).DecoderBuffer;
var assert = __webpack_require__(15);

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};


/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(7);

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

var constants = __webpack_require__(179);

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

var decoders = exports;

decoders.der = __webpack_require__(180);
decoders.pem = __webpack_require__(371);


/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(7);
var Buffer = __webpack_require__(5).Buffer;

var DERDecoder = __webpack_require__(180);

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

var encoders = exports;

encoders.der = __webpack_require__(181);
encoders.pem = __webpack_require__(373);


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

var inherits = __webpack_require__(7);

var DEREncoder = __webpack_require__(181);

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2017 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 3.5.1
 * Features enabled: core
 * Features disabled: race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
*/
!function(t){if(true)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;"undefined"!=typeof window?e=window:"undefined"!=typeof global?e=global:"undefined"!=typeof self&&(e=self),e.Promise=t()}}(function(){var t,e,n;return function r(t,e,n){function i(a,s){if(!e[a]){if(!t[a]){var c="function"==typeof _dereq_&&_dereq_;if(!s&&c)return c(a,!0);if(o)return o(a,!0);var l=new Error("Cannot find module '"+a+"'");throw l.code="MODULE_NOT_FOUND",l}var u=e[a]={exports:{}};t[a][0].call(u.exports,function(e){var n=t[a][1][e];return i(n?n:e)},u,u.exports,r,t,e,n)}return e[a].exports}for(var o="function"==typeof _dereq_&&_dereq_,a=0;a<n.length;a++)i(n[a]);return i}({1:[function(t,e,n){"use strict";function r(){this._customScheduler=!1,this._isTickUsed=!1,this._lateQueue=new u(16),this._normalQueue=new u(16),this._haveDrainedQueues=!1,this._trampolineEnabled=!0;var t=this;this.drainQueues=function(){t._drainQueues()},this._schedule=l}function i(t,e,n){this._lateQueue.push(t,e,n),this._queueTick()}function o(t,e,n){this._normalQueue.push(t,e,n),this._queueTick()}function a(t){this._normalQueue._pushOne(t),this._queueTick()}var s;try{throw new Error}catch(c){s=c}var l=t("./schedule"),u=t("./queue"),p=t("./util");r.prototype.setScheduler=function(t){var e=this._schedule;return this._schedule=t,this._customScheduler=!0,e},r.prototype.hasCustomScheduler=function(){return this._customScheduler},r.prototype.enableTrampoline=function(){this._trampolineEnabled=!0},r.prototype.disableTrampolineIfNecessary=function(){p.hasDevTools&&(this._trampolineEnabled=!1)},r.prototype.haveItemsQueued=function(){return this._isTickUsed||this._haveDrainedQueues},r.prototype.fatalError=function(t,e){e?(process.stderr.write("Fatal "+(t instanceof Error?t.stack:t)+"\n"),process.exit(2)):this.throwLater(t)},r.prototype.throwLater=function(t,e){if(1===arguments.length&&(e=t,t=function(){throw e}),"undefined"!=typeof setTimeout)setTimeout(function(){t(e)},0);else try{this._schedule(function(){t(e)})}catch(n){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")}},p.hasDevTools?(r.prototype.invokeLater=function(t,e,n){this._trampolineEnabled?i.call(this,t,e,n):this._schedule(function(){setTimeout(function(){t.call(e,n)},100)})},r.prototype.invoke=function(t,e,n){this._trampolineEnabled?o.call(this,t,e,n):this._schedule(function(){t.call(e,n)})},r.prototype.settlePromises=function(t){this._trampolineEnabled?a.call(this,t):this._schedule(function(){t._settlePromises()})}):(r.prototype.invokeLater=i,r.prototype.invoke=o,r.prototype.settlePromises=a),r.prototype._drainQueue=function(t){for(;t.length()>0;){var e=t.shift();if("function"==typeof e){var n=t.shift(),r=t.shift();e.call(n,r)}else e._settlePromises()}},r.prototype._drainQueues=function(){this._drainQueue(this._normalQueue),this._reset(),this._haveDrainedQueues=!0,this._drainQueue(this._lateQueue)},r.prototype._queueTick=function(){this._isTickUsed||(this._isTickUsed=!0,this._schedule(this.drainQueues))},r.prototype._reset=function(){this._isTickUsed=!1},e.exports=r,e.exports.firstLineError=s},{"./queue":17,"./schedule":18,"./util":21}],2:[function(t,e,n){"use strict";e.exports=function(t,e,n,r){var i=!1,o=function(t,e){this._reject(e)},a=function(t,e){e.promiseRejectionQueued=!0,e.bindingPromise._then(o,o,null,this,t)},s=function(t,e){0===(50397184&this._bitField)&&this._resolveCallback(e.target)},c=function(t,e){e.promiseRejectionQueued||this._reject(t)};t.prototype.bind=function(o){i||(i=!0,t.prototype._propagateFrom=r.propagateFromFunction(),t.prototype._boundValue=r.boundValueFunction());var l=n(o),u=new t(e);u._propagateFrom(this,1);var p=this._target();if(u._setBoundTo(l),l instanceof t){var f={promiseRejectionQueued:!1,promise:u,target:p,bindingPromise:l};p._then(e,a,void 0,u,f),l._then(s,c,void 0,u,f),u._setOnCancel(l)}else u._resolveCallback(p);return u},t.prototype._setBoundTo=function(t){void 0!==t?(this._bitField=2097152|this._bitField,this._boundTo=t):this._bitField=-2097153&this._bitField},t.prototype._isBound=function(){return 2097152===(2097152&this._bitField)},t.bind=function(e,n){return t.resolve(n).bind(e)}}},{}],3:[function(t,e,n){"use strict";function r(){try{Promise===o&&(Promise=i)}catch(t){}return o}var i;"undefined"!=typeof Promise&&(i=Promise);var o=t("./promise")();o.noConflict=r,e.exports=o},{"./promise":15}],4:[function(t,e,n){"use strict";e.exports=function(e,n,r,i){var o=t("./util"),a=o.tryCatch,s=o.errorObj,c=e._async;e.prototype["break"]=e.prototype.cancel=function(){if(!i.cancellation())return this._warn("cancellation is disabled");for(var t=this,e=t;t._isCancellable();){if(!t._cancelBy(e)){e._isFollowing()?e._followee().cancel():e._cancelBranched();break}var n=t._cancellationParent;if(null==n||!n._isCancellable()){t._isFollowing()?t._followee().cancel():t._cancelBranched();break}t._isFollowing()&&t._followee().cancel(),t._setWillBeCancelled(),e=t,t=n}},e.prototype._branchHasCancelled=function(){this._branchesRemainingToCancel--},e.prototype._enoughBranchesHaveCancelled=function(){return void 0===this._branchesRemainingToCancel||this._branchesRemainingToCancel<=0},e.prototype._cancelBy=function(t){return t===this?(this._branchesRemainingToCancel=0,this._invokeOnCancel(),!0):(this._branchHasCancelled(),this._enoughBranchesHaveCancelled()?(this._invokeOnCancel(),!0):!1)},e.prototype._cancelBranched=function(){this._enoughBranchesHaveCancelled()&&this._cancel()},e.prototype._cancel=function(){this._isCancellable()&&(this._setCancelled(),c.invoke(this._cancelPromises,this,void 0))},e.prototype._cancelPromises=function(){this._length()>0&&this._settlePromises()},e.prototype._unsetOnCancel=function(){this._onCancelField=void 0},e.prototype._isCancellable=function(){return this.isPending()&&!this._isCancelled()},e.prototype.isCancellable=function(){return this.isPending()&&!this.isCancelled()},e.prototype._doInvokeOnCancel=function(t,e){if(o.isArray(t))for(var n=0;n<t.length;++n)this._doInvokeOnCancel(t[n],e);else if(void 0!==t)if("function"==typeof t){if(!e){var r=a(t).call(this._boundValue());r===s&&(this._attachExtraTrace(r.e),c.throwLater(r.e))}}else t._resultCancelled(this)},e.prototype._invokeOnCancel=function(){var t=this._onCancel();this._unsetOnCancel(),c.invoke(this._doInvokeOnCancel,this,t)},e.prototype._invokeInternalOnCancel=function(){this._isCancellable()&&(this._doInvokeOnCancel(this._onCancel(),!0),this._unsetOnCancel())},e.prototype._resultCancelled=function(){this.cancel()}}},{"./util":21}],5:[function(t,e,n){"use strict";e.exports=function(e){function n(t,n,s){return function(c){var l=s._boundValue();t:for(var u=0;u<t.length;++u){var p=t[u];if(p===Error||null!=p&&p.prototype instanceof Error){if(c instanceof p)return o(n).call(l,c)}else if("function"==typeof p){var f=o(p).call(l,c);if(f===a)return f;if(f)return o(n).call(l,c)}else if(r.isObject(c)){for(var h=i(p),_=0;_<h.length;++_){var d=h[_];if(p[d]!=c[d])continue t}return o(n).call(l,c)}}return e}}var r=t("./util"),i=t("./es5").keys,o=r.tryCatch,a=r.errorObj;return n}},{"./es5":10,"./util":21}],6:[function(t,e,n){"use strict";e.exports=function(t){function e(){this._trace=new e.CapturedTrace(r())}function n(){return i?new e:void 0}function r(){var t=o.length-1;return t>=0?o[t]:void 0}var i=!1,o=[];return t.prototype._promiseCreated=function(){},t.prototype._pushContext=function(){},t.prototype._popContext=function(){return null},t._peekContext=t.prototype._peekContext=function(){},e.prototype._pushContext=function(){void 0!==this._trace&&(this._trace._promiseCreated=null,o.push(this._trace))},e.prototype._popContext=function(){if(void 0!==this._trace){var t=o.pop(),e=t._promiseCreated;return t._promiseCreated=null,e}return null},e.CapturedTrace=null,e.create=n,e.deactivateLongStackTraces=function(){},e.activateLongStackTraces=function(){var n=t.prototype._pushContext,o=t.prototype._popContext,a=t._peekContext,s=t.prototype._peekContext,c=t.prototype._promiseCreated;e.deactivateLongStackTraces=function(){t.prototype._pushContext=n,t.prototype._popContext=o,t._peekContext=a,t.prototype._peekContext=s,t.prototype._promiseCreated=c,i=!1},i=!0,t.prototype._pushContext=e.prototype._pushContext,t.prototype._popContext=e.prototype._popContext,t._peekContext=t.prototype._peekContext=r,t.prototype._promiseCreated=function(){var t=this._peekContext();t&&null==t._promiseCreated&&(t._promiseCreated=this)}},e}},{}],7:[function(t,e,n){"use strict";e.exports=function(e,n){function r(t,e){return{promise:e}}function i(){return!1}function o(t,e,n){var r=this;try{t(e,n,function(t){if("function"!=typeof t)throw new TypeError("onCancel must be a function, got: "+I.toString(t));r._attachCancellationCallback(t)})}catch(i){return i}}function a(t){if(!this._isCancellable())return this;var e=this._onCancel();void 0!==e?I.isArray(e)?e.push(t):this._setOnCancel([e,t]):this._setOnCancel(t)}function s(){return this._onCancelField}function c(t){this._onCancelField=t}function l(){this._cancellationParent=void 0,this._onCancelField=void 0}function u(t,e){if(0!==(1&e)){this._cancellationParent=t;var n=t._branchesRemainingToCancel;void 0===n&&(n=0),t._branchesRemainingToCancel=n+1}0!==(2&e)&&t._isBound()&&this._setBoundTo(t._boundTo)}function p(t,e){0!==(2&e)&&t._isBound()&&this._setBoundTo(t._boundTo)}function f(){var t=this._boundTo;return void 0!==t&&t instanceof e?t.isFulfilled()?t.value():void 0:t}function h(){this._trace=new x(this._peekContext())}function _(t,e){if(H(t)){var n=this._trace;if(void 0!==n&&e&&(n=n._parent),void 0!==n)n.attachExtraTrace(t);else if(!t.__stackCleaned__){var r=E(t);I.notEnumerableProp(t,"stack",r.message+"\n"+r.stack.join("\n")),I.notEnumerableProp(t,"__stackCleaned__",!0)}}}function d(t,e,n,r,i){if(void 0===t&&null!==e&&X){if(void 0!==i&&i._returnedNonUndefined())return;if(0===(65535&r._bitField))return;n&&(n+=" ");var o="",a="";if(e._trace){for(var s=e._trace.stack.split("\n"),c=C(s),l=c.length-1;l>=0;--l){var u=c[l];if(!V.test(u)){var p=u.match(Q);p&&(o="at "+p[1]+":"+p[2]+":"+p[3]+" ");break}}if(c.length>0)for(var f=c[0],l=0;l<s.length;++l)if(s[l]===f){l>0&&(a="\n"+s[l-1]);break}}var h="a promise was created in a "+n+"handler "+o+"but was not returned from it, see http://goo.gl/rRqMUw"+a;r._warn(h,!0,e)}}function v(t,e){var n=t+" is deprecated and will be removed in a future version.";return e&&(n+=" Use "+e+" instead."),y(n)}function y(t,n,r){if(ot.warnings){var i,o=new U(t);if(n)r._attachExtraTrace(o);else if(ot.longStackTraces&&(i=e._peekContext()))i.attachExtraTrace(o);else{var a=E(o);o.stack=a.message+"\n"+a.stack.join("\n")}tt("warning",o)||k(o,"",!0)}}function g(t,e){for(var n=0;n<e.length-1;++n)e[n].push("From previous event:"),e[n]=e[n].join("\n");return n<e.length&&(e[n]=e[n].join("\n")),t+"\n"+e.join("\n")}function m(t){for(var e=0;e<t.length;++e)(0===t[e].length||e+1<t.length&&t[e][0]===t[e+1][0])&&(t.splice(e,1),e--)}function b(t){for(var e=t[0],n=1;n<t.length;++n){for(var r=t[n],i=e.length-1,o=e[i],a=-1,s=r.length-1;s>=0;--s)if(r[s]===o){a=s;break}for(var s=a;s>=0;--s){var c=r[s];if(e[i]!==c)break;e.pop(),i--}e=r}}function C(t){for(var e=[],n=0;n<t.length;++n){var r=t[n],i="    (No stack trace)"===r||q.test(r),o=i&&nt(r);i&&!o&&(M&&" "!==r.charAt(0)&&(r="    "+r),e.push(r))}return e}function w(t){for(var e=t.stack.replace(/\s+$/g,"").split("\n"),n=0;n<e.length;++n){var r=e[n];if("    (No stack trace)"===r||q.test(r))break}return n>0&&"SyntaxError"!=t.name&&(e=e.slice(n)),e}function E(t){var e=t.stack,n=t.toString();return e="string"==typeof e&&e.length>0?w(t):["    (No stack trace)"],{message:n,stack:"SyntaxError"==t.name?e:C(e)}}function k(t,e,n){if("undefined"!=typeof console){var r;if(I.isObject(t)){var i=t.stack;r=e+G(i,t)}else r=e+String(t);"function"==typeof N?N(r,n):("function"==typeof console.log||"object"==typeof console.log)&&console.log(r)}}function j(t,e,n,r){var i=!1;try{"function"==typeof e&&(i=!0,"rejectionHandled"===t?e(r):e(n,r))}catch(o){B.throwLater(o)}"unhandledRejection"===t?tt(t,n,r)||i||k(n,"Unhandled rejection "):tt(t,r)}function F(t){var e;if("function"==typeof t)e="[function "+(t.name||"anonymous")+"]";else{e=t&&"function"==typeof t.toString?t.toString():I.toString(t);var n=/\[object [a-zA-Z0-9$_]+\]/;if(n.test(e))try{var r=JSON.stringify(t);e=r}catch(i){}0===e.length&&(e="(empty array)")}return"(<"+T(e)+">, no stack trace)"}function T(t){var e=41;return t.length<e?t:t.substr(0,e-3)+"..."}function P(){return"function"==typeof it}function R(t){var e=t.match(rt);return e?{fileName:e[1],line:parseInt(e[2],10)}:void 0}function S(t,e){if(P()){for(var n,r,i=t.stack.split("\n"),o=e.stack.split("\n"),a=-1,s=-1,c=0;c<i.length;++c){var l=R(i[c]);if(l){n=l.fileName,a=l.line;break}}for(var c=0;c<o.length;++c){var l=R(o[c]);if(l){r=l.fileName,s=l.line;break}}0>a||0>s||!n||!r||n!==r||a>=s||(nt=function(t){if(D.test(t))return!0;var e=R(t);return e&&e.fileName===n&&a<=e.line&&e.line<=s?!0:!1})}}function x(t){this._parent=t,this._promisesCreated=0;var e=this._length=1+(void 0===t?0:t._length);it(this,x),e>32&&this.uncycle()}var O,A,N,L=e._getDomain,B=e._async,U=t("./errors").Warning,I=t("./util"),H=I.canAttachTrace,D=/[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/,V=/\((?:timers\.js):\d+:\d+\)/,Q=/[\/<\(](.+?):(\d+):(\d+)\)?\s*$/,q=null,G=null,M=!1,W=!(0==I.env("BLUEBIRD_DEBUG")||!I.env("BLUEBIRD_DEBUG")&&"development"!==I.env("NODE_ENV")),$=!(0==I.env("BLUEBIRD_WARNINGS")||!W&&!I.env("BLUEBIRD_WARNINGS")),z=!(0==I.env("BLUEBIRD_LONG_STACK_TRACES")||!W&&!I.env("BLUEBIRD_LONG_STACK_TRACES")),X=0!=I.env("BLUEBIRD_W_FORGOTTEN_RETURN")&&($||!!I.env("BLUEBIRD_W_FORGOTTEN_RETURN"));e.prototype.suppressUnhandledRejections=function(){var t=this._target();t._bitField=-1048577&t._bitField|524288},e.prototype._ensurePossibleRejectionHandled=function(){if(0===(524288&this._bitField)){this._setRejectionIsUnhandled();var t=this;setTimeout(function(){t._notifyUnhandledRejection()},1)}},e.prototype._notifyUnhandledRejectionIsHandled=function(){j("rejectionHandled",O,void 0,this)},e.prototype._setReturnedNonUndefined=function(){this._bitField=268435456|this._bitField},e.prototype._returnedNonUndefined=function(){return 0!==(268435456&this._bitField)},e.prototype._notifyUnhandledRejection=function(){if(this._isRejectionUnhandled()){var t=this._settledValue();this._setUnhandledRejectionIsNotified(),j("unhandledRejection",A,t,this)}},e.prototype._setUnhandledRejectionIsNotified=function(){this._bitField=262144|this._bitField},e.prototype._unsetUnhandledRejectionIsNotified=function(){this._bitField=-262145&this._bitField},e.prototype._isUnhandledRejectionNotified=function(){return(262144&this._bitField)>0},e.prototype._setRejectionIsUnhandled=function(){this._bitField=1048576|this._bitField},e.prototype._unsetRejectionIsUnhandled=function(){this._bitField=-1048577&this._bitField,this._isUnhandledRejectionNotified()&&(this._unsetUnhandledRejectionIsNotified(),this._notifyUnhandledRejectionIsHandled())},e.prototype._isRejectionUnhandled=function(){return(1048576&this._bitField)>0},e.prototype._warn=function(t,e,n){return y(t,e,n||this)},e.onPossiblyUnhandledRejection=function(t){var e=L();A="function"==typeof t?null===e?t:I.domainBind(e,t):void 0},e.onUnhandledRejectionHandled=function(t){var e=L();O="function"==typeof t?null===e?t:I.domainBind(e,t):void 0};var K=function(){};e.longStackTraces=function(){if(B.haveItemsQueued()&&!ot.longStackTraces)throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");if(!ot.longStackTraces&&P()){var t=e.prototype._captureStackTrace,r=e.prototype._attachExtraTrace;ot.longStackTraces=!0,K=function(){if(B.haveItemsQueued()&&!ot.longStackTraces)throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");e.prototype._captureStackTrace=t,e.prototype._attachExtraTrace=r,n.deactivateLongStackTraces(),B.enableTrampoline(),ot.longStackTraces=!1},e.prototype._captureStackTrace=h,e.prototype._attachExtraTrace=_,n.activateLongStackTraces(),B.disableTrampolineIfNecessary()}},e.hasLongStackTraces=function(){return ot.longStackTraces&&P()};var J=function(){try{if("function"==typeof CustomEvent){var t=new CustomEvent("CustomEvent");return I.global.dispatchEvent(t),function(t,e){var n=new CustomEvent(t.toLowerCase(),{detail:e,cancelable:!0});return!I.global.dispatchEvent(n)}}if("function"==typeof Event){var t=new Event("CustomEvent");return I.global.dispatchEvent(t),function(t,e){var n=new Event(t.toLowerCase(),{cancelable:!0});return n.detail=e,!I.global.dispatchEvent(n)}}var t=document.createEvent("CustomEvent");return t.initCustomEvent("testingtheevent",!1,!0,{}),I.global.dispatchEvent(t),function(t,e){var n=document.createEvent("CustomEvent");return n.initCustomEvent(t.toLowerCase(),!1,!0,e),!I.global.dispatchEvent(n)}}catch(e){}return function(){return!1}}(),Y=function(){return I.isNode?function(){return process.emit.apply(process,arguments)}:I.global?function(t){var e="on"+t.toLowerCase(),n=I.global[e];return n?(n.apply(I.global,[].slice.call(arguments,1)),!0):!1}:function(){return!1}}(),Z={promiseCreated:r,promiseFulfilled:r,promiseRejected:r,promiseResolved:r,promiseCancelled:r,promiseChained:function(t,e,n){return{promise:e,child:n}},warning:function(t,e){return{warning:e}},unhandledRejection:function(t,e,n){return{reason:e,promise:n}},rejectionHandled:r},tt=function(t){var e=!1;try{e=Y.apply(null,arguments)}catch(n){B.throwLater(n),e=!0}var r=!1;try{r=J(t,Z[t].apply(null,arguments))}catch(n){B.throwLater(n),r=!0}return r||e};e.config=function(t){if(t=Object(t),"longStackTraces"in t&&(t.longStackTraces?e.longStackTraces():!t.longStackTraces&&e.hasLongStackTraces()&&K()),"warnings"in t){var n=t.warnings;ot.warnings=!!n,X=ot.warnings,I.isObject(n)&&"wForgottenReturn"in n&&(X=!!n.wForgottenReturn)}if("cancellation"in t&&t.cancellation&&!ot.cancellation){if(B.haveItemsQueued())throw new Error("cannot enable cancellation after promises are in use");e.prototype._clearCancellationData=l,e.prototype._propagateFrom=u,e.prototype._onCancel=s,e.prototype._setOnCancel=c,e.prototype._attachCancellationCallback=a,e.prototype._execute=o,et=u,ot.cancellation=!0}return"monitoring"in t&&(t.monitoring&&!ot.monitoring?(ot.monitoring=!0,e.prototype._fireEvent=tt):!t.monitoring&&ot.monitoring&&(ot.monitoring=!1,e.prototype._fireEvent=i)),e},e.prototype._fireEvent=i,e.prototype._execute=function(t,e,n){try{t(e,n)}catch(r){return r}},e.prototype._onCancel=function(){},e.prototype._setOnCancel=function(t){},e.prototype._attachCancellationCallback=function(t){},e.prototype._captureStackTrace=function(){},e.prototype._attachExtraTrace=function(){},e.prototype._clearCancellationData=function(){},e.prototype._propagateFrom=function(t,e){};var et=p,nt=function(){return!1},rt=/[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;I.inherits(x,Error),n.CapturedTrace=x,x.prototype.uncycle=function(){var t=this._length;if(!(2>t)){for(var e=[],n={},r=0,i=this;void 0!==i;++r)e.push(i),i=i._parent;t=this._length=r;for(var r=t-1;r>=0;--r){var o=e[r].stack;void 0===n[o]&&(n[o]=r)}for(var r=0;t>r;++r){var a=e[r].stack,s=n[a];if(void 0!==s&&s!==r){s>0&&(e[s-1]._parent=void 0,e[s-1]._length=1),e[r]._parent=void 0,e[r]._length=1;var c=r>0?e[r-1]:this;t-1>s?(c._parent=e[s+1],c._parent.uncycle(),c._length=c._parent._length+1):(c._parent=void 0,c._length=1);for(var l=c._length+1,u=r-2;u>=0;--u)e[u]._length=l,l++;return}}}},x.prototype.attachExtraTrace=function(t){if(!t.__stackCleaned__){this.uncycle();for(var e=E(t),n=e.message,r=[e.stack],i=this;void 0!==i;)r.push(C(i.stack.split("\n"))),i=i._parent;b(r),m(r),I.notEnumerableProp(t,"stack",g(n,r)),I.notEnumerableProp(t,"__stackCleaned__",!0)}};var it=function(){var t=/^\s*at\s*/,e=function(t,e){return"string"==typeof t?t:void 0!==e.name&&void 0!==e.message?e.toString():F(e)};if("number"==typeof Error.stackTraceLimit&&"function"==typeof Error.captureStackTrace){Error.stackTraceLimit+=6,q=t,G=e;var n=Error.captureStackTrace;return nt=function(t){return D.test(t)},function(t,e){Error.stackTraceLimit+=6,n(t,e),Error.stackTraceLimit-=6}}var r=new Error;if("string"==typeof r.stack&&r.stack.split("\n")[0].indexOf("stackDetection@")>=0)return q=/@/,G=e,M=!0,function(t){t.stack=(new Error).stack};var i;try{throw new Error}catch(o){i="stack"in o}return"stack"in r||!i||"number"!=typeof Error.stackTraceLimit?(G=function(t,e){return"string"==typeof t?t:"object"!=typeof e&&"function"!=typeof e||void 0===e.name||void 0===e.message?F(e):e.toString()},null):(q=t,G=e,function(t){Error.stackTraceLimit+=6;try{throw new Error}catch(e){t.stack=e.stack}Error.stackTraceLimit-=6})}([]);"undefined"!=typeof console&&"undefined"!=typeof console.warn&&(N=function(t){console.warn(t)},I.isNode&&process.stderr.isTTY?N=function(t,e){var n=e?"[33m":"[31m";console.warn(n+t+"[0m\n")}:I.isNode||"string"!=typeof(new Error).stack||(N=function(t,e){console.warn("%c"+t,e?"color: darkorange":"color: red")}));var ot={warnings:$,longStackTraces:!1,cancellation:!1,monitoring:!1};return z&&e.longStackTraces(),{longStackTraces:function(){return ot.longStackTraces},warnings:function(){return ot.warnings},cancellation:function(){return ot.cancellation},monitoring:function(){return ot.monitoring},propagateFromFunction:function(){return et},boundValueFunction:function(){return f},checkForgottenReturns:d,setBounds:S,warn:y,deprecated:v,CapturedTrace:x,fireDomEvent:J,fireGlobalEvent:Y}}},{"./errors":9,"./util":21}],8:[function(t,e,n){"use strict";e.exports=function(t){function e(){return this.value}function n(){throw this.reason}t.prototype["return"]=t.prototype.thenReturn=function(n){return n instanceof t&&n.suppressUnhandledRejections(),this._then(e,void 0,void 0,{value:n},void 0)},t.prototype["throw"]=t.prototype.thenThrow=function(t){return this._then(n,void 0,void 0,{reason:t},void 0)},t.prototype.catchThrow=function(t){if(arguments.length<=1)return this._then(void 0,n,void 0,{reason:t},void 0);var e=arguments[1],r=function(){throw e};return this.caught(t,r)},t.prototype.catchReturn=function(n){if(arguments.length<=1)return n instanceof t&&n.suppressUnhandledRejections(),this._then(void 0,e,void 0,{value:n},void 0);var r=arguments[1];r instanceof t&&r.suppressUnhandledRejections();var i=function(){return r};return this.caught(n,i)}}},{}],9:[function(t,e,n){"use strict";function r(t,e){function n(r){return this instanceof n?(p(this,"message","string"==typeof r?r:e),p(this,"name",t),void(Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):Error.call(this))):new n(r)}return u(n,Error),n}function i(t){return this instanceof i?(p(this,"name","OperationalError"),p(this,"message",t),this.cause=t,this.isOperational=!0,void(t instanceof Error?(p(this,"message",t.message),p(this,"stack",t.stack)):Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor))):new i(t)}var o,a,s=t("./es5"),c=s.freeze,l=t("./util"),u=l.inherits,p=l.notEnumerableProp,f=r("Warning","warning"),h=r("CancellationError","cancellation error"),_=r("TimeoutError","timeout error"),d=r("AggregateError","aggregate error");try{o=TypeError,a=RangeError}catch(v){o=r("TypeError","type error"),a=r("RangeError","range error")}for(var y="join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "),g=0;g<y.length;++g)"function"==typeof Array.prototype[y[g]]&&(d.prototype[y[g]]=Array.prototype[y[g]]);s.defineProperty(d.prototype,"length",{value:0,configurable:!1,writable:!0,enumerable:!0}),d.prototype.isOperational=!0;var m=0;d.prototype.toString=function(){var t=Array(4*m+1).join(" "),e="\n"+t+"AggregateError of:\n";m++,t=Array(4*m+1).join(" ");for(var n=0;n<this.length;++n){for(var r=this[n]===this?"[Circular AggregateError]":this[n]+"",i=r.split("\n"),o=0;o<i.length;++o)i[o]=t+i[o];r=i.join("\n"),e+=r+"\n"}return m--,e},u(i,Error);var b=Error.__BluebirdErrorTypes__;b||(b=c({CancellationError:h,TimeoutError:_,OperationalError:i,RejectionError:i,AggregateError:d}),s.defineProperty(Error,"__BluebirdErrorTypes__",{value:b,writable:!1,enumerable:!1,configurable:!1})),e.exports={Error:Error,TypeError:o,RangeError:a,CancellationError:b.CancellationError,OperationalError:b.OperationalError,TimeoutError:b.TimeoutError,AggregateError:b.AggregateError,Warning:f}},{"./es5":10,"./util":21}],10:[function(t,e,n){var r=function(){"use strict";return void 0===this}();if(r)e.exports={freeze:Object.freeze,defineProperty:Object.defineProperty,getDescriptor:Object.getOwnPropertyDescriptor,keys:Object.keys,names:Object.getOwnPropertyNames,getPrototypeOf:Object.getPrototypeOf,isArray:Array.isArray,isES5:r,propertyIsWritable:function(t,e){var n=Object.getOwnPropertyDescriptor(t,e);return!(n&&!n.writable&&!n.set)}};else{var i={}.hasOwnProperty,o={}.toString,a={}.constructor.prototype,s=function(t){var e=[];for(var n in t)i.call(t,n)&&e.push(n);return e},c=function(t,e){return{value:t[e]}},l=function(t,e,n){return t[e]=n.value,t},u=function(t){return t},p=function(t){try{return Object(t).constructor.prototype}catch(e){return a}},f=function(t){try{return"[object Array]"===o.call(t)}catch(e){return!1}};e.exports={isArray:f,keys:s,names:s,defineProperty:l,getDescriptor:c,freeze:u,getPrototypeOf:p,isES5:r,propertyIsWritable:function(){return!0}}}},{}],11:[function(t,e,n){"use strict";e.exports=function(e,n,r){function i(t,e,n){this.promise=t,this.type=e,this.handler=n,this.called=!1,this.cancelPromise=null}function o(t){this.finallyHandler=t}function a(t,e){return null!=t.cancelPromise?(arguments.length>1?t.cancelPromise._reject(e):t.cancelPromise._cancel(),t.cancelPromise=null,!0):!1}function s(){return l.call(this,this.promise._target()._settledValue())}function c(t){return a(this,t)?void 0:(f.e=t,f)}function l(t){var i=this.promise,l=this.handler;if(!this.called){this.called=!0;var u=this.isFinallyHandler()?l.call(i._boundValue()):l.call(i._boundValue(),t);if(u===r)return u;if(void 0!==u){i._setReturnedNonUndefined();var h=n(u,i);if(h instanceof e){if(null!=this.cancelPromise){if(h._isCancelled()){var _=new p("late cancellation observer");return i._attachExtraTrace(_),f.e=_,f}h.isPending()&&h._attachCancellationCallback(new o(this))}return h._then(s,c,void 0,this,void 0)}}}return i.isRejected()?(a(this),f.e=t,f):(a(this),t)}var u=t("./util"),p=e.CancellationError,f=u.errorObj,h=t("./catch_filter")(r);return i.prototype.isFinallyHandler=function(){return 0===this.type},o.prototype._resultCancelled=function(){a(this.finallyHandler)},e.prototype._passThrough=function(t,e,n,r){return"function"!=typeof t?this.then():this._then(n,r,void 0,new i(this,e,t),void 0)},e.prototype.lastly=e.prototype["finally"]=function(t){return this._passThrough(t,0,l,l)},e.prototype.tap=function(t){return this._passThrough(t,1,l)},e.prototype.tapCatch=function(t){var n=arguments.length;if(1===n)return this._passThrough(t,1,void 0,l);var r,i=new Array(n-1),o=0;for(r=0;n-1>r;++r){var a=arguments[r];if(!u.isObject(a))return e.reject(new TypeError("tapCatch statement predicate: expecting an object but got "+u.classString(a)));i[o++]=a}i.length=o;var s=arguments[r];return this._passThrough(h(i,s,this),1,void 0,l)},i}},{"./catch_filter":5,"./util":21}],12:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o,a){var s=t("./util");s.canEvaluate,s.tryCatch,s.errorObj;e.join=function(){var t,e=arguments.length-1;if(e>0&&"function"==typeof arguments[e]){t=arguments[e];var r}var i=[].slice.call(arguments);t&&i.pop();var r=new n(i).promise();return void 0!==t?r.spread(t):r}}},{"./util":21}],13:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o){var a=t("./util"),s=a.tryCatch;e.method=function(t){if("function"!=typeof t)throw new e.TypeError("expecting a function but got "+a.classString(t));return function(){var r=new e(n);r._captureStackTrace(),r._pushContext();var i=s(t).apply(this,arguments),a=r._popContext();return o.checkForgottenReturns(i,a,"Promise.method",r),r._resolveFromSyncValue(i),r}},e.attempt=e["try"]=function(t){if("function"!=typeof t)return i("expecting a function but got "+a.classString(t));var r=new e(n);r._captureStackTrace(),r._pushContext();var c;if(arguments.length>1){o.deprecated("calling Promise.try with more than 1 argument");var l=arguments[1],u=arguments[2];c=a.isArray(l)?s(t).apply(u,l):s(t).call(u,l)}else c=s(t)();var p=r._popContext();return o.checkForgottenReturns(c,p,"Promise.try",r),r._resolveFromSyncValue(c),r},e.prototype._resolveFromSyncValue=function(t){t===a.errorObj?this._rejectCallback(t.e,!1):this._resolveCallback(t,!0)}}},{"./util":21}],14:[function(t,e,n){"use strict";function r(t){return t instanceof Error&&u.getPrototypeOf(t)===Error.prototype}function i(t){var e;if(r(t)){e=new l(t),e.name=t.name,e.message=t.message,e.stack=t.stack;for(var n=u.keys(t),i=0;i<n.length;++i){var o=n[i];p.test(o)||(e[o]=t[o])}return e}return a.markAsOriginatingFromRejection(t),t}function o(t,e){return function(n,r){if(null!==t){if(n){var o=i(s(n));t._attachExtraTrace(o),t._reject(o)}else if(e){var a=[].slice.call(arguments,1);t._fulfill(a)}else t._fulfill(r);t=null}}}var a=t("./util"),s=a.maybeWrapAsError,c=t("./errors"),l=c.OperationalError,u=t("./es5"),p=/^(?:name|message|stack|cause)$/;e.exports=o},{"./errors":9,"./es5":10,"./util":21}],15:[function(t,e,n){"use strict";e.exports=function(){function n(){}function r(t,e){if(null==t||t.constructor!==i)throw new g("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");if("function"!=typeof e)throw new g("expecting a function but got "+h.classString(e))}function i(t){t!==b&&r(this,t),this._bitField=0,this._fulfillmentHandler0=void 0,this._rejectionHandler0=void 0,this._promise0=void 0,this._receiver0=void 0,this._resolveFromExecutor(t),this._promiseCreated(),this._fireEvent("promiseCreated",this)}function o(t){this.promise._resolveCallback(t)}function a(t){this.promise._rejectCallback(t,!1)}function s(t){var e=new i(b);e._fulfillmentHandler0=t,e._rejectionHandler0=t,e._promise0=t,e._receiver0=t}var c,l=function(){return new g("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n")},u=function(){return new i.PromiseInspection(this._target())},p=function(t){return i.reject(new g(t))},f={},h=t("./util");c=h.isNode?function(){var t=process.domain;return void 0===t&&(t=null),t}:function(){return null},h.notEnumerableProp(i,"_getDomain",c);var _=t("./es5"),d=t("./async"),v=new d;_.defineProperty(i,"_async",{value:v});var y=t("./errors"),g=i.TypeError=y.TypeError;i.RangeError=y.RangeError;var m=i.CancellationError=y.CancellationError;i.TimeoutError=y.TimeoutError,i.OperationalError=y.OperationalError,i.RejectionError=y.OperationalError,i.AggregateError=y.AggregateError;var b=function(){},C={},w={},E=t("./thenables")(i,b),k=t("./promise_array")(i,b,E,p,n),j=t("./context")(i),F=(j.create,t("./debuggability")(i,j)),T=(F.CapturedTrace,t("./finally")(i,E,w)),P=t("./catch_filter")(w),R=t("./nodeback"),S=h.errorObj,x=h.tryCatch;return i.prototype.toString=function(){return"[object Promise]"},i.prototype.caught=i.prototype["catch"]=function(t){var e=arguments.length;if(e>1){var n,r=new Array(e-1),i=0;for(n=0;e-1>n;++n){var o=arguments[n];if(!h.isObject(o))return p("Catch statement predicate: expecting an object but got "+h.classString(o));r[i++]=o}return r.length=i,t=arguments[n],this.then(void 0,P(r,t,this))}return this.then(void 0,t)},i.prototype.reflect=function(){return this._then(u,u,void 0,this,void 0)},i.prototype.then=function(t,e){if(F.warnings()&&arguments.length>0&&"function"!=typeof t&&"function"!=typeof e){var n=".then() only accepts functions but was passed: "+h.classString(t);arguments.length>1&&(n+=", "+h.classString(e)),this._warn(n)}return this._then(t,e,void 0,void 0,void 0)},i.prototype.done=function(t,e){var n=this._then(t,e,void 0,void 0,void 0);n._setIsFinal()},i.prototype.spread=function(t){return"function"!=typeof t?p("expecting a function but got "+h.classString(t)):this.all()._then(t,void 0,void 0,C,void 0);
},i.prototype.toJSON=function(){var t={isFulfilled:!1,isRejected:!1,fulfillmentValue:void 0,rejectionReason:void 0};return this.isFulfilled()?(t.fulfillmentValue=this.value(),t.isFulfilled=!0):this.isRejected()&&(t.rejectionReason=this.reason(),t.isRejected=!0),t},i.prototype.all=function(){return arguments.length>0&&this._warn(".all() was passed arguments but it does not take any"),new k(this).promise()},i.prototype.error=function(t){return this.caught(h.originatesFromRejection,t)},i.getNewLibraryCopy=e.exports,i.is=function(t){return t instanceof i},i.fromNode=i.fromCallback=function(t){var e=new i(b);e._captureStackTrace();var n=arguments.length>1?!!Object(arguments[1]).multiArgs:!1,r=x(t)(R(e,n));return r===S&&e._rejectCallback(r.e,!0),e._isFateSealed()||e._setAsyncGuaranteed(),e},i.all=function(t){return new k(t).promise()},i.cast=function(t){var e=E(t);return e instanceof i||(e=new i(b),e._captureStackTrace(),e._setFulfilled(),e._rejectionHandler0=t),e},i.resolve=i.fulfilled=i.cast,i.reject=i.rejected=function(t){var e=new i(b);return e._captureStackTrace(),e._rejectCallback(t,!0),e},i.setScheduler=function(t){if("function"!=typeof t)throw new g("expecting a function but got "+h.classString(t));return v.setScheduler(t)},i.prototype._then=function(t,e,n,r,o){var a=void 0!==o,s=a?o:new i(b),l=this._target(),u=l._bitField;a||(s._propagateFrom(this,3),s._captureStackTrace(),void 0===r&&0!==(2097152&this._bitField)&&(r=0!==(50397184&u)?this._boundValue():l===this?void 0:this._boundTo),this._fireEvent("promiseChained",this,s));var p=c();if(0!==(50397184&u)){var f,_,d=l._settlePromiseCtx;0!==(33554432&u)?(_=l._rejectionHandler0,f=t):0!==(16777216&u)?(_=l._fulfillmentHandler0,f=e,l._unsetRejectionIsUnhandled()):(d=l._settlePromiseLateCancellationObserver,_=new m("late cancellation observer"),l._attachExtraTrace(_),f=e),v.invoke(d,l,{handler:null===p?f:"function"==typeof f&&h.domainBind(p,f),promise:s,receiver:r,value:_})}else l._addCallbacks(t,e,s,r,p);return s},i.prototype._length=function(){return 65535&this._bitField},i.prototype._isFateSealed=function(){return 0!==(117506048&this._bitField)},i.prototype._isFollowing=function(){return 67108864===(67108864&this._bitField)},i.prototype._setLength=function(t){this._bitField=-65536&this._bitField|65535&t},i.prototype._setFulfilled=function(){this._bitField=33554432|this._bitField,this._fireEvent("promiseFulfilled",this)},i.prototype._setRejected=function(){this._bitField=16777216|this._bitField,this._fireEvent("promiseRejected",this)},i.prototype._setFollowing=function(){this._bitField=67108864|this._bitField,this._fireEvent("promiseResolved",this)},i.prototype._setIsFinal=function(){this._bitField=4194304|this._bitField},i.prototype._isFinal=function(){return(4194304&this._bitField)>0},i.prototype._unsetCancelled=function(){this._bitField=-65537&this._bitField},i.prototype._setCancelled=function(){this._bitField=65536|this._bitField,this._fireEvent("promiseCancelled",this)},i.prototype._setWillBeCancelled=function(){this._bitField=8388608|this._bitField},i.prototype._setAsyncGuaranteed=function(){v.hasCustomScheduler()||(this._bitField=134217728|this._bitField)},i.prototype._receiverAt=function(t){var e=0===t?this._receiver0:this[4*t-4+3];return e===f?void 0:void 0===e&&this._isBound()?this._boundValue():e},i.prototype._promiseAt=function(t){return this[4*t-4+2]},i.prototype._fulfillmentHandlerAt=function(t){return this[4*t-4+0]},i.prototype._rejectionHandlerAt=function(t){return this[4*t-4+1]},i.prototype._boundValue=function(){},i.prototype._migrateCallback0=function(t){var e=(t._bitField,t._fulfillmentHandler0),n=t._rejectionHandler0,r=t._promise0,i=t._receiverAt(0);void 0===i&&(i=f),this._addCallbacks(e,n,r,i,null)},i.prototype._migrateCallbackAt=function(t,e){var n=t._fulfillmentHandlerAt(e),r=t._rejectionHandlerAt(e),i=t._promiseAt(e),o=t._receiverAt(e);void 0===o&&(o=f),this._addCallbacks(n,r,i,o,null)},i.prototype._addCallbacks=function(t,e,n,r,i){var o=this._length();if(o>=65531&&(o=0,this._setLength(0)),0===o)this._promise0=n,this._receiver0=r,"function"==typeof t&&(this._fulfillmentHandler0=null===i?t:h.domainBind(i,t)),"function"==typeof e&&(this._rejectionHandler0=null===i?e:h.domainBind(i,e));else{var a=4*o-4;this[a+2]=n,this[a+3]=r,"function"==typeof t&&(this[a+0]=null===i?t:h.domainBind(i,t)),"function"==typeof e&&(this[a+1]=null===i?e:h.domainBind(i,e))}return this._setLength(o+1),o},i.prototype._proxy=function(t,e){this._addCallbacks(void 0,void 0,e,t,null)},i.prototype._resolveCallback=function(t,e){if(0===(117506048&this._bitField)){if(t===this)return this._rejectCallback(l(),!1);var n=E(t,this);if(!(n instanceof i))return this._fulfill(t);e&&this._propagateFrom(n,2);var r=n._target();if(r===this)return void this._reject(l());var o=r._bitField;if(0===(50397184&o)){var a=this._length();a>0&&r._migrateCallback0(this);for(var s=1;a>s;++s)r._migrateCallbackAt(this,s);this._setFollowing(),this._setLength(0),this._setFollowee(r)}else if(0!==(33554432&o))this._fulfill(r._value());else if(0!==(16777216&o))this._reject(r._reason());else{var c=new m("late cancellation observer");r._attachExtraTrace(c),this._reject(c)}}},i.prototype._rejectCallback=function(t,e,n){var r=h.ensureErrorObject(t),i=r===t;if(!i&&!n&&F.warnings()){var o="a promise was rejected with a non-error: "+h.classString(t);this._warn(o,!0)}this._attachExtraTrace(r,e?i:!1),this._reject(t)},i.prototype._resolveFromExecutor=function(t){if(t!==b){var e=this;this._captureStackTrace(),this._pushContext();var n=!0,r=this._execute(t,function(t){e._resolveCallback(t)},function(t){e._rejectCallback(t,n)});n=!1,this._popContext(),void 0!==r&&e._rejectCallback(r,!0)}},i.prototype._settlePromiseFromHandler=function(t,e,n,r){var i=r._bitField;if(0===(65536&i)){r._pushContext();var o;e===C?n&&"number"==typeof n.length?o=x(t).apply(this._boundValue(),n):(o=S,o.e=new g("cannot .spread() a non-array: "+h.classString(n))):o=x(t).call(e,n);var a=r._popContext();i=r._bitField,0===(65536&i)&&(o===w?r._reject(n):o===S?r._rejectCallback(o.e,!1):(F.checkForgottenReturns(o,a,"",r,this),r._resolveCallback(o)))}},i.prototype._target=function(){for(var t=this;t._isFollowing();)t=t._followee();return t},i.prototype._followee=function(){return this._rejectionHandler0},i.prototype._setFollowee=function(t){this._rejectionHandler0=t},i.prototype._settlePromise=function(t,e,r,o){var a=t instanceof i,s=this._bitField,c=0!==(134217728&s);0!==(65536&s)?(a&&t._invokeInternalOnCancel(),r instanceof T&&r.isFinallyHandler()?(r.cancelPromise=t,x(e).call(r,o)===S&&t._reject(S.e)):e===u?t._fulfill(u.call(r)):r instanceof n?r._promiseCancelled(t):a||t instanceof k?t._cancel():r.cancel()):"function"==typeof e?a?(c&&t._setAsyncGuaranteed(),this._settlePromiseFromHandler(e,r,o,t)):e.call(r,o,t):r instanceof n?r._isResolved()||(0!==(33554432&s)?r._promiseFulfilled(o,t):r._promiseRejected(o,t)):a&&(c&&t._setAsyncGuaranteed(),0!==(33554432&s)?t._fulfill(o):t._reject(o))},i.prototype._settlePromiseLateCancellationObserver=function(t){var e=t.handler,n=t.promise,r=t.receiver,o=t.value;"function"==typeof e?n instanceof i?this._settlePromiseFromHandler(e,r,o,n):e.call(r,o,n):n instanceof i&&n._reject(o)},i.prototype._settlePromiseCtx=function(t){this._settlePromise(t.promise,t.handler,t.receiver,t.value)},i.prototype._settlePromise0=function(t,e,n){var r=this._promise0,i=this._receiverAt(0);this._promise0=void 0,this._receiver0=void 0,this._settlePromise(r,t,i,e)},i.prototype._clearCallbackDataAtIndex=function(t){var e=4*t-4;this[e+2]=this[e+3]=this[e+0]=this[e+1]=void 0},i.prototype._fulfill=function(t){var e=this._bitField;if(!((117506048&e)>>>16)){if(t===this){var n=l();return this._attachExtraTrace(n),this._reject(n)}this._setFulfilled(),this._rejectionHandler0=t,(65535&e)>0&&(0!==(134217728&e)?this._settlePromises():v.settlePromises(this))}},i.prototype._reject=function(t){var e=this._bitField;if(!((117506048&e)>>>16))return this._setRejected(),this._fulfillmentHandler0=t,this._isFinal()?v.fatalError(t,h.isNode):void((65535&e)>0?v.settlePromises(this):this._ensurePossibleRejectionHandled())},i.prototype._fulfillPromises=function(t,e){for(var n=1;t>n;n++){var r=this._fulfillmentHandlerAt(n),i=this._promiseAt(n),o=this._receiverAt(n);this._clearCallbackDataAtIndex(n),this._settlePromise(i,r,o,e)}},i.prototype._rejectPromises=function(t,e){for(var n=1;t>n;n++){var r=this._rejectionHandlerAt(n),i=this._promiseAt(n),o=this._receiverAt(n);this._clearCallbackDataAtIndex(n),this._settlePromise(i,r,o,e)}},i.prototype._settlePromises=function(){var t=this._bitField,e=65535&t;if(e>0){if(0!==(16842752&t)){var n=this._fulfillmentHandler0;this._settlePromise0(this._rejectionHandler0,n,t),this._rejectPromises(e,n)}else{var r=this._rejectionHandler0;this._settlePromise0(this._fulfillmentHandler0,r,t),this._fulfillPromises(e,r)}this._setLength(0)}this._clearCancellationData()},i.prototype._settledValue=function(){var t=this._bitField;return 0!==(33554432&t)?this._rejectionHandler0:0!==(16777216&t)?this._fulfillmentHandler0:void 0},i.defer=i.pending=function(){F.deprecated("Promise.defer","new Promise");var t=new i(b);return{promise:t,resolve:o,reject:a}},h.notEnumerableProp(i,"_makeSelfResolutionError",l),t("./method")(i,b,E,p,F),t("./bind")(i,b,E,F),t("./cancel")(i,k,p,F),t("./direct_resolve")(i),t("./synchronous_inspection")(i),t("./join")(i,k,E,b,v,c),i.Promise=i,i.version="3.5.1",h.toFastProperties(i),h.toFastProperties(i.prototype),s({a:1}),s({b:2}),s({c:3}),s(1),s(function(){}),s(void 0),s(!1),s(new i(b)),F.setBounds(d.firstLineError,h.lastLineError),i}},{"./async":1,"./bind":2,"./cancel":4,"./catch_filter":5,"./context":6,"./debuggability":7,"./direct_resolve":8,"./errors":9,"./es5":10,"./finally":11,"./join":12,"./method":13,"./nodeback":14,"./promise_array":16,"./synchronous_inspection":19,"./thenables":20,"./util":21}],16:[function(t,e,n){"use strict";e.exports=function(e,n,r,i,o){function a(t){switch(t){case-2:return[];case-3:return{};case-6:return new Map}}function s(t){var r=this._promise=new e(n);t instanceof e&&r._propagateFrom(t,3),r._setOnCancel(this),this._values=t,this._length=0,this._totalResolved=0,this._init(void 0,-2)}var c=t("./util");c.isArray;return c.inherits(s,o),s.prototype.length=function(){return this._length},s.prototype.promise=function(){return this._promise},s.prototype._init=function l(t,n){var o=r(this._values,this._promise);if(o instanceof e){o=o._target();var s=o._bitField;if(this._values=o,0===(50397184&s))return this._promise._setAsyncGuaranteed(),o._then(l,this._reject,void 0,this,n);if(0===(33554432&s))return 0!==(16777216&s)?this._reject(o._reason()):this._cancel();o=o._value()}if(o=c.asArray(o),null===o){var u=i("expecting an array or an iterable object but got "+c.classString(o)).reason();return void this._promise._rejectCallback(u,!1)}return 0===o.length?void(-5===n?this._resolveEmptyArray():this._resolve(a(n))):void this._iterate(o)},s.prototype._iterate=function(t){var n=this.getActualLength(t.length);this._length=n,this._values=this.shouldCopyValues()?new Array(n):this._values;for(var i=this._promise,o=!1,a=null,s=0;n>s;++s){var c=r(t[s],i);c instanceof e?(c=c._target(),a=c._bitField):a=null,o?null!==a&&c.suppressUnhandledRejections():null!==a?0===(50397184&a)?(c._proxy(this,s),this._values[s]=c):o=0!==(33554432&a)?this._promiseFulfilled(c._value(),s):0!==(16777216&a)?this._promiseRejected(c._reason(),s):this._promiseCancelled(s):o=this._promiseFulfilled(c,s)}o||i._setAsyncGuaranteed()},s.prototype._isResolved=function(){return null===this._values},s.prototype._resolve=function(t){this._values=null,this._promise._fulfill(t)},s.prototype._cancel=function(){!this._isResolved()&&this._promise._isCancellable()&&(this._values=null,this._promise._cancel())},s.prototype._reject=function(t){this._values=null,this._promise._rejectCallback(t,!1)},s.prototype._promiseFulfilled=function(t,e){this._values[e]=t;var n=++this._totalResolved;return n>=this._length?(this._resolve(this._values),!0):!1},s.prototype._promiseCancelled=function(){return this._cancel(),!0},s.prototype._promiseRejected=function(t){return this._totalResolved++,this._reject(t),!0},s.prototype._resultCancelled=function(){if(!this._isResolved()){var t=this._values;if(this._cancel(),t instanceof e)t.cancel();else for(var n=0;n<t.length;++n)t[n]instanceof e&&t[n].cancel()}},s.prototype.shouldCopyValues=function(){return!0},s.prototype.getActualLength=function(t){return t},s}},{"./util":21}],17:[function(t,e,n){"use strict";function r(t,e,n,r,i){for(var o=0;i>o;++o)n[o+r]=t[o+e],t[o+e]=void 0}function i(t){this._capacity=t,this._length=0,this._front=0}i.prototype._willBeOverCapacity=function(t){return this._capacity<t},i.prototype._pushOne=function(t){var e=this.length();this._checkCapacity(e+1);var n=this._front+e&this._capacity-1;this[n]=t,this._length=e+1},i.prototype.push=function(t,e,n){var r=this.length()+3;if(this._willBeOverCapacity(r))return this._pushOne(t),this._pushOne(e),void this._pushOne(n);var i=this._front+r-3;this._checkCapacity(r);var o=this._capacity-1;this[i+0&o]=t,this[i+1&o]=e,this[i+2&o]=n,this._length=r},i.prototype.shift=function(){var t=this._front,e=this[t];return this[t]=void 0,this._front=t+1&this._capacity-1,this._length--,e},i.prototype.length=function(){return this._length},i.prototype._checkCapacity=function(t){this._capacity<t&&this._resizeTo(this._capacity<<1)},i.prototype._resizeTo=function(t){var e=this._capacity;this._capacity=t;var n=this._front,i=this._length,o=n+i&e-1;r(this,0,this,e,o)},e.exports=i},{}],18:[function(t,e,n){"use strict";var r,i=t("./util"),o=function(){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n")},a=i.getNativePromise();if(i.isNode&&"undefined"==typeof MutationObserver){var s=global.setImmediate,c=process.nextTick;r=i.isRecentNode?function(t){s.call(global,t)}:function(t){c.call(process,t)}}else if("function"==typeof a&&"function"==typeof a.resolve){var l=a.resolve();r=function(t){l.then(t)}}else r="undefined"==typeof MutationObserver||"undefined"!=typeof window&&window.navigator&&(window.navigator.standalone||window.cordova)?"undefined"!=typeof setImmediate?function(t){setImmediate(t)}:"undefined"!=typeof setTimeout?function(t){setTimeout(t,0)}:o:function(){var t=document.createElement("div"),e={attributes:!0},n=!1,r=document.createElement("div"),i=new MutationObserver(function(){t.classList.toggle("foo"),n=!1});i.observe(r,e);var o=function(){n||(n=!0,r.classList.toggle("foo"))};return function(n){var r=new MutationObserver(function(){r.disconnect(),n()});r.observe(t,e),o()}}();e.exports=r},{"./util":21}],19:[function(t,e,n){"use strict";e.exports=function(t){function e(t){void 0!==t?(t=t._target(),this._bitField=t._bitField,this._settledValueField=t._isFateSealed()?t._settledValue():void 0):(this._bitField=0,this._settledValueField=void 0)}e.prototype._settledValue=function(){return this._settledValueField};var n=e.prototype.value=function(){if(!this.isFulfilled())throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");return this._settledValue()},r=e.prototype.error=e.prototype.reason=function(){if(!this.isRejected())throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");return this._settledValue()},i=e.prototype.isFulfilled=function(){return 0!==(33554432&this._bitField)},o=e.prototype.isRejected=function(){return 0!==(16777216&this._bitField)},a=e.prototype.isPending=function(){return 0===(50397184&this._bitField)},s=e.prototype.isResolved=function(){return 0!==(50331648&this._bitField)};e.prototype.isCancelled=function(){return 0!==(8454144&this._bitField)},t.prototype.__isCancelled=function(){return 65536===(65536&this._bitField)},t.prototype._isCancelled=function(){return this._target().__isCancelled()},t.prototype.isCancelled=function(){return 0!==(8454144&this._target()._bitField)},t.prototype.isPending=function(){return a.call(this._target())},t.prototype.isRejected=function(){return o.call(this._target())},t.prototype.isFulfilled=function(){return i.call(this._target())},t.prototype.isResolved=function(){return s.call(this._target())},t.prototype.value=function(){return n.call(this._target())},t.prototype.reason=function(){var t=this._target();return t._unsetRejectionIsUnhandled(),r.call(t)},t.prototype._value=function(){return this._settledValue()},t.prototype._reason=function(){return this._unsetRejectionIsUnhandled(),this._settledValue()},t.PromiseInspection=e}},{}],20:[function(t,e,n){"use strict";e.exports=function(e,n){function r(t,r){if(u(t)){if(t instanceof e)return t;var i=o(t);if(i===l){r&&r._pushContext();var c=e.reject(i.e);return r&&r._popContext(),c}if("function"==typeof i){if(a(t)){var c=new e(n);return t._then(c._fulfill,c._reject,void 0,c,null),c}return s(t,i,r)}}return t}function i(t){return t.then}function o(t){try{return i(t)}catch(e){return l.e=e,l}}function a(t){try{return p.call(t,"_promise0")}catch(e){return!1}}function s(t,r,i){function o(t){s&&(s._resolveCallback(t),s=null)}function a(t){s&&(s._rejectCallback(t,p,!0),s=null)}var s=new e(n),u=s;i&&i._pushContext(),s._captureStackTrace(),i&&i._popContext();var p=!0,f=c.tryCatch(r).call(t,o,a);return p=!1,s&&f===l&&(s._rejectCallback(f.e,!0,!0),s=null),u}var c=t("./util"),l=c.errorObj,u=c.isObject,p={}.hasOwnProperty;return r}},{"./util":21}],21:[function(t,e,n){"use strict";function r(){try{var t=R;return R=null,t.apply(this,arguments)}catch(e){return P.e=e,P}}function i(t){return R=t,r}function o(t){return null==t||t===!0||t===!1||"string"==typeof t||"number"==typeof t}function a(t){return"function"==typeof t||"object"==typeof t&&null!==t}function s(t){return o(t)?new Error(v(t)):t}function c(t,e){var n,r=t.length,i=new Array(r+1);for(n=0;r>n;++n)i[n]=t[n];return i[n]=e,i}function l(t,e,n){if(!F.isES5)return{}.hasOwnProperty.call(t,e)?t[e]:void 0;var r=Object.getOwnPropertyDescriptor(t,e);return null!=r?null==r.get&&null==r.set?r.value:n:void 0}function u(t,e,n){if(o(t))return t;var r={value:n,configurable:!0,enumerable:!1,writable:!0};return F.defineProperty(t,e,r),t}function p(t){throw t}function f(t){try{if("function"==typeof t){var e=F.names(t.prototype),n=F.isES5&&e.length>1,r=e.length>0&&!(1===e.length&&"constructor"===e[0]),i=A.test(t+"")&&F.names(t).length>0;if(n||r||i)return!0}return!1}catch(o){return!1}}function h(t){function e(){}e.prototype=t;for(var n=8;n--;)new e;return t}function _(t){return N.test(t)}function d(t,e,n){for(var r=new Array(t),i=0;t>i;++i)r[i]=e+i+n;return r}function v(t){try{return t+""}catch(e){return"[no string representation]"}}function y(t){return t instanceof Error||null!==t&&"object"==typeof t&&"string"==typeof t.message&&"string"==typeof t.name}function g(t){try{u(t,"isOperational",!0)}catch(e){}}function m(t){return null==t?!1:t instanceof Error.__BluebirdErrorTypes__.OperationalError||t.isOperational===!0}function b(t){return y(t)&&F.propertyIsWritable(t,"stack")}function C(t){return{}.toString.call(t)}function w(t,e,n){for(var r=F.names(t),i=0;i<r.length;++i){var o=r[i];if(n(o))try{F.defineProperty(e,o,F.getDescriptor(t,o))}catch(a){}}}function E(t){return H?process.env[t]:void 0}function k(){if("function"==typeof Promise)try{var t=new Promise(function(){});if("[object Promise]"==={}.toString.call(t))return Promise}catch(e){}}function j(t,e){return t.bind(e)}var F=t("./es5"),T="undefined"==typeof navigator,P={e:{}},R,S="undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:void 0!==this?this:null,x=function(t,e){function n(){this.constructor=t,this.constructor$=e;for(var n in e.prototype)r.call(e.prototype,n)&&"$"!==n.charAt(n.length-1)&&(this[n+"$"]=e.prototype[n])}var r={}.hasOwnProperty;return n.prototype=e.prototype,t.prototype=new n,t.prototype},O=function(){var t=[Array.prototype,Object.prototype,Function.prototype],e=function(e){for(var n=0;n<t.length;++n)if(t[n]===e)return!0;return!1};if(F.isES5){var n=Object.getOwnPropertyNames;return function(t){for(var r=[],i=Object.create(null);null!=t&&!e(t);){var o;try{o=n(t)}catch(a){return r}for(var s=0;s<o.length;++s){var c=o[s];if(!i[c]){i[c]=!0;var l=Object.getOwnPropertyDescriptor(t,c);null!=l&&null==l.get&&null==l.set&&r.push(c)}}t=F.getPrototypeOf(t)}return r}}var r={}.hasOwnProperty;return function(n){if(e(n))return[];var i=[];t:for(var o in n)if(r.call(n,o))i.push(o);else{for(var a=0;a<t.length;++a)if(r.call(t[a],o))continue t;i.push(o)}return i}}(),A=/this\s*\.\s*\S+\s*=/,N=/^[a-z$_][a-z$_0-9]*$/i,L=function(){return"stack"in new Error?function(t){return b(t)?t:new Error(v(t))}:function(t){if(b(t))return t;try{throw new Error(v(t))}catch(e){return e}}}(),B=function(t){return F.isArray(t)?t:null};if("undefined"!=typeof Symbol&&Symbol.iterator){var U="function"==typeof Array.from?function(t){return Array.from(t)}:function(t){for(var e,n=[],r=t[Symbol.iterator]();!(e=r.next()).done;)n.push(e.value);return n};B=function(t){return F.isArray(t)?t:null!=t&&"function"==typeof t[Symbol.iterator]?U(t):null}}var I="undefined"!=typeof process&&"[object process]"===C(process).toLowerCase(),H="undefined"!=typeof process&&"undefined"!=typeof process.env,D={isClass:f,isIdentifier:_,inheritedDataKeys:O,getDataPropertyOrDefault:l,thrower:p,isArray:F.isArray,asArray:B,notEnumerableProp:u,isPrimitive:o,isObject:a,isError:y,canEvaluate:T,errorObj:P,tryCatch:i,inherits:x,withAppended:c,maybeWrapAsError:s,toFastProperties:h,filledRange:d,toString:v,canAttachTrace:b,ensureErrorObject:L,originatesFromRejection:m,markAsOriginatingFromRejection:g,classString:C,copyDescriptors:w,hasDevTools:"undefined"!=typeof chrome&&chrome&&"function"==typeof chrome.loadTimes,isNode:I,hasEnvVariables:H,env:E,global:S,getNativePromise:k,domainBind:j};D.isRecentNode=D.isNode&&function(){var t=process.versions.node.split(".").map(Number);return 0===t[0]&&t[1]>10||t[0]>0}(),D.isNode&&D.toFastProperties(process);try{throw new Error}catch(V){D.lastLineError=V}e.exports=D},{"./es5":10}]},{},[3])(3)}),"undefined"!=typeof window&&null!==window?window.P=window.Promise:"undefined"!=typeof self&&null!==self&&(self.P=self.Promise);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23), __webpack_require__(3), __webpack_require__(165).setImmediate))

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(64)
var Transform = __webpack_require__(25)
var inherits = __webpack_require__(7)
var modes = __webpack_require__(65)
var StreamCipher = __webpack_require__(190)
var AuthCipher = __webpack_require__(183)
var ebtk = __webpack_require__(101)

inherits(Decipher, Transform)
function Decipher (mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}
function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }
  return null
}
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache
  }
}
function unpad (last) {
  var padded = last[15]
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) {
    return
  }
  return last.slice(0, 16 - padded)
}

var modelist = {
  ECB: __webpack_require__(188),
  CBC: __webpack_require__(184),
  CFB: __webpack_require__(185),
  CFB8: __webpack_require__(187),
  CFB1: __webpack_require__(186),
  OFB: __webpack_require__(189),
  CTR: __webpack_require__(66),
  GCM: __webpack_require__(66)
}

function createDecipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true)
  }
  return new Decipher(modelist[config.mode], password, iv)
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}
exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var aes = __webpack_require__(64)
var Transform = __webpack_require__(25)
var inherits = __webpack_require__(7)
var modes = __webpack_require__(65)
var ebtk = __webpack_require__(101)
var StreamCipher = __webpack_require__(190)
var AuthCipher = __webpack_require__(183)
inherits(Cipher, Transform)
function Cipher (mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv)
  }
  Transform.call(this)
  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = new Buffer(iv.length)
  iv.copy(this._prev)
  this._mode = mode
  this._autopadding = true
}
Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}
Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  if (!(this instanceof Splitter)) {
    return new Splitter()
  }
  this.cache = new Buffer('')
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = new Buffer(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }
  var out = Buffer.concat([this.cache, padBuff])
  return out
}
var modelist = {
  ECB: __webpack_require__(188),
  CBC: __webpack_require__(184),
  CFB: __webpack_require__(185),
  CFB8: __webpack_require__(187),
  CFB1: __webpack_require__(186),
  OFB: __webpack_require__(189),
  CTR: __webpack_require__(66),
  GCM: __webpack_require__(66)
}

function createCipheriv (suite, password, iv) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv)
  }
  if (typeof password === 'string') {
    password = new Buffer(password)
  }
  if (password.length !== config.key / 8) {
    throw new TypeError('invalid key length ' + password.length)
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length)
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv)
  }
  return new Cipher(modelist[config.mode], password, iv)
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()]
  if (!config) {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var zeros = new Buffer(16)
zeros.fill(0)
module.exports = GHASH
function GHASH (key) {
  this.h = key
  this.state = new Buffer(16)
  this.state.fill(0)
  this.cache = new Buffer('')
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsb_Vi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - i % 8))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi)
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16))
  }
  this.ghash(fromArray([
    0, abl,
    0, bl
  ]))
  return this.state
}

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}
function fromArray (out) {
  out = out.map(fixup_uint32)
  var buf = new Buffer(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}
var uint_max = Math.pow(2, 32)
function fixup_uint32 (x) {
  var ret, x_pos
  ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x
  return ret
}
function xor (a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3]
  ]
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

var ebtk = __webpack_require__(101)
var aes = __webpack_require__(108)
var DES = __webpack_require__(380)
var desModes = __webpack_require__(381)
var aesModes = __webpack_require__(65)
function createCipher (suite, password) {
  var keyLen, ivLen
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}
function createDecipher (suite, password) {
  var keyLen, ivLen
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }
  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    return aes.createCipheriv(suite, key, iv)
  } else if (desModes[suite]) {
    return new DES({
      key: key,
      iv: iv,
      mode: suite
    })
  } else {
    throw new TypeError('invalid suite type')
  }
}
function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) {
    return aes.createDecipheriv(suite, key, iv)
  } else if (desModes[suite]) {
    return new DES({
      key: key,
      iv: iv,
      mode: suite,
      decrypt: true
    })
  } else {
    throw new TypeError('invalid suite type')
  }
}
exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}
exports.listCiphers = exports.getCiphers = getCiphers


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var CipherBase = __webpack_require__(25)
var des = __webpack_require__(155)
var inherits = __webpack_require__(7)

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return new Buffer(this._des.update(data))
}
DES.prototype._final = function () {
  return new Buffer(this._des.final())
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 381 */
/***/ (function(module, exports) {

exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}


/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(333)


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(61)
var stream = __webpack_require__(163)
var inherits = __webpack_require__(7)
var sign = __webpack_require__(384)
var verify = __webpack_require__(385)

var algorithms = __webpack_require__(333)
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = __webpack_require__(320)
var crt = __webpack_require__(109)
var EC = __webpack_require__(13).ec
var BN = __webpack_require__(10)
var parseKeys = __webpack_require__(103)
var curves = __webpack_require__(334)

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [ 0 ].concat(r)
  if (s[0] & 0x80) s = [ 0 ].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([ zeros, x ])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([ zeros, out ])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = new Buffer(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([ t, kv.v ])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = __webpack_require__(10)
var EC = __webpack_require__(13).ec
var parseKeys = __webpack_require__(103)
var curves = __webpack_require__(334)

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = new Buffer(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

var Color, Matrix, Perimeter, Point, Rectangle, _package;

Color = __webpack_require__(191);

Point = __webpack_require__(53);

Rectangle = __webpack_require__(68);

Matrix = __webpack_require__(192);

Perimeter = __webpack_require__(193);

module.exports = [
  [Color, "isColor", "rgbColor", "newColor", "color", "hslColor", "rgb256Color", "colorNames", "colorNamesMap"], [Point, "isPoint", "point", "point0", "point1", "pointWithAspectRatioAndArea"], [Rectangle, "isRect", "rect", "nothing", "everything"], [Matrix, "isMatrix", "matrix", "identityMatrix"], [Perimeter, "perimeter", "isPerimeter", "perimeter0"], {
    "package": _package = __webpack_require__(328),
    version: _package.version
  }
];


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(67);

module.exports.includeInNamespace(__webpack_require__(386)).addModules({
  Base: __webpack_require__(35),
  Color: __webpack_require__(191),
  Matrix: __webpack_require__(192),
  Perimeter: __webpack_require__(193),
  Point: __webpack_require__(53),
  Rectangle: __webpack_require__(68)
});


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(9)).vivifySubnamespace('Art');

__webpack_require__(67);


/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(393);


/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(196);

module.exports = [
  __webpack_require__(110), {
    stream: (__webpack_require__(195)).stream
  }, [__webpack_require__(28), "binary binaryFromBlob downloadBinaryData"]
];


/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var EncodedImage, ErrorWithInfo, HTMLImageElement, Image, Promise, StandardLib, binary, escapeRegExp, isBinary, isNode, isObject, isString, log, readFileAsDataUrl, ref, sameOrigin, toDataUri;

StandardLib = __webpack_require__(1);

toDataUri = __webpack_require__(194).toDataUri;

isNode = StandardLib.isNode, log = StandardLib.log, Promise = StandardLib.Promise, readFileAsDataUrl = StandardLib.readFileAsDataUrl, ErrorWithInfo = StandardLib.ErrorWithInfo, isString = StandardLib.isString, escapeRegExp = StandardLib.escapeRegExp, isObject = StandardLib.isObject, sameOrigin = StandardLib.sameOrigin;

ref = __webpack_require__(28), isBinary = ref.isBinary, binary = ref.binary;

__webpack_require__(142);

if (!global.Image) {
  try {
    global.HTMLImageElement = global.Image = (global.HTMLCanvasElement = eval('require')("canvas")).Image;
  } catch (error) {}
}

Image = global.Image, HTMLImageElement = global.HTMLImageElement;

module.exports = EncodedImage = (function() {
  var get;

  function EncodedImage() {}


  /*
  IN:
    first arg:
      String: url
      or
      Binary: image data
      or
      HTMLImageElement
  
    second arg:
      options: (object)
        options for RestClient.getArrayBuffer
        NOTE: if options is provided, image-data is fetched using
          RestClient.getArrayBuffer
        This seems to work to endrun TAINT.
  
      crossOrigin: true/false/null/undefined
        false: DO NOT make crossorigin request
        null/undefined: AUTO
          crossOrigin is set to 'anonymous' if the request is indeed cross-origin
        true: crossOrigin is always set to 'anonymous'
  
    CORS/TAINT
      To avoid taint, either set the second option to {} or true.
      AND - make sure the server is returning the correct headers.
  
  OUT:
    promise.then (fullyLoadedHtmlImage) ->
    , (htmlImageOnerrorEvent) ->
  
  
  CORS NOTES
    crossOrigin = "Anonymous" required to getImageData and avoid this error
      "The canvas has been tainted by cross-origin data."
  
    performance???
      I don't think there is a performance hit for making the crossOrigin request.
      - SBD March-2018
  
    crossOrigin should only be set for HTTP requests - since it can only be
    fulfilled with HTTP response headers. Some browsers (safari) get cranky
    if you use it with file or data URIs:
  
      file: urls break with crossOrigin in WkWebKit
      data: urls break with crossOrigin in Safari
   */

  EncodedImage.get = get = function(source, b) {
    var complete, crossOrigin, image, naturalWidth, options;
    if (isObject(b)) {
      options = b;
    } else {
      crossOrigin = b != null ? !!b : void 0;
    }
    if (source == null) {
      return Promise.reject();
    }
    if (source.constructor === HTMLImageElement || source.constructor === Image) {
      image = source;
      complete = source.complete, naturalWidth = source.naturalWidth;
      return new Promise(function(resolve, reject) {
        if (complete && (naturalWidth > 0 || isNode)) {
          return resolve(source);
        } else {
          image.onload = function() {
            return resolve(image);
          };
          return image.onerror = function(event) {
            return reject(new ErrorWithInfo("image load error", event));
          };
        }
      });
    } else {
      return Promise.then(function() {
        if (isBinary(source)) {
          if (Neptune.isNode) {
            return binary(source).nodeBuffer;
          } else {
            return toDataUri(source);
          }
        } else if (isString(source)) {
          if (isObject(options)) {
            return Neptune.Art.RestClient.getArrayBuffer(source, options).then(function(arrayBuffer) {
              return readFileAsDataUrl(new Blob([arrayBuffer]));
            });
          } else {
            return source;
          }
        } else {
          throw new Error("expected arg #1 to be string or binary");
        }
      }).then(function(url) {
        image = new Image;
        if (!isNode) {
          if (crossOrigin != null ? crossOrigin : !sameOrigin(url) && /^https?:/i.test(url)) {
            image.crossOrigin = "anonymous";
          }
        }
        image.src = url;
        return get(image);
      });
    }
  };

  EncodedImage.toImage = function(encodedImageData) {
    return toDataUri(encodedImageData).then((function(_this) {
      return function(dataUri) {
        return get(dataUri);
      };
    })(this));
  };

  return EncodedImage;

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, Promise, StandardLib, WriteStream, binary, bound, bufferSize, log, readFileAsArrayBuffer,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(1);

ClassSystem = __webpack_require__(6);

binary = __webpack_require__(28).binary;

Promise = StandardLib.Promise, readFileAsArrayBuffer = StandardLib.readFileAsArrayBuffer, bound = StandardLib.bound;

BaseObject = ClassSystem.BaseObject, log = ClassSystem.log;

bufferSize = 1024;

module.exports = WriteStream = (function(superClass) {
  extend(WriteStream, superClass);

  function WriteStream() {
    this._written = [];
    this._writeBuffer = new Uint8Array(bufferSize);
    this._pos = 0;
    this._writtenLength = 0;
  }

  WriteStream.prototype.writeByte = function(byte) {
    if (this._pos === bufferSize) {
      this._commitHead();
    }
    return this._writeBuffer[this._pos++] = byte;
  };

  WriteStream.prototype.writeAsi = function(number) {
    var nextByte, results;
    if (!(number >= 0)) {
      throw new Error("expected number >= 0");
    }
    results = [];
    while (true) {
      nextByte = number & 0x7F;
      number >>= 7;
      if (number > 0) {
        results.push(this.writeByte(nextByte | 0x80));
      } else {
        this.writeByte(nextByte);
        break;
      }
    }
    return results;
  };

  WriteStream.prototype.write = function(string) {
    var binaryString;
    binaryString = binary(string);
    if (this._pos + binaryString.length <= bufferSize) {
      this._writeBuffer.set(binaryString.uint8Array, this._pos);
      return this._pos += binaryString.length;
    } else {
      this._commitHead();
      this._writtenLength += binaryString.length;
      return this._written.push(binaryString.uint8Array);
    }
  };

  WriteStream.prototype.writeAsiString = function(string) {
    var binaryString;
    binaryString = binary(string);
    this.writeAsi(binaryString.length);
    return this.write(binaryString);
  };

  WriteStream.getter({
    arrayBufferPromise: function() {
      return this._compact().then(function(uint8Array) {
        return uint8Array.buffer;
      });
    },
    binaryStringPromise: function() {
      return this.arrayBufferPromise.then(function(ab) {
        return binary(ab);
      });
    },
    length: function() {
      return this._pos + this._writtenLength;
    }
  });


  /*
  Using new Blob is much faster, thus we use Promises since it is async
    http://jsperf.com/appending-arraybuffers
  
  OUT: promise.then (compactedUint8Array) ->
  EFFECT:
    head was committed
    if @_written.length <= 1 then it isn't changed
    else @_written = [compactedUint8Array]
   */

  WriteStream.prototype._compact = function() {
    this._commitHead();
    switch (this._written.length) {
      case 0:
        return new Promise(function(resolve) {
          return resolve(new Uint8Array(0));
        });
      case 1:
        return new Promise((function(_this) {
          return function(resolve) {
            return resolve(_this._written[0]);
          };
        })(this));
      default:
        return readFileAsArrayBuffer(new Blob(this._written)).then((function(_this) {
          return function(ab) {
            _this._written = [new Uint8Array(ab)];
            return _this._written[0];
          };
        })(this));
    }
  };

  WriteStream.prototype._commitHead = function() {
    if (!(this._pos > 0)) {
      return;
    }
    this._writtenLength += this._pos;
    this._written.push(this._writeBuffer.slice(0, this._pos));
    return this._pos = 0;
  };

  return WriteStream;

})(BaseObject);


/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(111);

module.exports.includeInNamespace(__webpack_require__(390)).addModules({
  BinaryString: __webpack_require__(28),
  DataUri: __webpack_require__(194),
  EncodedImage: __webpack_require__(391),
  File: __webpack_require__(110),
  Stream: __webpack_require__(195),
  TypedarraySlicePolyfill: __webpack_require__(196),
  Utf8: __webpack_require__(197),
  WriteStream: __webpack_require__(392)
});


/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

var isCanvas, isImage, ref;

ref = __webpack_require__(69), isCanvas = ref.isCanvas, isImage = ref.isImage;

module.exports = {
  isCanvas: isCanvas,
  isImage: isImage
};


/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Bitmap, Div, FontLoader, Link, Promise, Style, defaultLoadedTestText, defaultTimeout, defineModule, each, find, formattedInspect, isPlainObject, log, merge, object, point, present, ref, ref1, timeout;

ref = __webpack_require__(1), present = ref.present, isPlainObject = ref.isPlainObject, object = ref.object, merge = ref.merge, defineModule = ref.defineModule, formattedInspect = ref.formattedInspect, log = ref.log, timeout = ref.timeout, Promise = ref.Promise, each = ref.each, find = ref.find;

point = __webpack_require__(4).point;

Bitmap = __webpack_require__(198);

ref1 = __webpack_require__(2).Browser.DomElementFactories, Div = ref1.Div, Link = ref1.Link, Style = ref1.Style;

defaultTimeout = 30000;

defaultLoadedTestText = "aA";


/*
fonts:
  nameKey:
    loadedTestText: string of characters with different glyphs than Arial (actually rendered to validate they changed)
    css:            URL to the css file that will load the font
    url:            URL to the font-file to load
    fontFamily:     font-family name [default: nameKey]
 */

defineModule(module, FontLoader = (function() {
  var loadedWidthBasedTest, loadingTestBitmap;

  function FontLoader() {}


  /*
  IN: see 'fonts' above
  OUT: promise.then (object) -> all specified fonts have been loaded
    object lists all the input keys with 'true' for the values - because
    they have all been loaded
  
  TODO: there should probably be a timeout option, and then add:
    OUT: promise.catch (object) ->
      object is keys -> true or false for which fonts have and havenot been loaded
   */

  FontLoader.allFontsLoaded = function(fonts) {
    var timeExpired;
    timeExpired = 0;
    return new Promise((function(_this) {
      return function(resolve, reject) {
        var testFonts;
        testFonts = function() {
          var e, fontsLoaded, haveUnloadedFonts, verbose;
          try {
            verbose = timeExpired >= 1000 && timeExpired % 1000 === 0;
            fontsLoaded = FontLoader.fontsLoadedSync(fonts, verbose);
            haveUnloadedFonts = find(fontsLoaded, function(loaded) {
              return !loaded;
            });
            if (!haveUnloadedFonts) {
              if (timeExpired >= 100) {
                log.warn(formattedInspect({
                  FontLoader: {
                    success: {
                      milliseconds: timeExpired,
                      fonts: Object.keys(fonts)
                    }
                  }
                }));
              }
              return resolve(fontsLoaded);
            } else {
              if (verbose) {
                log.warn(formattedInspect({
                  FontLoader: {
                    waiting: {
                      milliseconds: timeExpired,
                      fonts: Object.keys(fonts)
                    }
                  }
                }));
              }
              if (_this.allFontLoadsExpired(fontsLoaded, fonts, verbose, timeExpired)) {
                return resolve(fontsLoaded);
              } else {
                timeExpired += 25;
                return timeout(25, testFonts);
              }
            }
          } catch (error) {
            e = error;
            return log({
              e: e
            });
          }
        };
        return testFonts();
      };
    })(this)).then((function(_this) {
      return function() {
        return _this._cleanup();
      };
    })(this));
  };

  FontLoader.allFontLoadsExpired = function(fontsLoaded, fonts, verbose, timeExpired) {
    var allExpired;
    allExpired = true;
    each(fonts, {
      when: function(fontOptions, fontFamily) {
        return !fontsLoaded[fontFamily];
      },
      "with": function(fontOptions, fontFamily) {
        var onTimeout, previouslyExpired, ref2, timeoutMs;
        timeoutMs = (ref2 = fontOptions.timeout) != null ? ref2 : defaultTimeout, onTimeout = fontOptions.onTimeout, previouslyExpired = fontOptions.previouslyExpired;
        if (timeExpired > timeoutMs) {
          if (!previouslyExpired) {
            if (typeof onTimeout === "function") {
              onTimeout({
                fontFamily: fontFamily,
                fontOptions: fontOptions,
                timeExpired: timeExpired,
                timeoutMs: timeoutMs
              });
            }
            return fontOptions.previouslyExpired = true;
          }
        } else {
          return allExpired = false;
        }
      }
    });
    return allExpired;
  };

  FontLoader.allFontsLoadedSync = function(fonts, verbose) {
    var k, loaded, ref2;
    ref2 = FontLoader.fontsLoadedSync(fonts, verbose);
    for (k in ref2) {
      loaded = ref2[k];
      if (!loaded) {
        return false;
      }
    }
    return true;
  };

  FontLoader.fontsLoadedSync = function(fonts, verbose) {
    return object(fonts, function(fontOptions, fontFamily) {
      return FontLoader.fontLoaded(fontOptions, fontFamily, verbose);
    });
  };

  FontLoader.loadFonts = function(fonts) {
    var css, fontFamily, fontsLoaded, loadedTestText, name, ref2, url;
    log(formattedInspect({
      loadFonts: fonts
    }));
    if (!isPlainObject(fonts)) {
      throw new Error("ArtCanvas.FontLoader.loadFonts: fonts should be an object");
    }
    log({
      FontLoader: {
        loading: fonts
      }
    });
    fontsLoaded = this.fontsLoadedSync(fonts);
    for (name in fonts) {
      ref2 = fonts[name], fontFamily = ref2.fontFamily, loadedTestText = ref2.loadedTestText, css = ref2.css, url = ref2.url;
      if (!(!fontsLoaded[fontFamily])) {
        continue;
      }
      loadedTestText || (loadedTestText = defaultLoadedTestText);
      fontFamily || (fontFamily = name);
      log({
        loading: {
          fontFamily: fontFamily
        }
      });
      if (css) {
        document.head.appendChild(Link({
          rel: "stylesheet",
          href: css
        }));
      } else if (url) {
        document.head.appendChild(Style("@font-face { font-family: " + fontFamily + "; src: url('" + url + "'); } "));
      }
      document.body.appendChild(Div({
        style: {
          fontFamily: fontFamily,
          position: "absolute",
          fontSize: "0"
        }
      }, loadedTestText));
    }
    return this.allFontsLoaded(fonts);
  };

  loadedWidthBasedTest = function(bitmap, fontFamily, loadedTestText, expectedTestWidth, verbose) {
    var context, obj, referenceWidth, testWidth;
    context = bitmap.context;
    context.font = "12px sans serif";
    referenceWidth = context.measureText(loadedTestText).width;
    context.font = "12px " + fontFamily + ", sans serif";
    testWidth = context.measureText(loadedTestText).width;
    verbose && log((
      obj = {},
      obj["loading " + fontFamily] = {
        fontFamily: fontFamily,
        loadedTestText: loadedTestText,
        expectedTestWidth: expectedTestWidth,
        testWidth: testWidth,
        referenceWidth: referenceWidth
      },
      obj
    ));
    if (expectedTestWidth != null) {
      return Math.abs(expectedTestWidth - testWidth) < .9 && Math.abs(expectedTestWidth - referenceWidth) > .1;
    } else {
      return testWidth > 0 && testWidth !== referenceWidth;
    }
  };

  loadingTestBitmap = null;

  FontLoader.fontLoaded = function(fontOptions, fontFamily, verbose) {
    var expectedTestWidth, loadedTestText;
    loadedTestText = fontOptions.loadedTestText, expectedTestWidth = fontOptions.expectedTestWidth;
    if (loadedTestText == null) {
      throw new Error("loadedTestText required");
    }
    loadingTestBitmap || (loadingTestBitmap = new Bitmap(point(1)));
    return loadedWidthBasedTest(loadingTestBitmap, fontFamily, loadedTestText, expectedTestWidth, verbose);
  };

  FontLoader._cleanup = function() {
    return loadingTestBitmap = null;
  };

  return FontLoader;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

var BatchLoader, Foundation, GoogleFontLoader, WebFont, inspect, log,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

if (!Neptune.isNode) {
  WebFont = __webpack_require__(632);
}

inspect = Foundation.inspect, log = Foundation.log, BatchLoader = Foundation.BatchLoader;

module.exports = GoogleFontLoader = (function(superClass) {
  extend(GoogleFontLoader, superClass);

  GoogleFontLoader.singletonClass();

  function GoogleFontLoader(options) {
    if (options == null) {
      options = {};
    }
    this.defaultWeight = {
      UnifrakturCook: 700
    };
    GoogleFontLoader.__super__.constructor.call(this, (function(_this) {
      return function(src) {
        return _this.webFontLoadWithWaiting([src]);
      };
    })(this));
  }

  GoogleFontLoader.prototype.googleFamilies = function(fontFamilies) {
    var font, i, len, results, weight;
    results = [];
    for (i = 0, len = fontFamilies.length; i < len; i++) {
      font = fontFamilies[i];
      weight = this.defaultWeight[font] || "";
      results.push((font.split(" ").join("+")) + ":" + weight + ":latin,latin-ext");
    }
    return results;
  };

  GoogleFontLoader.prototype.webFontLoad = function(fontFamilies, done) {
    return WebFont.load({
      google: {
        families: this.googleFamilies(fontFamilies)
      },
      fontactive: (function(_this) {
        return function(font) {
          return _this.addAsset(font, font);
        };
      })(this),
      fontinactive: (function(_this) {
        return function(font) {
          return _this.addAsset(font, "FAILED TO LOAD");
        };
      })(this),
      inactive: done,
      active: done
    });
  };

  GoogleFontLoader.prototype.webFontLoadWithWaiting = function(fontFamilies) {
    var font, i, len, wfw;
    if (window.WebFontConfig) {
      wfw = window.WebFontWaiting || (window.WebFontWaiting = {});
      for (i = 0, len = fontFamilies.length; i < len; i++) {
        font = fontFamilies[i];
        wfw[font] = true;
      }
      return;
    }
    return this.webFontLoad(fontFamilies, (function(_this) {
      return function() {
        var waitingList;
        waitingList = window.WebFontWaiting && Object.keys(window.WebFontWaiting);
        window.WebFontWaiting = null;
        window.WebFontConfig = null;
        if (waitingList) {
          return _this.webFontLoad(waitingList);
        }
      };
    })(this));
  };

  return GoogleFontLoader;

})(BatchLoader);


/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(202);

module.exports.includeInNamespace(__webpack_require__(394)).addModules({
  Bitmap: __webpack_require__(198),
  BitmapBase: __webpack_require__(69),
  FontLoader: __webpack_require__(395),
  GoogleFontLoader: __webpack_require__(396),
  GradientFillStyle: __webpack_require__(199),
  Paths: __webpack_require__(200),
  StackBlur: __webpack_require__(201)
});


/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = BaseObject = (function(superClass) {
  extend(BaseObject, superClass);

  function BaseObject() {
    return BaseObject.__super__.constructor.apply(this, arguments);
  }

  return BaseObject;

})(__webpack_require__(112));


/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  createWithPostCreate: __webpack_require__(112).createWithPostCreate
};


/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var defineModule, each, isPlainObject, log, lowerCamelCase, object, ref, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, object = ref.object, upperCamelCase = ref.upperCamelCase, lowerCamelCase = ref.lowerCamelCase, each = ref.each, isPlainObject = ref.isPlainObject;

defineModule(module, function() {
  return function(superClass) {
    var DeclarableMixin;
    return DeclarableMixin = (function(superClass1) {
      extend(DeclarableMixin, superClass1);

      function DeclarableMixin() {
        return DeclarableMixin.__super__.constructor.apply(this, arguments);
      }


      /*
        define a declarable field
      
        IN:
          map:
            key: name: string
            value: true-ish OR
              options:
                preprocess: (v) -> newV
                validate:   (v) -> truthish
                extendable: defaultValue
                  If present, this is an extendable property.
                  See: @extendableProperty
                  passed to: @extendableProperty "#{key}": options.extendable
              NOTE: validate is evaluated BEFORE preprocess
      
        EFFECT:
          creates:
      
             * class declarator function, with preprocessing
            @name: (...)->
      
             * class getter-function
            @getName: ->
      
             * instance-getter
            @getter name: ->
       */

      DeclarableMixin.declarable = function(map) {
        return each(map, (function(_this) {
          return function(options, name) {
            var extendable, getter, getterName, internalName, obj, preprocess, ucProp, validate;
            if (isPlainObject(options)) {
              preprocess = options.preprocess, validate = options.validate, extendable = options.extendable, getter = options.getter;
            }
            preprocess || (preprocess = function(v) {
              return v;
            });
            validate || (validate = function() {
              return true;
            });
            name = lowerCamelCase(name);
            ucProp = upperCamelCase(name);
            internalName = _this.propInternalName(name);
            getterName = "get" + ucProp;
            if (extendable) {
              return _this.extendableProperty((
                obj = {},
                obj["" + name] = extendable,
                obj
              ));
            } else {
              _this[name] = function(value) {
                if (!validate(value)) {
                  throw new Error("invalid value: " + (formattedInspect({
                    value: value,
                    name: name
                  })));
                }
                return this[internalName] = preprocess(value);
              };
              _this[getterName] = getter || function() {
                return this[internalName];
              };
              return _this.addGetter(name, function() {
                return this["class"][internalName];
              });
            }
          };
        })(this));
      };

      return DeclarableMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(402);

module.exports.includeInNamespace(__webpack_require__(399)).addModules({
  BaseClass: __webpack_require__(112),
  BaseObject: __webpack_require__(398),
  DeclarableMixin: __webpack_require__(400),
  ExtendablePropertyMixin: __webpack_require__(203),
  WebpackHotLoader: __webpack_require__(204)
});


/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

var ClassSystem,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.ClassSystem', ClassSystem = (function(superClass) {
  extend(ClassSystem, superClass);

  function ClassSystem() {
    return ClassSystem.__super__.constructor.apply(this, arguments);
  }

  ClassSystem.version = __webpack_require__(587).version;

  return ClassSystem;

})(Neptune.PackageNamespace));


/***/ }),
/* 403 */
/***/ (function(module, exports) {

var CommunicationStatus;

module.exports = CommunicationStatus = (function() {
  var communicationStatuses, k, ref, v;

  function CommunicationStatus() {}

  CommunicationStatus.communicationStatuses = communicationStatuses = {

    /*
    status: success
    
    * An unqualified success.
    * I guess it could be qualified, with additional information in another field,
      but the 'expected' data should be present.
     */
    success: {
      httpStatus: 200

      /*
      status: missing
      
      * The request was properly formatted.
      * There were no network errors.
      * There were no server errors.
      * The only problem is the server could not find the requested resource.
       */
    },
    missing: {
      httpStatus: 404,
      failure: true

      /*
      status: clientFailure
      
      * The server rejected the request.
      * There is something wrong with the client's request.
      * It's up to the client to fix the problem.
      * This includes mal-formed requests as well as invalid data.
      * all 4xx errors except 404
      NOTE: 404 is not necessarilly a client NOR server error, therefor it's status: missing
       */
    },
    clientFailure: {
      httpStatus: 400,
      clientFailure: true,
      failure: true

      /*
      status: notAuthorized
      
      * The resource exists, but the client is not allowed to access it.
      
      This is a form of clientFailure because the client could possibly change
      something in the request to make it work.
       */
    },
    clientFailureNotAuthorized: {
      httpStatus: 403,
      clientFailure: true,
      failure: true

      /*
      status: serverFailure
      
      * There is something broken on the server.
      * There is nothing the client can do to solve this problem.
      
      SBD: Possble rename to 'internalFailure': Reason: so it also makes sense for local library calls.
        If something is failing in a local library, serverFailure makes less sense.
        Then again, local libraries pretty-much don't need communicationStatus at all - they
        can use 'throw' or 'promise.reject'
       */
    },
    serverFailure: {
      httpStatus: 500,
      failure: true,
      serverFailure: true

      /*
      status: networkFailure
      
      * The remote-server could not be reached.
      * There is nothing the code running on the Client NOR Server can do to fix this.
      * There is something wrong with the network between the client computer and the server.
      * The client can attempt to retry at a later time and it might magically work.
      * The client-side-humans or server-side-humans can attempt to fix the network.
      * The failure may be one of the following:
        a) the local computer has no internet connection OR
        b) the internet is in a shitstorm ;) OR
        c) there is an network problem within the Servers' facility.
       */
    },
    networkFailure: {
      failure: true

      /*
      status: aborted
      
      * the request was aborted, AS REQUESTED BY THE CLIENT
       */
    },
    aborted: {
      failure: true

      /*
      status: pending
      
      * The request is proceeding.
      * No errors so far.
       */
    },
    pending: {},

    /*
    status: failure
    
    Use when the same code is used clientSide and serverSide.
    
    Server code should convert :failure into :serverFailure when sending
    a failing reply to a client.
     */
    failure: {
      httpStatus: 500,
      failure: true
    }
  };

  ref = CommunicationStatus.communicationStatuses;
  for (k in ref) {
    v = ref[k];
    CommunicationStatus[k] = k;
  }

  CommunicationStatus.isClientFailure = function(status) {
    var ref1;
    return !!((ref1 = communicationStatuses[status]) != null ? ref1.clientFailure : void 0);
  };

  CommunicationStatus.isServerFailure = function(status) {
    var ref1;
    return !!((ref1 = communicationStatuses[status]) != null ? ref1.serverFailure : void 0);
  };

  CommunicationStatus.isFailure = function(status) {
    var ref1;
    return !!((ref1 = communicationStatuses[status]) != null ? ref1.failure : void 0);
  };

  CommunicationStatus.isSuccess = function(status) {
    return status === "success";
  };


  /*
  OUT: true if status is a valid status-string
   */

  CommunicationStatus.validStatus = function(status) {
    return CommunicationStatus[status] === status;
  };

  CommunicationStatus.decodeHttpStatus = function(httpStatus) {
    var status;
    if (httpStatus == null) {
      return {
        status: CommunicationStatus.networkFailure,
        message: "network failure"
      };
    }
    status = (function() {
      switch (httpStatus / 100 | 0) {
        case 2:
          return this.success;
        case 3:
          return this.missing;
        case 4:
          switch (httpStatus) {
            case 403:
              return this.clientFailureNotAuthorized;
            case 404:
              return this.missing;
            default:
              return this.clientFailure;
          }
          break;
        case 5:
          switch (httpStatus) {
            case 502:
            case 503:
            case 504:
              return this.networkFailure;
            case 501:
            case 505:
            case 530:
              return this.clientFailure;
            case 500:
              return this.serverFailure;
          }
      }
    }).call(CommunicationStatus);
    if (status == null) {
      throw new Error("unhandled httpStatus: " + httpStatus);
    }
    return {
      status: status,
      httpStatus: httpStatus,
      message: status + " (" + httpStatus + ")"
    };
  };

  CommunicationStatus.encodeHttpStatus = function(status) {
    var httpStatus, ref1;
    if (!(httpStatus = (ref1 = CommunicationStatus.communicationStatuses[status]) != null ? ref1.httpStatus : void 0)) {
      throw new Error("There is no valid HttpStatus for " + status + ".");
    }
    return httpStatus;
  };

  return CommunicationStatus;

})();


/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(205);

module.exports.includeInNamespace(__webpack_require__(403));


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(9)).vivifySubnamespace('Art');

__webpack_require__(205);


/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

var defaultArtConfigName;

module.exports = [
  {
    Config: __webpack_require__(206),
    config: {
      yesArtConfig: true
    },
    configName: defaultArtConfigName = "Development",
    defaultArtConfigName: defaultArtConfigName
  }, __webpack_require__(208)
];


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseClass, ConfigRegistry, Configurable, ErrorWithInfo, EventedMixin, deepMerge, defineModule, isPlainObject, log, merge, mergeInto, namespace, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, merge = ref.merge, isPlainObject = ref.isPlainObject, mergeInto = ref.mergeInto, deepMerge = ref.deepMerge, isPlainObject = ref.isPlainObject, ErrorWithInfo = ref.ErrorWithInfo;

BaseClass = __webpack_require__(6).BaseClass;

namespace = __webpack_require__(209);

ConfigRegistry = __webpack_require__(70);

EventedMixin = __webpack_require__(14).EventedMixin;


/*

TO USE:
1) Inherit from Configurable and
2) OPTIONAL: call @defaults to set configuration defaults
3) OPTIONAL, override one of:
  @configure
  @preprocessConfig
  @configured
 */

defineModule(module, Configurable = (function(superClass) {
  extend(Configurable, superClass);

  function Configurable() {
    return Configurable.__super__.constructor.apply(this, arguments);
  }

  Configurable.abstractClass();

  Configurable.declarable({
    defaults: {}
  });

  Configurable.getDefaultConfig = function() {
    return this.getDefaults();
  };

  Configurable.extendConfig = function() {
    if (this.hasOwnProperty("config")) {
      return this.config;
    } else {
      return this.config = {};
    }
  };

  Configurable.reset = function() {
    var config, defaults, k, ref1, v;
    defaults = this.getDefaults();
    config = this.extendConfig();
    for (k in config) {
      v = config[k];
      if (defaults[k] == null) {
        delete config[k];
      }
    }
    mergeInto(config, defaults);
    if (this.namespace !== namespace) {
      if ((ref1 = this.namespace) != null) {
        ref1.config || (ref1.config = config);
      }
    }
    return config;
  };

  Configurable.getInspectedObjects = function() {
    var obj;
    return (
      obj = {},
      obj["" + (this.getConfigurationPathString())] = this.config,
      obj
    );
  };

  Configurable.getPathedDefaultConfig = function() {
    var obj;
    return (
      obj = {},
      obj["" + (this.getConfigurationPathString())] = this.getDefaults(),
      obj
    );
  };

  Configurable.configure = function(globalConfig) {
    var obj;
    globalConfig.verbose && log({
      Configurable: (
        obj = {},
        obj["" + (this.getConfigurationPathString())] = this.getConfigurationFromPath(globalConfig),
        obj
      )
    });
    return mergeInto(this.reset(), this.getConfigurationFromPath(globalConfig));
  };

  Configurable.on = function() {
    var a, ref1;
    a = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (ref1 = this.getSingleton()).on.apply(ref1, a);
  };

  Configurable.configured = function() {
    return this.getSingleton().handleEvent("configured", {
      config: this.config
    });
  };

  Configurable.getConfigurationPath = function() {
    var _Configurable, _Neptune, i, path, ref1;
    ref1 = this.getNamespacePath().split('.'), _Neptune = ref1[0], path = 3 <= ref1.length ? slice.call(ref1, 1, i = ref1.length - 1) : (i = 1, []), _Configurable = ref1[i++];
    return path;
  };

  Configurable.getConfigurationPathString = function() {
    return this.getConfigurationPath().join('.');
  };

  Configurable.getConfigurationFromPath = function(config, path) {
    var el, i, len;
    if (path == null) {
      path = this.getConfigurationPath();
    }
    for (i = 0, len = path.length; i < len; i++) {
      el = path[i];
      config = config != null ? config[el] : void 0;
    }
    return config;
  };

  Configurable._register = function() {
    this.reset();
    return ConfigRegistry.registerConfigurable(this);
  };

  Configurable.postCreateConcreteClass = function(arg) {
    var hotReloaded;
    hotReloaded = arg.hotReloaded;
    if (hotReloaded) {
      ConfigRegistry.reload();
    } else {
      this._register();
    }
    return Configurable.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
  };

  return Configurable;

})(EventedMixin(BaseClass)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(209);

module.exports.includeInNamespace(__webpack_require__(406)).addModules({
  ConfigRegistry: __webpack_require__(70),
  Configurable: __webpack_require__(407),
  Configuration: __webpack_require__(206),
  Lib: __webpack_require__(207),
  Main: __webpack_require__(208)
});


/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, EasingFunctions, EasingPersistantAnimator, EventedObject, Events, Foundation, PersistantAnimator, interpolate, isFunction, isNumber, isString, log, max, min,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Events = __webpack_require__(14);

EasingFunctions = __webpack_require__(72);

PersistantAnimator = __webpack_require__(114);

log = Foundation.log, BaseClass = Foundation.BaseClass, isFunction = Foundation.isFunction, isString = Foundation.isString, isNumber = Foundation.isNumber, min = Foundation.min, max = Foundation.max;

EventedObject = Events.EventedObject;

interpolate = PersistantAnimator.interpolate;

module.exports = EasingPersistantAnimator = (function(superClass) {
  extend(EasingPersistantAnimator, superClass);

  EasingPersistantAnimator.getter("duration easingFunction");

  EasingPersistantAnimator.getter({
    animationPos: function() {
      return min(1, this.getAnimationSeconds() / this._duration);
    }
  });

  EasingPersistantAnimator.setter({
    duration: function(d) {
      return this._duration = isNumber(d) ? max(.001, d) : .25;
    },
    easingFunction: function(f) {
      this._easingFunction = f;
      if (isString(f)) {
        if (!(this._easingFunction = EasingFunctions[f])) {
          console.warn("invalid easing easingFunction: " + f);
        }
      }
      return this._easingFunction || (this._easingFunction = EasingFunctions.easeInQuad);
    }
  });

  function EasingPersistantAnimator(_, options) {
    if (options == null) {
      options = {};
    }
    EasingPersistantAnimator.__super__.constructor.apply(this, arguments);
    this.setEasingFunction(options.f || options.easingFunction);
    this.setDuration(options.d != null ? options.d : options.duration);
  }

  EasingPersistantAnimator.prototype.animate = function() {
    var animationPos, easingFunction, ref, startValue, toValue;
    ref = this, startValue = ref.startValue, toValue = ref.toValue, animationPos = ref.animationPos, easingFunction = ref.easingFunction;
    if (1 === animationPos) {
      this.stop();
    }
    return interpolate(startValue, toValue, easingFunction(animationPos));
  };

  return EasingPersistantAnimator;

})(PersistantAnimator);


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, EasingFunctions, EventedObject, Events, Foundation, PeriodicPersistantAnimator, PersistantAnimator, interpolate, isFunction, isNumber, isString, log, max, min,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Events = __webpack_require__(14);

EasingFunctions = __webpack_require__(72);

PersistantAnimator = __webpack_require__(114);

log = Foundation.log, BaseClass = Foundation.BaseClass, isFunction = Foundation.isFunction, isString = Foundation.isString, isNumber = Foundation.isNumber, min = Foundation.min, max = Foundation.max;

EventedObject = Events.EventedObject;

interpolate = PersistantAnimator.interpolate;

module.exports = PeriodicPersistantAnimator = (function(superClass) {
  extend(PeriodicPersistantAnimator, superClass);

  PeriodicPersistantAnimator.getter({
    animationPos: function() {
      return (this.getAnimationSeconds() % this._period) / this._period;
    }
  });

  PeriodicPersistantAnimator.property("period");

  function PeriodicPersistantAnimator(_, options) {
    if (options == null) {
      options = {};
    }
    PeriodicPersistantAnimator.__super__.constructor.apply(this, arguments);
    this.period = options.period;
  }

  return PeriodicPersistantAnimator;

})(PersistantAnimator);


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var ArtEngineEvents, Atomic, Browser, Canvas, CanvasElement, DrawEpoch, Element, EngineStat, Foundation, GlobalEpochCycle, HtmlCanvas, KeyEvent, Matrix, Point, PointerEvent, PointerEventManager, Rectangle, clone, config, createWithPostCreate, currentSecond, domElementOffset, drawEpoch, durationString, first, getDevicePixelRatio, getEnv, getOrientationAngle, globalEpochCycle, iOSDetect, iPadDetect, inspect, isMobileBrowser, isPlainObject, log, matrix, merge, nativeAppDetect, nextTick, objectDiff, point, rect, ref, ref1, select, showPartialDrawAreas, timeStampToPerformanceSecond, timeout, wordsArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Canvas = __webpack_require__(11);

ArtEngineEvents = __webpack_require__(235);

Element = __webpack_require__(36);

GlobalEpochCycle = __webpack_require__(26);

DrawEpoch = __webpack_require__(74).DrawEpoch;

EngineStat = __webpack_require__(216);

config = __webpack_require__(73).config;

ref = __webpack_require__(1), log = ref.log, inspect = ref.inspect, nextTick = ref.nextTick, currentSecond = ref.currentSecond, timeout = ref.timeout, durationString = ref.durationString, timeStampToPerformanceSecond = ref.timeStampToPerformanceSecond, first = ref.first, wordsArray = ref.wordsArray, select = ref.select, merge = ref.merge, objectDiff = ref.objectDiff, isPlainObject = ref.isPlainObject, clone = ref.clone, getEnv = ref.getEnv;

showPartialDrawAreas = getEnv().showPartialDrawAreas;

createWithPostCreate = __webpack_require__(6).createWithPostCreate;

Browser = __webpack_require__(2).Browser;

nativeAppDetect = Browser.nativeAppDetect, iPadDetect = Browser.iPadDetect, iOSDetect = Browser.iOSDetect, isMobileBrowser = Browser.isMobileBrowser, getOrientationAngle = Browser.getOrientationAngle;

HtmlCanvas = Browser.DomElementFactories.Canvas;

point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix;

ref1 = Browser.Dom, getDevicePixelRatio = ref1.getDevicePixelRatio, domElementOffset = ref1.domElementOffset;

PointerEventManager = ArtEngineEvents.PointerEventManager, PointerEvent = ArtEngineEvents.PointerEvent, KeyEvent = ArtEngineEvents.KeyEvent;

globalEpochCycle = GlobalEpochCycle.globalEpochCycle;

drawEpoch = DrawEpoch.drawEpoch;

module.exports = createWithPostCreate(CanvasElement = (function(superClass) {
  extend(CanvasElement, superClass);

  CanvasElement.classGetter({
    devicePixelsPerPoint: function() {
      return getDevicePixelRatio();
    }
  });

  CanvasElement.prototype._updateRegistryFromPendingState = function() {
    return null;
  };


  /*
  IN:
    options:
      for 'real' mode, set one of the following
      for 'test' mode, leave all blank and there will be no HTMLCanvasElement
        canvas:             HTMLCanvasElement instance
        canvasId:           canvas = document.getElementById canvasId
        parentHtmlElement:  parentHtmlElement.appendChild HtmlCanvas(...)
  
      parentHtmlElement is the preferred option:
        A new HtmlCanvas is generated, and
        it's styles are setup for the best results.
   */

  function CanvasElement(options) {
    var ref2;
    if (options == null) {
      options = {};
    }
    CanvasElement.__super__.constructor.apply(this, arguments);
    this._focusedElement = null;
    this._wasFocusedElement = null;
    this._devicePixelsPerPoint = (ref2 = options.pixelsPerPoint) != null ? ref2 : options.disableRetina ? 1 : getDevicePixelRatio();
    this._domEventListeners = [];
    this._drawEpochPreprocessing = [];
    this._drawEpochQueued = false;
    this._documentToElementMatrix = this._elementToDocumentMatrix = this._absToDocumentMatrix = this._documentToAbsMatrix = null;
    this._attach(this._getOrCreateCanvasElement(options));
    this.engineStat = new EngineStat;
    this.pointerEventManager = new PointerEventManager({
      canvasElement: this
    });
    self.canvasElement || (self.canvasElement = this);
  }

  CanvasElement.getter("documentToElementMatrix elementToDocumentMatrix absToDocumentMatrix documentToAbsMatrix");

  CanvasElement.prototype._getOrCreateCanvasElement = function(arg) {
    var canvas, canvasId, noHtmlCanvasElement, parentHtmlElement;
    canvas = arg.canvas, canvasId = arg.canvasId, parentHtmlElement = arg.parentHtmlElement, noHtmlCanvasElement = arg.noHtmlCanvasElement;
    if (!noHtmlCanvasElement) {
      this._parentHtmlElement = parentHtmlElement || document.getElementById("artDomConsoleArea") || document.body;
      if (canvas || (canvas = document.getElementById(canvasId))) {
        this._parentHtmlElement = canvas.parentElement || this._parentHtmlElement;
        return canvas;
      } else {
        return this._createCanvasElement(this._parentHtmlElement);
      }
    }
  };

  CanvasElement.prototype._createCanvasElement = function(parentHtmlElement) {
    this._createdHtmlCanvasElement = HtmlCanvas({
      style: merge(this.pendingStyle, {
        position: "absolute",
        outline: "none",
        top: "0",
        left: "0"
      }),
      id: "artCanvas"
    });
    this.onNextReady().then((function(_this) {
      return function() {
        return parentHtmlElement.appendChild(_this._createdHtmlCanvasElement);
      };
    })(this));
    return this._createdHtmlCanvasElement;
  };

  CanvasElement.concreteProperty({
    style: {
      "default": {},
      validate: function(v) {
        return isPlainObject(v);
      },
      postSetter: function(newValue, oldValue, rawNewValue) {
        var remove, update;
        update = (function(_this) {
          return function(key, newValue) {
            return _this._canvas.style[key] = newValue;
          };
        })(this);
        remove = (function(_this) {
          return function(key) {
            return _this._canvas.style[key] = null;
          };
        })(this);
        return this._canvas && objectDiff(newValue, oldValue, update, remove, update);
      }
    }
  });

  CanvasElement.virtualProperty({
    parentSizeForChildren: function(pending) {
      return this.getParentSize(pending);
    },
    parentSize: function(pending) {
      var clientHeight, clientWidth, height, innerHeight, innerWidth, ref2, ref3, ref4, width;
      if (this._canvas) {
        if (this._parentHtmlElement && this._parentHtmlElement !== global.document.body) {
          ref2 = this._parentHtmlElement, clientWidth = ref2.clientWidth, clientHeight = ref2.clientHeight;
        }
        innerWidth = global.innerWidth, innerHeight = global.innerHeight;
        ref3 = global.screen, width = ref3.width, height = ref3.height;
        if (Math.abs(getOrientationAngle()) === 90 && height > width) {
          ref4 = [height, width], width = ref4[0], height = ref4[1];
        }
        if (clientWidth > 0 && clientHeight > 0) {
          width = clientWidth;
          height = clientHeight;
        } else if (innerWidth > 0 && innerHeight > 0) {
          if (nativeAppDetect() && iOSDetect()) {
            if (!(iPadDetect() && innerHeight !== height - 20)) {
              innerHeight = height;
            }
          }
          width = innerWidth;
          height = innerHeight;
        }
        return point(width, height);
      } else {
        return point(100);
      }
    }
  });

  CanvasElement.prototype._domListener = function(target, type, listener) {
    target.addEventListener(type, listener);
    return this._domEventListeners.push({
      target: target,
      type: type,
      listener: listener
    });
  };

  CanvasElement.prototype.detach = function() {
    var ref2;
    globalEpochCycle.detachCanvasElement(this);
    if (this._createdHtmlCanvasElement) {
      log("CanvasElement#detach: removing createdHtmlCanvasElement...");
      if ((ref2 = this._createdHtmlCanvasElement.parentElement) != null) {
        ref2.removeChild(this._createdHtmlCanvasElement);
      }
      this._createdHtmlCanvasElement = null;
      this._canvas = null;
      log("CanvasElement#detach: removed createdHtmlCanvasElement.");
    }
    this._unregister();
    return this._detachDomEventListeners();
  };

  CanvasElement.prototype._detachDomEventListeners = function() {
    var i, len, listener, ref2;
    if (!this._eventListenersAttached) {
      return;
    }
    this._eventListenersAttached = false;
    ref2 = this._domEventListeners;
    for (i = 0, len = ref2.length; i < len; i++) {
      listener = ref2[i];
      listener.target.removeEventListener(listener.type, listener.listener);
    }
    return this._domEventListeners = [];
  };

  CanvasElement.prototype.isFocused = function(el) {
    return (!this._canvas || (document.hasFocus() && (document.activeElement === this._canvas || document.activeElement === (el != null ? el._domElement : void 0)))) && this.pointerEventManager.isFocused(el);
  };

  CanvasElement.prototype._blur = function() {
    return this._focusedElement = null;
  };

  CanvasElement.prototype.focusCanvas = function() {
    var ref2;
    return (ref2 = this._canvas) != null ? ref2.focus() : void 0;
  };

  CanvasElement.prototype.blur = function() {
    var ref2;
    if ((ref2 = this._canvas) != null) {
      ref2.blur();
    }
    return this._blur();
  };

  CanvasElement.prototype.focusElement = function(el) {
    if (!(el && el !== this._focusedElement)) {
      return;
    }
    this._focusedElement = this._wasFocusedElement = el;
    return this.pointerEventManager.focus(null, el);
  };

  CanvasElement.prototype._restoreFocus = function() {
    return (this._wasFocusedElement || this)._focus();
  };

  CanvasElement.prototype.enableFileDrop = function() {
    if (!window.FileReader) {
      this.log(this.className + "#enableFileDrop failed - browser not supported");
      return false;
    }
    this._domListener(window, 'dragover', (function(_this) {
      return function(e) {
        return _this.routeFileDropEvent(e, 'dragOver');
      };
    })(this));
    this._domListener(window, 'dragenter', (function(_this) {
      return function(e) {
        return _this.routeFileDropEvent(e, 'dragEnter');
      };
    })(this));
    this._domListener(window, 'dragleave', (function(_this) {
      return function(e) {
        return _this.routeFileDropEvent(e, 'dragLeave');
      };
    })(this));
    this._domListener(window, 'drop', (function(_this) {
      return function(e) {
        return _this.routeFileDropEvent(e, 'drop');
      };
    })(this));
    this.log(this.className + "#enableFileDrop enabled");
    return true;
  };

  CanvasElement.prototype.routeFileDropEvent = function(e, type) {
    if (e.dataTransfer.types[0] !== "Files") {
      return true;
    }
    e.preventDefault();
    this.pointerEventManager.fileDropEvent(type, {
      locations: [this._domEventLocation(e)],
      files: e.dataTransfer.files
    });
    return false;
  };

  CanvasElement.prototype._needsRedrawing = function(descendant) {
    this._addDescendantsDirtyDrawArea(descendant);
    CanvasElement.__super__._needsRedrawing.apply(this, arguments);
    return this.queueDrawEpoch();
  };

  CanvasElement.prototype._releaseAllCacheBitmaps = function() {};

  CanvasElement.prototype.queueDrawEpoch = function() {
    if (!this._drawEpochQueued) {
      this._drawEpochQueued = true;
      return drawEpoch.queueItem((function(_this) {
        return function() {
          return _this.processEpoch();
        };
      })(this));
    }
  };

  CanvasElement.prototype.queueDrawEpochPreprocessor = function(f) {
    this._drawEpochPreprocessing.push(f);
    return this.queueDrawEpoch();
  };

  CanvasElement.prototype.processEpoch = function() {
    var f, i, len, pp;
    this._drawEpochQueued = false;
    if (this._drawEpochPreprocessing.length > 0) {
      pp = this._drawEpochPreprocessing;
      this._drawEpochPreprocessing = [];
      for (i = 0, len = pp.length; i < len; i++) {
        f = pp[i];
        f();
      }
    }
    return this.drawOnBitmap();
  };

  CanvasElement.setter({
    cssCursor: function(cursor) {
      var ref2;
      if (cursor == null) {
        cursor = null;
      }
      if (cursor !== this._cssCursor) {
        if ((ref2 = this._canvas) != null) {
          ref2.style.cursor = cursor;
        }
        return this._cssCursor = cursor;
      }
    }
  });

  CanvasElement.getter({
    inspectedObjects: function() {
      return {
        CanvasElement: {
          currentSize: this.currentSize,
          canvasBitmap: this.canvasBitmap
        }
      };
    },
    htmlCanvasElement: function() {
      return this._canvas;
    },
    numActivePointers: function() {
      return this.pointerEventManager.getNumActivePointers();
    },
    cacheable: function() {
      return false;
    },
    canvasElement: function() {
      return this;
    },
    cssCursor: function() {
      return this._cssCursor;
    },
    windowScrollOffset: function() {
      return point(window.scrollX, window.scrollY);
    },
    geometry: function() {
      return {
        size: this.size,
        scale: this.scale,
        absToElementMatrix: this.absToElementMatrix,
        elementToAbsMatrix: this.elementToAbsMatrix,
        documentToElementMatrix: this.documentToElementMatrix,
        elementToDocumentMatrix: this.elementToDocumentMatrix,
        documentToAbsMatrix: this.documentToAbsMatrix,
        absToDocumentMatrix: this.absToDocumentMatrix,
        parentToElementMatrix: this.parentToElementMatrix,
        elementToParentMatrix: this.elementToParentMatrix
      };
    },
    canvasInnerSize: function() {
      return point(this._fullPageWidth ? window.innerWidth : this._canvas.clientWidth, this._fullPageHeight ? window.innerHeight : this._canvas.clientHeight);
    }
  });

  CanvasElement.prototype._attach = function(canvas) {
    globalEpochCycle.attachCanvasElement(this);
    this.onNextReady((function(_this) {
      return function() {
        return _this._register();
      };
    })(this));
    this._canvas = canvas;
    if (canvas) {
      this._updateCanvasGeometry();
      return this._attachDomEventListeners();
    }
  };

  CanvasElement.prototype._sizeChanged = function(newSize, oldSize) {
    CanvasElement.__super__._sizeChanged.apply(this, arguments);
    this._pointSize = newSize;
    this._canvas.style.width = newSize.x + "px";
    this._canvas.style.height = newSize.y + "px";
    this._pixelSize = this._pointSize.mul(this._devicePixelsPerPoint);
    this._canvas.setAttribute("width", this._pixelSize.x);
    this._canvas.setAttribute("height", this._pixelSize.y);
    this._updateDocumentMatricies();
    this._bitmapFactory = this.canvasBitmap = new Canvas.Bitmap(this._canvas);
    return this.queueDrawEpoch();
  };

  CanvasElement.prototype._setElementToParentMatrixFromLayoutXY = function(x, y) {
    var e2p, ref2, ref3;
    if (this._locationLayoutDisabled) {
      return;
    }
    e2p = this._getElementToParentMatrixForXY(true, x, y, 1);
    if ((ref2 = this._canvas) != null) {
      ref2.style.left = e2p.locationX + "px";
    }
    if ((ref3 = this._canvas) != null) {
      ref3.style.top = e2p.locationY + "px";
    }
    e2p = (this._getElementToParentMatrixForXY(true, x, y)).withLocation(0);
    if (!this._pendingState._elementToParentMatrix.eq(e2p)) {
      this._pendingState._elementToParentMatrix = e2p;
      return this._elementChanged();
    }
  };

  CanvasElement.prototype._updateCanvasGeometry = function(retryCount) {
    var retryMap;
    if (retryCount == null) {
      retryCount = 3;
    }
    this._updateDocumentMatricies();
    this._layoutPropertyChanged();
    this._elementChanged();
    if (retryCount > 0) {
      retryMap = {
        1: 1000,
        2: 100,
        3: 10
      };
      return timeout(retryMap[retryCount], (function(_this) {
        return function() {
          return _this._updateCanvasGeometry(retryCount - 1);
        };
      })(this));
    }
  };

  CanvasElement.prototype._updateDocumentMatricies = function() {
    var elementToDocumentMatrix, left, ref2, top;
    ref2 = domElementOffset(this._canvas), left = ref2.left, top = ref2.top;
    elementToDocumentMatrix = Matrix.translateXY(left, top);
    if (!elementToDocumentMatrix.eq(this._elementToDocumentMatrix)) {
      this._elementToDocumentMatrix = elementToDocumentMatrix;
      this._documentToElementMatrix = this._elementToDocumentMatrix.inv;
      this._documentToAbsMatrix = this._documentToElementMatrix.scale(this._devicePixelsPerPoint);
      this._absToDocumentMatrix = this._documentToAbsMatrix.inv;
      this._parentToElementMatrix = this._absToElementMatrix = this._absToDocumentMatrix.mul(this._documentToElementMatrix);
      this._elementToParentMatrix = this._elementToAbsMatrix = this._absToElementMatrix.inv;
      this.scale = this._devicePixelsPerPoint;
      return this.queueEvent("documentMatriciesChanged");
    }
  };

  CanvasElement.prototype._domEventLocation = function(domEvent) {
    var windowScrollOffset;
    windowScrollOffset = this.getWindowScrollOffset();
    return this._documentToAbsMatrix.transformXY(domEvent.clientX + windowScrollOffset.x, domEvent.clientY + windowScrollOffset.y);
  };

  CanvasElement.prototype._attachResizeListener = function() {
    return this._domListener(window, "resize", (function(_this) {
      return function(domEvent) {
        _this._updateCanvasGeometry();
        return globalEpochCycle.processEpoch();
      };
    })(this));
  };

  CanvasElement.prototype._attachBlurFocusListeners = function() {
    this._domListener(this._canvas, "blur", (function(_this) {
      return function(domEvent) {
        return _this._blur();
      };
    })(this));
    return this._domListener(this._canvas, "focus", (function(_this) {
      return function(domEvent) {
        return _this._restoreFocus();
      };
    })(this));
  };

  CanvasElement.prototype._attachPointerMoveListeners = function() {
    this._domListener(this._canvas, "mousemove", (function(_this) {
      return function(domEvent) {
        if (_this.numActivePointers === 0) {
          return _this.mouseMove(_this._domEventLocation(domEvent, timeStampToPerformanceSecond(domEvent.timeStamp)));
        }
      };
    })(this));
    return this._domListener(window, "mousemove", (function(_this) {
      return function(domEvent) {
        if (_this.numActivePointers > 0) {
          return _this.mouseMove(_this._domEventLocation(domEvent), timeStampToPerformanceSecond(domEvent.timeStamp));
        }
      };
    })(this));
  };

  CanvasElement.getter({
    numActivePointers: function() {
      return this.pointerEventManager.numActivePointers;
    },
    activePointers: function() {
      return this.pointerEventManager.activePointers;
    }
  });

  CanvasElement.prototype.mouseDown = function(location, timeStampInPerformanceSeconds) {
    this.pointerEventManager.mouseMove(location, timeStampInPerformanceSeconds);
    return this.pointerEventManager.mouseDown(location, timeStampInPerformanceSeconds);
  };

  CanvasElement.prototype.mouseMove = function(location, timeStampInPerformanceSeconds) {
    return this.pointerEventManager.mouseMove(location, timeStampInPerformanceSeconds);
  };

  CanvasElement.prototype.mouseUp = function(location, timeStampInPerformanceSeconds) {
    this.pointerEventManager.mouseMove(location, timeStampInPerformanceSeconds);
    return this.pointerEventManager.mouseUp(timeStampInPerformanceSeconds);
  };

  CanvasElement.prototype.mouseWheel = function(location, timeStampInPerformanceSeconds, props) {
    return this.pointerEventManager.mouseWheel(location, timeStampInPerformanceSeconds, props);
  };

  CanvasElement.prototype.touchDown = function(id, location, timeStampInPerformanceSeconds) {
    return this.pointerEventManager.pointerDown(id, location, timeStampInPerformanceSeconds);
  };

  CanvasElement.prototype.touchMove = function(id, location, timeStampInPerformanceSeconds) {
    return this.pointerEventManager.pointerMove(id, location, timeStampInPerformanceSeconds);
  };

  CanvasElement.prototype.touchUp = function(id, location, timeStampInPerformanceSeconds) {
    this.pointerEventManager.pointerMove(id, location, timeStampInPerformanceSeconds);
    return this.pointerEventManager.pointerUp(id, timeStampInPerformanceSeconds);
  };

  CanvasElement.prototype.touchCancel = function(id, timeStampInPerformanceSeconds) {
    return this.pointerEventManager.pointerCancel(id, timeStampInPerformanceSeconds);
  };

  CanvasElement.prototype._focus = function() {
    this._canvas.focus();
    return this.focusElement(this._focusedElement = this._wasFocusedElement);
  };

  CanvasElement.prototype.capturePointerEvents = function(element) {
    return this.pointerEventManager.capturePointerEvents(element);
  };

  CanvasElement.prototype.pointerEventsCapturedBy = function(element) {
    return this.pointerEventManager.pointerEventsCapturedBy(element);
  };

  CanvasElement.prototype._attachPointerButtonListeners = function() {
    this._domListener(this._canvas, "mouseover", (function(_this) {
      return function(domEvent) {
        return _this._updateDocumentMatricies();
      };
    })(this));
    this._domListener(this._canvas, "mousedown", (function(_this) {
      return function(domEvent) {
        _this._updateDocumentMatricies();
        _this._restoreFocus();
        if (domEvent.button === 0) {
          domEvent.preventDefault();
          return _this.mouseDown(_this._domEventLocation(domEvent), timeStampToPerformanceSecond(domEvent.timeStamp));
        }
      };
    })(this));
    return this._domListener(window, "mouseup", (function(_this) {
      return function(domEvent) {
        if (domEvent.button === 0 && _this.activePointers["mousePointer"]) {
          domEvent.preventDefault();
          return _this.mouseUp(_this._domEventLocation(domEvent), timeStampToPerformanceSecond(domEvent.timeStamp));
        }
      };
    })(this));
  };

  CanvasElement.prototype._attachPointerWheelListeners = function() {
    return this._domListener(this._canvas, "wheel", (function(_this) {
      return function(domEvent) {
        domEvent.preventDefault();
        return _this.mouseWheel(_this._domEventLocation(domEvent), timeStampToPerformanceSecond(domEvent.timeStamp), merge({
          deltaMode: (function() {
            switch (domEvent.deltaMode) {
              case 0:
                return "pixel";
              case 1:
                return "line";
              case 2:
                return "page";
            }
          })()
        }, select(domEvent, "deltaX", "deltaY", "deltaZ")));
      };
    })(this));
  };

  CanvasElement.prototype._attachPointerTouchListeners = function() {
    this._domListener(this._canvas, "touchstart", (function(_this) {
      return function(e) {
        var changedTouch, i, len, ref2, results;
        _this._updateDocumentMatricies();
        e.preventDefault();
        _this._restoreFocus();
        ref2 = e.changedTouches;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          changedTouch = ref2[i];
          results.push(_this.touchDown(changedTouch.identifier, _this._domEventLocation(changedTouch), timeStampToPerformanceSecond(e.timeStamp)));
        }
        return results;
      };
    })(this));
    this._domListener(this._canvas, "touchmove", (function(_this) {
      return function(e) {
        var changedTouch, i, len, ref2, results;
        e.preventDefault();
        ref2 = e.changedTouches;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          changedTouch = ref2[i];
          results.push(_this.pointerEventManager.pointerMove(changedTouch.identifier, _this._domEventLocation(changedTouch), timeStampToPerformanceSecond(e.timeStamp)));
        }
        return results;
      };
    })(this));
    this._domListener(this._canvas, "touchend", (function(_this) {
      return function(e) {
        var changedTouch, i, len, ref2, results;
        e.preventDefault();
        ref2 = e.changedTouches;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          changedTouch = ref2[i];
          results.push(_this.touchUp(changedTouch.identifier, _this._domEventLocation(changedTouch), timeStampToPerformanceSecond(e.timeStamp)));
        }
        return results;
      };
    })(this));
    return this._domListener(this._canvas, "touchcancel", (function(_this) {
      return function(e) {
        var changedTouch, i, len, ref2, results;
        e.preventDefault();
        ref2 = e.changedTouches;
        results = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          changedTouch = ref2[i];
          results.push(_this.touchCancel(changedTouch.identifier, timeStampToPerformanceSecond(e.timeStamp)));
        }
        return results;
      };
    })(this));
  };

  CanvasElement.prototype.queueKeyEvents = function(type, keyboardEvent) {
    return this.pointerEventManager.queueKeyEvents(type, keyboardEvent);
  };

  CanvasElement.prototype.keyDownEvent = function(keyboardEvent) {
    this.queueKeyEvents("keyDown", keyboardEvent);
    return this.queueKeyEvents("keyPress", keyboardEvent);
  };

  CanvasElement.prototype.keyUpEvent = function(keyboardEvent) {
    return this.queueKeyEvents("keyUp", keyboardEvent);
  };

  CanvasElement.prototype._attachKeypressListeners = function() {
    this._domListener(this._canvas, "keydown", (function(_this) {
      return function(keyboardEvent) {
        _this.keyDownEvent(keyboardEvent);
        if (keyboardEvent.key === "Backspace") {
          return keyboardEvent.preventDefault();
        }
      };
    })(this));
    return this._domListener(this._canvas, "keyup", (function(_this) {
      return function(keyboardEvent) {
        return _this.keyUpEvent(keyboardEvent);
      };
    })(this));
  };

  CanvasElement.prototype._enableHtmlFocusOnCanvas = function() {
    if (!isMobileBrowser()) {
      this._canvas.tabIndex = "-1";
      return this._canvas.contentEditable = true;
    }
  };

  CanvasElement.prototype._attachDomEventListeners = function() {
    if (this._eventListenersAttached) {
      return;
    }
    this._eventListenersAttached = true;
    this._enableHtmlFocusOnCanvas();
    this._attachBlurFocusListeners();
    this._attachPointerMoveListeners();
    this._attachPointerTouchListeners();
    this._attachPointerButtonListeners();
    this._attachPointerWheelListeners();
    this._attachResizeListener();
    return this._attachKeypressListeners();
  };

  CanvasElement.prototype.drawOnBitmap = function() {
    var dirtyDrawArea, frameEndTime, frameStartTime, i, j, lastClippingInfo, len, len1, ref2, ref3, ref4;
    Element.resetStats();
    frameStartTime = currentSecond();
    this.firstFrameTime || (this.firstFrameTime = frameStartTime);
    if (this.lastFrameTime) {
      this.engineStat.add("fps", 1 / (frameStartTime - this.lastFrameTime));
      this.engineStat.add("frameTimeMS", (frameStartTime - this.lastFrameTime) * 1000);
    }
    this.lastFrameTime = frameStartTime;
    if (this.canvasBitmap) {
      if (config.partialRedrawEnabled && this._dirtyDrawAreas) {
        ref2 = this._dirtyDrawAreas;
        for (i = 0, len = ref2.length; i < len; i++) {
          dirtyDrawArea = ref2[i];
          lastClippingInfo = this.canvasBitmap.openClipping(dirtyDrawArea.mul(this._devicePixelsPerPoint));
          CanvasElement.__super__.drawOnBitmap.call(this, this.canvasBitmap, this.elementToParentMatrix);
          this.canvasBitmap.closeClipping(lastClippingInfo);
        }
      } else {
        CanvasElement.__super__.drawOnBitmap.call(this, this.canvasBitmap, this.elementToParentMatrix);
      }
    }
    if (showPartialDrawAreas || config.showPartialDrawAreas) {
      ref3 = this._dirtyDrawAreas || [this.drawArea];
      for (j = 0, len1 = ref3.length; j < len1; j++) {
        dirtyDrawArea = ref3[j];
        if ((ref4 = this.canvasBitmap) != null) {
          ref4.drawBorder(null, dirtyDrawArea.mul(this._devicePixelsPerPoint), {
            color: "red"
          });
        }
      }
    }
    frameEndTime = currentSecond();
    this.engineStat.add("drawTimeMS", (frameEndTime - frameStartTime) * 1000 | 0);
    this._redrawAll = false;
    return this._dirtyDrawAreas = null;
  };

  CanvasElement.prototype._showDrawStats = function() {
    var numSamples;
    numSamples = this.engineStat.length("drawTimeMS");
    return timeout(1000, (function(_this) {
      return function() {
        var totalDrawDuration;
        if (numSamples === _this.engineStat.length("drawTimeMS")) {
          totalDrawDuration = frameEndTime - _this.firstFrameTime;
          _this.engineStat.log();
          _this.engineStat.reset();
          _this.log({
            cache: {
              count: Element._activeCacheCount,
              size: (Element._activeCacheByteSize / (1024 * 1024)).toFixed(1) + "mb"
            }
          });
          _this.firstFrameTime = null;
          _this.frameCount = 0;
          return _this.lastFrameTime = null;
        }
      };
    })(this));
  };

  return CanvasElement;

})(Element));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

var merge;

__webpack_require__(26);

__webpack_require__(74);

merge = __webpack_require__(1).merge;

module.exports = merge({
  newElement: (__webpack_require__(119)).newElement
}, __webpack_require__(120));


/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
var BaseClass, Color, DrawAreaCollector, GradientFillStyle, Matrix, Paths, addDirtyDrawArea, circlePath, clone, compactFlatten, defineModule, each, ellipsePath, formattedInspect, identityMatrix, isArray, isColor, isFunction, isNumber, isPlainObject, isRect, isString, log, max, merge, mergeInto, object, objectWithout, perimeter, point, rect, rectanglePath, ref, ref1, ref2, rgbColor,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), compactFlatten = ref.compactFlatten, objectWithout = ref.objectWithout, defineModule = ref.defineModule, formattedInspect = ref.formattedInspect, clone = ref.clone, max = ref.max, isFunction = ref.isFunction, log = ref.log, object = ref.object, isNumber = ref.isNumber, isArray = ref.isArray, isPlainObject = ref.isPlainObject, isString = ref.isString, each = ref.each, isPlainObject = ref.isPlainObject, merge = ref.merge, mergeInto = ref.mergeInto;

ref1 = __webpack_require__(4), Matrix = ref1.Matrix, identityMatrix = ref1.identityMatrix, Color = ref1.Color, point = ref1.point, rect = ref1.rect, rgbColor = ref1.rgbColor, isRect = ref1.isRect, isColor = ref1.isColor, perimeter = ref1.perimeter;

ref2 = __webpack_require__(11), GradientFillStyle = ref2.GradientFillStyle, Paths = ref2.Paths;

rectanglePath = Paths.rectanglePath, ellipsePath = Paths.ellipsePath, circlePath = Paths.circlePath;

BaseClass = __webpack_require__(6).BaseClass;

DrawAreaCollector = __webpack_require__(213);

addDirtyDrawArea = __webpack_require__(117).addDirtyDrawArea;

defineModule(module, function() {
  return function(superClass) {
    var ElementDrawAreaMixin;
    return ElementDrawAreaMixin = (function(superClass1) {
      extend(ElementDrawAreaMixin, superClass1);

      function ElementDrawAreaMixin() {
        return ElementDrawAreaMixin.__super__.constructor.apply(this, arguments);
      }

      ElementDrawAreaMixin.setter({
        dirtyDrawAreasChanged: function(v) {
          if (v) {
            this._dirtyDrawAreasChangedWasTrue = v;
          } else if (this._dirtyDrawAreasChangedWasTrue) {
            this.onNextReady((function(_this) {
              return function() {
                return _this._dirtyDrawAreasChangedWasTrue = false;
              };
            })(this));
          }
          return this._dirtyDrawAreasChanged = v;
        }
      });

      ElementDrawAreaMixin.virtualProperty({
        preFilteredBaseDrawArea: function(pending) {
          var _currentPadding, _currentSize, h, ref3, w, x, y;
          ref3 = this.getState(pending), _currentPadding = ref3._currentPadding, _currentSize = ref3._currentSize;
          x = _currentSize.x, y = _currentSize.y;
          w = _currentPadding.w, h = _currentPadding.h;
          return rect(0, 0, max(0, x - w), max(0, y - h));
        },
        baseDrawArea: function(pending) {
          return this.getPreFilteredBaseDrawArea(pending);
        }
      });

      ElementDrawAreaMixin.getter({
        parentSpaceDrawArea: function() {
          return this._elementToParentMatrix.transformBoundingRect(this.getElementSpaceDrawArea());
        },
        elementSpaceDrawArea: function() {
          return this._elementSpaceDrawArea || (this._elementSpaceDrawArea = this._computeElementSpaceDrawArea());
        },
        drawArea: function() {
          return this.elementSpaceDrawArea;
        }
      });

      ElementDrawAreaMixin.prototype.drawAreaIn = function(elementToTargetMatrix) {
        if (elementToTargetMatrix == null) {
          elementToTargetMatrix = this.getElementToAbsMatrix();
        }
        return elementToTargetMatrix.transformBoundingRect(this.getElementSpaceDrawArea());
      };

      ElementDrawAreaMixin.prototype.drawAreaInElement = function(element) {
        return this.drawAreaIn(this.getElementToElementMatrix(element));
      };

      ElementDrawAreaMixin.getter({
        clippedDrawArea: function(stopAtParent) {
          var drawArea, parent, requiredParentFound;
          parent = this;
          requiredParentFound = false;
          drawArea = clone(this.drawAreaInElement(stopAtParent));
          while (parent = parent.getParent()) {
            if (parent.clip) {
              parent.drawAreaInElement(stopAtParent).intersectInto(drawArea);
            }
            if (parent === stopAtParent) {
              requiredParentFound = true;
              break;
            }
          }
          if (stopAtParent && !requiredParentFound) {
            return rect();
          }
          return drawArea;
        }
      });

      ElementDrawAreaMixin.prototype._drawAreaChanged = function() {
        var p;
        if (this._elementSpaceDrawArea) {
          this._elementSpaceDrawArea = null;
          if (p = this.getPendingParent()) {
            return p._childsDrawAreaChanged();
          }
        }
      };

      ElementDrawAreaMixin.prototype._childsDrawAreaChanged = function() {
        return this._drawAreaChanged();
      };

      ElementDrawAreaMixin.prototype._computeElementSpaceDrawArea = function(upToChild) {
        var drawAreaCollector;
        drawAreaCollector = new DrawAreaCollector(this.currentPadding);
        if (this.getClip()) {
          drawAreaCollector.openClipping(null, identityMatrix, this.paddedArea);
        }
        this._drawChildren(drawAreaCollector, identityMatrix, false, upToChild);
        return drawAreaCollector.drawArea;
      };

      ElementDrawAreaMixin.prototype._addDescendantsDirtyDrawArea = function(descendant) {
        var dirtyArea;
        if (descendant && !this._redrawAll) {
          if (descendant !== this) {
            return this._addDirtyDrawArea((dirtyArea = descendant.getClippedDrawArea(this)), true);
          }
        } else {
          this._dirtyDrawAreas = null;
          return this._redrawAll = true;
        }
      };

      ElementDrawAreaMixin.prototype._addDirtyDrawArea = function(dirtyArea, triggeredByChild) {
        var pixelsPerPoint, snapTo;
        if (dirtyArea == null) {
          dirtyArea = this.drawArea;
        }
        pixelsPerPoint = this.getDevicePixelsPerPoint();
        snapTo = 1 / pixelsPerPoint;
        if (triggeredByChild) {
          this.setDirtyDrawAreasChanged(true);
        }
        return this._dirtyDrawAreas = addDirtyDrawArea(this._dirtyDrawAreas, dirtyArea, snapTo);
      };

      return ElementDrawAreaMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
var BaseClass, Color, GradientFillStyle, Matrix, Paths, circlePath, clone, colorPrecision, compactFlatten, config, defaultLineWidth, defaultMiterLimit, defineModule, drawCacheManager, each, ellipsePath, floatEq, formattedInspect, globalEpochCycle, identityMatrix, isArray, isColor, isFunction, isNumber, isPlainObject, isRect, isString, legalDrawCommands, log, looksLikeColor, max, maxCanvasSize, merge, mergeInto, neq, normalizeDrawStep, object, objectWithout, partitionAreasByInteresection, perimeter, point, prepareDrawOptions, rect, rectanglePath, ref, ref1, ref2, ref3, rgbColor, truncateLayoutCoordinate,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), compactFlatten = ref.compactFlatten, objectWithout = ref.objectWithout, defineModule = ref.defineModule, formattedInspect = ref.formattedInspect, clone = ref.clone, max = ref.max, isFunction = ref.isFunction, log = ref.log, object = ref.object, isNumber = ref.isNumber, isArray = ref.isArray, isPlainObject = ref.isPlainObject, isString = ref.isString, each = ref.each, isPlainObject = ref.isPlainObject, merge = ref.merge, mergeInto = ref.mergeInto, floatEq = ref.floatEq, neq = ref.neq;

ref1 = __webpack_require__(4), Matrix = ref1.Matrix, identityMatrix = ref1.identityMatrix, Color = ref1.Color, point = ref1.point, rect = ref1.rect, rgbColor = ref1.rgbColor, isRect = ref1.isRect, isColor = ref1.isColor, perimeter = ref1.perimeter;

ref2 = __webpack_require__(11), GradientFillStyle = ref2.GradientFillStyle, Paths = ref2.Paths;

rectanglePath = Paths.rectanglePath, ellipsePath = Paths.ellipsePath, circlePath = Paths.circlePath;

BaseClass = __webpack_require__(6).BaseClass;

defaultMiterLimit = 3;

defaultLineWidth = 1;

config = __webpack_require__(73).config;

drawCacheManager = __webpack_require__(116).drawCacheManager;

globalEpochCycle = __webpack_require__(26).globalEpochCycle;

maxCanvasSize = 16777216;

ref3 = __webpack_require__(117), normalizeDrawStep = ref3.normalizeDrawStep, prepareDrawOptions = ref3.prepareDrawOptions, looksLikeColor = ref3.looksLikeColor, legalDrawCommands = ref3.legalDrawCommands, partitionAreasByInteresection = ref3.partitionAreasByInteresection, colorPrecision = ref3.colorPrecision;

truncateLayoutCoordinate = function(v) {
  return floor(v + colorPrecision);
};

defineModule(module, function() {
  return function(superClass) {
    var ElementDrawMixin;
    return ElementDrawMixin = (function(superClass1) {
      var drawWithCachingOptions, sharedDrawOptions, sharedShadowOptions;

      extend(ElementDrawMixin, superClass1);

      function ElementDrawMixin() {
        return ElementDrawMixin.__super__.constructor.apply(this, arguments);
      }

      sharedDrawOptions = {};

      sharedShadowOptions = {};

      ElementDrawMixin.drawProperty({
        stage: {
          "default": null,
          validate: function(v) {
            return v === null || v === false || v === true;
          },
          description: "true:   always stage\nfalse:  never stage\nnull:   stage as needed"
        },
        cacheThrough: {
          "default": false,
          validate: function(v) {
            return v === false || v === true;
          }
        },
        cacheDraw: {
          "default": false,
          validate: function(v) {
            return v === false || v === true || isPlainObject(v);
          },
          description: "true => stage always unless cacheThrough or it's not needed AND it's faster w/o"
        }
      });

      ElementDrawMixin.drawLayoutProperty({
        draw: {
          "default": null,
          validate: function(v) {
            return (v == null) || isRect(v) || isFunction(v) || isArray(v) || isPlainObject(v) || isString(v) || isColor(v) || v.constructor === GradientFillStyle;
          },
          preprocess: function(drawSteps) {
            var color, colors, drawStep, fill, from, i, j, len, len1, needsNormalizing, outline, padding, radius, ref10, ref4, ref5, ref6, ref7, ref8, ref9, results, shadow, step, to;
            if (drawSteps != null) {
              if (!isArray(drawSteps)) {
                drawSteps = [drawSteps];
              }
              drawSteps = compactFlatten(drawSteps);
              needsNormalizing = false;
              for (i = 0, len = drawSteps.length; i < len; i++) {
                step = drawSteps[i];
                fill = step.fill, outline = step.outline, radius = step.radius, color = step.color, colors = step.colors, padding = step.padding, shadow = step.shadow, to = step.to, from = step.from;
                if ((ref4 = (ref5 = (ref6 = (ref7 = (ref8 = (ref9 = (ref10 = radius != null ? radius : fill) != null ? ref10 : outline) != null ? ref9 : color) != null ? ref8 : colors) != null ? ref7 : padding) != null ? ref6 : to) != null ? ref5 : from) != null ? ref4 : looksLikeColor(step)) {
                  needsNormalizing = true;
                  break;
                }
              }
              if (needsNormalizing) {
                results = [];
                for (j = 0, len1 = drawSteps.length; j < len1; j++) {
                  drawStep = drawSteps[j];
                  results.push(normalizeDrawStep(drawStep));
                }
                return results;
              } else {
                return drawSteps;
              }
            } else {
              return null;
            }
          }
        }
      });

      ElementDrawMixin.virtualProperty({
        drawOrder: {
          getter: function(pending) {
            return this.getState(pending)._draw;
          },
          setter: function(v) {
            return this.setDraw(v);
          }
        }
      });

      ElementDrawMixin.prototype.drawOnBitmap = function(target, elementToTargetMatrix) {
        var cacheDrawRequested, needsStagingBitmap, targetSpaceDrawArea;
        try {
          if (this.opacity < colorPrecision) {
            return;
          }
          this._currentDrawTarget = target;
          this._currentToTargetMatrix = elementToTargetMatrix;
          targetSpaceDrawArea = this.drawAreaIn(elementToTargetMatrix).intersection(target.getClippingArea());
          if (!(targetSpaceDrawArea.area > 0)) {
            return;
          }
          cacheDrawRequested = this.getCacheDrawRequested(elementToTargetMatrix);
          needsStagingBitmap = this.getNeedsStagingBitmap(elementToTargetMatrix);
          if (needsStagingBitmap || (cacheDrawRequested && !this._cacheThrough && !(this._dirtyDrawAreasChanged || this._dirtyDrawAreasChangedWasTrue))) {
            this._drawWithCaching(targetSpaceDrawArea, target, elementToTargetMatrix);
          } else {
            if (!cacheDrawRequested) {
              this._clearDrawCache();
            }
            if (cacheDrawRequested || this._cacheThrough) {
              if (target.shouldPixelSnap(elementToTargetMatrix)) {
                elementToTargetMatrix = target.pixelSnapMatrix(elementToTargetMatrix);
              }
            }
            if (this._clip) {
              this._drawWithClipping(targetSpaceDrawArea, target, elementToTargetMatrix);
            } else {
              this._drawChildren(target, elementToTargetMatrix);
            }
          }
          if (this._dirtyDrawAreasChanged) {
            this._dirtyDrawAreasChangedWasTrue = true;
            return this.setDirtyDrawAreasChanged(false);
          }
        } finally {
          this._currentDrawTarget = this._currentToTargetMatrix = null;
        }
      };

      ElementDrawMixin.prototype._drawChildren = function(target, elementToTargetMatrix, usingStagedBitmap, upToChild) {
        var area, child, childElement, childKey, children, childrenByKey, circle, clip, currentDrawArea, currentPath, currentPathOptions, customShapePath, drawMatrix, drawStep, drawSteps, drewChildren, error, explicitlyDrawnChildrenByKey, fill, i, instruction, j, k, key, l, lastClippingInfo, len, len1, len2, len3, len4, len5, m, n, newShapeOptions, outline, padding, rectangle, ref4, shape;
        children = this.children;
        if (drawSteps = this.getDraw()) {
          currentPath = rectanglePath;
          currentPathOptions = null;
          drawMatrix = this._currentPadding.needsTranslation ? Matrix.translateXY(-this._currentPadding.left, -this._currentPadding.top).mul(elementToTargetMatrix) : elementToTargetMatrix;
          currentDrawArea = this._currentSize;
          drewChildren = false;
          lastClippingInfo = null;
          try {
            explicitlyDrawnChildrenByKey = null;
            for (i = 0, len = drawSteps.length; i < len; i++) {
              drawStep = drawSteps[i];
              if ((childKey = drawStep.child) != null) {
                (explicitlyDrawnChildrenByKey || (explicitlyDrawnChildrenByKey = {}))[childKey] = true;
              }
            }
            if (explicitlyDrawnChildrenByKey) {
              childrenByKey = {};
              for (j = 0, len1 = children.length; j < len1; j++) {
                child = children[j];
                if ((key = child._key) != null) {
                  childrenByKey[key] = child;
                }
              }
            }
            for (k = 0, len2 = drawSteps.length; k < len2; k++) {
              drawStep = drawSteps[k];
              if (isFunction(drawStep)) {
                drawStep(target, elementToTargetMatrix, this, currentDrawArea, currentPath);
              } else if (isRect(drawStep)) {
                currentPath = rectanglePath;
                currentDrawArea = drawStep;
                currentPathOptions = null;
              } else if (isString(instruction = drawStep)) {
                switch (instruction) {
                  case "reset":
                    currentPath = rectanglePath;
                    currentDrawArea = this.currentSize;
                    currentPathOptions = null;
                    if (lastClippingInfo != null) {
                      target.closeClipping(lastClippingInfo);
                      lastClippingInfo = null;
                    }
                    break;
                  case "resetClip":
                    if (lastClippingInfo != null) {
                      target.closeClipping(lastClippingInfo);
                      lastClippingInfo = null;
                    }
                    break;
                  case "resetDrawArea":
                  case "logicalDrawArea":
                    currentDrawArea = this.currentSize;
                    break;
                  case "padded":
                  case "paddedDrawArea":
                    currentDrawArea = this.currentPadding.pad(this.currentSize);
                    break;
                  case "resetShape":
                    currentPath = rectanglePath;
                    currentPathOptions = null;
                    break;
                  case "circle":
                    currentPath = circlePath;
                    currentPathOptions = null;
                    break;
                  case "rectangle":
                    currentPath = rectanglePath;
                    currentPathOptions = null;
                    break;
                  case "clip":
                    if (lastClippingInfo) {
                      target.closeClipping(lastClippingInfo);
                    }
                    lastClippingInfo = target.openClipping(currentPath, drawMatrix, currentDrawArea, currentPathOptions);
                    break;
                  case "children":
                    for (l = 0, len3 = children.length; l < len3; l++) {
                      child = children[l];
                      if (!(!(((key = child._key) != null) && (explicitlyDrawnChildrenByKey != null ? explicitlyDrawnChildrenByKey[key] : void 0)))) {
                        continue;
                      }
                      if (upToChild === child) {
                        upToChild = "done";
                        break;
                      }
                      child.visible && target.drawDrawable(child, child.getElementToTargetMatrix(elementToTargetMatrix));
                    }
                    drewChildren = true;
                    break;
                  default:
                    console.warn("Art.Engine.Element: invalid draw instruction: " + instruction);
                }
                if (upToChild === "done") {
                  break;
                }
              } else if (isPlainObject(drawStep)) {
                padding = drawStep.padding, fill = drawStep.fill, clip = drawStep.clip, outline = drawStep.outline, shape = drawStep.shape, rectangle = drawStep.rectangle, child = drawStep.child, circle = drawStep.circle;
                if (newShapeOptions = (ref4 = rectangle != null ? rectangle : circle) != null ? ref4 : shape) {
                  currentPathOptions = isPlainObject(newShapeOptions) ? ((area = newShapeOptions.area, customShapePath = newShapeOptions.path, newShapeOptions), newShapeOptions) : (shape ? customShapePath = shape : area = newShapeOptions, null);
                  currentDrawArea = isFunction(area) ? area(this._currentSize, currentPathOptions, this) : isRect(area) ? area : currentDrawArea;
                  currentPath = (function() {
                    switch (false) {
                      case !circle:
                        return circlePath;
                      case !rectangle:
                        return rectanglePath;
                      case !shape:
                        return customShapePath;
                    }
                  })();
                }
                if (padding) {
                  currentDrawArea = padding.pad(currentDrawArea);
                }
                if (clip != null) {
                  if (clip) {
                    if (lastClippingInfo != null) {
                      target.closeClipping(lastClippingInfo);
                    }
                    lastClippingInfo = target.openClipping(currentPath, drawMatrix, currentDrawArea, currentPathOptions);
                  } else {
                    if (lastClippingInfo != null) {
                      target.closeClipping(lastClippingInfo);
                      lastClippingInfo = null;
                    }
                  }
                }
                if (fill != null) {
                  target.fillShape(drawMatrix, prepareDrawOptions(fill, currentDrawArea), currentPath, currentDrawArea, currentPathOptions);
                }
                if (outline != null) {
                  target.strokeShape(drawMatrix, prepareDrawOptions(outline, currentDrawArea, true), currentPath, currentDrawArea, currentPathOptions);
                }
                if ((child != null) && (childElement = childrenByKey[child])) {
                  if (upToChild === child) {
                    break;
                  }
                  target.drawDrawable(childElement, childElement.getElementToTargetMatrix(elementToTargetMatrix));
                }
              }
            }
          } catch (error1) {
            error = error1;
            log.error({
              ElementDrawMixin: {
                drawChildren: {
                  error: error
                }
              }
            });
          }
          if (!drewChildren) {
            for (m = 0, len4 = children.length; m < len4; m++) {
              child = children[m];
              if (!(!(((key = child._key) != null) && (explicitlyDrawnChildrenByKey != null ? explicitlyDrawnChildrenByKey[key] : void 0)))) {
                continue;
              }
              if (upToChild === child) {
                break;
              }
              child.visible && target.drawDrawable(child, child.getElementToTargetMatrix(elementToTargetMatrix));
            }
          }
          if (lastClippingInfo != null) {
            target.closeClipping(lastClippingInfo);
          }
        } else {
          for (n = 0, len5 = children.length; n < len5; n++) {
            child = children[n];
            if (child === upToChild) {
              break;
            }
            child.visible && target.drawDrawable(child, child.getElementToTargetMatrix(elementToTargetMatrix));
          }
        }
        return children;
      };

      ElementDrawMixin.prototype._drawWithClipping = function(clipArea, target, elementToTargetMatrix) {
        var lastClippingInfo;
        lastClippingInfo = target.openClipping(clipArea);
        this._drawChildren(target, elementToTargetMatrix);
        return target.closeClipping(lastClippingInfo);
      };


      /*
      "pixel-exact-caching"
      
      Right now (Dec 2016), my strategy is:
      
        if cacheDraw
          cache in element space scaled by pixelsPerPoint
          changes to these specific props do not invalidate the cache:
            elementToParentMatrix (and all derriviatives)
            opacity
            compositeMode
        else if needsStagingBitmap
          use pixel-exact cache
      
      Additional options:
        cacheAt prop
          We may add another option which lets of add a "cache-at" scale factor to force lower or
          higher resolution caching.
      
        global "fast-mode"
          In the old C++ Art.Engine we had a global "fast" mode where caches were not invalidated under
          any draw-matrix changes until fast-mode was turned off, then a final redraw pass was made
          where pixel-inexact caches were invalidated and redrawn. This allowed good user interactivity
          followed by maximum quality renders. This was handy for the more general-purpose Kimi-editor,
          for the current purpose-built kimi-editor, it isn't needed.
       */

      ElementDrawMixin.prototype._resetDrawCache = function() {
        this._dirtyDrawAreasChangedWasTrue = false;
        this._dirtyDrawAreasChanged = false;
        this._redrawAll = false;
        this._drawCacheBitmap = this._drawCacheToElementMatrix = this._dirtyDrawAreas = null;
        return this._elementToDrawCacheMatrix = null;
      };

      ElementDrawMixin.prototype._drawPropertiesChanged = function() {
        return this._clearDrawCache();
      };

      ElementDrawMixin.prototype._needsRedrawing = function(descendant) {
        var ref4;
        if (descendant == null) {
          descendant = this;
        }
        if (this._drawCacheBitmap) {
          this._addDescendantsDirtyDrawArea(descendant);
        }
        if (this.getVisible() && this.getOpacity() > colorPrecision) {
          return (ref4 = this.getParent()) != null ? ref4._needsRedrawing(descendant) : void 0;
        }
      };

      ElementDrawMixin.prototype.__clearDrawCacheCallbackFromDrawCacheManager = function() {
        return this._resetDrawCache();
      };

      ElementDrawMixin.prototype._clearDrawCache = function() {
        if (!this._drawCacheBitmap) {
          return;
        }
        drawCacheManager.doneWithCacheBitmap(this);
        return true;
      };

      ElementDrawMixin.prototype._releaseAllCacheBitmaps = function() {
        var child, count, i, len, ref4;
        count = this._clearDrawCache() ? 1 : 0;
        ref4 = this._children;
        for (i = 0, len = ref4.length; i < len; i++) {
          child = ref4[i];
          count += child._releaseAllCacheBitmaps();
        }
        return count;
      };

      ElementDrawMixin._activeCacheDrawDepth = 0;

      ElementDrawMixin.prototype.getCacheDrawRequested = function(elementToTargetMatrix) {
        return config.drawCacheEnabled && this["class"]._activeCacheDrawDepth === 0 && this.getCacheable() && this.getCacheDraw();
      };

      ElementDrawMixin.getter({
        drawOrderRequiresStaging: function() {
          var compositeMode, draw, fill, i, len, outline, ref4;
          if (!(draw = this.draw)) {
            return false;
          }
          for (i = 0, len = draw.length; i < len; i++) {
            ref4 = draw[i], fill = ref4.fill, outline = ref4.outline;
            if (fill) {
              compositeMode = fill.compositeMode;
              if ((compositeMode != null) && compositeMode !== "normal") {
                return true;
              }
            }
            if (outline) {
              compositeMode = outline.compositeMode;
              if ((compositeMode != null) && compositeMode !== "normal") {
                return true;
              }
            }
          }
        }
      });

      ElementDrawMixin.prototype.getNeedsStagingBitmap = function(elementToTargetMatrix) {
        var draw, stage;
        if ((stage = this.stage) != null) {
          return stage;
        }
        draw = this.draw;
        return !!(this.getIsMask() || ((this.getHasChildren() || (draw != null)) && !this.getCompositingIsBasic()) || (this._clip && (elementToTargetMatrix != null ? elementToTargetMatrix.getHasSkew() : void 0)) || this.getChildRequiresParentStagingBitmap() || this.drawOrderRequiresStaging);
      };

      ElementDrawMixin.getter({
        compositingIsBasic: function() {
          return this._compositeMode === "normal" && floatEq(this._opacity, 1);
        },
        cacheIsValid: function() {
          return !!this._drawCacheBitmap;
        },
        cacheable: function() {
          return true;
        }
      });

      drawWithCachingOptions = {
        opacity: 1,
        compositeMode: null
      };

      ElementDrawMixin.prototype._drawWithCaching = function(targetSpaceDrawArea, target, elementToTargetMatrix) {
        this._updateDrawCache(targetSpaceDrawArea, elementToTargetMatrix);
        if (!!this._drawCacheBitmap !== !!this._drawCacheToElementMatrix) {
          throw new Error("expected both or neither: @_drawCacheToElementMatrix, @_drawCacheBitmap");
        }
        if (this._drawCacheBitmap) {
          drawWithCachingOptions.opacity = this.opacity;
          drawWithCachingOptions.compositeMode = this.compositeMode;
          return target.drawBitmap(this._drawCacheToElementMatrix.mul(elementToTargetMatrix), this._drawCacheBitmap, drawWithCachingOptions);
        }
      };

      ElementDrawMixin.prototype._updateDrawCache = function(targetSpaceDrawArea, elementToTargetMatrix) {
        var bitmapAlreadyClear, cacheScale, cacheSpaceDrawArea, clippedElementSpaceDrawArea, d2eMatrix, dirtyAreasToDraw, dirtyDrawArea, drawCacheSpaceDrawArea, elementSpaceDrawArea, i, insideAreas, lastClippingInfo, len, outsideAreas, pixelsPerPoint, ref4, ref5, ref6, remainingDirtyAreas, results, snapTo;
        pixelsPerPoint = (ref4 = (ref5 = this._cacheDraw) != null ? ref5.pixelsPerPoint : void 0) != null ? ref4 : this.getDevicePixelsPerPoint();
        snapTo = 1 / pixelsPerPoint;
        elementSpaceDrawArea = this.getElementSpaceDrawArea().roundOut(snapTo, colorPrecision);
        if (elementSpaceDrawArea.getArea() <= 0) {
          return;
        }
        cacheScale = pixelsPerPoint * (this.getCacheDraw() || this.getStage() ? 1 : elementToTargetMatrix.getExactScaler());
        cacheSpaceDrawArea = elementSpaceDrawArea.mul(cacheScale);
        while (cacheSpaceDrawArea.area >= maxCanvasSize) {
          cacheSpaceDrawArea = elementSpaceDrawArea.mul(cacheScale *= .75);
        }
        cacheSpaceDrawArea = cacheSpaceDrawArea.roundOut(snapTo, colorPrecision);
        d2eMatrix = Matrix.translateXY(-elementSpaceDrawArea.x, -elementSpaceDrawArea.y).scale(cacheScale).inv;
        bitmapAlreadyClear = false;
        if (d2eMatrix.eq(this._drawCacheToElementMatrix) && drawCacheManager.canUseBitmap(this._drawCacheBitmap, cacheSpaceDrawArea)) {
          drawCacheManager.useDrawCache(this);
          this._drawCacheBitmap.clearOutsideArea(cacheSpaceDrawArea.size);
          if (!(this._dirtyDrawAreas || this._redrawAll)) {
            return;
          }
        } else {
          this._clearDrawCache();
          this._drawCacheBitmap = drawCacheManager.allocateCacheBitmap(this, cacheSpaceDrawArea.size);
          bitmapAlreadyClear = true;
          this._dirtyDrawAreas = null;
          this._redrawAll = true;
        }
        this._drawCacheToElementMatrix = d2eMatrix;
        this._elementToDrawCacheMatrix = this._drawCacheToElementMatrix.inv;
        if (!elementToTargetMatrix) {
          thrwo(new Error("why no elementToTargetMatrix?"));
        }
        clippedElementSpaceDrawArea = elementToTargetMatrix.inv.transformBoundingRect(targetSpaceDrawArea).roundOut(snapTo, colorPrecision).intersection(elementSpaceDrawArea);
        remainingDirtyAreas = null;
        dirtyAreasToDraw = this._dirtyDrawAreas;
        if (!clippedElementSpaceDrawArea.contains(elementSpaceDrawArea)) {
          ref6 = partitionAreasByInteresection(clippedElementSpaceDrawArea, dirtyAreasToDraw || [elementSpaceDrawArea]), insideAreas = ref6.insideAreas, outsideAreas = ref6.outsideAreas;
          dirtyAreasToDraw = insideAreas;
          remainingDirtyAreas = outsideAreas;
        }
        this["class"].stats.stagingBitmapsCreated++;
        this["class"].stats.lastStagingBitmapSize = this._drawCacheBitmap.size;
        this._currentDrawTarget = this._drawCacheBitmap;
        this._currentToTargetMatrix = this._elementToDrawCacheMatrix;
        try {
          this["class"]._activeCacheDrawDepth++;
          if (config.partialRedrawEnabled && (this._filterChildren.length === 0) && (dirtyAreasToDraw || remainingDirtyAreas)) {
            if (dirtyAreasToDraw) {
              results = [];
              for (i = 0, len = dirtyAreasToDraw.length; i < len; i++) {
                dirtyDrawArea = dirtyAreasToDraw[i];
                drawCacheSpaceDrawArea = this._elementToDrawCacheMatrix.transformBoundingRect(dirtyDrawArea, true);
                lastClippingInfo = this._drawCacheBitmap.openClipping(drawCacheSpaceDrawArea);
                this._updateCurrentDrawCacheClippedArea(bitmapAlreadyClear, true);
                results.push(this._drawCacheBitmap.closeClipping(lastClippingInfo));
              }
              return results;
            }
          } else {
            globalEpochCycle.logEvent("fullDrawCache", this.uniqueId);
            return this._updateCurrentDrawCacheClippedArea(bitmapAlreadyClear);
          }
        } finally {
          this._redrawAll = false;
          this._dirtyDrawAreas = (remainingDirtyAreas != null ? remainingDirtyAreas.length : void 0) > 0 ? remainingDirtyAreas : null;
          this["class"]._activeCacheDrawDepth--;
        }
      };

      ElementDrawMixin.prototype._updateCurrentDrawCacheClippedArea = function(alreadyClear, alreadyClipped) {
        var hasCustomClipping, targetSpaceDrawArea;
        if (!alreadyClear) {
          this._drawCacheBitmap.clear();
        }
        if (this._clip && (!alreadyClipped || (hasCustomClipping = this.getHasCustomClipping()))) {
          if (!hasCustomClipping) {
            targetSpaceDrawArea = this.drawAreaIn(this._elementToDrawCacheMatrix).intersection(this._drawCacheBitmap.size);
          }
          return this._drawWithClipping(targetSpaceDrawArea, this._drawCacheBitmap, this._elementToDrawCacheMatrix);
        } else {
          return this._drawChildren(this._drawCacheBitmap, this._elementToDrawCacheMatrix, true);
        }
      };

      return ElementDrawMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(220);

module.exports.addModules({
  FlexLayout: __webpack_require__(217),
  FlowLayout: __webpack_require__(218),
  Infinity: __webpack_require__(75),
  LayoutTools: __webpack_require__(76),
  StateEpochLayout: __webpack_require__(219)
});


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Atomic, Canvas, EngineCore, Foundation, GlobalEpochCycle, Matrix, aimColor, currentSecond, defineModule, floor, globalEpochCycle, log, max, min, miniInspect, peek, point, reactColor, rect, rgbColor, timeout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Canvas = __webpack_require__(11);

EngineCore = __webpack_require__(38);

defineModule = Foundation.defineModule, log = Foundation.log, miniInspect = Foundation.miniInspect, currentSecond = Foundation.currentSecond, max = Foundation.max, min = Foundation.min, timeout = Foundation.timeout, peek = Foundation.peek;

point = Atomic.point, rect = Atomic.rect, Matrix = Atomic.Matrix, rgbColor = Atomic.rgbColor;

GlobalEpochCycle = EngineCore.GlobalEpochCycle;

globalEpochCycle = GlobalEpochCycle.globalEpochCycle;

floor = Math.floor;

reactColor = rgbColor("gold");

aimColor = rgbColor("#9c3");

defineModule(module, function() {
  var GlobalEpochStat, GlobalEpochStats;
  GlobalEpochStat = (function(superClass) {
    var statColors, statFields;

    extend(GlobalEpochStat, superClass);

    function GlobalEpochStat(sampleTime1, total1, sampleSet1) {
      this.sampleTime = sampleTime1;
      this.total = total1;
      this.sampleSet = sampleSet1;
    }

    GlobalEpochStat.statFields = statFields = ["total", "draw", "aim", "aimLayout", "aimTL", "aimRR", "react", "reactAim", "reactLC", "reactRender", "event", "flux"];

    GlobalEpochStat.statColors = statColors = {
      total: "gray",
      draw: "#39c",
      aim: aimColor,
      aimLayout: aimColor.withLightness(aimColor.lightness * .9),
      aimTL: aimColor.withLightness(aimColor.lightness * .8),
      aimRR: aimColor.withLightness(aimColor.lightness * .7),
      react: reactColor,
      reactAim: reactColor.withLightness(reactColor.lightness * .9),
      reactLC: reactColor.withLightness(reactColor.lightness * .8),
      reactRender: reactColor.withLightness(reactColor.lightness * .7),
      event: "#ff6347",
      flux: "#d936a3"
    };

    GlobalEpochStat.prototype.getStacked = function(sampleName) {
      var i, sn, sum;
      if (sampleName === "total") {
        return this.total;
      }
      sum = 0;
      for (i = statFields.length - 1; i >= 0; i += -1) {
        sn = statFields[i];
        sum += this.sampleSet[sn] || 0;
        if (sn === sampleName) {
          break;
        }
      }
      return sum;
    };

    GlobalEpochStat.prototype.drawSample = function(bitmap, drawMatrix, sampleWidth, sampleField, h) {
      var sample, sampleTime, x, y;
      sampleTime = this.sampleTime;
      sample = this.getStacked(sampleField);
      x = floor(drawMatrix.transformX(sampleTime, sample));
      y = floor(drawMatrix.transformY(sampleTime, sample));
      return bitmap.drawRectangle(null, rect(x, y, sampleWidth, h - y), {
        color: statColors[sampleField]
      });
    };

    return GlobalEpochStat;

  })(Foundation.BaseClass);
  return GlobalEpochStats = (function(superClass) {
    extend(GlobalEpochStats, superClass);

    GlobalEpochStats.classGetter({
      enabled: function() {
        return !!globalEpochCycle.globalEpochStats;
      }
    });

    GlobalEpochStats.enable = function() {
      log("Enabled globalEpochStats");
      globalEpochCycle.globalEpochStats = new this;
      return true;
    };

    GlobalEpochStats.toggle = function() {
      if (this.enabled) {
        return this.disable();
      } else {
        return this.enable();
      }
    };

    GlobalEpochStats.disable = function() {
      log("Disabled globalEpochStats");
      globalEpochCycle.globalEpochStats = null;
      return false;
    };

    function GlobalEpochStats() {
      this.reset();
    }

    GlobalEpochStats.prototype.reset = function() {
      this.maxMs = 2 / 60;
      this.stats = [];
      this.nextEventIdIndex = 0;
      this.eventsById = {};
      this.eventLegend = {};
      this._minSampleTime = null;
      return this._maxSampleTime = null;
    };

    GlobalEpochStats.prototype.add = function(sampleTime, total, sampleSet) {
      var ges;
      this.stats.push(ges = new GlobalEpochStat(sampleTime, total, sampleSet));
      this.maxMs = max(this.maxMs, total * 1.5);
      this.logAndResetWhenIdle();
      return this.addSampleTime(sampleTime);
    };

    GlobalEpochStats.prototype.addSampleTime = function(time) {
      this._minSampleTime = min(time, this._minSampleTime || time);
      return this._maxSampleTime = max(time, this._maxSampleTime || time);
    };

    GlobalEpochStats.prototype.logEvent = function(name, id) {
      var base, clr, colors, ebi, now;
      now = currentSecond();
      this.addSampleTime(now);
      colors = {
        generateDrawCache: "green",
        animation: "#77f",
        animationAborted: "#f77",
        animationDone: "#77f",
        "default": "gray"
      };
      clr = colors[name] || colors["default"];
      ebi = (base = this.eventsById)[id] || (base[id] = {
        startTime: now,
        endTime: now,
        index: this.nextEventIdIndex++,
        events: [],
        name: name,
        clr: clr
      });
      ebi.startTime = min(now, ebi.startTime);
      ebi.endTime = max(now, ebi.endTime);
      this.eventLegend[name] = clr;
      return ebi.events.push({
        time: now,
        name: name,
        clr: clr
      });
    };

    GlobalEpochStats.getter({
      minSampleTime: function() {
        return this._minSampleTime;
      },
      maxSampleTime: function() {
        return this._maxSampleTime;
      },
      sampleTimeRange: function() {
        return this.maxSampleTime - this.minSampleTime;
      }
    });

    GlobalEpochStats.prototype.drawAllSamplesForOneField = function(bitmap, drawMatrix, sampleField) {
      var h, i, len, ref, sampleTimeRange, sampleWidth, size, stat, stats, w;
      size = bitmap.size;
      w = size.w, h = size.h;
      ref = this, sampleTimeRange = ref.sampleTimeRange, stats = ref.stats;
      sampleWidth = floor((w / sampleTimeRange) / 60);
      for (i = 0, len = stats.length; i < len; i++) {
        stat = stats[i];
        stat.drawSample(bitmap, drawMatrix, sampleWidth, sampleField, h);
      }
      return null;
    };

    GlobalEpochStats.prototype.getDrawMatrix = function(size) {
      var h, legendWidth, maxMs, minSampleTime, ref, sampleTimeRange, sampleWidth, w, xScale, yScale;
      w = size.w, h = size.h;
      legendWidth = 80;
      w -= legendWidth;
      ref = this, sampleTimeRange = ref.sampleTimeRange, minSampleTime = ref.minSampleTime, maxMs = ref.maxMs;
      sampleWidth = floor((w / sampleTimeRange) / 60);
      xScale = (w - sampleWidth) / sampleTimeRange;
      yScale = h / maxMs;
      return Matrix.scaleXY(1, -1).translateXY(-minSampleTime, 0).scaleXY(xScale, yScale).translateXY(legendWidth, h);
    };

    GlobalEpochStats.prototype.drawLabeledHLine = function(bitmap, x1, x2, y, clr, label) {
      bitmap.drawRectangle(null, rect(x1, y, x2 - x1, 1), {
        color: rgbColor(clr)
      });
      return bitmap.drawText(point(x1, y - 5), label, {
        size: 14,
        color: rgbColor(clr)
      });
    };

    GlobalEpochStats.prototype.drawEvents = function(bitmap, drawMatrix) {
      var clr, endTime, eventTimeLineHeight, events, h, id, index, name, ref, ref1, ref2, results, startTime, time, w, x, x1, x2, y;
      ref = bitmap.size, w = ref.w, h = ref.h;
      eventTimeLineHeight = floor(h / 20);
      ref1 = this.eventsById;
      results = [];
      for (id in ref1) {
        ref2 = ref1[id], index = ref2.index, startTime = ref2.startTime, endTime = ref2.endTime, clr = ref2.clr, events = ref2.events, name = ref2.name;
        x1 = floor(drawMatrix.transformX(startTime, 0));
        x2 = floor(drawMatrix.transformX(endTime, 0));
        y = (index + 1) * eventTimeLineHeight;
        this.drawLabeledHLine(bitmap, x1, x2, y, clr, name);
        results.push((function() {
          var i, len, ref3, results1;
          results1 = [];
          for (i = 0, len = events.length; i < len; i++) {
            ref3 = events[i], time = ref3.time, name = ref3.name, clr = ref3.clr;
            x = floor(drawMatrix.transformX(time, 0));
            results1.push(bitmap.drawRectangle(null, rect(x, y, 1, eventTimeLineHeight * (1 / 3)), {
              color: clr
            }));
          }
          return results1;
        })());
      }
      return results;
    };

    GlobalEpochStats.prototype.log = function() {
      var averageFps, averageFrameTimeMs, averageFrameTimeMsY, bitmap, ce, clr, drawMatrix, field, fiveMsY, h, i, j, legend, len, len1, missedFrames, perfectFrameCount, ref, ref1, ref2, sampleField, size, tenMsY, totalFrames, w, y;
      if (!(this.stats.length > 0)) {
        return;
      }
      !((ref = Neptune.Art.Foundation.DevTools.DomConsole) != null ? ref.enabled : void 0) && (ce = GlobalEpochCycle.activeCanvasElements[0]);
      bitmap = new Canvas.Bitmap(size = ce ? ce.canvasBitmap.size : point(1000, 600));
      w = size.w, h = size.h;
      bitmap.clear("#fff");
      drawMatrix = this.getDrawMatrix(size);
      y = floor(drawMatrix.transformY(0, 1 / 60));
      tenMsY = floor(drawMatrix.transformY(0, 1 / 100));
      fiveMsY = floor(drawMatrix.transformY(0, 1 / 200));
      bitmap.drawRectangle(null, rect(0, y, w, 1), {
        color: "#0007"
      });
      ref1 = GlobalEpochStat.statFields;
      for (i = 0, len = ref1.length; i < len; i++) {
        sampleField = ref1[i];
        this.drawAllSamplesForOneField(bitmap, drawMatrix, sampleField);
      }
      legend = {};
      this.drawLabeledHLine(bitmap, 40, w, tenMsY, "#0007", "10ms");
      this.drawLabeledHLine(bitmap, 40, w, fiveMsY, "#0007", "5ms");
      this.drawEvents(bitmap, drawMatrix);
      totalFrames = this.stats.length;
      averageFrameTimeMs = this.sampleTimeRange / totalFrames;
      perfectFrameCount = this.sampleTimeRange * 60 + .5 | 0;
      missedFrames = perfectFrameCount - totalFrames;
      averageFrameTimeMsY = floor(drawMatrix.transformY(0, averageFrameTimeMs));
      if ((averageFps = 1 / averageFrameTimeMs + .5 | 0) < 55) {
        this.drawLabeledHLine(bitmap, 40, w, y, "#0007", "60fps - 16.7ms");
      }
      this.drawLabeledHLine(bitmap, 40, w, averageFrameTimeMsY, "#0007", "average: " + averageFps + "fps (miss-rate: " + ((100 * missedFrames / perfectFrameCount).toPrecision(2)) + "% " + missedFrames + "/" + perfectFrameCount + ")");
      y = 0;
      ref2 = GlobalEpochStat.statFields;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        field = ref2[j];
        clr = GlobalEpochStat.statColors[field];
        bitmap.drawRectangle(null, rect(0, y, 75, 23), {
          color: clr
        });
        bitmap.drawText(point(5, y + 18), field, {
          size: 16,
          color: rgbColor("white")
        });
        y += 25;
      }
      bitmap.drawBorder(null, bitmap.size, "#eee");
      if (ce) {
        log("showing GlobalEpochStats");
        return ce.canvasBitmap.drawBitmap(null, bitmap, {
          opacity: .9
        });
      } else {
        return log(bitmap);
      }
    };

    GlobalEpochStats.prototype.logAndResetWhenIdle = function() {
      var samples;
      samples = this.stats.length;
      if (samples > 0) {
        return timeout(1000, (function(_this) {
          return function() {
            if (samples === _this.stats.length && GlobalEpochStats.enabled) {
              _this.log();
              return _this.reset();
            }
          };
        })(this));
      }
    };

    return GlobalEpochStats;

  })(Foundation.BaseClass);
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(224);

module.exports.addModules({
  GlobalEpochStats: __webpack_require__(416)
});


/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = [__webpack_require__(229), __webpack_require__(225), __webpack_require__(231), __webpack_require__(227)];


/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Atomic, BlurElement, FilterElement, Foundation, defineModule,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

FilterElement = __webpack_require__(122);

defineModule = Foundation.defineModule;

defineModule(module, BlurElement = (function(superClass) {
  extend(BlurElement, superClass);

  function BlurElement() {
    return BlurElement.__super__.constructor.apply(this, arguments);
  }

  BlurElement.prototype.defaultRadius = 10;

  BlurElement.prototype.defaultCompositeMode = "replace";

  BlurElement.prototype.filter = function(elementSpaceTarget, scale) {
    return elementSpaceTarget.blur(this.radius * scale);
  };

  return BlurElement;

})(FilterElement));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var FilterElement, ShadowElement, defineModule, log, merge, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, merge = ref.merge;

FilterElement = __webpack_require__(122);

defineModule(module, ShadowElement = (function(superClass) {
  extend(ShadowElement, superClass);

  function ShadowElement() {
    return ShadowElement.__super__.constructor.apply(this, arguments);
  }

  ShadowElement.prototype.defaultCompositeMode = "destOver";

  ShadowElement.drawProperty({
    inverted: {
      "default": false
    }
  });

  ShadowElement.prototype.filter = function(elementSpaceTarget, scale, elementToFilterScratchMatrix, options) {
    elementSpaceTarget.blurAlpha(this._radius * scale, {
      inverted: this.inverted
    });
    options = merge(options, {
      compositeMode: "targetAlphaMask",
      opacity: 1
    });
    if (options.from) {
      options.from = elementToFilterScratchMatrix.transform(options.from);
    }
    if (options.to) {
      options.to = elementToFilterScratchMatrix.transform(options.to);
    }
    return elementSpaceTarget.drawRectangle(null, elementSpaceTarget.size, options);
  };


  /*
  NOTES
    Okay, we have two options:
  
    a) we override fillShape here:
      we render to a stagingBitmap in element-space, but with borders expanded sufficiently
      Then we have to "fill" those borders with @_color after the filtered data has been provided.
  
    b) we hook it into the filter processes itself and pre-enlarge the filter-source bitmap to be large enough
      to include the extra pixels we need. This means more filter work which isn't necessary.
   */

  return ShadowElement;

})(FilterElement));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, Canvas, FillElement, Foundation, GradientFillStyle, ShadowableElement, createWithPostCreate, log,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Canvas = __webpack_require__(11);

ShadowableElement = __webpack_require__(29);

log = Foundation.log, createWithPostCreate = Foundation.createWithPostCreate;

GradientFillStyle = Canvas.GradientFillStyle;

module.exports = createWithPostCreate(FillElement = (function(superClass) {
  var _drawOptionsTemp;

  extend(FillElement, superClass);

  function FillElement() {
    return FillElement.__super__.constructor.apply(this, arguments);
  }

  FillElement.virtualProperty({
    preFilteredBaseDrawArea: function(pending) {
      return this.getParent(pending).getPreFilteredBaseDrawArea(pending);
    }
  });

  FillElement.prototype.getNormalizedShadow = function(pending) {
    var ref;
    if (this.getShadow(pending)) {
      return FillElement.__super__.getNormalizedShadow.apply(this, arguments);
    } else {
      return (ref = this.getParent(pending)) != null ? ref.getNormalizedShadow(pending) : void 0;
    }
  };


  /*
  NOTE:
  
  _prepareDrawOptions replaces values, even with null ones.
  Hence, we prepare two separate draw optons and the merge them.
   */

  _drawOptionsTemp = {};

  FillElement.prototype.drawBasic = function(target, elementToTargetMatrix, compositeMode, opacity) {
    var base, k, v;
    if (typeof (base = this._parent)._prepareDrawOptions === "function") {
      base._prepareDrawOptions(this._drawOptions, compositeMode, opacity);
    }
    this._prepareDrawOptions(_drawOptionsTemp, compositeMode, opacity);
    for (k in _drawOptionsTemp) {
      v = _drawOptionsTemp[k];
      if (v) {
        this._drawOptions[k] = v;
      }
    }
    return this._parent.fillShape(target, elementToTargetMatrix, this._drawOptions);
  };

  return FillElement;

})(ShadowableElement));


/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, Color, Foundation, Matrix, OutlineElement, Point, Rectangle, ShadowableElement, color, createWithPostCreate, isPlainArray, log, matrix, merge, point, rect,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

ShadowableElement = __webpack_require__(29);

merge = Foundation.merge, createWithPostCreate = Foundation.createWithPostCreate, log = Foundation.log, isPlainArray = Foundation.isPlainArray;

color = Atomic.color, Color = Atomic.Color, point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix;

module.exports = createWithPostCreate(OutlineElement = (function(superClass) {
  var validLineCaps, validLineJoins;

  extend(OutlineElement, superClass);

  function OutlineElement() {
    return OutlineElement.__super__.constructor.apply(this, arguments);
  }

  validLineCaps = ["butt", "round", "square"];

  validLineJoins = ["round", "bevel", "miter"];

  OutlineElement.drawAreaProperty({
    lineWidth: {
      "default": 1,
      validate: function(v) {
        return typeof v === "number";
      }
    },
    lineJoin: {
      "default": "miter",
      validate: function(v) {
        return indexOf.call(validLineJoins, v) >= 0;
      }
    },
    miterLimit: {
      "default": 3,
      validate: function(v) {
        return !v || typeof v === "number";
      },
      preprocess: function(v) {
        if (v != null) {
          return v;
        } else {
          return 3;
        }
      }
    }
  });

  OutlineElement.drawProperty({
    lineCap: {
      "default": "butt",
      validate: function(v) {
        return indexOf.call(validLineCaps, v) >= 0;
      }
    },
    lineDash: {
      "default": null,
      validate: function(v) {
        return !v || isPlainArray(v);
      }
    },
    filled: {
      "default": false
    }
  });

  OutlineElement.virtualProperty({
    drawAreaPadding: function(pending) {
      var _lineJoin, _lineWidth, _miterLimit, ref;
      ref = this.getState(pending), _lineWidth = ref._lineWidth, _lineJoin = ref._lineJoin, _miterLimit = ref._miterLimit;
      return _lineWidth * (_lineJoin === "miter" ? _miterLimit / 2 : .5);
    }
  });

  OutlineElement.prototype.getPreFilteredBaseDrawArea = function(pending) {
    return OutlineElement.__super__.getPreFilteredBaseDrawArea.apply(this, arguments).grow(this.getDrawAreaPadding(pending));
  };

  OutlineElement.getter({
    cacheable: function() {
      return this.getHasChildren();
    }
  });

  OutlineElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
    if (this._filled) {
      this._parent.fillShape(target, elementToTargetMatrix, options);
    }
    return this._parent.strokeShape(target, elementToTargetMatrix, options);
  };

  OutlineElement.prototype._prepareDrawOptions = function(drawOptions, compositeMode, opacity) {
    OutlineElement.__super__._prepareDrawOptions.apply(this, arguments);
    drawOptions.lineWidth = this._lineWidth;
    drawOptions.lineCap = this._lineCap;
    drawOptions.lineJoin = this._lineJoin;
    drawOptions.lineDash = this._lineDash;
    return drawOptions.miterLimit = this._miterLimit;
  };

  return OutlineElement;

})(ShadowableElement));


/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseClass, Bitmap, BitmapBase, BitmapElement, Matrix, Promise, ShadowableElement, bound, ceil, createWithPostCreate, defineModule, inspect, isImage, isNumber, isPlainArray, isString, log, max, min, point, point0, point1, rect, ref, ref1, ref2, round, timeout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ceil = Math.ceil, round = Math.round;

ref = __webpack_require__(1), defineModule = ref.defineModule, inspect = ref.inspect, min = ref.min, max = ref.max, bound = ref.bound, log = ref.log, createWithPostCreate = ref.createWithPostCreate, isString = ref.isString, isNumber = ref.isNumber, isPlainArray = ref.isPlainArray, timeout = ref.timeout, Promise = ref.Promise;

BaseClass = __webpack_require__(6).BaseClass;

ref1 = __webpack_require__(4), point = ref1.point, rect = ref1.rect, Matrix = ref1.Matrix, point0 = ref1.point0, point1 = ref1.point1;

ref2 = __webpack_require__(11), isImage = ref2.isImage, Bitmap = ref2.Bitmap, BitmapBase = ref2.BitmapBase;

ShadowableElement = __webpack_require__(29);

defineModule(module, BitmapElement = (function(superClass) {
  var halfPoint, sourceToBitmapCache;

  extend(BitmapElement, superClass);

  BitmapElement.SourceToBitmapCache = (function(superClass1) {
    extend(SourceToBitmapCache, superClass1);

    SourceToBitmapCache.singletonClass();

    function SourceToBitmapCache() {
      this._cache = {};
      this._referenceCounts = {};
      this._loaded = {};
    }

    SourceToBitmapCache.prototype.get = function(url, initializerPromise) {
      var base, out;
      if (!isString(url)) {
        return Bitmap.get(url);
      }
      this._referenceCounts[url] = (this._referenceCounts[url] || 0) + 1;
      out = (base = this._cache)[url] || (base[url] = initializerPromise || Bitmap.get(url));
      out.then((function(_this) {
        return function(bitmap) {
          return _this._loaded[url] = bitmap;
        };
      })(this));
      return out;
    };

    SourceToBitmapCache.prototype.loaded = function(url) {
      return this._loaded[url];
    };

    SourceToBitmapCache.prototype.temporaryPut = function(duration, url, bitmap) {
      this.get(url, Promise.resolve(bitmap));
      return timeout(duration, (function(_this) {
        return function() {
          return _this.release(url);
        };
      })(this));
    };

    SourceToBitmapCache.prototype.release = function(url) {
      if (!isString(url)) {
        return;
      }
      if (!isNumber(this._referenceCounts[url])) {
        throw new Error("no references for " + url);
      }
      if (this._referenceCounts[url] === 0 || !isNumber(this._referenceCounts[url])) {
        return console.error("invalid referenceCount: " + (inspect(this._referenceCounts[url])) + " for url: " + url);
      }
      this._referenceCounts[url]--;
      if (this._referenceCounts[url] === 0) {
        delete this._cache[url];
        delete this._loaded[url];
        return true;
      } else {
        return false;
      }
    };

    return SourceToBitmapCache;

  })(BaseClass);

  BitmapElement.bitmapCache = sourceToBitmapCache = BitmapElement.SourceToBitmapCache.singleton;

  function BitmapElement(options) {
    BitmapElement.__super__.constructor.apply(this, arguments);
    this._bitmapToElementMatrix = new Matrix;
  }

  BitmapElement.prototype._unregister = function() {
    sourceToBitmapCache.release(this.getSource());
    return BitmapElement.__super__._unregister.apply(this, arguments);
  };

  BitmapElement.getter({
    cacheable: function() {
      return false;
    }
  });

  BitmapElement.prototype.nonChildrenLayoutFirstPass = function() {
    var ref3;
    return ((ref3 = this.getPendingBitmap()) != null ? ref3.pointSize : void 0) || point0;
  };

  halfPoint = point(.5);

  BitmapElement.drawProperty({
    focus: {
      "default": halfPoint,
      preprocess: function(v) {
        if (v != null) {
          return point(v).bound(point0, point1);
        } else {
          return halfPoint;
        }
      }
    },
    layout: {
      "default": "stretch",
      preprocess: function(v) {
        return (v != null ? v.toString() : void 0) || null;
      }
    },
    sourceArea: {
      "default": null,
      preprocess: function(v) {
        if (v != null) {
          return rect(v);
        } else {
          return null;
        }
      }
    },
    aspectRatio: {
      "default": null,
      validate: function(v) {
        return (v == null) || isNumber(v);
      }
    }
  });

  BitmapElement.drawLayoutProperty({
    bitmap: {
      "default": null,
      validate: function(v) {
        return !v || v instanceof BitmapBase;
      }
    }
  });

  BitmapElement.virtualProperty({
    mode: {
      setter: function(mode) {
        log.error("DEPRICATED BitmapElement property 'mode' is now 'layout'");
        return this.setLayout(mode);
      }
    }
  });

  BitmapElement.concreteProperty({

    /*
    source-property:
      will fetch a bitmap from the specified URL
      will trigger the following events: 'load' and 'error'
      will set the @bitmap property on success
      if 'source' changes
        will load the new URL
        will trigger another 'load' or 'error'
      if altSources are specified
        the first altSource which is ALREADY LOADED
        will be displayed until 'source' can be loaded.
     */
    source: {
      "default": null,
      validate: function(v) {
        return !v || (isImage(v)) || (isString(v));
      },
      postSetter: function(v) {
        return v && this._loadBitmapFromSource(v);
      }
    },

    /*
    altSources is an array of URLs/cache-names
    
    When drawing, if 'bitmap' is not set, the first altSource which is
    already loaded in the cache will be display.
     */
    altSources: {
      "default": null,
      validate: function(v) {
        return !v || isPlainArray(v);
      }
    }
  });

  BitmapElement.prototype._loadBitmapFromSource = function(source) {
    return sourceToBitmapCache.get(source).then((function(_this) {
      return function(bitmap) {
        _this.onNextReady(function() {
          return _this.queueEvent("load", function() {
            return {
              bitmap: bitmap
            };
          });
        });
        return _this.setBitmap(bitmap);
      };
    })(this), (function(_this) {
      return function(error) {
        console.error({
          BitmapElement: {
            _loadBitmapFromSource: {
              error: error
            }
          }
        });
        return _this.onNextReady(function() {
          return _this.queueEvent("error", function() {
            return {
              error: e
            };
          });
        });
      };
    })(this));
  };

  BitmapElement.getter({
    currentBitmap: function() {
      var i, len, loaded, ref3, url;
      if (this._bitmap) {
        return this._bitmap;
      }
      if (this._altSources) {
        ref3 = this._altSources;
        for (i = 0, len = ref3.length; i < len; i++) {
          url = ref3[i];
          if (loaded = sourceToBitmapCache.loaded(url)) {
            return loaded;
          }
        }
      }
    }
  });

  BitmapElement.prototype._prepareDrawOptions = function(drawOptions, compositeMode, opacity) {
    BitmapElement.__super__._prepareDrawOptions.apply(this, arguments);
    drawOptions.focus = this._focus;
    drawOptions.layout = this.getLayout();
    drawOptions.targetSize = this.getSizeForChildren();
    return drawOptions.aspectRatio = this.getAspectRatio();
  };

  BitmapElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
    return target.drawBitmapWithLayout(elementToTargetMatrix, this.getCurrentBitmap(), options);
  };

  return BitmapElement;

})(ShadowableElement));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var AtomElement, Atomic, Paths, RectangleElement, ShadowableElement, Text, defineModule, floatEq, isNumber, isPlainObject, log, pureMerge, rectanglePath, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Atomic = __webpack_require__(4);

Text = __webpack_require__(153);

ShadowableElement = __webpack_require__(29);

Paths = __webpack_require__(11).Paths;

ref = __webpack_require__(1), pureMerge = ref.pureMerge, floatEq = ref.floatEq, log = ref.log, AtomElement = ref.AtomElement, defineModule = ref.defineModule, isPlainObject = ref.isPlainObject, isNumber = ref.isNumber;

rectanglePath = Paths.rectanglePath;

defineModule(module, RectangleElement = (function(superClass) {
  var clipOptions;

  extend(RectangleElement, superClass);

  function RectangleElement() {
    return RectangleElement.__super__.constructor.apply(this, arguments);
  }

  RectangleElement.drawProperty({
    radius: {
      "default": 0,
      validate: function(v) {
        return !v || isNumber(v) || isPlainObject(v);
      },
      preprocess: function(v) {
        return v || 0;
      }
    }
  });

  RectangleElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
    options.radius = this._radius;
    options.color || (options.color = this._color);
    return target.drawRectangle(elementToTargetMatrix, this.getPaddedArea(), options);
  };

  RectangleElement.prototype.strokeShape = function(target, elementToTargetMatrix, options) {
    options.radius = this._radius;
    options.color || (options.color = this._color);
    return target.strokeRectangle(elementToTargetMatrix, this.getPaddedArea(), options);
  };

  clipOptions = {
    radius: 0
  };

  RectangleElement.prototype._drawWithClipping = function(clipArea, target, elementToTargetMatrix) {
    var lastClippingInfo;
    if (floatEq(this._radius, 0)) {
      return RectangleElement.__super__._drawWithClipping.apply(this, arguments);
    } else {
      clipOptions.radius = this._radius;
      lastClippingInfo = target.openClipping(rectanglePath, elementToTargetMatrix, this.paddedArea, clipOptions);
      this._drawChildren(target, elementToTargetMatrix);
      return target.closeClipping(lastClippingInfo);
    }
  };

  RectangleElement.getter({
    hasCustomClipping: function() {
      return this._radius > 0;
    }
  });

  return RectangleElement;

})(ShadowableElement));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, Foundation, ShadowableElement, ShapeElement, Text, createWithPostCreate, isFunction, pureMerge,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Text = __webpack_require__(153);

ShadowableElement = __webpack_require__(29);

pureMerge = Foundation.pureMerge, isFunction = Foundation.isFunction, createWithPostCreate = Foundation.createWithPostCreate;

module.exports = createWithPostCreate(ShapeElement = (function(superClass) {
  extend(ShapeElement, superClass);

  function ShapeElement() {
    ShapeElement.__super__.constructor.apply(this, arguments);
    this._lastPathFunction = null;
    this._curriedPathFunction = null;
  }

  ShapeElement.drawProperty({
    fillRule: {
      "default": "nonzero",
      validate: function(r) {
        return r === "nonzero" || r === "evenodd";
      }
    },
    path: {
      "default": function(context, size) {
        var h, w;
        w = size.w, h = size.h;
        context.beginPath();
        context.moveTo(0, 0);
        context.lineTo(0, h);
        context.lineTo(w, h);
        context.lineTo(w, 0);
        context.lineTo(0, 0);
        return context.closePath();
      },
      validate: function(f) {
        return isFunction(f);
      }
    }
  });

  ShapeElement.prototype.drawBasic = function(target, elementToTargetMatrix, compositeMode, opacity) {
    this._prepareDrawOptions(this._drawOptions, compositeMode, opacity);
    return this.fillShape(target, elementToTargetMatrix, this._drawOptions);
  };

  ShapeElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
    options.color || (options.color = this._color);
    options.fillRule = this._fillRule;
    return target.fillShape(elementToTargetMatrix, options, this._path, this.paddedSize);
  };

  ShapeElement.prototype.strokeShape = function(target, elementToTargetMatrix, options) {
    options.color || (options.color = this._color);
    return target.strokeShape(elementToTargetMatrix, options, this._path, paddedSize);
  };

  return ShapeElement;

})(ShadowableElement));


/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, BaseClass, Foundation, GlobalEpochCycle, ShadowableElement, Text, TextElement, createWithPostCreate, globalEpochCycle, isNumber, isPlainArray, isString, log, merge, normalizeFontOptions, point, propInternalName, propSetterName, pureMerge, rect, shallowClone,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Text = __webpack_require__(153);

ShadowableElement = __webpack_require__(29);

GlobalEpochCycle = __webpack_require__(26);

log = Foundation.log, BaseClass = Foundation.BaseClass, shallowClone = Foundation.shallowClone, pureMerge = Foundation.pureMerge, merge = Foundation.merge, createWithPostCreate = Foundation.createWithPostCreate, isPlainArray = Foundation.isPlainArray, isString = Foundation.isString, isNumber = Foundation.isNumber;

point = Atomic.point, rect = Atomic.rect;

normalizeFontOptions = Text.Metrics.normalizeFontOptions;

globalEpochCycle = GlobalEpochCycle.globalEpochCycle;

propInternalName = BaseClass.propInternalName;

propSetterName = BaseClass._propSetterName;

module.exports = createWithPostCreate(TextElement = (function(superClass) {
  extend(TextElement, superClass);

  function TextElement() {
    TextElement.__super__.constructor.apply(this, arguments);
    this._textLayout = null;
  }

  TextElement.getter({
    cacheable: function() {
      return true;
    }
  });

  TextElement.drawLayoutProperty({
    fontSize: {
      "default": 16,
      validate: function(v) {
        return isNumber(v);
      }
    },
    fontFamily: {
      "default": "Times",
      validate: function(v) {
        return isString(v);
      }
    },
    fontStyle: {
      "default": "normal",
      validate: function(v) {
        return isString(v);
      }
    },
    fontVariant: {
      "default": "normal",
      validate: function(v) {
        return isString(v);
      }
    },
    fontWeight: {
      "default": "normal",
      validate: function(v) {
        return isString(v);
      }
    },
    align: {
      "default": 0,
      preprocess: function(v) {
        return point(v);
      }
    },
    layoutMode: {
      "default": "textualBaseline",
      validate: function(v) {
        return isString(v);
      }
    },
    leading: {
      "default": 1.25,
      validate: function(v) {
        return isNumber(v);
      }
    },
    paragraphLeading: {
      "default": null,
      validate: function(v) {
        return v === null || isNumber(v);
      }
    },
    maxLines: {
      "default": null,
      validate: function(v) {
        return (v == null) || isNumber(v);
      }
    },
    overflow: {
      "default": "ellipsis",
      validate: function(v) {
        return isString(v);
      }
    },
    text: {
      "default": Text.Layout.defaultText,
      preprocess: function(t) {
        if (isPlainArray(t)) {
          return t.join("\n");
        } else {
          return "" + t;
        }
      }
    }
  });

  TextElement.virtualProperty({
    font: {
      getter: function(pending) {
        var _fontFamily, _fontSize, _fontStyle, _fontVariant, _fontWeight, ref;
        ref = this.getState(pending), _fontFamily = ref._fontFamily, _fontSize = ref._fontSize, _fontStyle = ref._fontStyle, _fontVariant = ref._fontVariant, _fontWeight = ref._fontWeight;
        return {
          fontFamily: _fontFamily,
          fontSize: _fontSize,
          fontStyle: _fontStyle,
          fontVariant: _fontVariant,
          fontWeight: _fontWeight
        };
      }
    },
    format: {
      getter: function(pending) {
        var _align, _layoutMode, _leading, _maxLines, _overflow, _paragraphLeading, ref;
        ref = this.getState(pending), _align = ref._align, _layoutMode = ref._layoutMode, _paragraphLeading = ref._paragraphLeading, _leading = ref._leading, _maxLines = ref._maxLines, _overflow = ref._overflow;
        return {
          align: _align,
          layoutMode: _layoutMode,
          leading: _leading,
          paragraphLeading: _paragraphLeading,
          maxLines: _maxLines,
          overflow: _overflow
        };
      }
    }
  });

  TextElement.virtualProperty({
    preFilteredBaseDrawArea: function(pending) {
      var ref;
      return ((ref = this._textLayout) != null ? ref.getDrawArea() : void 0) || ShadowableElement.preFilteredBaseDrawArea.call(this, pending);
    }
  });

  TextElement.prototype.nonChildrenLayoutFirstPass = function(constrainedSize, unconstrainedSize) {
    var ret, start;
    ret = null;
    start = globalEpochCycle.startTimePerformance();
    this._textLayout = new Text.Layout(this.getPendingText(), this.getPendingFont(), this.getPendingFormat(), unconstrainedSize.x, unconstrainedSize.y);
    ret = this._textLayout.getSize();
    globalEpochCycle.endTimePerformance(start, "aimTL");
    return ret;
  };

  TextElement.prototype.nonChildrenLayoutFinalPass = function(size) {
    this._textLayout.setWidth(size.x);
    return this._textLayout.size;
  };

  TextElement.prototype.fillShape = function(target, elementToTargetMatrix, options) {
    return this._textLayout.draw(target, elementToTargetMatrix, pureMerge(options, {
      layoutSize: this.getCurrentSize(),
      color: (options != null ? options.color : void 0) || this._color
    }));
  };

  TextElement.prototype.strokeShape = function(target, elementToTargetMatrix, options) {
    return this._textLayout.stroke(target, elementToTargetMatrix, pureMerge(options, {
      layoutSize: this.getCurrentSize(),
      color: (options != null ? options.color : void 0) || this._color
    }));
  };

  return TextElement;

})(ShadowableElement));


/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var AnimatorSupport, Atomic, BaseClass, Element, EventEpoch, Foundation, GestureRecognizer, Matrix, PagingScrollElement, Point, Rectangle, ScrollAnimator, abs, absGt, absGte, absLt, absLte, animatorSpringConstant, animatorSpringFriction, bound, brakingFactor, ceil, createGestureRecognizer, createWithPostCreate, crossScrollProperties, currentSecond, defineModule, eventEpoch, first, flickSpeedMultiplier, inspect, isPlainArray, isPoint, last, log, matrix, max, maxChange, maxMagnitude, merge, min, minMagnitude, minimumFlickVelocity, peek, point, point0, pointNearInfinity, rect, requestAnimationFrame, round, scrollProperties, timeout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

EventEpoch = __webpack_require__(14).EventEpoch;

Element = __webpack_require__(36);

GestureRecognizer = __webpack_require__(123);

log = Foundation.log, inspect = Foundation.inspect, currentSecond = Foundation.currentSecond, bound = Foundation.bound, round = Foundation.round, first = Foundation.first, last = Foundation.last, peek = Foundation.peek, min = Foundation.min, max = Foundation.max, abs = Foundation.abs, merge = Foundation.merge, createWithPostCreate = Foundation.createWithPostCreate, BaseClass = Foundation.BaseClass, timeout = Foundation.timeout, ceil = Foundation.ceil, round = Foundation.round, isPlainArray = Foundation.isPlainArray, absLt = Foundation.absLt, absLte = Foundation.absLte, absGt = Foundation.absGt, absGte = Foundation.absGte, minMagnitude = Foundation.minMagnitude, maxMagnitude = Foundation.maxMagnitude, maxChange = Foundation.maxChange, absLt = Foundation.absLt, requestAnimationFrame = Foundation.requestAnimationFrame, defineModule = Foundation.defineModule;

point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix, isPoint = Atomic.isPoint;

point0 = Point.point0, pointNearInfinity = Point.pointNearInfinity;

eventEpoch = EventEpoch.eventEpoch;

createGestureRecognizer = GestureRecognizer.createGestureRecognizer;

scrollProperties = {
  vertical: "y",
  horizontal: "x"
};

crossScrollProperties = {
  vertical: "x",
  horizontal: "y"
};

brakingFactor = 3;

minimumFlickVelocity = 300;

animatorSpringConstant = 300;

animatorSpringFriction = 25;

flickSpeedMultiplier = 1;


/*
TODO: Pages should be able to have margins!
  But we have a big problem. Pages are split across two parents and the two parents
  can't inherit the children's margins.

I'm more and more thinking I want a fully custom ArtEngine layout for PSE.
It would make a lot of things simpler to understand...
 */


/*
PagingScrollElement

guarantee:
  Will never scroll more than one "windowSize" per frame.
  That means you need at least as many "pages" as it will take to display one more window-full of content
  above or below the current displayed content.

margins:
  Margins on paging elements are currently not supported.
  We could relatively easilly support constant margins.
  Anything more complex gets a little tedious.
  Recomendation: Use Padding instead of Margins.

events:
  currentPageChanged:
    oldCurrentPage: element
    currentPage:    element
  scrollUpdate:
    currentPage:          element           - @currentPage
    currentGeometry:      plain object      - @currentGeometry
    pagesBeforeBaseline:  array of elements - @pagesBeforeBaseline
    pagesAfterBaseline:   array of elements - @pagesAfterBaseline

naming:

  All "positions" are scalers.
  All "positions" are relative to the top/left of the PagingScrollElement.
  Positive values indicate more to the bottom/right of the PagingScrollElement.

  "scrollPosition" is the main geometry value for the PagingScrollElement.

  I chose "scrollPosition" over just "position" or "location".
  location vs position: http://www.eng-tips.com/viewthread.cfm?qid=180516
    position can be used to refer to internal configuration, which scrollPosition is,
    but location cannot. This avoids confusion with Element's currentLocations.

Implementation Notes:

  When to use "pending" property values:
    - use pending values only as inputs to computation that results in setting another property
    - use current (non-pending) poperty values for all getters
 */


/*
ScrollAnimator

scrollElement api:
  @getter
    minScrollPosition:
    maxScrollPosition:
    scrollPosition:

  @setter
    scrollPosition: (scrollPosition) ->

onIdle is called when all animations and gestures have stopped.
 */

ScrollAnimator = (function(superClass1) {
  var frameCount, missCount;

  extend(ScrollAnimator, superClass1);

  function ScrollAnimator(scrollElement, maximumVelocity1) {
    this.scrollElement = scrollElement;
    this.maximumVelocity = maximumVelocity1;
    ScrollAnimator.__super__.constructor.apply(this, arguments);
    this._referenceFrame = this.scrollElement.getPendingReferenceFrame();
    this._velocity = 0;
    this._mode = "tracking";

    /*
    modes:
      braking:      friction only
      spring:       spring
      tracking:     direct tracking, no physics
     */
  }

  ScrollAnimator.getter("desiredScrollPosition", {
    mode: function() {
      return this._mode;
    },
    minScrollPosition: function() {
      return this.scrollElement.getMinScrollPositionInReferenceFrame(this._referenceFrame);
    },
    maxScrollPosition: function() {
      return this.scrollElement.getMaxScrollPositionInReferenceFrame(this._referenceFrame);
    },
    scrollPosition: function() {
      return this.scrollElement.getScrollPositionInReferenceFrame(this._referenceFrame);
    },
    animationDone: function() {
      switch (this.mode) {
        case "spring":
          return this.velocityIsSlow() && this._desiredScrollPosition === this.getScrollPosition();
        case "braking":
          return this.velocityIsSlow();
        default:
          return !this._activeTouch;
      }
    },
    animationContinues: function() {
      return !this.getAnimationDone();
    }
  });

  ScrollAnimator.setter("desiredScrollPosition", {
    mode: function(v) {
      return this._mode = v;
    },
    referenceFrame: function(v) {
      return this._referenceFrame = v;
    },
    scrollPosition: function(l) {
      return this.scrollElement.setScrollPositionInReferenceFrame(round(l), this._referenceFrame);
    },
    activeTouch: function(v) {
      if (!(this._activeTouch = !!v)) {
        this.mode = "spring";
        return this._desiredScrollPosition = this.boundLocation(this._desiredScrollPosition);
      }
    }
  });

  ScrollAnimator.prototype.addToDesiredScrollPosition = function(delta) {
    return this._desiredScrollPosition += delta;
  };

  ScrollAnimator.prototype.animateToLocation = function(desiredScrollPosition) {
    this.mode = "spring";
    return this._desiredScrollPosition = desiredScrollPosition;
  };

  ScrollAnimator.prototype.boundLocation = function(scrollPosition) {
    return bound(this.getMinScrollPosition(), scrollPosition, this.getMaxScrollPosition());
  };

  ScrollAnimator.prototype.startTracking = function(desiredScrollPosition, referenceFrame) {
    this._referenceFrame = referenceFrame;
    this.mode = "tracking";
    this._velocity = 0;
    this.setDesiredScrollPosition(desiredScrollPosition);
    return this._activeTouch = true;
  };

  ScrollAnimator.prototype.addVelocity = function(v) {
    this._velocity = v;
    return this.mode = "braking";
  };

  ScrollAnimator.prototype.velocityIsSlow = function() {
    return absLte(this._velocity, 60);
  };

  frameCount = 0;

  missCount = 0;

  ScrollAnimator.prototype.frameUpdate = function(frameTime) {
    var acceleration, boundedLocation, boundedTargetLocation, currentToTargetVector, distanceSquared, frictionAcceleration, frictionConstant, maxBeyond, maxV, minV, scrollPosition, springAcceleration, springConstant, targetScrollPosition, tookFrames, windowSize;
    tookFrames = Math.round(frameTime * 60);
    frameCount++;
    if (absLt(frameTime * 60 - 1, .25)) {

    } else {
      if (tookFrames > 1) {
        missCount++;
      }
    }
    scrollPosition = this.getScrollPosition();
    targetScrollPosition = this._desiredScrollPosition;
    this._velocity = maxMagnitude(this._velocity, this.maximumVelocity);
    switch (this._mode) {
      case "tracking":
        windowSize = this.scrollElement.windowSize;
        boundedTargetLocation = this.boundLocation(targetScrollPosition);
        maxBeyond = windowSize / 3;
        minV = min(boundedTargetLocation, targetScrollPosition);
        maxV = max(boundedTargetLocation, targetScrollPosition);
        targetScrollPosition = bound(minV, boundedTargetLocation + Math.atan((targetScrollPosition - boundedTargetLocation) / maxBeyond) * (2 / Math.PI) * maxBeyond, maxV);
        this._velocity = 0;
        this.setScrollPosition(targetScrollPosition);
        break;
      case "braking":
        this._activeTouch = false;
        frictionConstant = brakingFactor;
        frictionAcceleration = this._velocity * -frictionConstant;
        acceleration = frictionAcceleration;
        this._velocity += acceleration * frameTime;
        scrollPosition = scrollPosition + this._velocity * frameTime;
        this.setScrollPosition(scrollPosition);
        if (scrollPosition !== (boundedLocation = this.boundLocation(scrollPosition))) {
          this.mode = "spring";
          this._desiredScrollPosition = boundedLocation;
        }
        break;
      case "spring":
        currentToTargetVector = targetScrollPosition - scrollPosition;
        distanceSquared = currentToTargetVector * currentToTargetVector;
        springConstant = animatorSpringConstant;
        frictionConstant = animatorSpringFriction;
        springAcceleration = currentToTargetVector * springConstant;
        frictionAcceleration = this._velocity * -frictionConstant;
        acceleration = springAcceleration + frictionAcceleration;
        this._velocity = this._velocity + acceleration * frameTime;
        this.setScrollPosition(this.velocityIsSlow() && abs(scrollPosition - targetScrollPosition) <= 1 ? targetScrollPosition : scrollPosition + minMagnitude(this._velocity * frameTime, 1));
    }
    if (!this.getAnimationContinues()) {
      log("frameUpdate " + this._mode + ": DONE (miss rate: " + missCount + " / " + frameCount + ")");
    }
    return this.getAnimationContinues();
  };

  return ScrollAnimator;

})(BaseClass);

AnimatorSupport = function(superClass) {
  return AnimatorSupport = (function(superClass1) {
    extend(AnimatorSupport, superClass1);

    function AnimatorSupport() {
      return AnimatorSupport.__super__.constructor.apply(this, arguments);
    }

    AnimatorSupport.getter({
      animatorsActive: function() {
        return !!this._activeAnimators;
      }
    });

    AnimatorSupport.prototype.initAnimatorSupport = function() {
      this._lastTime = 0;
      this._activeAnimators = null;
      return this._frameUpdateQueued = false;
    };

    AnimatorSupport.prototype.startAnimator = function(animator) {
      if (this.getAnimatorsActive()) {
        this._activeAnimators.push(animator);
      } else {
        this._activeAnimators = [animator];
        this._lastTime = currentSecond();
        this.getAnimatorsActive();
      }
      this._startAnimatorLoop();
      return animator;
    };


    /*
    OUT: newAnimator
    SIDE-EFFECT:
      if oldAnimator is in @_activeAnimators
      then: replaced it with newAnimator
      else: @startAnimator newAnimator
    
    POST ASSERTIONS
      newAnimator is in @_activeAnimators
      oldAnimator is NOT in @_activeAnimators
     */

    AnimatorSupport.prototype.replaceAnimator = function(newAnimator, oldAnimator) {
      var index;
      if (!(this._activeAnimators && oldAnimator)) {
        return this.startAnimator(newAnimator);
      }
      index = this._activeAnimators.indexOf(oldAnimator);
      if (!(index >= 0)) {
        return this.startAnimator(newAnimator);
      }
      return this._activeAnimators[index] = newAnimator;
    };

    AnimatorSupport.prototype.stopAllAnimators = function() {
      return this._activeAnimators = null;
    };

    AnimatorSupport.prototype._frameUpdate = function(frameTime) {
      var animator, i, j, len, nextAnimators, now, ref;
      if (!this._activeAnimators) {
        return;
      }
      now = frameTime;
      frameTime = now - this._lastTime;
      nextAnimators = null;
      ref = this._activeAnimators;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        animator = ref[i];
        if (animator.frameUpdate(frameTime)) {
          if (nextAnimators != null) {
            nextAnimators.push(animator);
          }
        } else {
          this.queueEvent("animatorDone", {
            animator: animator
          });
          nextAnimators || (nextAnimators = this._activeAnimators.slice(0, i));
        }
      }
      if (nextAnimators) {
        if (nextAnimators.length === 0) {
          this._activeAnimators = null;
          this.queueEvent("allAnimatorsDone");
        } else {
          this._activeAnimators = nextAnimators;
        }
      }
      return this._lastTime = now;
    };

    AnimatorSupport.prototype._startAnimatorLoop = function() {
      if (this._frameUpdateQueued) {
        return;
      }
      return requestAnimationFrame((function(_this) {
        return function(frameTimeMs) {
          var queueNextFrameUpdate;
          _this._lastTime = frameTimeMs / 1000;
          queueNextFrameUpdate = function() {
            if (!_this.getAnimatorsActive()) {
              return;
            }
            _this._frameUpdateQueued = true;
            return requestAnimationFrame(function(frameTimeMs) {
              _this._frameUpdateQueued = false;
              _this._frameUpdate(frameTimeMs / 1000);
              return queueNextFrameUpdate();
            });
          };
          return queueNextFrameUpdate();
        };
      })(this));
    };

    return AnimatorSupport;

  })(superClass);
};

defineModule(module, PagingScrollElement = (function(superClass1) {
  var defaultReferenceFrame;

  extend(PagingScrollElement, superClass1);

  function PagingScrollElement() {
    this.initAnimatorSupport();
    this._initGestureProps();
    this._pages = null;
    this._currentPage = null;
    this._atEnd = false;
    this._atStart = true;
    this._scrollContents = this._pagesBeforeBaselineWrapper = this._pagesAfterBaselineWrapper = null;
    this._setVerticalAxis();
    this._lastScrollUpdatedAt = currentSecond();
    this._activelyScrolling = false;
    PagingScrollElement.__super__.constructor.apply(this, arguments);
    self.pagingScrollElement = this;
    this._updateHiddenChildren();
    this.onNextReady((function(_this) {
      return function() {
        if (_this.startAtEnd) {
          _this.jumpToEnd();
        }
        return _this._scrollPositionChanged();
      };
    })(this));
  }

  PagingScrollElement.prototype.preprocessEventHandlers = function(handlerMap) {
    return merge(this._externalHandlerMap = handlerMap, {
      mouseWheel: (function(_this) {
        return function(event) {
          var horizontal, position, scrollValue, windowSize;
          _this._mostRecentMouseWheelEvent = event;
          windowSize = _this.windowSize;
          scrollValue = (horizontal = _this.scroll === "horizontal") ? event.props.deltaX || 0 : event.props.deltaY || 0;
          switch (event.props.deltaMode) {
            case "line":
              scrollValue *= 16;
              break;
            case "page":
              scrollValue *= windowSize * .75;
          }
          if (!_this.getActiveScrollAnimator()) {
            _this.startScrollAnimatorTracking();
          }
          scrollValue = bound(-windowSize, -scrollValue, windowSize);
          position = _this.getScrollAnimator().desiredScrollPosition + scrollValue;
          _this.getScrollAnimator().desiredScrollPosition = bound(_this.getScrollAnimator().minScrollPosition, position, _this.getScrollAnimator().maxScrollPosition);
          return timeout(100).then(function() {
            if (_this._mostRecentMouseWheelEvent !== event) {
              return;
            }
            return _this.endScrollAnimatorTracking();
          });
        };
      })(this),
      animatorDone: (function(_this) {
        return function(arg) {
          var animator, props;
          props = arg.props;
          animator = props.animator;
          if (animator === _this._scrollAnimator) {
            return _this._scrollAnimator = null;
          }
        };
      })(this)
    }, createGestureRecognizer({
      custom: {
        resume: this.gestureResume.bind(this),
        recognize: this.gestureRecognize.bind(this),
        begin: this.gestureBegin.bind(this),
        move: this.gestureMove.bind(this),
        end: this.gestureEnd.bind(this)
      }
    }));
  };

  PagingScrollElement.prototype._setVerticalAxis = function() {
    this.newPoint = function(mainV, crossV) {
      if (crossV == null) {
        crossV = 0;
      }
      return point(crossV, mainV);
    };
    this.getPagePosition = function(page) {
      return (page != null ? page.transformToAncestorSpaceY(0, this) : void 0) || 0;
    };
    return this.getMainCoordinate = function(pnt) {
      return pnt.y;
    };
  };

  PagingScrollElement.prototype._setHorizontalAxis = function() {
    this.newPoint = function(mainV, crossV) {
      if (crossV == null) {
        crossV = 0;
      }
      return point(mainV, crossV);
    };
    this.getPagePosition = function(page) {
      return (page != null ? page.transformToAncestorSpaceX(0, this) : void 0) || 0;
    };
    return this.getMainCoordinate = function(pnt) {
      return pnt.x;
    };
  };

  PagingScrollElement.prototype.getPageSize = function(page) {
    if (!page) {
      return 0;
    } else {
      return this.getMainCoordinate(page.getCurrentSize());
    }
  };

  PagingScrollElement.prototype.getPageEdgeOffset = function(arg) {
    var atEndEdge, page;
    page = arg.page, atEndEdge = arg.atEndEdge;
    if (atEndEdge) {
      return this.getPageSize(page);
    } else {
      return 0;
    }
  };

  PagingScrollElement.prototype.getPageCenter = function(page) {
    return this.getPagePosition(page) + this.getPageSize(page) / 2;
  };

  defaultReferenceFrame = {
    page: null,
    atEndEdge: false
  };

  PagingScrollElement.concreteProperty({
    startAtEnd: {
      "default": false
    },
    referenceFrame: {
      "default": defaultReferenceFrame,
      postSetter: function(newReferenceFrame, previousReferenceFrame) {
        var delta;
        if (newReferenceFrame === previousReferenceFrame) {
          console.warn("referenceFrame_postSetter - frame didn't change");
        }
        this._addToScrollPosition(delta = this.getReferenceFrameDelta(newReferenceFrame, previousReferenceFrame));
        this._updatePointerReferenceFrame(newReferenceFrame);
        this._queueUpdateEvent(newReferenceFrame, previousReferenceFrame);
        return this._updatePagesSplit();
      }
    },
    pages: {
      "default": [],
      validate: function(pages) {
        return isPlainArray(pages);
      },
      postSetter: function(pages, oldPages) {
        var atEndEdge, page, ref, referenceFrame;
        ref = referenceFrame = this.getPendingReferenceFrame(), page = ref.page, atEndEdge = ref.atEndEdge;
        if (this._atEnd) {
          atEndEdge = true;
          page = last(pages);
        }
        if (this._atStart || !page) {
          atEndEdge = false;
          page = first(pages);
        }
        if (referenceFrame.page && 0 > pages.indexOf(referenceFrame.page)) {
          console.warn("PagingScrollElement#pages setter: New page list does not contain the current referenceFrame. ALWAYS include the current referenceFrame when setting pages. Screen will jump!\n\npage keys: " + (inspect((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = pages.length; j < len; j++) {
              page = pages[j];
              results.push(page.key);
            }
            return results;
          })())));
        }
        if (referenceFrame.page !== page || referenceFrame.atEndEdge !== atEndEdge) {
          this.setReferenceFrame({
            page: page,
            atEndEdge: atEndEdge
          });
        } else {
          this._updatePagesSplit();
        }
        if (oldPages.length > 0) {
          return this.onNextReady((function(_this) {
            return function() {
              return _this._updateAtStartAndAtEnd();
            };
          })(this));
        }
      }
    },
    scrollPosition: {
      "default": 0,
      postSetter: function(position) {
        this._scrollPositionChanged();
        this.onNextReady((function(_this) {
          return function() {
            return _this._updateAtStartAndAtEnd();
          };
        })(this));

        /*
        TODO
        NOTES on childrenAlignment:
          This doesn't work yet.
        
          This needs to update whenever the size of children or parent changes.
        
          This code only updates when scrollPosition changes.
         */
        return this._scrollContents.setLocation(this.newPoint(position));
      }
    }
  });

  PagingScrollElement.prototype._scrollPositionChanged = function() {
    var thisScrollUpdateWasAt;
    if (!this._activelyScrolling) {
      this.queueEvent("scrollingActive");
      this._activelyScrolling = true;
    }
    this._lastScrollUpdatedAt = thisScrollUpdateWasAt = currentSecond();
    return timeout(250, (function(_this) {
      return function() {
        if (_this._lastScrollUpdatedAt === thisScrollUpdateWasAt) {
          _this._activelyScrolling = false;
          return _this.queueEvent("scrollingIdle");
        }
      };
    })(this));
  };

  PagingScrollElement.prototype._updatePagesSplit = function(pages, referenceFrame) {
    var atEndEdge, page, splitIndex;
    if (pages == null) {
      pages = this.getPendingPages();
    }
    if (referenceFrame == null) {
      referenceFrame = this.getPendingReferenceFrame();
    }
    page = referenceFrame.page, atEndEdge = referenceFrame.atEndEdge;
    splitIndex = pages.indexOf(page);
    if (splitIndex < 0) {
      if (page) {
        console.warn("PagingScrollElement#_updatePagesSplit: could not find the old referenceFrame.page(key: " + (page.key || page.inspectedName) + ") in the new children. New current page picked; display WILL jump.");
      }
      splitIndex = 0;
    }
    if (atEndEdge) {
      splitIndex++;
    }
    this._pagesBeforeBaselineWrapper.setChildren(pages.slice(0, splitIndex));
    return this._pagesAfterBaselineWrapper.setChildren(pages.slice(splitIndex));
  };

  PagingScrollElement.layoutProperty({
    scroll: {
      "default": "vertical",
      validate: function(v) {
        return v === "vertical" || v === "horizontal";
      },
      postSetter: function(newV) {
        if (newV === "vertical") {
          this._setVerticalAxis();
        } else {
          this._setHorizontalAxis();
        }
        return this._updateHiddenChildren(newV);
      }
    }
  });

  PagingScrollElement.prototype.getReferenceFrameDelta = function(toReferenceFrame, fromReferenceFrame) {
    var edgeDelta, positionDelta;
    if (toReferenceFrame == null) {
      toReferenceFrame = defaultReferenceFrame;
    }
    if (fromReferenceFrame == null) {
      fromReferenceFrame = defaultReferenceFrame;
    }
    if (toReferenceFrame === fromReferenceFrame) {
      return 0;
    }
    positionDelta = toReferenceFrame.page === fromReferenceFrame.page ? 0 : this.getPagePosition(toReferenceFrame.page) - this.getPagePosition(fromReferenceFrame.page);
    edgeDelta = this.getPageEdgeOffset(toReferenceFrame) - this.getPageEdgeOffset(fromReferenceFrame);
    return positionDelta + edgeDelta;
  };

  PagingScrollElement.prototype.getScrollPositionInReferenceFrame = function(targetReferenceFrame) {
    return this.getScrollPosition() + this.getReferenceFrameDelta(targetReferenceFrame, this.getReferenceFrame());
  };

  PagingScrollElement.prototype.setScrollPositionInReferenceFrame = function(scrollPosition, referenceFrame) {
    var pendingReferenceFrame;
    if (referenceFrame == null) {
      referenceFrame = this.getPendingReferenceFrame();
    }
    this.onNextReady((function(_this) {
      return function() {
        return _this._updateReferenceFrame();
      };
    })(this));
    pendingReferenceFrame = this.getPendingReferenceFrame();
    scrollPosition += this.getReferenceFrameDelta(pendingReferenceFrame, referenceFrame);
    return this.setScrollPosition(scrollPosition);
  };

  PagingScrollElement.getter({
    minScrollPosition: function() {
      return this.getMinScrollPositionInReferenceFrame(this.getReferenceFrame());
    },
    maxScrollPosition: function() {
      return this.getMaxScrollPositionInReferenceFrame(this.getReferenceFrame());
    }
  });

  PagingScrollElement.prototype.getMinScrollPositionInReferenceFrame = function(referenceFrame) {
    var afterSize, beforeSize, windowSize;
    windowSize = this.getWindowSize();
    beforeSize = this.getPagesBeforeBaselineSize();
    afterSize = this.getPagesAfterBaselineSize();
    if (beforeSize + afterSize <= windowSize) {
      return 0;
    }
    return windowSize - afterSize + this.getReferenceFrameDelta(referenceFrame, this.getReferenceFrame());
  };

  PagingScrollElement.prototype.getMaxScrollPositionInReferenceFrame = function(referenceFrame) {
    var afterSize, beforeSize, delta, windowSize;
    windowSize = this.getWindowSize();
    beforeSize = this.getPagesBeforeBaselineSize();
    afterSize = this.getPagesAfterBaselineSize();
    delta = this.getReferenceFrameDelta(referenceFrame, this.getReferenceFrame());
    if (beforeSize + afterSize <= windowSize) {
      return 0;
    }
    return beforeSize + delta;
  };

  PagingScrollElement.prototype.jumpToStart = function() {
    return this.setScrollPositionInReferenceFrame(0, {
      page: first(this.getPendingPages()),
      atEndEdge: false
    });
  };

  PagingScrollElement.prototype.jumpToEnd = function() {
    log("jumpToEnd");
    if (this.getPagesFitInWindow()) {
      return this.jumpToStart();
    } else {
      return this.setScrollPositionInReferenceFrame(this.getWindowSize(), {
        page: last(this.getPendingPages()),
        atEndEdge: true
      });
    }
  };

  PagingScrollElement.getter({
    atEnd: function() {
      return this._atEnd;
    },
    atStart: function() {
      return this._atStart;
    },
    inMiddle: function() {
      return !this._atEnd && !this._atStart;
    },
    pagesFitInWindow: function() {
      return this.getWindowSize() >= this.getTotalPageSize();
    },
    windowSize: function() {
      return this.getMainCoordinate(this.getCurrentSize());
    },
    currentPagePosition: function() {
      return this.getMainCoordinate(this._scrollContents.getCurrentLocation());
    },
    pagesBeforeBaselineSize: function() {
      return this.getMainCoordinate(this._pagesBeforeBaselineWrapper.getCurrentSize());
    },
    pagesAfterBaselineSize: function() {
      return this.getMainCoordinate(this._pagesAfterBaselineWrapper.getCurrentSize());
    },
    pagesBeforeBaseline: function() {
      return this._pagesBeforeBaselineWrapper.getChildren();
    },
    pagesAfterBaseline: function() {
      return this._pagesAfterBaselineWrapper.getChildren();
    },
    totalPageSize: function() {
      return this.getPagesBeforeBaselineSize() + this.getPagesAfterBaselineSize();
    },
    pagesOnScreenBeforeBaseline: function() {
      var averagePageSize, count, j, page, pages, pixelsLeft, pixelsOnScreen, ref, totalSize;
      pixelsOnScreen = this.getScrollPosition();
      totalSize = 0;
      count = 0;
      ref = pages = this._pagesBeforeBaselineWrapper.getChildren();
      for (j = ref.length - 1; j >= 0; j += -1) {
        page = ref[j];
        count++;
        totalSize += this.getMainCoordinate(page.getCurrentSize());
        if (totalSize >= pixelsOnScreen) {
          break;
        }
      }
      if (totalSize < pixelsOnScreen && pages.length > 0 && totalSize > 0) {
        averagePageSize = totalSize / pages.length;
        pixelsLeft = pixelsOnScreen - totalSize;
        count += ceil(pixelsLeft / averagePageSize);
      }
      return count;
    },
    pagesOnScreenAfterBaseline: function() {
      var averagePageSize, count, j, len, page, pages, pixelsLeft, pixelsOnScreen, ref, totalSize;
      pixelsOnScreen = this.getWindowSize() - this.getScrollPosition();
      totalSize = 0;
      count = 0;
      ref = pages = this._pagesAfterBaselineWrapper.getChildren();
      for (j = 0, len = ref.length; j < len; j++) {
        page = ref[j];
        count++;
        totalSize += this.getMainCoordinate(page.getCurrentSize());
        if (totalSize >= pixelsOnScreen) {
          break;
        }
      }
      if (totalSize < pixelsOnScreen && pages.length > 0 && totalSize > 0) {
        averagePageSize = totalSize / pages.length;
        pixelsLeft = pixelsOnScreen - totalSize;
        count += ceil(pixelsLeft / averagePageSize);
      }
      return count;
    },
    currentGeometry: function() {
      var currentPos, numPages, pixelsAfter, pixelsBefore, suggestedPageSpread, totalPageSize, windowSize;
      windowSize = this.getWindowSize();
      currentPos = this.getCurrentPagePosition();
      pixelsBefore = this.getPagesBeforeBaselineSize();
      pixelsAfter = this.getPagesAfterBaselineSize();
      numPages = this._pages.length;
      totalPageSize = pixelsBefore + pixelsAfter;
      suggestedPageSpread = this.getPagesOnScreenBeforeBaseline() + this.getPagesOnScreenAfterBaseline();
      return {
        currentPagePosition: currentPos,
        windowSize: windowSize,
        numPages: numPages,
        numPagesBeforeBaseline: this._pagesBeforeBaselineWrapper.getChildren().length,
        numPagesAfterBaseline: this._pagesAfterBaselineWrapper.getChildren().length,
        totalPageSize: totalPageSize,
        focusedPageBeforeBaseline: this.getReferenceFrame().atEndEdge,
        suggestedPageSpread: suggestedPageSpread,
        pixelsOffscreenBeforeWindow: pixelsBefore - currentPos,
        pixelsOffscreenAfterWindow: pixelsAfter - windowSize + currentPos,
        pagesBeforeBaselineSize: pixelsBefore,
        pagesAfterBaselineSize: pixelsAfter
      };
    }
  });

  PagingScrollElement.prototype._initGestureProps = function() {
    this._flicked = false;
    this._pointerStartPosition = 0;
    this._pointerReferenceFrame = null;
    this._lastPointerEventTime = null;
    this._flickSpeed = 0;
    this._gestureActive = false;
    return this._scrollAnimator = null;
  };

  PagingScrollElement.getter({
    activeScrollAnimator: function() {
      return this._scrollAnimator;
    },
    scrollAnimator: function() {
      var maximumVelocity;
      maximumVelocity = this.getWindowSize() * 60 / 2;
      return this._scrollAnimator || (this._scrollAnimator = this.startAnimator(new ScrollAnimator(this, maximumVelocity)));
    },
    debugState: function() {
      var child, ref, referenceFrame;
      referenceFrame = this.referenceFrame;
      return {
        referenceFrame: {
          page: (ref = referenceFrame.page) != null ? ref.inspectedName : void 0,
          atEndEdge: referenceFrame.atEndEdge
        },
        pagesBefore: (function() {
          var j, len, ref1, results;
          ref1 = this._pagesBeforeBaselineWrapper.children;
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            child = ref1[j];
            results.push(child.inspectedName + " " + ((this.getMainCoordinate(child.currentSize)) | 0));
          }
          return results;
        }).call(this),
        pagesAfter: (function() {
          var j, len, ref1, results;
          ref1 = this._pagesAfterBaselineWrapper.children;
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            child = ref1[j];
            results.push(child.inspectedName + " " + ((this.getMainCoordinate(child.currentSize)) | 0));
          }
          return results;
        }).call(this),
        geometry: this.currentGeometry
      };
    }
  });

  PagingScrollElement.prototype.gestureRecognize = function(arg) {
    var delta;
    delta = arg.delta;
    if (this._scroll === "vertical") {
      return 1 > delta.absoluteAspectRatio;
    } else {
      return 1 < delta.absoluteAspectRatio;
    }
  };

  PagingScrollElement.prototype.gestureBegin = function(e) {
    var location, timeStamp;
    location = e.location, timeStamp = e.timeStamp;
    this._flickSpeed = 0;
    this._gestureActive = true;
    location = this.getMainCoordinate(location);
    this._pointerReferenceFrame = this._referenceFrame;
    this._pointerStartPosition = location - this._scrollPosition;
    this._lastPointerEventTime = timeStamp;
    if (this.getActiveScrollAnimator()) {
      this._flicked = false;
      return timeout(60, (function(_this) {
        return function() {
          var referenceFrame, scrollPosition;
          if (!_this._flicked && _this._gestureActive) {
            _this._pointerReferenceFrame = _this._referenceFrame;
            scrollPosition = _this.getPendingScrollPosition();
            referenceFrame = _this.getPendingReferenceFrame();
            _this._pointerStartPosition = location - scrollPosition;
            return _this.getScrollAnimator().startTracking(scrollPosition, referenceFrame);
          }
        };
      })(this));
    } else {
      return this.startScrollAnimatorTracking();
    }
  };

  PagingScrollElement.prototype.gestureResume = function(e) {
    return !!this.getActiveScrollAnimator();
  };

  PagingScrollElement.prototype.gestureMove = function(e) {
    var delta, deltaV, location, scrollAnimator, timeStamp;
    timeStamp = e.timeStamp, delta = e.delta, location = e.location;
    location = this.getMainCoordinate(location);
    delta = this.getMainCoordinate(deltaV = delta);
    scrollAnimator = this.getScrollAnimator();
    if (timeStamp > this._lastPointerEventTime) {
      this._flickSpeed = deltaV.getMagnitude() / (timeStamp - this._lastPointerEventTime);
      this._flickDirection = (delta / abs(delta)) || 1;
      this._lastPointerEventTime = timeStamp;
    }
    return scrollAnimator.setDesiredScrollPosition(location - this._pointerStartPosition);
  };

  PagingScrollElement.prototype.gestureEnd = function(e) {
    var scrollAnimator;
    this._gestureActive = false;
    if (absGt(this._flickSpeed, minimumFlickVelocity)) {
      scrollAnimator = this.getScrollAnimator();
      scrollAnimator.addVelocity(this._flickSpeed * this._flickDirection * flickSpeedMultiplier);
      return this._flicked = true;
    } else {
      return this.endScrollAnimatorTracking();
    }
  };

  PagingScrollElement.prototype.startScrollAnimatorTracking = function() {
    return this.getScrollAnimator().startTracking(this._scrollPosition, this._referenceFrame);
  };

  PagingScrollElement.prototype.endScrollAnimatorTracking = function() {
    var scrollAnimator;
    if (!(scrollAnimator = this.getActiveScrollAnimator())) {
      return;
    }
    scrollAnimator.setReferenceFrame(this.getReferenceFrame());
    scrollAnimator.setDesiredScrollPosition(this.getScrollPosition());
    return scrollAnimator.setActiveTouch(false);
  };


  /*
  When children are set "from outside", we split them based on the @_currentPage and set then as
  grandchildren - children of the direct, but hidden children:
    _pagesBeforeBaselineWrapper or
    _pagesAfterBaselineWrapper
  
  Why? This allows us to leverage existing row and column layouts to do most of
  the heavy lifting for actual element layout.
   */

  PagingScrollElement.prototype.setChildren = function(newPages, oldChildren) {
    var newChildren;
    if (oldChildren == null) {
      oldChildren = this.getPendingChildren();
    }
    newChildren = !((oldChildren != null ? oldChildren.length : void 0) > 0) ? (this._updateHiddenChildren(), [this._scrollContents]) : oldChildren;
    this.setPages(newPages);
    return PagingScrollElement.__super__.setChildren.call(this, newChildren);
  };

  PagingScrollElement.prototype._updatePointerReferenceFrame = function(newReferenceFrame) {
    var delta, ref, ref1;
    if (!this._pointerReferenceFrame) {
      return;
    }
    delta = this.getReferenceFrameDelta(newReferenceFrame, this._pointerReferenceFrame);
    this._pointerStartPosition -= delta;
    if ((ref = this.getActiveScrollAnimator()) != null) {
      ref.addToDesiredScrollPosition(delta);
    }
    return (ref1 = this.getActiveScrollAnimator()) != null ? ref1.setReferenceFrame(this._pointerReferenceFrame = newReferenceFrame) : void 0;
  };

  PagingScrollElement.prototype._getPageUnderPosition = function(testPosition) {
    var child, j, len, ref, relativeTestPosition, size, wrapper;
    relativeTestPosition = testPosition - this.getScrollPosition();
    wrapper = relativeTestPosition < 0 ? (relativeTestPosition += this.getMainCoordinate(this._pagesBeforeBaselineWrapper.getCurrentSize()), this._pagesBeforeBaselineWrapper) : this._pagesAfterBaselineWrapper;
    ref = wrapper.getChildren();
    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      size = this.getMainCoordinate(child.getCurrentSize());
      if (relativeTestPosition < size) {
        return child;
      }
      relativeTestPosition -= size;
    }
    console.warn("PagingScrollElement#_getPageUnderPosition: could not find page under position");
    return null;
  };

  PagingScrollElement.prototype._updateAtStartAndAtEnd = function() {
    var newAtEnd, newAtStart, pages, scrollPosition;
    scrollPosition = this.getScrollPosition();
    if (this.getTotalPageSize() <= this.getWindowSize()) {
      newAtStart = true;
      newAtEnd = false;
    } else {
      newAtEnd = scrollPosition <= this.getMinScrollPosition();
      newAtStart = scrollPosition >= this.getMaxScrollPosition();
    }
    pages = this.getPages();
    if (newAtStart && newAtStart !== this._atStart) {
      this.setReferenceFrame({
        page: first(pages)
      });
    } else if (newAtEnd && newAtEnd !== this._atEnd) {
      this.setReferenceFrame({
        atEndEdge: true,
        page: last(pages)
      });
    }
    this._atEnd = newAtEnd;
    this._atStart = newAtStart;
    return newAtEnd || newAtStart;
  };

  PagingScrollElement.prototype._addToScrollPosition = function(delta) {
    return this.setScrollPosition(this.getPendingScrollPosition() + delta);
  };


  /*
  update currentPage to be the page that overlaps the center-line of the view-window
  
  need to:
    update scrollPosition
    need to @_setChildren
   */

  PagingScrollElement.prototype._updateReferenceFrame = function() {
    var atEndEdge, centerPosition, newCurrentPage, pageCenterPosition, referenceFrame, scrollPosition;
    if (this._updateAtStartAndAtEnd()) {
      return;
    }
    scrollPosition = this.getScrollPosition();
    centerPosition = this.getWindowSize() / 2;
    newCurrentPage = this._getPageUnderPosition(centerPosition);
    if (!newCurrentPage) {
      console.warn("_updateReferenceFrame: no newCurrentPage");
    }
    pageCenterPosition = this.getPageCenter(newCurrentPage);
    atEndEdge = centerPosition > pageCenterPosition;
    referenceFrame = this.getReferenceFrame();
    if (referenceFrame.page !== newCurrentPage || referenceFrame.atEndEdge !== atEndEdge) {
      return this.setReferenceFrame({
        page: newCurrentPage,
        atEndEdge: atEndEdge
      });
    }
  };

  PagingScrollElement.prototype._queueUpdateEvent = function(newReferenceFrame, previousReferenceFrame) {
    return this.onNextReady((function(_this) {
      return function() {
        var referenceFrame;
        referenceFrame = _this.getReferenceFrame();
        return _this.queueEvent("scrollUpdate", {
          previousReferenceFrame: previousReferenceFrame,
          referenceFrame: referenceFrame,
          focusedPage: referenceFrame.page,
          currentGeometry: _this.getCurrentGeometry(),
          pagesBeforeBaseline: _this.getPagesBeforeBaseline(),
          pagesAfterBaseline: _this.getPagesAfterBaseline()
        });
      };
    })(this));
  };

  PagingScrollElement.prototype._sizeChanged = function(newSize, oldSize) {
    this._queueUpdateEvent();
    return PagingScrollElement.__super__._sizeChanged.apply(this, arguments);
  };

  PagingScrollElement.prototype._updateHiddenChildren = function(scrollMode) {
    var commonSizeLayout;
    if (scrollMode == null) {
      scrollMode = this.getPendingScroll();
    }
    this._scrollContents || (this._scrollContents = new Element({
      key: "scrollContents",
      receivePointerEvents: "passToChildren"
    }, this._pagesBeforeBaselineWrapper = new Element({
      key: "pagesBeforeBaseline"
    }), this._pagesAfterBaselineWrapper = new Element({
      key: "pagesAfterBaseline"
    })));
    if (scrollMode === "horizontal") {
      commonSizeLayout = {
        hh: 1,
        wcw: 1
      };
      this._pagesBeforeBaselineWrapper.setAxis("topRight");
      this._pagesBeforeBaselineWrapper.setChildrenLayout("row");
      this._pagesAfterBaselineWrapper.setChildrenLayout("row");
    } else {
      commonSizeLayout = {
        ww: 1,
        hch: 1
      };
      this._pagesBeforeBaselineWrapper.setAxis("bottomLeft");
      this._pagesBeforeBaselineWrapper.setChildrenLayout("column");
      this._pagesAfterBaselineWrapper.setChildrenLayout("column");
    }
    this._scrollContents.setSize(commonSizeLayout);
    this._pagesBeforeBaselineWrapper.setSize(commonSizeLayout);
    this._pagesAfterBaselineWrapper.setSize(commonSizeLayout);
    this._lastScrollUpdatedAt = currentSecond();
    return this._activelyScrolling = false;
  };

  return PagingScrollElement;

})(AnimatorSupport(Element)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Atomic, BaseClass, Element, EventEpoch, Foundation, GestureRecognizer, Matrix, Point, Rectangle, ScrollElement, abs, absGt, absGte, absLt, absLte, animatorSpringConstant, animatorSpringFriction, bound, brakingFactor, ceil, createGestureRecognizer, createWithPostCreate, currentSecond, defineModule, eventEpoch, first, flickSpeedMultiplier, inspect, isPlainArray, isPoint, last, log, matrix, max, maxChange, maxMagnitude, merge, min, minMagnitude, minimumFlickVelocity, peek, point, point0, pointNearInfinity, rect, requestAnimationFrame, round, timeout,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

EventEpoch = __webpack_require__(14).EventEpoch;

Element = __webpack_require__(36);

GestureRecognizer = __webpack_require__(123);

log = Foundation.log, inspect = Foundation.inspect, currentSecond = Foundation.currentSecond, bound = Foundation.bound, round = Foundation.round, first = Foundation.first, last = Foundation.last, peek = Foundation.peek, min = Foundation.min, max = Foundation.max, abs = Foundation.abs, merge = Foundation.merge, createWithPostCreate = Foundation.createWithPostCreate, BaseClass = Foundation.BaseClass, timeout = Foundation.timeout, ceil = Foundation.ceil, round = Foundation.round, isPlainArray = Foundation.isPlainArray, absLt = Foundation.absLt, absLte = Foundation.absLte, absGt = Foundation.absGt, absGte = Foundation.absGte, minMagnitude = Foundation.minMagnitude, maxMagnitude = Foundation.maxMagnitude, maxChange = Foundation.maxChange, absLt = Foundation.absLt, requestAnimationFrame = Foundation.requestAnimationFrame, defineModule = Foundation.defineModule;

point = Atomic.point, Point = Atomic.Point, rect = Atomic.rect, Rectangle = Atomic.Rectangle, matrix = Atomic.matrix, Matrix = Atomic.Matrix, isPoint = Atomic.isPoint;

point0 = Point.point0, pointNearInfinity = Point.pointNearInfinity;

eventEpoch = EventEpoch.eventEpoch;

createGestureRecognizer = GestureRecognizer.createGestureRecognizer;

brakingFactor = 3;

minimumFlickVelocity = 300;

animatorSpringConstant = 300;

animatorSpringFriction = 25;

flickSpeedMultiplier = 1;


/*
ScrollElement

guarantee:
  Will never scroll more than one "windowSize" per frame.
  That means you need at least as many "pages" as it will take to display one more window-full of content
  above or below the current displayed content.

events:
  scrollingUpdate:
  scrollingActive:
  scrollUpdate:
 */

defineModule(module, ScrollElement = (function(superClass) {
  var legalTrackingValues, overScrollTransformation;

  extend(ScrollElement, superClass);

  legalTrackingValues = {
    top: "start",
    start: "start",
    left: "start",
    bottom: "end",
    right: "end",
    end: "end"
  };

  ScrollElement.layoutProperty({
    focusedChild: {
      "default": null
    },
    track: {
      "default": "start",
      validate: function(v) {
        return !!legalTrackingValues[v];
      },
      preprocess: function(v) {
        return legalTrackingValues[v];
      }
    },
    tracking: {
      "default": null
    },
    scrollPosition: {
      "default": 0,
      postSetter: function(position) {
        return this._scrollPositionChanged();
      }
    }
  });

  ScrollElement.prototype.defaultChildrenLayout = "column";

  ScrollElement.prototype.defaultChildArea = "logicalArea";

  function ScrollElement() {
    this.mouseWheelEvent = bind(this.mouseWheelEvent, this);
    ScrollElement.__super__.constructor.apply(this, arguments);
    this._spMinusTp = 0;
    this._inFlowChildren = null;
    this._childrenOffset = 0;
    this._childrenSize = 0;
    this._windowSize = 0;
    this._firstOnScreenChildIndex = -1;
    this._lastOnScreenChildIndex = -1;
    this._focusedChildIndex = -1;
    this._initGestureProps();
    this._gestureScrollPosition = 0;
    this.onNextReady((function(_this) {
      return function() {
        return _this._scrollPositionChanged();
      };
    })(this));
  }

  ScrollElement.getter("childrenOffset firstOnScreenChildIndex lastOnScreenChildIndex focusedChildIndex childrenSize windowSize inFlowChildren");

  overScrollTransformation = function(scrollPosition, windowSize) {
    var maxBeyond;
    maxBeyond = windowSize / 3;
    return Math.atan(scrollPosition / maxBeyond) * (2 / Math.PI) * maxBeyond;
  };

  ScrollElement.prototype.postFlexLayout = function(mainCoordinate, inFlowChildren, mainChildrenSize, mainElementSizeForChildren, mainChildrenAlignedOffset) {
    var child, contentFits, j, k, len, len1, offsetDelta, wasntTracking, windowSizeChanged;
    contentFits = mainChildrenSize <= mainElementSizeForChildren;
    windowSizeChanged = this._windowSize !== mainElementSizeForChildren;
    wasntTracking = !this._pendingState._tracking;
    if (wasntTracking && !contentFits && "end" === (this._pendingState._tracking = this._pendingState._track)) {
      this._spMinusTp -= mainElementSizeForChildren;
    } else if (windowSizeChanged && this._pendingState._tracking === "end") {
      this._spMinusTp += this._windowSize - mainElementSizeForChildren;
    }
    this._windowSize = mainElementSizeForChildren;
    this._childrenSize = mainChildrenSize;
    this._inFlowChildren = inFlowChildren;
    offsetDelta = contentFits ? this.firstElementPosition : this.firstElementPosition - mainChildrenAlignedOffset;
    if (0 !== offsetDelta) {
      if (this.isHorizontal) {
        for (j = 0, len = inFlowChildren.length; j < len; j++) {
          child = inFlowChildren[j];
          child._translateLocationXY(offsetDelta, 0);
        }
      } else {
        for (k = 0, len1 = inFlowChildren.length; k < len1; k++) {
          child = inFlowChildren[k];
          child._translateLocationXY(0, offsetDelta);
        }
      }
    }
    return this._updateTracking(mainCoordinate, inFlowChildren, mainChildrenSize, mainElementSizeForChildren, mainChildrenAlignedOffset + offsetDelta);
  };


  /*
  given the pending geometry:
  
    update: _tracking, _spMinusTp, and _focusedChild
    not changed: _scrollPosition
   */

  ScrollElement.prototype._updateTracking = function(mainCoordinate, inFlowChildren, mainChildrenSize, mainElementSizeForChildren, mainChildrenOffset) {
    var _scrollPosition, _track, _tracking, contentFits, oldChildrenOffset, ref, scrolled, scrolledPastEnd, scrolledPastStart, wasTracking, wasntTracking;
    oldChildrenOffset = this._childrenOffset;
    this._childrenOffset = mainChildrenOffset;
    ref = this.getPendingState(), _scrollPosition = ref._scrollPosition, _tracking = ref._tracking, _track = ref._track;
    contentFits = mainChildrenSize <= mainElementSizeForChildren;
    wasntTracking = !_tracking;
    wasTracking = !wasntTracking;
    scrolledPastEnd = mainChildrenOffset + mainChildrenSize <= mainElementSizeForChildren;
    scrolledPastStart = mainChildrenOffset >= 0;
    scrolled = this._scrollPosition !== _scrollPosition;
    this._pendingState._tracking = _tracking = contentFits ? null : wasntTracking && !scrolled ? _track : scrolledPastEnd ? "end" : scrolledPastStart ? "start" : "child";

    /*
    NOTE - the "!scrolled" in the "wasntTracking && !scrolled" test is mostly for testing.
    It is for the case when we scroll AND the size of the children went from contentFits to !contentFits.
    This probably never happens EXCEPT if we init scrollPosition to a non-0 value AND we init with
    children - which is what we are doing in testing.
    
    But, it's good to test that odd case, since it is theoretically possible in the wild.
     */
    if (_tracking === "child") {
      this._updateFocusedChild(mainCoordinate, inFlowChildren, mainChildrenSize, mainElementSizeForChildren);
    } else {
      this._pendingState._focusedChild = null;
    }
    if (contentFits) {
      if (wasTracking) {
        this._pendingState._spMinusTp = _scrollPosition;
      }
    } else {
      this._pendingState._spMinusTp = _scrollPosition - this.trackingPositionFromPendingGeometry;
    }
    return this._updateOnScreenInfo(oldChildrenOffset !== this._childrenOffset);
  };

  ScrollElement.prototype._updateOnScreenInfo = function(childrenOffsetChanged) {
    var child, children, firstOnScreenChildIndex, focusedChild, focusedChildIndex, i, isVertical, j, lastOnScreenChildIndex, len, pos, ref, size, windowSize;
    ref = this, isVertical = ref.isVertical, windowSize = ref.windowSize;
    focusedChild = this._pendingState._focusedChild;
    children = this._pendingState._children;
    firstOnScreenChildIndex = children.length;
    lastOnScreenChildIndex = focusedChildIndex = -1;
    for (i = j = 0, len = children.length; j < len; i = ++j) {
      child = children[i];
      if (child.getPendingInFlow()) {
        if (isVertical) {
          pos = child.getCurrentLocationY(false, point0);
          size = child.getCurrentSize().y;
        } else {
          pos = child.getCurrentLocationX(false, point0);
          size = child.getCurrentSize().x;
        }
        if (pos < windowSize && pos + size > 0) {
          firstOnScreenChildIndex = min(i, firstOnScreenChildIndex);
          lastOnScreenChildIndex = max(i, lastOnScreenChildIndex);
          if (child === focusedChild) {
            focusedChildIndex = i;
          }
        }
      }
    }
    if (firstOnScreenChildIndex === children.length) {
      firstOnScreenChildIndex = -1;
    }
    if (childrenOffsetChanged || firstOnScreenChildIndex !== this._firstOnScreenChildIndex || lastOnScreenChildIndex !== this._lastOnScreenChildIndex || focusedChildIndex !== this._focusedChildIndex || focusedChild !== this._focusedChild) {
      this.queueEvent("scrollUpdate", (function(_this) {
        return function() {
          return {
            childrenOffset: _this.childrenOffset,
            childrenSize: _this.childrenSize,
            windowSize: windowSize,
            focusedChild: focusedChild,
            firstOnScreenChildIndex: firstOnScreenChildIndex,
            lastOnScreenChildIndex: lastOnScreenChildIndex,
            focusedChildIndex: focusedChildIndex
          };
        };
      })(this));
    }
    this._firstOnScreenChildIndex = firstOnScreenChildIndex;
    this._lastOnScreenChildIndex = lastOnScreenChildIndex;
    this._focusedChildIndex = focusedChildIndex;
    return null;
  };

  ScrollElement.prototype._updateFocusedChild = function(mainCoordinate, inFlowChildren, mainChildrenSize, mainElementSizeForChildren) {
    var child, childPos, focusLine, focusedChild, focusedChildPos, j, k, len, len1;
    focusLine = mainElementSizeForChildren / 2;
    focusedChild = null;
    focusedChildPos = 0;
    if (this.isHorizontal) {
      for (j = 0, len = inFlowChildren.length; j < len; j++) {
        child = inFlowChildren[j];
        if ((focusLine > (childPos = child.getCurrentLocationX(true, point0))) || !focusedChild) {
          focusedChild = child;
          focusedChildPos = childPos;
        }
      }
    } else {
      for (k = 0, len1 = inFlowChildren.length; k < len1; k++) {
        child = inFlowChildren[k];
        if ((focusLine > (childPos = child.getCurrentLocationY(true, point0))) || !focusedChild) {
          focusedChild = child;
          focusedChildPos = childPos;
        }
      }
    }
    if (!focusedChild) {
      throw new Error("no focused child");
    }
    this._pendingState._focusedChild = focusedChild;
    return focusedChildPos;
  };

  ScrollElement.getter({
    focusedChildFromPendingGeometry: function() {
      var focusedChild;
      focusedChild = this.getPendingFocusedChild();
      if (focusedChild && focusedChild.getPendingParent() !== this) {
        return this.getPendingStart()._focusedChild = this._inFlowChildren[min(this._inFlowChildren.length - 1, this._focusedChildIndex)];
      } else {
        return focusedChild;
      }
    },
    firstChildPositionFromPendingGeometry: function() {
      return this.getChildPosition(this.inFlowChildren[0]);
    },
    lastChildPositionFromPendingGeometry: function() {
      return this._childrenOffset + this._childrenSize;
    },
    focusedChildPositionFromPendingGeometry: function() {
      return this.getChildPosition(this.focusedChildFromPendingGeometry);
    },
    focusedChildOffsetFromPendingGeometry: function() {
      return this.focusedChildPositionFromPendingGeometry - this.firstChildPositionFromPendingGeometry;
    },
    trackingPositionFromPendingGeometry: function() {
      return this.fp2tp(this.firstChildPositionFromPendingGeometry);
    },
    trackingPosition: function() {
      return this.sp2tp(this.getPendingScrollPosition());
    },
    firstElementPosition: function() {
      return this.sp2fp(this.getPendingScrollPosition());
    },
    boundedScrollPosition: function() {
      return this.boundSp(this.getPendingScrollPosition());
    },
    isHorizontal: function() {
      return this.getPendingChildrenLayout() !== "column";
    },
    isVertical: function() {
      return this.getPendingChildrenLayout() === "column";
    }
  });

  ScrollElement.prototype.getChildPosition = function(child) {
    if (this.isVertical) {
      return child.getCurrentLocationY(true, point0);
    } else {
      return child.getCurrentLocationX(true, point0);
    }
  };


  /*
  This part is confusing - end-tracking is rather different than start/child tracking:
  
    tracking:
      start/null: the start of firstChild   is pinned relative to the start of ScrollElement
      child:      the start of focusedChild is pinned relative to the start of ScrollElement
      end:        the end   of lastChild    is pinned relative to the end   of ScrollElement
  
    startPosition: top/left
    endPosition: bottom/right
  
  trackingPosition: (tp)
    position in element-space of the tracking-line
    trackingPosition = switch tracking
      when start, null then firstChild.startPosition
      when child       then focusedChild.startPosition
      when end         then windowSize - lastChild.endPosition
  
  firstElementPosition: (fp)
    position in element-space of the first element
  
  scrollPosition: (sp)
    @_spMinusTp + trackingPosition
   */

  ScrollElement.prototype.sp2tp = function(sp) {
    return sp - this._spMinusTp;
  };

  ScrollElement.prototype.tp2sp = function(tp) {
    return this._spMinusTp + tp;
  };

  ScrollElement.prototype.sp2fp = function(sp) {
    return this.tp2fp(this.sp2tp(sp));
  };

  ScrollElement.prototype.fp2sp = function(fp) {
    return this.tp2sp(this.fp2tp(fp));
  };

  ScrollElement.prototype.tp2fp = function(tp) {
    switch (this.getPendingTracking()) {
      case "end":
        return tp - this._childrenSize;
      case "child":
        return tp - this.focusedChildOffsetFromPendingGeometry;
      default:
        return tp;
    }
  };

  ScrollElement.prototype.fp2tp = function(fp) {
    switch (this.getPendingTracking()) {
      case "end":
        return fp + this._childrenSize;
      case "child":
        return fp + this.focusedChildOffsetFromPendingGeometry;
      default:
        return fp;
    }
  };

  ScrollElement.prototype.boundFp = function(fp) {
    var offscreenChildrenSize;
    if (0 < (offscreenChildrenSize = this.childrenSize - this.windowSize)) {
      return bound(-offscreenChildrenSize, fp, 0);
    } else {
      return 0;
    }
  };

  ScrollElement.prototype.boundSp = function(sp) {
    return this.fp2sp(this.boundFp(this.sp2fp(sp)));
  };

  ScrollElement.prototype.animateToValidScrollPosition = function() {
    var boundedScrollPosition, originialAnimators, ref, scrollPosition;
    ref = this, boundedScrollPosition = ref.boundedScrollPosition, scrollPosition = ref.scrollPosition;
    if (boundedScrollPosition !== scrollPosition) {
      this.animators = merge(originialAnimators = this.animators, {
        scrollPosition: {
          on: {
            done: (function(_this) {
              return function() {
                return _this.animators = originialAnimators;
              };
            })(this)
          }
        }
      });
      return this.scrollPosition = boundedScrollPosition;
    }
  };

  ScrollElement.prototype._scrollPositionChanged = function() {
    var thisScrollUpdateWasAt;
    if (!this._activelyScrolling) {
      this.queueEvent("scrollingActive");
      this._activelyScrolling = true;
    }
    this._lastScrollUpdatedAt = thisScrollUpdateWasAt = currentSecond();
    return timeout(250, (function(_this) {
      return function() {
        if (_this._lastScrollUpdatedAt === thisScrollUpdateWasAt) {
          _this._activelyScrolling = false;
          return _this.queueEvent("scrollingIdle");
        }
      };
    })(this));
  };

  ScrollElement.prototype.preprocessEventHandlers = function(handlerMap) {
    return merge(this._externalHandlerMap = handlerMap, {
      mouseWheel: this.mouseWheelEvent.bind(this)
    }, createGestureRecognizer({
      custom: {
        resume: this.gestureResume.bind(this),
        recognize: this.gestureRecognize.bind(this),
        begin: this.gestureBegin.bind(this),
        move: this.gestureMove.bind(this),
        end: this.gestureEnd.bind(this)
      }
    }));
  };

  ScrollElement.prototype.mouseWheelEvent = function(event) {
    var ref, scrollValue, tracking, windowSize;
    this._mostRecentMouseWheelEvent = event;
    ref = this, windowSize = ref.windowSize, tracking = ref.tracking;
    scrollValue = this.isVertical ? event.props.deltaY || 0 : event.props.deltaX || 0;
    switch (event.props.deltaMode) {
      case "line":
        scrollValue *= 16;
        break;
      case "page":
        scrollValue *= windowSize * .75;
    }
    this.scrollPosition = this.boundSp(this.getScrollPosition(true) + bound(-windowSize, -scrollValue, windowSize));
    return timeout(100).then((function(_this) {
      return function() {
        if (_this._mostRecentMouseWheelEvent !== event) {
          return;
        }
        return _this.animateToValidScrollPosition();
      };
    })(this));
  };

  ScrollElement.prototype._initGestureProps = function() {
    this._flicked = false;
    this._pointerStartPosition = 0;
    this._pointerReferenceFrame = null;
    this._lastPointerEventTime = null;
    return this._flickSpeed = 0;
  };

  ScrollElement.prototype.getMainCoordinate = function(pnt) {
    if (this.isVertical) {
      return pnt.y;
    } else {
      return pnt.x;
    }
  };

  ScrollElement.prototype.gestureRecognize = function(arg) {
    var delta;
    delta = arg.delta;
    if (this.isVertical) {
      return 1 > delta.absoluteAspectRatio;
    } else {
      return 1 < delta.absoluteAspectRatio;
    }
  };

  ScrollElement.prototype.gestureBegin = function(e) {
    return this._gestureScrollPosition = this.getPendingScrollPosition();
  };

  ScrollElement.prototype.gestureResume = function(e) {};

  ScrollElement.prototype.gestureMove = function(e) {
    var boundedSp, scrollPosition;
    scrollPosition = this._gestureScrollPosition += this.getMainCoordinate(e.delta);
    return this.scrollPosition = scrollPosition !== (boundedSp = this.boundSp(scrollPosition)) ? boundedSp + overScrollTransformation(scrollPosition - boundedSp, this._windowSize) : scrollPosition;
  };

  ScrollElement.prototype.gestureEnd = function(e) {
    return this.animateToValidScrollPosition();
  };

  return ScrollElement;

})(Element));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

var _package;

module.exports = [
  __webpack_require__(38), __webpack_require__(78), __webpack_require__(115), __webpack_require__(240), __webpack_require__(40), {
    "package": _package = __webpack_require__(329),
    version: _package.version
  }
];


/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, EventEpoch, KeyEvent, Pointer, PointerEvent, PointerEventManager, arrayWithoutValue, clone, eq, eventEpoch, first, formattedInspect, inspect, isArray, isObject, log, matrix, max, min, peek, point, rect, ref, ref1, shallowClone, stableSort,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), inspect = ref.inspect, clone = ref.clone, shallowClone = ref.shallowClone, peek = ref.peek, first = ref.first, min = ref.min, max = ref.max, eq = ref.eq, arrayWithoutValue = ref.arrayWithoutValue, stableSort = ref.stableSort, log = ref.log, isObject = ref.isObject, formattedInspect = ref.formattedInspect, isArray = ref.isArray;

BaseClass = __webpack_require__(6).BaseClass;

ref1 = __webpack_require__(4), point = ref1.point, rect = ref1.rect, matrix = ref1.matrix;

EventEpoch = __webpack_require__(14).EventEpoch;

eventEpoch = EventEpoch.eventEpoch;

Pointer = __webpack_require__(124);

PointerEvent = __webpack_require__(234);

KeyEvent = __webpack_require__(233);


/*
PointerEventManager

All Event Types:
  pointerCancel
  pointerMove
  pointerUp
  pointerDown
  mouseMove
  mouseIn
  mouseOut
  focus
  blur

  pointerClick
  pointerUpInside
  pointerUpOutside
  pointerIn
  pointerOut

Keyboard events are routed through the PointerEventManager.
  Keyboard Event types:
    keyDown
    keyUp
    keyPress

  see KeyEvent for details on the event

TODO:
  Rename these events:

    mouseMove => cursorMove
    mouseIn   => cursorMoveIn
    mouseOut  => cursorMoveOut

DESIGN NOTES
Purpose:
  Support Touch and Mouse events.
  Support a common set of events for the subset of Touch and Mouse semantics that overlap:
    single-touch / single-mouse-button-down

  Synthesize events:
    pointerClick
      triggered if active-locations went from 0 to non-0 and back to 0 without moving outside the pointerDeadZone
    pointerUpInside / pointerUpOutside
      just before the pointerUp event is sent:
        if pointer is "pointInside" for the target element
          send pointerUpInside
        else
          send pointerUpOutside
    pointerIn / pointerOut
      pointer's "pointInside" changed from false>>true for the target element
        send pointerMovedIn
      else
        send pointerMovedOut

Differences between Touch events and Mouse events
  Touch Events
    can have 0 or more "active" locations. Does not have "inactive" locations.
    locations can be added or removed. A removed location is not "re-added", only "new" locations are added.
  Mouse Events
    can have 1 active or 1 "inactive" location
    the "active" location has state:
      what mouse buttons are down

EVENT ORDER
  Parents get events before children.
  If a parent captures a pointer during an event, children will NOT see the event.

TODO
  updateMousePath should be called anytime Elements are added, removed or any other change that might effect the mousePath

HOW IT WORKS
  pointerDown, pointerUp and pointerMove events all happen when a pointer is being ACTIVE:
    touchs are always "active"
    mouse is "active" if one or more buttons are down (currently only left button is supported)

  multi-touch:
    Each active touch sends its own events. Ex:
      these sequence of real-world events:
        index-finger-touch-start
        middle-finger-touch-start
        hand-moves-and-so-do-both-fingers
        remove-all-fingers
      results in an event sequence like this:
        touch_down id: 7
        touch_down id: 3
        touch_move id: 7
        touch_move id: 3
        touch_up   id: 7
        touch_down id: 3

      NOTE: the ids are abitrary, but consistent across events for a touch sequence
      NOTE: Because of this, if you listen to "pointerMove" without inspecting the pointer's id,
        you might get more move events than you are expecting.

  mouseMove is sent every time the mouse moves regardless of button status
    NOTE: mouseMove is never sent on a touch device.

GUARANTEES
  All pointer movement will send mouseMove events!
    This isn't true with the raw DOM events. Mouse-Pointer up/down and touchEnd can all show locations different from the last move event.
    This means:
      On desktop, if you are tracking "null" move events (inactive pointer), then you'll be up-to-date with the pointer-location when a click happens.
      On either desktop or touch devices, if you are tracking move events, the pointer's location won't have changed between the last mouseMove event and the pointerUp event.
 */

module.exports = PointerEventManager = (function(superClass) {
  var elementToRootPath, prioritySortElements, rootToElementPath, updatePath;

  extend(PointerEventManager, superClass);

  function PointerEventManager(options) {
    if (options == null) {
      options = {};
    }
    PointerEventManager.__super__.constructor.apply(this, arguments);
    this.canvasElement = options.canvasElement;
    this.mouse = new Pointer("mouse", point(-1));
    this.activePointers = {};
    this._numActivePointers = 0;
    this.capturingElement = null;
    this.currentMousePath = [];
    this._currentFocusedPath = [this.canvasElement];
  }

  PointerEventManager.getter({
    currentFocusedPath: function() {
      return this._currentFocusedPath;
    },
    numActivePointers: function() {
      return this._numActivePointers;
    },
    hasMouseCursor: function() {
      return true;
    },
    currentMousePathClassNames: function() {
      var el, j, len, ref2, results;
      ref2 = this.currentMousePath;
      results = [];
      for (j = 0, len = ref2.length; j < len; j++) {
        el = ref2[j];
        results.push(el.classPathName);
      }
      return results;
    }
  });

  PointerEventManager.setter({
    currentFocusedPath: function() {
      throw new Error("can't set currentFocusedPath directly");
    }
  });

  PointerEventManager.prototype.capturePointerEvents = function(element) {
    var elementsToCancel, name, pointer, ref2;
    elementsToCancel = arrayWithoutValue(this.currentFocusedPath, element);
    ref2 = this.activePointers;
    for (name in ref2) {
      pointer = ref2[name];
      this.queuePointerEventForElements(elementsToCancel, "pointerCancel", pointer);
    }
    return this.capturingElement = element;
  };

  PointerEventManager.prototype.pointerEventsCapturedBy = function(element) {
    return element === this.capturingElement;
  };

  PointerEventManager.prototype.pointerElementPath = function(pointer) {
    var element, newPath, root;
    root = this.canvasElement;
    if (!root.pointInside(pointer.location)) {
      return [];
    }
    element = root;
    newPath = [];
    while (element) {
      newPath.push(element);
      element = element.childUnderPoint(pointer.locationIn(element));
    }
    return newPath;
  };

  PointerEventManager.prototype.queueEventForElements = function(elements, type, newEventFunction) {
    var element, j, len, results;
    results = [];
    for (j = 0, len = elements.length; j < len; j++) {
      element = elements[j];
      results.push(element.queueEvent(type, newEventFunction));
    }
    return results;
  };

  PointerEventManager.prototype.queuePointerEventForElement = function(element, type, pointer, timeStampInPerformanceSeconds, props) {
    return element.queueEvent(type, (function(_this) {
      return function() {
        if (!_this.capturingElement || type === "pointerCancel" || element === _this.capturingElement) {
          return new PointerEvent(type, pointer, timeStampInPerformanceSeconds, props);
        }
      };
    })(this));
  };


  /*
  SBD NOTE 2016: This method of sorting priority is global and breaks "parents encapsulate children".
  Breaking that rule makes Elements/Components less modular. A Component (subranch of the AIM tree) could
  move within the tree and have its own behavior or the behavior of ancesors change unpredictably.
  
  Is there a better way??? We need to better understand the use-cases. Mostly it has to do with gestures.
  Sometimes we want the child to have a chance to capture a gesture first, if it decides to, and then let
  the parent have a default gesture if the child declines.
  
  Old Idea: allow the parent to invert its own priority. It can set itself to have lower priority than its children.
    This meets the encapsulation requirement.
    It does limit us to only putting the parent before all children or after all children for events.
      Do we need a way to put a parent in the middle of its children event-wise?
  
  2016 May Idea: Use a similar system to the one I'm putting in place today for KeyboardEvents:
    Change pointerEventPriority to be one of:
      beforeAncestors:
      beforeDescendents:
      beforeChildren: (default)
      afterChildren
  
    OR a function which takes: (pointerEventType, pointer) -> and returns one of the above values.
  
    If we implement it as a recursive function, it looks like this:
  
  
      add = (index) ->
  
      recurse = (startIndexInclusive, endIndexExclusive) ->
        firstBeforeDescendentsIndex = -1
        firstBeforeAncestorsIndex = -1
        lastBeforeAncestorsIndex = -1
  
        for i in [startIndexInclusive...endIndexExclusive] by 1
          priority = elementPriorities[i]
          switch priority
            when "beforeDescendents" then firstBeforeDescendentsIndex = i if firstBeforeDescendentsIndex < 0
            when "beforeAncestors"
              firstBeforeAncestorsIndex = i if firstBeforeAncestorsIndex < 0
              lastBeforeAncestorsIndex = i
  
        if firstBeforeDescendentsIndex >= 0 && firstBeforeDescendentsIndex < firstBeforeAncestorsIndex
          recurse startIndexInclusive, firstBeforeDescendentsIndex
          add firstBeforeDescendentsIndex
          recurse firstBeforeDescendentsIndex + 1, endIndexExclusive
  
        else if lastBeforeAncestorsIndex >= 0
          add lastBeforeAncestorsIndex
          recurse lastBeforeAncestorsIndex + 1, endIndexExclusive
          recurse startIndexInclusive, lastBeforeAncestorsIndex
  
        else # none in range are beforeAncestors or beforeDescendents
          addLast = null
          for i in [startIndexInclusive...endIndexExclusive] by 1
            if elementPriorities[i] "afterChildren"
              if addLast
                addLast.push i
              else
                addLast = [i]
            else
              add i
  
          add i for i in addLast by -1 if addLast
   */

  PointerEventManager.prioritySortElements = prioritySortElements = function(elements) {
    return stableSort(elements, function(a, b) {
      return b._pointerEventPriority - a._pointerEventPriority;
    });
  };

  PointerEventManager.sortElementsBaseOnRelationshipPriority = function(elementPriorities) {
    var add, orderList, recurse;
    orderList = [];
    add = function(index) {
      return orderList.push(index);
    };
    recurse = function(startIndexInclusive, endIndexExclusive) {
      var addLast, firstBeforeAncestorsIndex, firstBeforeDescendentsIndex, i, j, k, l, priority, ref2, ref3, ref4, ref5, ref6, ref7, results;
      if (endIndexExclusive <= startIndexInclusive) {
        return;
      }
      if (startIndexInclusive + 1 === endIndexExclusive) {
        return add(startIndexInclusive);
      }
      firstBeforeDescendentsIndex = endIndexExclusive;
      firstBeforeAncestorsIndex = endIndexExclusive;
      for (i = j = ref2 = endIndexExclusive - 1, ref3 = startIndexInclusive; j >= ref3; i = j += -1) {
        priority = elementPriorities[i];
        switch (priority) {
          case "beforeDescendents":
            firstBeforeDescendentsIndex = i;
            break;
          case "beforeAncestors":
            if (i > startIndexInclusive) {
              firstBeforeAncestorsIndex = i;
            }
        }
      }
      if (firstBeforeDescendentsIndex <= firstBeforeAncestorsIndex) {
        addLast = false;
        for (i = k = ref4 = startIndexInclusive, ref5 = firstBeforeDescendentsIndex; k < ref5; i = k += 1) {
          if (elementPriorities[i] === "afterChildren") {
            addLast = true;
          } else {
            add(i);
          }
        }
        if (firstBeforeDescendentsIndex < endIndexExclusive) {
          add(firstBeforeDescendentsIndex);
        }
        recurse(firstBeforeDescendentsIndex + 1, endIndexExclusive);
        if (addLast) {
          results = [];
          for (i = l = ref6 = firstBeforeDescendentsIndex - 1, ref7 = startIndexInclusive; l >= ref7; i = l += -1) {
            if (elementPriorities[i] === "afterChildren") {
              results.push(add(i));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      } else if (firstBeforeAncestorsIndex < endIndexExclusive) {
        recurse(firstBeforeAncestorsIndex, endIndexExclusive);
        return recurse(startIndexInclusive, firstBeforeAncestorsIndex);
      }
    };
    recurse(0, elementPriorities.length);
    return orderList;
  };

  PointerEventManager.prototype.queuePointerEventForElements = function(elements, type, pointer, timeStampInPerformanceSeconds, props) {
    var element, j, len, results;
    elements = prioritySortElements(elements.slice());
    results = [];
    for (j = 0, len = elements.length; j < len; j++) {
      element = elements[j];
      results.push(this.queuePointerEventForElement(element, type, pointer, timeStampInPerformanceSeconds, props));
    }
    return results;
  };

  PointerEventManager.prototype.queuePointerEvents = function(type, pointer, timeStampInPerformanceSeconds) {
    return this.forEachReceivingElement((function(_this) {
      return function(e) {
        return _this.queuePointerEventForElement(e, type, pointer, timeStampInPerformanceSeconds);
      };
    })(this));
  };

  PointerEventManager.prototype.forEachReceivingElement = function(f) {
    var e, j, len, ref2, results;
    if (e = this.capturingElement) {
      return f(e);
    } else {
      ref2 = prioritySortElements(this.currentFocusedPath);
      results = [];
      for (j = 0, len = ref2.length; j < len; j++) {
        e = ref2[j];
        results.push(f(e));
      }
      return results;
    }
  };

  PointerEventManager.prototype.queueMouseEvents = function(type, pointer, timeStampInPerformanceSeconds, props) {
    return this.queuePointerEventForElements(this.currentMousePath, type, pointer, timeStampInPerformanceSeconds, props);
  };


  /*
  queueKeyEvents
  
  NOTE: @currentFocusedPath is sorted ancestors first.
  
  All elements in @currentFocusedPath potentially can receive the event.
  
  To generate the exact elementsToSendEventTo list, we need to call
  @willConsumeKeyboardEvent() on all elements in @currentFocusedPath.
  
  Basic:
    Send the event to each element in @currentFocusedPath in order until one returns "beforeDescendents"
  Unless:
    If any return "beforeAncestors", only send the event to the very last one that returns "beforeAncestors"
   */

  PointerEventManager.prototype.queueKeyEvents = function(artEngineEventType, keyboardEvent) {
    var allowBrowserDefault, element, elements, elementsToSendEventTo, i, j, k, lastBeforeParent, len, len1, newEventFunction, order, results, willConsumeEvent;
    elementsToSendEventTo = elements = this.updateFocusedPath();
    lastBeforeParent = null;
    for (i = j = 0, len = elements.length; j < len; i = ++j) {
      element = elements[i];
      if (order = willConsumeEvent = element.getWillConsumeKeyboardEvent()(artEngineEventType, keyboardEvent)) {
        if (isObject(willConsumeEvent)) {
          order = willConsumeEvent.order, allowBrowserDefault = willConsumeEvent.allowBrowserDefault;
        }
        if (!allowBrowserDefault) {
          keyboardEvent.preventDefault();
        }
        switch (order) {
          case "beforeAncestors":
            lastBeforeParent = element;
            break;
          case "beforeDescendents":
            if (!lastBeforeParent) {
              elementsToSendEventTo = elements.slice(0, i + 1);
              break;
            }
        }
      }
    }
    newEventFunction = function() {
      return new KeyEvent(artEngineEventType, keyboardEvent);
    };
    if (lastBeforeParent) {
      return lastBeforeParent.queueEvent(artEngineEventType, newEventFunction);
    } else {
      results = [];
      for (k = 0, len1 = elementsToSendEventTo.length; k < len1; k++) {
        element = elementsToSendEventTo[k];
        results.push(element.queueEvent(artEngineEventType, newEventFunction));
      }
      return results;
    }
  };

  PointerEventManager.elementToRootPath = elementToRootPath = function(element) {
    var path;
    path = [];
    while (element) {
      path.push(element);
      element = element.parent;
    }
    return path;
  };

  PointerEventManager.rootToElementPath = rootToElementPath = function(element) {
    return elementToRootPath(element).reverse();
  };

  PointerEventManager.updatePath = updatePath = function(oldPath, newPath, removedElementsAction, addedElementsAction, onAnyChange) {
    var i, j, maxLen, minLen, ref2;
    minLen = min(oldPath.length, newPath.length);
    maxLen = max(oldPath.length, newPath.length);
    for (i = j = 0, ref2 = minLen; j < ref2; i = j += 1) {
      if (oldPath[i] !== newPath[i]) {
        removedElementsAction(oldPath.slice(i));
        addedElementsAction(newPath.slice(i));
        if (onAnyChange) {
          onAnyChange(newPath);
        }
        return newPath;
      }
    }
    if (minLen === maxLen) {
      return oldPath;
    }
    if (minLen < oldPath.length) {
      removedElementsAction(oldPath.slice(minLen));
    }
    if (minLen < newPath.length) {
      addedElementsAction(newPath.slice(minLen));
    }
    if (onAnyChange && minLen !== maxLen) {
      onAnyChange(newPath);
    }
    return newPath;
  };

  PointerEventManager.prototype.updateCursor = function(path) {
    var c, cursor, el, j, len;
    cursor = "default";
    for (j = 0, len = path.length; j < len; j++) {
      el = path[j];
      if (c = el.cursor) {
        cursor = c;
      }
    }
    return this.canvasElement.cssCursor = cursor;
  };

  PointerEventManager.prototype.queueOutEvents = function(pointer, elements) {
    return this.queuePointerEventForElements(elements, "mouseOut", pointer);
  };

  PointerEventManager.prototype.queueInEvents = function(pointer, elements) {
    return this.queuePointerEventForElements(elements, "mouseIn", pointer);
  };

  PointerEventManager.prototype.queueBlurEvents = function(pointer, elements) {
    return this.queuePointerEventForElements(elements, "blur", pointer);
  };

  PointerEventManager.prototype.queueFocusEvents = function(pointer, elements) {
    return this.queuePointerEventForElements(elements, "focus", pointer);
  };

  PointerEventManager.prototype.isFocused = function(element) {
    return this.currentFocusedPath.indexOf(element) >= 0;
  };

  PointerEventManager.getter({
    validatedFocusPath: function() {
      var element, i, lastElement, path;
      lastElement = this.canvasElement.parent;
      path = (function() {
        var j, len, ref2, results;
        ref2 = this.currentFocusedPath;
        results = [];
        for (i = j = 0, len = ref2.length; j < len; i = ++j) {
          element = ref2[i];
          if (!(element.canvasElement === this.canvasElement && element.parent === lastElement)) {
            break;
          }
          results.push(lastElement = element);
        }
        return results;
      }).call(this);
      if (path[0] !== this.canvasElement) {
        return [this.canvasElement];
      }
      return path;
    }
  });

  PointerEventManager.prototype.updateFocusedPath = function(pointer, element) {
    var el, newPath;
    pointer || (pointer = this.activePointers[0]);
    newPath = isArray(element) ? element : rootToElementPath(element || peek(this.currentFocusedPath));
    if (newPath[0] !== this.canvasElement) {
      newPath = this.validatedFocusPath;
    }
    this._currentFocusedPath = updatePath(this.currentFocusedPath, newPath, (function(_this) {
      return function(oldElements) {
        return _this.queueBlurEvents(pointer, oldElements);
      };
    })(this), (function(_this) {
      return function(newElements) {
        return _this.queueFocusEvents(pointer, newElements);
      };
    })(this));
    if (this.currentFocusedPath[0] !== this.canvasElement) {
      log((function() {
        var j, len, ref2, results;
        ref2 = this.currentFocusedPath;
        results = [];
        for (j = 0, len = ref2.length; j < len; j++) {
          el = ref2[j];
          results.push(el.inspectedName);
        }
        return results;
      }).call(this));
      throw new Error("root element should be canvas (internal error - it should be impossible for this to happen)");
    }
    return this.currentFocusedPath;
  };

  PointerEventManager.prototype.focus = function(pointer, element) {
    var ref2;
    if ((ref2 = element != null ? element : this.canvasElement) != null) {
      ref2._focusDomElement();
    }
    return this.updateFocusedPath(pointer, element || this.pointerElementPath(pointer));
  };

  PointerEventManager.prototype.updateMousePath = function() {
    var pointer;
    pointer = this.mouse;
    if (!(this._numActivePointers === 0 && this.getHasMouseCursor())) {
      return;
    }
    return this.currentMousePath = updatePath(this.currentMousePath, this.pointerElementPath(pointer), (function(_this) {
      return function(oldElements) {
        return _this.queueOutEvents(pointer, oldElements);
      };
    })(this), (function(_this) {
      return function(newElements) {
        return _this.queueInEvents(pointer, newElements);
      };
    })(this), (function(_this) {
      return function(newPath) {
        return _this.updateCursor(newPath);
      };
    })(this));
  };

  PointerEventManager.prototype.pointerDown = function(id, location, timeStampInPerformanceSeconds) {
    var pointer;
    eventEpoch.logEvent("pointerDown", id);
    if (this.activePointers[id]) {
      console.error("pointerDown(id:" + (inspect(id)) + ", location:" + (inspect(location)) + "): already have an active pointer for that id");
    } else {
      this._numActivePointers++;
    }
    pointer = this.activePointers[id] = new Pointer(id, location);
    if (this._numActivePointers === 1) {
      this.focus(pointer);
    }
    return this.queuePointerEvents("pointerDown", pointer, timeStampInPerformanceSeconds);
  };

  PointerEventManager.prototype.queuePointerUpInAndOutsideEvents = function(pointer, timeStampInPerformanceSeconds) {
    return this.forEachReceivingElement((function(_this) {
      return function(element) {
        var locationInParentSpace, type;
        locationInParentSpace = pointer.locationIn(element.parent);
        type = element.pointInside(locationInParentSpace) ? "pointerUpInside" : "pointerUpOutside";
        return _this.queuePointerEventForElement(element, type, pointer, timeStampInPerformanceSeconds);
      };
    })(this));
  };

  PointerEventManager.prototype.queuePointerMoveInAndOutEvents = function(pointer, timeStampInPerformanceSeconds) {
    var isInsideParent, wasInsideParent;
    isInsideParent = true;
    wasInsideParent = true;
    return this.forEachReceivingElement((function(_this) {
      return function(element) {
        var isInside, lastLocationInParentSpace, locationInParentSpace, type, wasInside;
        lastLocationInParentSpace = pointer.lastLocationIn(element.parent);
        locationInParentSpace = pointer.locationIn(element.parent);
        wasInside = wasInsideParent && element.pointInside(lastLocationInParentSpace);
        isInside = isInsideParent && element.pointInside(locationInParentSpace);
        if (isInside !== wasInside) {
          type = isInside ? "pointerIn" : "pointerOut";
          _this.queuePointerEventForElement(element, type, pointer, timeStampInPerformanceSeconds);
        }
        isInsideParent = isInside;
        return wasInsideParent = wasInside;
      };
    })(this));
  };

  PointerEventManager.prototype.pointerUp = function(id, timeStampInPerformanceSeconds) {
    var pointer;
    eventEpoch.flushEpochNow();
    eventEpoch.logEvent("pointerUp", id);
    if (!(pointer = this.activePointers[id])) {
      return console.error("pointerUp(" + id + "): no active pointer for that id");
    }
    this._numActivePointers--;
    delete this.activePointers[id];
    this.queuePointerUpInAndOutsideEvents(pointer, timeStampInPerformanceSeconds);
    this.queuePointerEvents("pointerUp", pointer, timeStampInPerformanceSeconds);
    if (pointer.stayedWithinDeadzone) {
      this.queuePointerEvents("pointerClick", pointer, timeStampInPerformanceSeconds);
      eventEpoch.flushEpochNow();
    }
    if (this.capturingElement && this._numActivePointers === 0) {
      return this.capturingElement = null;
    }
  };

  PointerEventManager.prototype.mouseWheel = function(location, timeStampInPerformanceSeconds, props) {
    return this.queueMouseEvents("mouseWheel", this.mouse, timeStampInPerformanceSeconds, props);
  };

  PointerEventManager.prototype.pointerCancel = function(id, timeStampInPerformanceSeconds) {
    var pointer;
    eventEpoch.logEvent("pointerCancel", id);
    if (!(pointer = this.activePointers[id])) {
      return console.error("pointerCancel(" + id + "): no active pointer for that id");
    }
    this._numActivePointers--;
    delete this.activePointers[id];
    this.queuePointerEvents("pointerCancel", pointer, timeStampInPerformanceSeconds);
    if (this.capturingElement && this._numActivePointers === 0) {
      return this.capturingElement = null;
    }
  };

  PointerEventManager.prototype.pointerMove = function(id, location, timeStampInPerformanceSeconds) {
    var pointer;
    eventEpoch.logEvent("pointerMove", id);
    if (!(pointer = this.activePointers[id])) {
      return console.error("pointerMove(" + id + ", " + location + "): no active pointer for that id");
    }
    if (!!pointer.location.eq(location)) {
      return;
    }
    this.activePointers[id] = pointer = pointer.moved(location);
    this.queuePointerMoveInAndOutEvents(pointer, timeStampInPerformanceSeconds);
    return this.queuePointerEvents("pointerMove", pointer, timeStampInPerformanceSeconds);
  };

  PointerEventManager.prototype.mouseDown = function(location, timeStampInPerformanceSeconds) {
    return this.pointerDown("mousePointer", location, timeStampInPerformanceSeconds);
  };

  PointerEventManager.prototype.mouseUp = function(timeStampInPerformanceSeconds) {
    this.pointerUp("mousePointer", timeStampInPerformanceSeconds);
    return this.updateMousePath();
  };

  PointerEventManager.prototype.mouseMove = function(location, timeStampInPerformanceSeconds) {
    if (!!this.mouse.location.eq(location)) {
      return;
    }
    this.mouse = this.mouse.moved(location);
    this.updateMousePath();
    if (this._numActivePointers > 0) {
      this.pointerMove("mousePointer", location, timeStampInPerformanceSeconds);
    }
    return this.queueMouseEvents("mouseMove", this.mouse);
  };

  return PointerEventManager;

})(BaseClass);


/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, BaseClass, Binary, Canvas, Core, Element, Elements, EncodedImage, ErrorWithInfo, Foundation, Promise, StateEpoch, V1Loader, Xbd, compositeModes, inspect, layoutModes, log, lowerCamelCase, matrix, merge, mergeInto, point, rect, stateEpoch, supportedCompositeModes,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Canvas = __webpack_require__(11);

Xbd = __webpack_require__(308);

Core = __webpack_require__(38);

Elements = __webpack_require__(78);

Binary = Foundation.Binary, inspect = Foundation.inspect, BaseClass = Foundation.BaseClass, Promise = Foundation.Promise, log = Foundation.log, mergeInto = Foundation.mergeInto, lowerCamelCase = Foundation.lowerCamelCase, merge = Foundation.merge, ErrorWithInfo = Foundation.ErrorWithInfo;

point = Atomic.point, rect = Atomic.rect, matrix = Atomic.matrix;

EncodedImage = Binary.EncodedImage;

Element = Core.Element, StateEpoch = Core.StateEpoch;

stateEpoch = StateEpoch.stateEpoch;

compositeModes = {
  normal: 0,
  add: 1,
  sub: 2,
  mul: 3,
  destOver: 4,
  replace: 5,
  alphaMask: 6,
  inverseAlphaMask: 7,
  erase: 8,
  0: "normal",
  1: "add",
  2: "sub",
  3: "mul",
  4: "destOver",
  5: "replace",
  6: "alphaMask",
  7: "inverseAlphaMask",
  8: "erase"
};

supportedCompositeModes = {
  normal: "normal",
  add: "add"
};

layoutModes = {
  leftAddWidthFixed: 0,
  rightAddWidthFixed: 1,
  centeredWidthFixed: 2,
  leftAddWidthChildren: 3,
  rightAddWidthChildren: 4,
  centeredWidthChildren: 5,
  bothAdd: 6,
  bothMul: 7,
  bothStretch: 8,
  0: "leftAddWidthFixed",
  1: "rightAddWidthFixed",
  2: "centeredWidthFixed",
  3: "leftAddWidthChildren",
  4: "rightAddWidthChildren",
  5: "centeredWidthChildren",
  6: "bothAdd",
  7: "bothMul",
  8: "bothStretch"
};

module.exports = V1Loader = (function(superClass) {
  extend(V1Loader, superClass);

  function V1Loader() {
    return V1Loader.__super__.constructor.apply(this, arguments);
  }

  V1Loader.singletonClass();

  V1Loader.load = function(data, bitmapFactory) {
    return this.singleton.load(data, bitmapFactory);
  };

  V1Loader.prototype.load = function(data, bitmapFactory1) {
    this.bitmapFactory = bitmapFactory1 != null ? bitmapFactory1 : Canvas.Bitmap;
    return this.decodeTopTag(Xbd.parse(data).tag("art_file")).then((function(_this) {
      return function(artFile) {
        var child;
        artFile.axis = point();
        artFile.location = point();
        artFile.children = (function() {
          var j, len, ref, results;
          ref = artFile.getPendingChildren();
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            if (!child.getPendingIsMask()) {
              results.push(child);
            }
          }
          return results;
        })();
        artFile.bitmapFactory = _this.bitmapFactory;
        return stateEpoch.onNextReady(function() {
          return artFile;
        });
      };
    })(this));
  };

  V1Loader.objectFactory = {
    art_file: function() {
      return new Element;
    },
    pego: function() {
      return new Element;
    },
    art_stencil_shape: function() {
      return new Element;
    },
    art_bitmap: function(tag, loader) {
      var bitmap, bitmap_id;
      bitmap_id = tag.attrs["bitmap_id"];
      bitmap = loader.bitmaps[bitmap_id];
      return new Elements.BitmapElement({
        bitmap: bitmap
      });
    }
  };

  V1Loader.prototype.decodeBitmapsTag = function(bitmapsTag) {
    var i, promises, tag;
    if (!bitmapsTag) {
      return Promise.resolve();
    }
    this.bitmaps = [];
    promises = (function() {
      var j, len, ref, results;
      ref = bitmapsTag.tags;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        tag = ref[i];
        results.push((function(_this) {
          return function(i, tag) {
            return EncodedImage.toImage(tag.attrs.pixel_data).then(function(image) {
              var bitmap, bitmapId;
              bitmapId = tag.attrs.bitmap_id | 0;
              _this.bitmaps[bitmapId] = bitmap = _this.bitmapFactory.newBitmap(image);
              if (bitmap.tainted) {
                log({
                  ArtEngine_V1Loader_decodeBitmapsTag: {
                    i: i,
                    length: bitmapsTag.tags.length,
                    bitmap: bitmap.taintedInfo
                  }
                });
                throw new ErrorWithInfo("ArtEngine_V1Loader_decodeBitmapsTag - tainted bitmap detected", {
                  bitmap: bitmap.taintedInfo,
                  numBitmaps: bitmapsTag.tags.length
                });
              } else {
                log("ArtEngine_V1Loader bitmap " + (i + 1) + "/" + bitmapsTag.tags.length + " is taint-free (" + bitmap.size + ")");
              }
              return bitmap;
            });
          };
        })(this)(i, tag));
      }
      return results;
    }).call(this);
    return Promise.all(promises);
  };

  V1Loader.prototype.decodeTopTag = function(topTag) {
    return this.decodeBitmapsTag(topTag.tag("bitmaps")).then((function(_this) {
      return function() {
        return _this.createElementFromTag(topTag);
      };
    })(this));
  };

  V1Loader.prototype.createElement = function(tag) {
    var constructor;
    constructor = V1Loader.objectFactory[tag.name];
    if (!constructor) {
      this.log("WARNING: unknown object type: " + tag.name + ". Defaulting to Art.Engine.Core.Element");
      return new Element;
    } else {
      return constructor(tag, this);
    }
  };

  V1Loader.prototype.populateChildrenFromTag = function(parent, childrenTag) {
    var child, children, j, len, len1, m, postChildren, ref, results, route, shapeChildren;
    shapeChildren = [];
    children = [];
    postChildren = [];
    route = {
      "-stencil": shapeChildren,
      "+stencil": shapeChildren,
      "stencil": shapeChildren,
      "normal": children,
      "post": postChildren
    };
    ref = childrenTag.tags;
    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      route[child.attrs.stack_mode || "normal"].push(this.createElementFromTag(child, parent));
    }
    parent.setChildren(children);
    if (shapeChildren.length > 0) {
      shapeChildren[0].isMask = true;
      parent.addChild(shapeChildren[0]);
      if (shapeChildren.length > 1) {
        this.log("WARNING - loading more than one mask (shape/stencil) child not currently supported! (using first one only)");
      }
    }
    results = [];
    for (m = 0, len1 = postChildren.length; m < len1; m++) {
      child = postChildren[m];
      results.push(parent.addChild(child));
    }
    return results;
  };

  V1Loader.prototype.decodeHorizontalLinearLayout = function(object, layout, l, s, locationOut, sizeOut) {
    switch (layout) {
      case layoutModes.leftAddWidthFixed:
        mergeInto(locationOut, {
          x: l
        });
        return mergeInto(sizeOut, {
          w: s
        });
      case layoutModes.rightAddWidthFixed:
        mergeInto(locationOut, {
          x: l,
          xpw: 1
        });
        return mergeInto(sizeOut, {
          w: s
        });
      case layoutModes.centeredWidthFixed:
        mergeInto(locationOut, {
          xpw: l
        });
        return mergeInto(sizeOut, {
          w: s
        });
      case layoutModes.bothAdd:
        mergeInto(locationOut, {
          x: l
        });
        return mergeInto(sizeOut, {
          w: s,
          wpw: 1
        });
      case layoutModes.bothMul:
        mergeInto(locationOut, {
          xpw: l
        });
        return mergeInto(sizeOut, {
          wpw: s
        });
      case layoutModes.bothStretch:
      case layoutModes.centeredWidthChildren:
      case layoutModes.rightAddWidthChildren:
      case layoutModes.leftAddWidthChildren:
        return this.log("WARNING: unsupported layout " + layoutModes[layout] + " for " + channel + " loc=" + location + " size=" + size);
    }
  };

  V1Loader.prototype.decodeVerticalLinearLayout = function(object, layout, l, s, locationOut, sizeOut) {
    switch (layout) {
      case layoutModes.leftAddWidthFixed:
        mergeInto(locationOut, {
          y: l
        });
        return mergeInto(sizeOut, {
          h: s
        });
      case layoutModes.rightAddWidthFixed:
        mergeInto(locationOut, {
          y: l,
          yph: 1
        });
        return mergeInto(sizeOut, {
          h: s
        });
      case layoutModes.centeredWidthFixed:
        mergeInto(locationOut, {
          yph: l
        });
        return mergeInto(sizeOut, {
          h: s
        });
      case layoutModes.bothAdd:
        mergeInto(locationOut, {
          y: l
        });
        return mergeInto(sizeOut, {
          h: s,
          hph: 1
        });
      case layoutModes.bothMul:
        mergeInto(locationOut, {
          yph: l
        });
        return mergeInto(sizeOut, {
          hph: s
        });
      case layoutModes.bothStretch:
      case layoutModes.centeredWidthChildren:
      case layoutModes.rightAddWidthChildren:
      case layoutModes.leftAddWidthChildren:
        return this.log("WARNING: unsupported layout " + layoutModes[layout] + " for " + channel + " loc=" + location + " size=" + size);
    }
  };

  V1Loader.prototype.decodeLayout = function(object, tag, parent) {
    var hVal, location, size, wVal, xLayout, xVal, yLayout, yVal;
    xLayout = (tag.attrs.x_layout_mode || layoutModes.leftAddWidthFixed) | 0;
    yLayout = (tag.attrs.y_layout_mode || layoutModes.leftAddWidthFixed) | 0;
    xVal = (tag.attrs.x_val || 0) - 0;
    yVal = (tag.attrs.y_val || 0) - 0;
    wVal = (tag.attrs.w_val || 0) - 0;
    hVal = (tag.attrs.h_val || 0) - 0;
    location = {};
    size = {};
    this.decodeHorizontalLinearLayout(object, xLayout, xVal, wVal, location, size);
    this.decodeVerticalLinearLayout(object, yLayout, yVal, hVal, location, size);
    object.location = location;
    return object.size = size;
  };

  V1Loader.prototype.setCompositeMode = function(object, mode) {
    if (!supportedCompositeModes[compositeModes[mode]]) {
      this.log("WARNING: unknown composite mode: " + mode);
    }
    return object.compositeMode = supportedCompositeModes[compositeModes[mode]] || "normal";
  };

  V1Loader.prototype.createElementFromTag = function(tag, parent) {
    var children, k, object, ref, tagKey, userProps, v;
    if (parent == null) {
      parent = null;
    }
    object = this.createElement(tag);
    object.axis = point(tag.attrs.handle || point(.5, .5));
    this.decodeLayout(object, tag, parent);
    userProps = {};
    ref = tag.attrs;
    for (k in ref) {
      v = ref[k];
      switch (k) {
        case "name":
          object.name = v;
          break;
        case "matrix":
          object.elementToParentMatrix = matrix(v);
          break;
        case "art_engine_version":
          break;
        case "kimi_editor_version":
          break;
        case "composite_mode":
          this.setCompositeMode(object, v);
          break;
        case "drop_in_enabled":
          userProps.dropInEnabled = true;
          break;
        case "lock_mode":
          break;
        case "handle":
        case "w_val":
        case "h_val":
        case "x_val":
        case "y_val":
        case "x_layout_mode":
        case "y_layout_mode":
        case "stack_mode":
          break;
        default:
          tagKey = tag.name + ":" + k;
          switch (tagKey) {
            case "art_file:bitmaps":
            case "art_bitmap:bitmap_id":
              break;
            default:
              userProps[lowerCamelCase(k)] = v.toString();
              this.log("WARNING: unknown tag:attribute: " + tagKey + " (ignored)");
          }
      }
    }
    object.userProps = userProps;
    if (children = tag.tags.children) {
      this.populateChildrenFromTag(object, children);
    }
    return object;
  };

  return V1Loader;

})(BaseClass);


/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtBitmapTag, ArtFileTag, ArtRectangleTag, ArtSolidFillTag, ArtStencilShapeTag, Atomic, BaseClass, BitmapTag, BitmapsTag, Canvas, ChildrenTag, Core, Elements, Foundation, PegoTag, Promise, RootTag, V1Writer, Xbd, XbdTag, createObjectTreeFactories, createTagFactories, createWithPostCreate, elementNameToV1NameMap, elementToTagFactory, floatEq, log, point, propsEq, ref, ref1,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Atomic = __webpack_require__(4);

Canvas = __webpack_require__(11);

Xbd = __webpack_require__(308);

Core = __webpack_require__(38);

Elements = __webpack_require__(78);

ref = __webpack_require__(237), BaseClass = ref.BaseClass, log = ref.log, createObjectTreeFactories = ref.createObjectTreeFactories, createWithPostCreate = ref.createWithPostCreate, floatEq = ref.floatEq, Promise = ref.Promise, propsEq = ref.propsEq;

point = Atomic.point;

XbdTag = Xbd.XbdTag, createTagFactories = Xbd.createTagFactories;

ref1 = createTagFactories("Root bitmaps bitmap art_file pego art_bitmap children art_stencil_shape art_rectangle art_solid_fill"), ArtFileTag = ref1.ArtFileTag, PegoTag = ref1.PegoTag, ArtBitmapTag = ref1.ArtBitmapTag, ChildrenTag = ref1.ChildrenTag, ArtStencilShapeTag = ref1.ArtStencilShapeTag, ArtRectangleTag = ref1.ArtRectangleTag, ArtSolidFillTag = ref1.ArtSolidFillTag, BitmapsTag = ref1.BitmapsTag, BitmapTag = ref1.BitmapTag, RootTag = ref1.RootTag;

elementNameToV1NameMap = {
  Element: "pego",
  BitmapElement: "art_bitmap"
};

elementToTagFactory = {
  Element: PegoTag,
  RectangleElement: PegoTag,
  BitmapElement: ArtBitmapTag
};


/*
RectangleElement needs to have the following pattern:

  <pego handle="(0,0)" w_val='50' h_val='100'>
    <children>
      <art_stencil_shape stack_mode="+stencil" x_layout_mode="7" x_val="0.5" w_val="1" y_layout_mode="7" y_val="0.5" h_val="1">
        <art_rectangle/>
      </art_stencil_shape>
      <art_solid_fill color="ffff00ff"/>
    </children>
  </pego>
 */

module.exports = createWithPostCreate(module, V1Writer = (function(superClass) {
  extend(V1Writer, superClass);

  V1Writer.singletonClass();

  V1Writer.toArtFileTags = function(element) {
    return V1Writer.singleton.toArtFileTags(element);
  };

  V1Writer.toEncodedArtFile = function(element) {
    return V1Writer.singleton.toEncodedArtFile(element);
  };

  function V1Writer() {
    this._toXbdTag = bind(this._toXbdTag, this);
    this.toEncodedArtFile = bind(this.toEncodedArtFile, this);
    V1Writer.__super__.constructor.apply(this, arguments);
    this.reset();
  }

  V1Writer.prototype.reset = function() {
    this.bitmapTags = {};
    return this.bitmapTagCount = 0;
  };


  /*
  IN: any Art.Engine.Element
  OUT: promise.then (binaryString) ->
   */

  V1Writer.prototype.toArtFileTags = function(rootElement) {
    this.reset();
    return rootElement.onNextReady().then((function(_this) {
      return function() {
        return _this._generateBitmapsTag(rootElement);
      };
    })(this)).then((function(_this) {
      return function() {
        return Promise.all([_this._encodeProps(rootElement), _this._getChildrenTagPromise(rootElement)]);
      };
    })(this)).then((function(_this) {
      return function(arg) {
        var childrenTag, encodedProps;
        encodedProps = arg[0], childrenTag = arg[1];
        encodedProps.art_engine_version = "0.0.2";
        encodedProps.kimi_editor_version = "0.6.0";
        return RootTag(ArtFileTag(encodedProps, childrenTag, _this.bitmapsTag));
      };
    })(this));
  };

  V1Writer.prototype.toEncodedArtFile = function(element) {
    return this.toArtFileTags(element).then(function(tag) {
      return tag.toXbd();
    });
  };

  V1Writer.prototype._encodeLayout = function(element, encodedProps) {
    var angle, axis, currentLocation, currentSize, e2p, matrix;
    currentSize = element.currentSize, currentLocation = element.currentLocation, axis = element.axis;
    e2p = element.getElementToParentMatrix();
    matrix = e2p.withLocation(0).toArray().join(',');
    if (matrix !== "1,1,0,0,0,0") {
      encodedProps.matrix = matrix;
    }
    if (!floatEq(0, angle = e2p.getAngle())) {
      encodedProps.angle = "" + angle;
    }
    encodedProps.w_val = currentSize.x.toString();
    encodedProps.h_val = currentSize.y.toString();
    if (!propsEq(currentLocation, point())) {
      encodedProps.x_val = currentLocation.x.toString();
      encodedProps.y_val = currentLocation.y.toString();
    }
    if (!propsEq(axis, point(.5))) {
      return encodedProps.handle = "(" + axis.x + "," + axis.y + ")";
    }
  };

  V1Writer.prototype._addTagForBitmap = function(element) {
    var bitmap, encodedBitmap, uniqueId, userProps;
    bitmap = element.bitmap, userProps = element.userProps;
    uniqueId = bitmap.uniqueId;
    if (this.bitmapTags[uniqueId]) {
      return Promise.resolve();
    }
    if (userProps) {
      encodedBitmap = userProps.encodedBitmap;
    }
    return Promise.resolve().then((function(_this) {
      return function() {
        if (encodedBitmap) {
          return encodedBitmap;
        } else if (bitmap.hasAlpha) {
          return bitmap.toPng();
        } else {
          return bitmap.toJpg();
        }
      };
    })(this)).then((function(_this) {
      return function(encodedBitmap) {
        return _this.bitmapTags[uniqueId] = BitmapTag({
          bitmap_id: _this.bitmapTagCount++,
          pixel_data: encodedBitmap
        });
      };
    })(this));
  };

  V1Writer.prototype._populateBitmapSubTagsRecursive = function(element) {
    var bitmap, children;
    bitmap = element.bitmap, children = element.children;
    return Promise.resolve().then((function(_this) {
      return function() {
        return bitmap && _this._addTagForBitmap(element);
      };
    })(this)).then((function(_this) {
      return function() {
        var child;
        return Promise.all((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = children.length; i < len; i++) {
            child = children[i];
            results.push(this._populateBitmapSubTagsRecursive(child));
          }
          return results;
        }).call(_this));
      };
    })(this));
  };

  V1Writer.prototype._generateBitmapsTag = function(element) {
    return this._populateBitmapSubTagsRecursive(element).then((function(_this) {
      return function() {
        var k, tag;
        if (_this.bitmapTagCount > 0) {
          return _this.bitmapsTag = BitmapsTag((function() {
            var ref2, results;
            ref2 = this.bitmapTags;
            results = [];
            for (k in ref2) {
              tag = ref2[k];
              results.push(tag);
            }
            return results;
          }).call(_this));
        }
      };
    })(this));
  };

  V1Writer.prototype._encodeProps = function(element) {
    var bitmapTag, encodedProps, k, minimalProps, v;
    minimalProps = element.minimalProps;
    encodedProps = {};
    for (k in minimalProps) {
      v = minimalProps[k];
      switch (k) {
        case "userProps":
          if (v.dropInEnabled) {
            encodedProps.drop_in_enabled = "true";
            encodedProps.lock_mode = "2";
          }
          break;
        case "compositeMode":
          if (v === "alphaMask") {
            encodedProps.stack_mode = "+stencil";
          }
          break;
        case "key":
          encodedProps.name = v.toString();
          break;
        case "elementToParentMatrix":
          encodedProps.matrix = v.toString();
          break;
        case "bitmap":
          if (!(bitmapTag = this.bitmapTags[v.uniqueId])) {
            console.warn("Bitmap missing: " + v.uniqueId);
          }
          encodedProps.bitmap_id = bitmapTag.attrs.bitmap_id;
          break;
        case "location":
        case "children":
        case "parent":
        case "currentSize":
        case "size":
        case "axis":
        case "color":
        case "scale":
        case "angle":
          break;
        default:
          console.warn("Art.Engine.V1Writer: ignored unsupported prop type: elementType: " + element["class"].name + ", propType: " + k);
      }
    }
    this._encodeLayout(element, encodedProps);
    return encodedProps;
  };

  V1Writer.prototype._getChildrenTagPromise = function(element) {
    return Promise.resolve().then((function(_this) {
      return function() {
        var child, ref2;
        switch (element["class"].name) {
          case "RectangleElement":
            return ChildrenTag(null, ArtStencilShapeTag({
              stack_mode: "+stencil",
              x_layout_mode: "7",
              x_val: "0.5",
              w_val: "1",
              y_layout_mode: "7",
              y_val: "0.5",
              h_val: "1"
            }, ArtRectangleTag()), ArtSolidFillTag({
              color: ((ref2 = element.color) != null ? ref2.rawRgbaHexString : void 0) || "000000ff"
            }));
          default:
            return Promise.all((function() {
              var i, len, ref3, results;
              ref3 = element.children;
              results = [];
              for (i = 0, len = ref3.length; i < len; i++) {
                child = ref3[i];
                results.push(this._toXbdTag(child));
              }
              return results;
            }).call(_this)).then(function(savedChildren) {
              return savedChildren.length > 0 && ChildrenTag(savedChildren);
            });
        }
      };
    })(this));
  };

  V1Writer.prototype._toXbdTag = function(element) {
    var TagFactory;
    if (!(TagFactory = elementToTagFactory[element["class"].name])) {
      console.warn("Art.Engine.V1Writer: unsupported Element type: " + element["class"].name);
      return null;
    }
    return Promise.all([this._encodeProps(element), this._getChildrenTagPromise(element)]).then((function(_this) {
      return function(arg) {
        var childrenTag, encodedProps;
        encodedProps = arg[0], childrenTag = arg[1];
        return TagFactory(encodedProps, childrenTag);
      };
    })(this));
  };

  return V1Writer;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(238);

module.exports.addModules({
  StandardImport: __webpack_require__(237),
  V1Loader: __webpack_require__(431),
  V1Writer: __webpack_require__(432)
});


/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Foundation, Input, SynchronizedDomOverlay, TextArea, TextInputElement, createElementFromHtml, defineModule, iOSDetect, inspect, log, max, merge, object, point, ref, ref1, ref2, rgbColor, select, timeout, wordsArray,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, object = ref.object, merge = ref.merge, select = ref.select, inspect = ref.inspect, wordsArray = ref.wordsArray, timeout = ref.timeout, max = ref.max;

ref1 = __webpack_require__(4), rgbColor = ref1.rgbColor, point = ref1.point;

Foundation = __webpack_require__(2);

iOSDetect = Foundation.Browser.iOSDetect;

createElementFromHtml = Foundation.Browser.Dom.createElementFromHtml;

ref2 = Foundation.Browser.DomElementFactories, TextArea = ref2.TextArea, Input = ref2.Input;

SynchronizedDomOverlay = __webpack_require__(239);

defineModule(module, TextInputElement = (function(superClass) {
  var defaultFontSize, normalizeAuto;

  extend(TextInputElement, superClass);

  defaultFontSize = 16;

  TextInputElement.concreteProperty({
    placeholder: {
      postSetter: function(v) {
        var ref3;
        return (ref3 = this.domElement) != null ? ref3.placeholder = v != null ? v : "" : void 0;
      }
    },
    maxLength: {
      postSetter: function(v) {
        var ref3;
        return (ref3 = this.domElement) != null ? ref3.maxLength = v != null ? v : null : void 0;
      }
    },
    fontFamily: "sans-serif",
    postSetter: function(v) {
      var ref3;
      return (ref3 = this.domElement) != null ? ref3.fontFamily = v != null ? v : "sans-serif" : void 0;
    },
    fontSize: {
      validate: function(v) {
        return v > 0;
      },
      "default": defaultFontSize,
      postSetter: function(v) {
        var ref3;
        return (ref3 = this.domElement) != null ? ref3.fontSize = (v || defaultFontSize) + "px" : void 0;
      }
    },
    color: {
      postSetter: function(v) {
        var ref3;
        return (ref3 = this.domElement) != null ? ref3.color = rgbColor(v || "black").toString() : void 0;
      }
    }
  });

  normalizeAuto = function(v) {
    if (v != null) {
      return v || "off";
    }
  };

  function TextInputElement(options) {
    var Factory, props, ref3, ref4, ref5;
    if (options == null) {
      options = {};
    }
    this._focusEventsDisabled = false;
    props = object({
      placeholder: options.placeholder || "",
      type: options.type,
      maxlength: options.maxLength || options.maxlength,
      autocapitalize: normalizeAuto((ref3 = options.autoCapitalize) != null ? ref3 : options.autocapitalize),
      autocomplete: normalizeAuto((ref4 = options.autoComplete) != null ? ref4 : options.autocomplete),
      autocorrect: normalizeAuto((ref5 = options.autoCorrect) != null ? ref5 : options.autocorrect)
    });
    Factory = props.type === "textarea" ? (delete props.type, TextArea) : (props.type || (props.type = 'text'), Input);
    options.domElement = Factory(props, options.attrs, options.style, {
      value: options.value || "",
      style: {
        resize: "none",
        backgroundColor: 'transparent',
        border: '0px',
        color: rgbColor(options.color || "black").toString(),
        fontFamily: options.fontFamily || "Arial",
        fontSize: (options.fontSize || defaultFontSize) + "px",
        margin: "0",
        outline: "0",
        padding: "0",
        textAlign: options.align || "left",
        verticalAlign: "bottom"
      },
      on: {
        keydown: (function(_this) {
          return function(keyboardEvent) {
            var ref6;
            return (ref6 = _this.getCanvasElement()) != null ? ref6.keyDownEvent(keyboardEvent) : void 0;
          };
        })(this),
        keyup: (function(_this) {
          return function(keyboardEvent) {
            var ref6;
            return (ref6 = _this.getCanvasElement()) != null ? ref6.keyUpEvent(keyboardEvent) : void 0;
          };
        })(this),
        change: (function(_this) {
          return function(event) {
            return _this.checkIfValueChanged();
          };
        })(this),
        input: (function(_this) {
          return function(event) {
            return _this.checkIfValueChanged();
          };
        })(this),
        select: (function(_this) {
          return function(event) {
            return _this.queueEvent("selectionChanged");
          };
        })(this),
        focus: (function(_this) {
          return function(event) {
            if (_this._safeToProcessFocusEvents()) {
              _this._canvasElementToFocusOnBlur = _this.getCanvasElement();
              return _this._focus();
            }
          };
        })(this),
        blur: (function(_this) {
          return function(event) {
            if (_this._safeToProcessFocusEvents()) {
              if (_this._canvasElementToFocusOnBlur) {
                timeout(0, function() {
                  if (document.body === document.activeElement) {
                    return _this._canvasElementToFocusOnBlur.focusCanvas();
                  }
                });
              }
              return _this._blur();
            }
          };
        })(this)
      }
    });
    TextInputElement.__super__.constructor.apply(this, arguments);
    this.willConsumeKeyboardEvent = {
      order: "beforeAncestors",
      allowBrowserDefault: true
    };
    this.lastValue = this.value;
  }

  TextInputElement.prototype.nonChildrenLayoutFirstPass = function() {
    return point(this.domElement.scrollWidth, max(this.getPendingFontSize() * 1.4, this.value.length > 0 ? this.domElement.scrollHeight : 0));
  };

  TextInputElement.prototype._safeToProcessFocusEvents = function() {
    if (this._focusEventsDisabled) {
      return false;
    } else {
      this._focusEventsDisabled = true;
      timeout(100, (function(_this) {
        return function() {
          return _this._focusEventsDisabled = false;
        };
      })(this));
      return true;
    }
  };

  TextInputElement.prototype.preprocessEventHandlers = function(handlerMap) {
    return merge(TextInputElement.__super__.preprocessEventHandlers.apply(this, arguments), {
      focus: (function(_this) {
        return function(event) {
          if (_this._safeToProcessFocusEvents()) {
            if (!_this.domElementFocused) {
              _this.domElement.focus();
            }
            return typeof handlerMap.focus === "function" ? handlerMap.focus(event) : void 0;
          }
        };
      })(this),
      blur: (function(_this) {
        return function(event) {
          if (_this._safeToProcessFocusEvents()) {
            if (_this.domElementFocused) {
              _this.domElement.blur();
            }
            return typeof handlerMap.blur === "function" ? handlerMap.blur(event) : void 0;
          }
        };
      })(this),
      keyPress: (function(_this) {
        return function(e) {
          var props;
          if (typeof handlerMap.keyPress === "function") {
            handlerMap.keyPress(e);
          }
          props = e.props;
          if (props.key === "Enter") {
            _this.handleEvent("enter", merge(props, {
              value: _this.value
            }));
          }
          if (props.key === "Escape") {
            return _this.handleEvent("escape", merge(props, {
              value: _this.value
            }));
          }
        };
      })(this)
    });
  };

  TextInputElement.prototype._unregister = function() {
    var ref3;
    if ((ref3 = this._canvasElementToFocusOnBlur) != null) {
      ref3.focusCanvas();
    }
    return TextInputElement.__super__._unregister.apply(this, arguments);
  };

  TextInputElement.prototype.checkIfValueChanged = function() {
    if (this.lastValue !== this.value) {
      if (this.size.childrenRelative) {
        this._layoutPropertyChanged();
      }
      this.lastValue = this.value;
      return this.queueEvent("valueChanged", {
        value: this.value,
        lastValue: this.lastValue
      });
    }
  };

  TextInputElement.virtualProperty({
    value: {
      getter: function(pending) {
        return this.domElement.value;
      },
      setter: function(v) {
        v = v != null ? "" + v : "";
        if (this.domElement.value !== v) {
          this._elementChanged(true);
          return this.domElement.value = v;
        }
      }
    },
    color: {
      getter: function() {
        return rgbColor(this.domElement.style.color);
      },
      setter: function(c) {
        self.domElement = this.domElement;
        return this.domElement.style.color = rgbColor(c).toString();
      }
    }
  });

  TextInputElement.prototype.selectAll = function() {
    return this.domElement.select();
  };

  TextInputElement.prototype.copy = function() {
    var contentEditable, el, range, readOnly, result, sel;
    el = this.domElement;
    if (iOSDetect()) {
      readOnly = el.readOnly, contentEditable = el.contentEditable;
      el.contentEditable = true;
      el.readOnly = false;
      range = document.createRange();
      range.selectNodeContents(el);
      sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
      el.setSelectionRange(0, 999999);
      result = document.execCommand('copy');
      el.contentEditable = contentEditable;
      el.readOnly = readOnly;
      sel.removeAllRanges();
      el.blur();
      return result;
    } else {
      el.select();
      return document.execCommand('copy');
    }
  };

  TextInputElement.prototype.insertAtCursor = function(insertValue) {
    var ref3, selectionEnd, selectionStart, value;
    log({
      insertAtCursor: {
        insertValue: insertValue
      }
    });
    if (this.domElement.selectionStart || this.domElement.selectionStart === '0') {
      ref3 = this.domElement, value = ref3.value, selectionStart = ref3.selectionStart, selectionEnd = ref3.selectionEnd;
      log({
        insertAtCursor: {
          value: value,
          selectionStart: selectionStart,
          selectionEnd: selectionEnd,
          insertValue: insertValue
        }
      });
      this.domElement.value = value.substring(0, selectionStart) + insertValue + value.substring(selectionEnd, value.length);
      this.domElement.selectionEnd = this.domElement.selectionStart = selectionStart + insertValue.length;
    } else {
      this.domElement.value += insertValue;
    }
    return this.checkIfValueChanged();
  };

  return TextInputElement;

})(SynchronizedDomOverlay));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var Browser, FontLoader, FullScreenApp, Link, Meta, Promise, configure, getDomReadyPromise, getEnv, iOSNative, isPlainObject, log, merge, ref, ref1, rgbColor;

ref = __webpack_require__(1), merge = ref.merge, Promise = ref.Promise, getEnv = ref.getEnv, log = ref.log, isPlainObject = ref.isPlainObject;

configure = __webpack_require__(113).configure;

Browser = __webpack_require__(2).Browser;

ref1 = Browser.DomElementFactories, Meta = ref1.Meta, Link = ref1.Link;

getDomReadyPromise = Browser.getDomReadyPromise;

FontLoader = __webpack_require__(11).FontLoader;

rgbColor = __webpack_require__(4).rgbColor;

iOSNative = global.cordova;

module.exports = FullScreenApp = (function() {
  function FullScreenApp() {}

  FullScreenApp._domReady = function() {
    var DomConsole, Engine, query;
    Engine = __webpack_require__(71);
    query = getEnv();
    log("Art.Engine.FullScreenApp options:\n  ?dev=true\n    show DomConsole\n  ?perfGraphs=true\n    show performance graphs");
    if ((query.dev != null) || (query.perfGraphs != null)) {

      /*
      TODO:
      1) I'd like a way to easily build production vs dev code.
      2) DomConsole should only be included in dev code.
      ANSWER:
        1. make DomConsole its own NPM
        2. let webpack rewrite the following require into a noop for production.
       */
      __webpack_require__(466);
      DomConsole = Neptune.Art.Foundation.DevTools.DomConsole;
      DomConsole.enable();
      if (query.perfGraphs != null) {
        Engine.DevTools.GlobalEpochStats.enable();
      }
    }
    return log("Art.Engine.FullScreenApp: app ready");
  };

  FullScreenApp._setBodyStyles = function(arg) {
    var backgroundColor, body, documentElement, ref2;
    backgroundColor = arg.backgroundColor;
    if (global.document) {
      ref2 = global.document, body = ref2.body, documentElement = ref2.documentElement;
      body.style.padding = "0px";
      body.style.margin = "0px";
      body.style.overflow = "hidden";
      body.style.fontSize = "0px";
      body.style.height = "100%";
      if (!iOSNative) {
        return documentElement.style.height = "100%";
      }
    }
  };


  /*
  IN:
    config:
      fonts: # SEE ArtCanvas.FontLoader for the most up-to-date-doc
  
    title: document.title
    styleSheets: array of style-sheet URLS to load
    scripts: array of script URLs to load
  
    meta: key-value map for meta-tags in the form:
      name: content
  
    link: add link tags to add in the form:
      rel: tag-body-text
  
    manifest: manifest file URL
   */

  FullScreenApp.init = function(config) {
    var fonts;
    if (config == null) {
      config = {};
    }
    configure(config);
    fonts = config.fonts;
    FullScreenApp.writeDom(config);
    return Promise.all([
      Promise.resolve(fonts && FontLoader.loadFonts(fonts)), getDomReadyPromise().then(function() {
        FullScreenApp._domReady();
        return FullScreenApp._setBodyStyles(config);
      })
    ]);
  };

  FullScreenApp.writeDom = function(arg) {
    var backgroundColor, content, i, info, len, link, manifest, meta, name, nameContentMetas, newLine, noDocumentWrite, ref2, rel, scriptLinks, scriptUrl, scripts, sheetUrl, styleSheets, title;
    noDocumentWrite = arg.noDocumentWrite, title = arg.title, styleSheets = arg.styleSheets, scripts = arg.scripts, meta = arg.meta, link = arg.link, manifest = arg.manifest, backgroundColor = arg.backgroundColor;
    document.title = title || "Art App";
    scripts || (scripts = []);
    styleSheets || (styleSheets = []);
    scriptLinks = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = scripts.length; i < len; i++) {
        scriptUrl = scripts[i];
        if (scriptUrl) {
          results.push("<script type='text/javascript' src='" + scriptUrl + "'></script>");
        }
      }
      return results;
    })();
    newLine = "\n    ";
    nameContentMetas = merge({
      "viewport": "user-scalable=no, width=device-width, initial-scale=1.0, viewport-fit=cover",
      "mobile-web-app-capable": "yes",
      "apple-touch-fullscreen": "yes",
      "apple-mobile-web-app-capable": "yes",
      "apple-mobile-web-app-status-bar-style": "black",
      "format-detection": "telephone=no"
    }, meta);
    document.head.appendChild(Meta({
      charset: "utf-8"
    }));
    document.head.appendChild(Meta({
      "http-equiv": "X-UA-Compatible",
      content: "IE=edge,chrome=1"
    }));
    for (name in nameContentMetas) {
      content = nameContentMetas[name];
      document.head.appendChild(Meta({
        name: name,
        content: content
      }));
    }
    for (i = 0, len = styleSheets.length; i < len; i++) {
      sheetUrl = styleSheets[i];
      document.head.appendChild(Link({
        rel: 'stylesheet',
        href: sheetUrl
      }));
    }
    ref2 = link || {};
    for (rel in ref2) {
      info = ref2[rel];
      document.head.appendChild(Link({
        rel: rel
      }, info));
    }
    return !noDocumentWrite && document.write("<html " + (manifest ? "manifest='" + manifest + "'" : "") + ">\n\n  <style>\n    " + (iOSNative ? '' : 'html {height: 100%;}') + "\n    body {\n      padding: 0px;\n      margin: 0px;\n      background-color: " + (rgbColor(backgroundColor || "#eee")) + ";\n      overflow: hidden;\n      font-size: 0px;\n      height: 100%;\n    }\n  </style>\n\n  <body>\n    " + (scriptLinks.join(newLine)) + "\n  </body>\n</html>");
  };

  return FullScreenApp;

})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

var Foundation, InterpolatedPointLayout, PointLayoutBase, log,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

PointLayoutBase = __webpack_require__(125);

log = Foundation.log;

module.exports = InterpolatedPointLayout = (function(superClass) {
  var interpolate1D;

  extend(InterpolatedPointLayout, superClass);

  PointLayoutBase.InterpolatedPointLayout = InterpolatedPointLayout;

  function InterpolatedPointLayout(layout1, layout2, p) {
    InterpolatedPointLayout.__super__.constructor.apply(this, arguments);
    this.layout1 = layout1;
    this.layout2 = layout2;
    this.p = p;
    this._hasXLayout = this.layout1._hasXLayout || !this.layout2._hasXLayout;
    this._hasYLayout = this.layout1._hasYLayout || !this.layout2._hasYLayout;
    this._xRelativeToParentW = this.layout1._xRelativeToParentW || this.layout2._xRelativeToParentW;
    this._xRelativeToParentH = this.layout1._xRelativeToParentH || this.layout2._xRelativeToParentH;
    this._yRelativeToParentW = this.layout1._yRelativeToParentW || this.layout2._yRelativeToParentW;
    this._yRelativeToParentH = this.layout1._yRelativeToParentH || this.layout2._yRelativeToParentH;
    this._xRelativeToChildrenW = this.layout1._xRelativeToChildrenW || this.layout2._xRelativeToChildrenW;
    this._xRelativeToChildrenH = this.layout1._xRelativeToChildrenH || this.layout2._xRelativeToChildrenH;
    this._yRelativeToChildrenW = this.layout1._yRelativeToChildrenW || this.layout2._yRelativeToChildrenW;
    this._yRelativeToChildrenH = this.layout1._yRelativeToChildrenH || this.layout2._yRelativeToChildrenH;
    this.layoutX = function(ps, cs) {
      return interpolate1D(p, layout1._hasXLayout, layout2._hasXLayout, layout1.layoutX(ps, cs), layout2.layoutX(ps, cs));
    };
    this.layoutY = function(ps, cs) {
      return interpolate1D(p, layout1._hasYLayout, layout2._hasYLayout, layout1.layoutY(ps, cs), layout2.layoutY(ps, cs));
    };
  }

  InterpolatedPointLayout.prototype.toString = function() {
    return "InterpolatedPointLayout(from: (" + (this.layout1.toStringLean()) + "), to: (" + (this.layout2.toStringLean()) + "), " + (this.p * 100 | 0) + "%)";
  };

  InterpolatedPointLayout.getter({
    inspectedString: function() {
      return this.toString();
    }
  });

  InterpolatedPointLayout.prototype.inspect = function() {
    return this.toString();
  };

  InterpolatedPointLayout.interpolate1D = interpolate1D = function(p, hasFrom, hasTo, from, to) {
    if (hasFrom) {
      if (hasTo) {
        return (to - from) * p + from;
      } else {
        return from;
      }
    } else {
      return to;
    }
  };

  return InterpolatedPointLayout;

})(PointLayoutBase);


/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var Components, Point, PointLayout, PointLayoutBase, defineModule, inspect, inspectLean, isFunction, isNumber, isPlainObject, isString, log, max, min, point, point0, ref, ref1,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(4), point = ref.point, Point = ref.Point;

point0 = Point.point0;

ref1 = __webpack_require__(1), defineModule = ref1.defineModule, log = ref1.log, inspect = ref1.inspect, inspectLean = ref1.inspectLean, isFunction = ref1.isFunction, isNumber = ref1.isNumber, isString = ref1.isString, isPlainObject = ref1.isPlainObject, min = ref1.min, max = ref1.max;

Components = (function() {
  var applyComponentsFunctions, preprocess2dValue, preprocessValue, pts, x, xcw, xph, xpw, y, ych, yph, ypw;

  function Components() {}

  Components.setupPointLayout = function(newPointLayout, options, previousLayout) {
    var applyFunction, k, maxLayout, v;
    maxLayout = newPointLayout.maxLayout = options.max ? new PointLayout(options.max) : void 0;
    for (k in options) {
      v = options[k];
      applyFunction = applyComponentsFunctions[k];
      if (!applyFunction) {
        throw new Error("invalid PointLayout component: " + (inspect(k)) + " in " + (inspect(options)));
      }
      applyFunction(v, newPointLayout);
    }
    if (!newPointLayout._hasXLayout && (previousLayout != null ? previousLayout._hasXLayout : void 0)) {
      newPointLayout.copyXLayout(previousLayout);
    }
    if (!newPointLayout._hasYLayout && (previousLayout != null ? previousLayout._hasYLayout : void 0)) {
      newPointLayout.copyYLayout(previousLayout);
    }
    if (maxLayout) {
      newPointLayout.mergeInLayoutRelativity(maxLayout);
    }
    return newPointLayout;
  };

  preprocessValue = function(value, pointLayout) {
    value || (value = 0);
    if (!isNumber(value)) {
      throw new Error("Each PointLayout component must be a number. Not " + (inspect(value)) + " from " + pointLayout);
    }
    return value;
  };

  preprocess2dValue = function(value, pointLayout) {
    return point(value);
  };

  Components._applyComponentsFunctions = applyComponentsFunctions = {
    max: function(value, pointLayout) {},
    pts: pts = function(value, pointLayout) {
      value = preprocess2dValue(value, pointLayout);
      pointLayout._hasXLayout = pointLayout._hasYLayout = true;
      pointLayout.x += value.x;
      return pointLayout.y += value.y;
    },
    x: x = function(value, pointLayout) {
      pointLayout._hasXLayout = true;
      if (isFunction(value)) {
        return pointLayout.customLayoutX = value;
      } else {
        value = preprocessValue(value, pointLayout);
        return pointLayout.x += value;
      }
    },
    y: y = function(value, pointLayout) {
      pointLayout._hasYLayout = true;
      if (isFunction(value)) {
        return pointLayout.customLayoutY = value;
      } else {
        value = preprocessValue(value, pointLayout);
        return pointLayout.y += value;
      }
    },
    ps: function(value, pointLayout) {
      value = preprocess2dValue(value, pointLayout);
      pointLayout._hasXLayout = pointLayout._hasYLayout = pointLayout._xRelativeToParentW = pointLayout._yRelativeToParentH = true;
      pointLayout.xpw += value.x;
      return pointLayout.yph += value.y;
    },
    xpw: xpw = function(value, pointLayout) {
      value = preprocessValue(value, pointLayout);
      pointLayout._hasXLayout = pointLayout._xRelativeToParentW = true;
      return pointLayout.xpw += value;
    },
    yph: yph = function(value, pointLayout) {
      value = preprocessValue(value, pointLayout);
      pointLayout._hasYLayout = pointLayout._yRelativeToParentH = true;
      return pointLayout.yph += value;
    },
    xph: xph = function(value, pointLayout) {
      value = preprocessValue(value, pointLayout);
      pointLayout._hasXLayout = pointLayout._xRelativeToParentH = true;
      return pointLayout.xph += value;
    },
    ypw: ypw = function(value, pointLayout) {
      value = preprocessValue(value, pointLayout);
      pointLayout._hasYLayout = pointLayout._yRelativeToParentW = true;
      return pointLayout.ypw += value;
    },
    cs: function(value, pointLayout) {
      value = preprocess2dValue(value, pointLayout);
      pointLayout._hasXLayout = pointLayout._hasYLayout = pointLayout._xRelativeToChildrenW = pointLayout._yRelativeToChildrenH = true;
      pointLayout.xcw += value.x;
      return pointLayout.ych += value.y;
    },
    xcw: xcw = function(value, pointLayout) {
      value = preprocessValue(value, pointLayout);
      pointLayout._hasXLayout = pointLayout._xRelativeToChildrenW = true;
      return pointLayout.xcw += value;
    },
    ych: ych = function(value, pointLayout) {
      value = preprocessValue(value, pointLayout);
      pointLayout._hasYLayout = pointLayout._yRelativeToChildrenH = true;
      return pointLayout.ych += value;
    },
    plus: pts,
    w: x,
    h: y,
    ww: xpw,
    hh: yph,
    xw: xpw,
    yh: yph,
    wh: xph,
    hw: ypw,
    xh: xph,
    yw: ypw,
    wpw: xpw,
    hph: yph,
    wph: xph,
    hpw: ypw,
    wcw: xcw,
    hch: ych,
    width: x,
    height: y,
    widthParentWidth: xpw,
    heightParentHeight: yph,
    widthChildrenWidth: xcw,
    heightChildrenHeight: ych,
    xParentWidth: xpw,
    yParentHeight: yph
  };

  return Components;

})();

defineModule(module, PointLayout = (function(superClass) {
  var pointLayout;

  extend(PointLayout, superClass);

  PointLayout.pointLayout = pointLayout = function(init, previousLayout) {
    if (init == null) {
      if (previousLayout != null) {
        return pointLayout(previousLayout);
      } else {
        return new PointLayout();
      }
    } else if (init instanceof PointLayoutBase) {
      return init;
    } else {
      return new PointLayout(init, previousLayout);
    }
  };


  /*
  constructor inputs: (initializer, previousLayout)
  
  constant initializer: anything that isn't a function or an object that is a legal initializer for Points
  
    123         # number
    point 1, 2  # point
    [1, 2]      # [x, y] array
    "topLeft"   # named point
    "1, 2"      # "x, y" string which is parsed
  
  function initializer: (ps, cs) -> Point or Number
  
    layout is an abitrary function based on ps (parent-size) and cs (children-size) returning a point
    NOTE: this is the least efficient option UNLESS the function directly returns ps or cs.
    REASON: otherwise you are creating new points each time the function is called.
  
  options object initializer:
  
     * contains one or more of the following options
  
     * layoutX = x if isFunction x
    x:         (ps, cs) -> number
  
     * layoutX is the sum of:
    x:         k # -> k
    xpw:       k # -> k * ps.w
    xcw:       k # -> k * cs.w
    plus:      k # -> k
    ps:        k # -> k * ps.w
    cs:        k # -> k * cs.w
  
     * layoutY = y if isFunction y
    y:         (ps, cs) -> number
  
     * layoutY is the sum of:
    y:         k # -> k
    yph:       k # -> k * ps.h
    ych:       k # -> k * cs.h
    plus:      k # -> k
    ps:        k # -> k * ps.h
    cs:        k # -> k * cs.h
  
     * Alaises
    w:                        x
    h:                        y
    wpw:                      xpw
    hph:                      yph
    wcw:                      xcw
    hch:                      ych
  
    width:                    x
    height:                   y
    width_parentWidth:        xpw
    height_parentHeight:      yph
    width_childrenWidth:      xcw
    height_childrenHeight:    ych
  
    x_parentWidth:            xpw
    y_parentHeight:           yph
    x_childrenWidth:          xcw
    y_childrenHeight:         ych
  
  constructor option examples:
  
    ps:1, plus:100      # @layout = (ps) -> ps.add 100
    ps:1, cs:1          # @layout = (cs, ps) -> ps.add cs
    x:100, y:200        # @layout = -> point 100, 200
    w:100, h:200        # @layout = -> point 100, 200
    wpw:1, hch:1        # @layout = (ps, cs) -> point ps.x, cs.y
  
  NOTE: When providing custom functions, their dependency on parent or children size is auto-detected by:
    Evaluating f(point0, point0) and comparing it with nearInfinity for each of the 4 input values respectively.
    If your function varies at all in response to an input value, it should return something different for point0
    vs nearInfinity.
   */

  function PointLayout(initializer, previousLayout) {
    this.initializer = initializer != null ? initializer : point0;
    PointLayout.__super__.constructor.apply(this, arguments);
    this._reset();
    if (isFunction(this.initializer)) {
      this._setupFromFunction(this.initializer);
    } else if (isPlainObject(this.initializer)) {
      this._setupFromOptions(this.initializer, previousLayout);
    } else {
      this._setupFromPoint(this.initializer);
    }
  }

  PointLayout.prototype._reset = function() {
    this.maxLayout = null;
    this.customLayout = null;
    this.customLayoutX = null;
    this.customLayoutY = null;
    return this.x = this.xpw = this.xph = this.xcw = this.y = this.yph = this.ypw = this.ych = 0.0;
  };

  PointLayout.prototype.toString = function() {
    return "pointLayout(" + (this.toStringLean()) + ")";
  };

  PointLayout.prototype.toStringLean = function() {
    var out;
    out = this.initializer ? this.initializer instanceof Point && this.initializer.x === this.initializer.y ? this.initializer.x : inspectLean(this.initializer) : '0';
    if (this._inheritedXLayout) {
      out += ", inheritedXLayout: " + this._inheritedXLayout;
    }
    if (this._inheritedYLayout) {
      out += ", inheritedYLayout: " + this._inheritedYLayout;
    }
    return out;
  };

  PointLayout.getter({
    inspectedInitializer: function() {
      if (this.initializer) {
        return inspect(this.initializer);
      } else {
        return '0';
      }
    },
    plainObjects: function() {
      var v;
      v = this.initializer || 0;
      if ((v instanceof Point) && v.x === v.y) {
        v = v.x;
      }
      if (v.getPlainObjects) {
        v = v.getPlainObjects();
      }
      return v;
    },
    inspectObjects: function() {
      if (isPlainObject(this.initializer)) {
        return {
          inspect: (function(_this) {
            return function() {
              return inspectLean(_this.initializer);
            };
          })(this)
        };
      } else if (isFunction(this.initializer)) {
        return {
          inspect: (function(_this) {
            return function() {
              return _this.initializer.toString().replace(/\s+/g, ' ');
            };
          })(this)
        };
      } else {
        return this.initializer;
      }
    }
  });

  PointLayout.prototype.layoutX = function(ps, cs) {
    var customLayout, customLayoutX, maxLayout, out, ref2, x, xcw, xph, xpw;
    ref2 = this, x = ref2.x, xpw = ref2.xpw, xph = ref2.xph, xcw = ref2.xcw, customLayout = ref2.customLayout, customLayoutX = ref2.customLayoutX, maxLayout = ref2.maxLayout;
    if (customLayout) {
      return customLayout(ps, cs).x;
    } else if (customLayoutX) {
      return customLayoutX(ps, cs);
    } else {
      out = x;
      if (ps != null) {
        out += xpw * ps.x + xph * ps.y;
      }
      if (cs != null) {
        out += xcw * cs.x;
      }
      if (maxLayout != null ? maxLayout.getHasXLayout() : void 0) {
        return min(out, maxLayout.layoutX(ps));
      } else {
        return out;
      }
    }
  };

  PointLayout.prototype.layoutY = function(ps, cs) {
    var customLayout, customLayoutY, maxLayout, out, ref2, y, ych, yph, ypw;
    ref2 = this, y = ref2.y, yph = ref2.yph, ypw = ref2.ypw, ych = ref2.ych, customLayout = ref2.customLayout, customLayoutY = ref2.customLayoutY, maxLayout = ref2.maxLayout;
    if (customLayout) {
      return customLayout(ps, cs).y;
    } else if (customLayoutY) {
      return customLayoutY(ps, cs);
    } else {
      out = y;
      if (ps != null) {
        out += yph * ps.y + ypw * ps.x;
      }
      if (cs != null) {
        out += ych * cs.y;
      }
      if (maxLayout != null ? maxLayout.getHasYLayout() : void 0) {
        return min(out, maxLayout.layoutY(ps));
      } else {
        return out;
      }
    }
  };

  PointLayout.prototype.copyXLayout = function(pointLayout) {
    this._hasXLayout = true;
    if (pointLayout.maxLayout || pointLayout.customLayout) {
      this.customLayoutY = fastBind(pointLayout.layoutX, pointLayout);
    } else {
      this.x = pointLayout.x, this.xpw = pointLayout.xpw, this.xph = pointLayout.xph, this.xcw = pointLayout.xcw, this.customLayoutX = pointLayout.customLayoutX;
    }
    return this._copyXRelativity(pointLayout);
  };

  PointLayout.prototype.copyYLayout = function(pointLayout) {
    this._hasYLayout = true;
    if (pointLayout.maxLayout || pointLayout.customLayout) {
      this.customLayoutY = fastBind(pointLayout.layoutY, pointLayout);
    } else {
      this.y = pointLayout.y, this.yph = pointLayout.yph, this.ypw = pointLayout.ypw, this.ych = pointLayout.ych, this.customLayoutY = pointLayout.customLayoutY;
    }
    return this._copyYRelativity(pointLayout);
  };

  PointLayout.prototype._setupFromPoint = function(val) {
    var ref2, x, y;
    this._hasXLayout = this._hasYLayout = true;
    if (isNumber(val)) {
      return this.x = this.y = val;
    } else {
      ref2 = this.initializer = point(val), x = ref2.x, y = ref2.y;
      if (isString(val)) {
        this.xpw = x;
        return this.yph = y;
      } else {
        this.x = x;
        return this.y = y;
      }
    }
  };

  PointLayout.prototype._setupFromFunction = function(layoutFunction) {
    this._hasXLayout = this._hasYLayout = true;
    if (isNumber(layoutFunction(point0, point0))) {
      this.customLayoutX = layoutFunction;
      this.customLayoutY = layoutFunction;
    } else {
      this.layout = this.customLayout = layoutFunction;
    }
    return this._detectRelativity();
  };

  PointLayout.prototype._setupFromOptions = function(options, previousLayout) {
    Components.setupPointLayout(this, options, previousLayout);
    if (this.customLayoutX) {
      this._detectXRelativity();
    }
    if (this.customLayoutY) {
      return this._detectYRelativity();
    }
  };

  return PointLayout;

})(PointLayoutBase = __webpack_require__(125)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(20);

module.exports.includeInNamespace(__webpack_require__(429)).addModules({
  Config: __webpack_require__(73),
  FullScreenApp: __webpack_require__(435),
  StandardImport: __webpack_require__(126)
});

__webpack_require__(115);

__webpack_require__(38);

__webpack_require__(417);

__webpack_require__(78);

__webpack_require__(235);

__webpack_require__(433);

__webpack_require__(240);

__webpack_require__(40);


/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(9)).vivifySubnamespace('Art');

__webpack_require__(20);


/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseClass, EpochClass, Promise, defineModule, evalAndThrowErrorsOutOfStack, inspect, ref, requestAnimationFrame,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(1), defineModule = ref.defineModule, inspect = ref.inspect, Promise = ref.Promise, requestAnimationFrame = ref.requestAnimationFrame, evalAndThrowErrorsOutOfStack = ref.evalAndThrowErrorsOutOfStack;

BaseClass = __webpack_require__(6).BaseClass;

defineModule(module, EpochClass = (function(superClass) {
  extend(EpochClass, superClass);

  function EpochClass(options) {
    if (options == null) {
      options = {};
    }
    EpochClass.__super__.constructor.apply(this, arguments);
    this._emptyQueueAfterProcessing = !!options.emptyQueueAfterProcessing;
    this._queuedItems = [];
    this._nextReadyQueue = [];
    this._epochQueued = false;
    this._processingEpoch = false;
    this._epochCount = 0;
    this._frameSecond = 0;
  }

  EpochClass.getter("processingEpoch epochQueued epochCount emptyQueueAfterProcessing frameSecond", {
    epochLength: function() {
      return this._queuedItems.length;
    }
  });

  EpochClass.prototype.updateGlobalCounts = function() {};


  /*
  This guarantess there will be a next "ready" event.
  If there were no setStates this epoch, then there won't be a next "ready" - unless you use this method.
  
  IN:
    f: an optional function to invoke on-next-ready
      mostly this is provided as a shortcut:
        @onNextReady =>
      is directly equivelent to:
        @onNextReady().then =>
  
  OUT: promise.then (result of calling f() or null if no f) ->
   */

  EpochClass.prototype.onNextReady = function(f, forceNextEpoch, passThroughArgument) {
    if (forceNextEpoch == null) {
      forceNextEpoch = true;
    }
    if (forceNextEpoch && !this._processingEpoch) {
      this.queueNextEpoch();
    }
    return new Promise((function(_this) {
      return function(resolve) {
        return _this._nextReadyQueue.push(function() {
          return resolve(f ? f(passThroughArgument) : passThroughArgument);
        });
      };
    })(this));
  };

  EpochClass.prototype._ready = function() {
    var f, i, len, nrq, results;
    if (!((nrq = this._nextReadyQueue).length > 0)) {
      return;
    }
    this._nextReadyQueue = [];
    results = [];
    for (i = 0, len = nrq.length; i < len; i++) {
      f = nrq[i];
      results.push(evalAndThrowErrorsOutOfStack((function(_this) {
        return function() {
          return f();
        };
      })(this)));
    }
    return results;
  };

  EpochClass.prototype.queueItem = function(item) {
    if (item) {
      this._queuedItems.push(item);
      this.queueNextEpoch();
    }
    return item;
  };

  EpochClass.prototype.isItemQueued = function(item) {
    return indexOf.call(this._queuedItems, item) >= 0;
  };

  EpochClass.prototype.queueNextEpoch = function() {
    if (!this._epochQueued) {
      this._epochQueued = true;
      return requestAnimationFrame((function(_this) {
        return function(frameTimeMs) {
          _this._frameSecond = frameTimeMs / 1000;
          _this._epochQueued = false;
          return _this.processEpoch();
        };
      })(this));
    }
  };

  EpochClass.prototype.flushEpochNow = function() {
    return this.processEpoch();
  };

  EpochClass.prototype.processEpoch = function() {
    var items;
    this._processingEpoch = true;
    items = this._queuedItems;
    if (this._emptyQueueAfterProcessing) {
      this.processEpochItemsWithErrorHandling(items);
      this._queuedItems = [];
    } else {
      this._queuedItems = [];
      this.processEpochItemsWithErrorHandling(items);
    }
    this._processingEpoch = false;
    this._epochCount++;
    return this._ready();
  };

  EpochClass.prototype.processEpochItemsWithErrorHandling = function(items) {
    return evalAndThrowErrorsOutOfStack((function(_this) {
      return function() {
        return _this.processEpochItems(items);
      };
    })(this));
  };

  EpochClass.prototype.processEpochItems = function(items) {
    var i, item, len, results;
    results = [];
    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];
      results.push(item());
    }
    return results;
  };

  return EpochClass;

})(BaseClass));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(243);

module.exports.addModules({
  EpochClass: __webpack_require__(440)
});


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(9)).vivifySubnamespace('Art');

__webpack_require__(243);


/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(444);

module.exports.addModules({
  IndexedDbPipeline: __webpack_require__(355),
  StandardImport: __webpack_require__(167)
});


/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

var IndexedDb,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.EryExtensions.IndexedDb', IndexedDb = (function(superClass) {
  extend(IndexedDb, superClass);

  function IndexedDb() {
    return IndexedDb.__super__.constructor.apply(this, arguments);
  }

  IndexedDb.version = __webpack_require__(591).version;

  return IndexedDb;

})(Neptune.PackageNamespace));


/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(447);


/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  defineArtEryPipelineFluxModels: __webpack_require__(244).defineModelsForAllPipelines
};


/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(448);

module.exports.includeInNamespace(__webpack_require__(446)).addModules({
  ArtEryFluxModel: __webpack_require__(244),
  ArtEryQueryFluxModel: __webpack_require__(245)
});


/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

var Flux,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(41)).addNamespace('Flux', Flux = (function(superClass) {
  extend(Flux, superClass);

  function Flux() {
    return Flux.__super__.constructor.apply(this, arguments);
  }

  return Flux;

})(Neptune.PackageNamespace));


/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

var Filters, PipelineRegistry, Promise, _package, log, ref;

PipelineRegistry = __webpack_require__(130);

Filters = __webpack_require__(80);

ref = __webpack_require__(1), log = ref.log, Promise = ref.Promise;

module.exports = [
  Filters, {
    pipelines: PipelineRegistry.pipelines,
    session: (__webpack_require__(133)).singleton,
    "package": _package = __webpack_require__(330),
    version: _package.version,
    config: __webpack_require__(27).config,
    _reset: function(pipelineTestFunction) {
      PipelineRegistry._reset(pipelineTestFunction);
      return Filters._resetFilters();
    },
    sendInitializeRequestToAllPipelines: function() {
      var k, pipeline, promises;
      promises = (function() {
        var ref1, results;
        ref1 = PipelineRegistry.pipelines;
        results = [];
        for (k in ref1) {
          pipeline = ref1[k];
          if (pipeline["class"].getHandlers().initialize) {
            results.push(pipeline.initialize());
          } else {
            results.push(void 0);
          }
        }
        return results;
      })();
      return Promise.all(promises);
    }
  }
];


/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

var AfterEventsFilter;

AfterEventsFilter = __webpack_require__(128);

module.exports = [
  __webpack_require__(249), {
    _resetFilters: function() {
      return AfterEventsFilter._reset();
    }
  }
];


/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var FieldTypes, Filter, Uuid, UuidFilter, defineModule, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log;

Filter = __webpack_require__(21);

Uuid = __webpack_require__(351);

FieldTypes = __webpack_require__(33).FieldTypes;

defineModule(module, UuidFilter = (function(superClass) {
  extend(UuidFilter, superClass);

  function UuidFilter() {
    return UuidFilter.__super__.constructor.apply(this, arguments);
  }

  UuidFilter.alwaysForceNewIds = true;

  UuidFilter.before({
    create: function(request) {
      return request.withMergedData({
        id: UuidFilter.alwaysForceNewIds ? Uuid.v4() : request.data.id || Uuid.v4()
      });
    }
  });

  UuidFilter.fields({
    id: FieldTypes.id
  });

  return UuidFilter;

})(Filter));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var AfterEventsFilter, KeyFieldsMixin, Pipeline, Promise, array, compactFlatten, deepMerge, defineModule, formattedInspect, log, merge, object, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log, merge = ref.merge, Promise = ref.Promise, object = ref.object, deepMerge = ref.deepMerge, compactFlatten = ref.compactFlatten, formattedInspect = ref.formattedInspect, array = ref.array;

Pipeline = __webpack_require__(254);

KeyFieldsMixin = __webpack_require__(253);

AfterEventsFilter = __webpack_require__(80).AfterEventsFilter;

defineModule(module, function() {
  return function(superClass) {
    var UpdateAfterMixin;
    return UpdateAfterMixin = (function(superClass1) {
      extend(UpdateAfterMixin, superClass1);

      function UpdateAfterMixin() {
        return UpdateAfterMixin.__super__.constructor.apply(this, arguments);
      }


      /*
      updateAfter vs afterEvent
      
      afterEvent is more basic, gives you more control, but lacks the special features
      updateAfter can deliver.
      
      afterEvent:
        Invokes the specified function when the AfterEvent fires for the specified
        type and pipeline. The return results is resolved if it is a promise, but unless
        the promise is rejected or an error is thrown, the result is ignored.
      
        That's it. That's all afterEvent does.
      
        SEE: AfterEventsFilter
      
      updateAfter:
        The specified function should return a propsObject or array-of-propsObjects
        (optionally via a promise).
        After the rootRequest(*) completes, all updateAfter props are aggregated and
        deep-merged (for the same pipeline+key) and then update is called for each
        unique pipeline+key pair.
      
        If any of the updates fail, the rootRequest fails.
        If any of the updatePropsFunctions fail, the triggering-request fails.
      
      updateAfter's key benefit:
        If you update the same record more than once for the same rootRequest via
        updateAfter functions, there will only be one 'update' request invoked.
      
        Exception/Feature: afterUpdates can trigger other afterUpdates, but they
        are always processed in a depth-first manner: all current afterUpdates
        are aggregated until no more are requested, then they are all processed,
        possibly triggering the next tier of afterUpdates.
      
      (*) Technically the update requests due to updateAfters are triggered
        after the root-most request on a pipeline that mixed in UpdateAfterMixin,
        not strictly the rootRequest. If you use the UpdateAfterMixin on all your
        pipelines, it will always be the rootRequest.
       */


      /*
      updateAfter:
        declare records in THIS pipeline that should be updated AFTER
        requests complete against another pipeline (or this one).
      
      IN: eventMap looks like:
        requestType: triggeringPipelineName: updateItemPropsFunction
      
        updateItemPropsFunction: (response) -> updateItemProps
        IN: response is the ArtEry request-response for the request-in-progress on
          the specified triggeringPipelineName.
          (response.pipelineName == the specified triggeringPipelineName)
      
        OUT: props object OR an array (compactFlattened) of props objects
          props-objects:
            Must have 'key' set to a string
            All same-key props-objects are deepMerged in the order they are listed.
              (i.e. last has priority)
      
      EXAMPLE:
        class User extends UpdateAfterMixin Pipeline
          @updateAfter
             * Increment postCount for all visible posts created by a user.
            create: post: ({data:{userId, createdAt, invisible}}) ->
              if !invisible
                key:  userId
                data: lastPostCreatedAt: createdAt
                add:  visiblePostCount: 1
       */

      UpdateAfterMixin.updateAfter = function(eventMap) {
        var pipelineName, requestType, requestTypeMap, results, updateRequestPropsFunction;
        if (this.getKeyFieldsString() !== "id") {
          throw new Error("keyFields must be 'id'");
        }
        results = [];
        for (requestType in eventMap) {
          requestTypeMap = eventMap[requestType];
          results.push((function() {
            var results1;
            results1 = [];
            for (pipelineName in requestTypeMap) {
              updateRequestPropsFunction = requestTypeMap[pipelineName];
              AfterEventsFilter.registerPipelineListener(this, pipelineName, requestType);
              results1.push(this._addUpdateAfterFunction(pipelineName, requestType, updateRequestPropsFunction));
            }
            return results1;
          }).call(this));
        }
        return results;
      };


      /*
      afterEvent: Add your own event handler after other pipeline's successful requests.
      If you return a promise:
        The original request won't complete (or succeed) until your returned promise resolves.
        If your promise is rejected, the original request is rejected.
      
      IN: eventMap looks like:
        requestType: pipelineName: (response) -> (ignored except for errors)
       */

      UpdateAfterMixin.afterEvent = function(eventMap) {
        var afterEventFunction, pipelineName, requestType, requestTypeMap, results;
        results = [];
        for (requestType in eventMap) {
          requestTypeMap = eventMap[requestType];
          results.push((function() {
            var results1;
            results1 = [];
            for (pipelineName in requestTypeMap) {
              afterEventFunction = requestTypeMap[pipelineName];
              AfterEventsFilter.registerPipelineListener(this, pipelineName, requestType);
              results1.push(this._addAfterEventFunction(pipelineName, requestType, afterEventFunction));
            }
            return results1;
          }).call(this));
        }
        return results;
      };

      UpdateAfterMixin.deleteAfter = function(eventMap) {
        var pipelineName;
        pipelineName = this.getPipelineName();
        return this.afterEvent(object(eventMap, function(requestTypeMap) {
          return object(requestTypeMap, function(getPropsFunction, otherPipelineName) {
            return function(response) {
              return Promise.resolve(getPropsFunction(response)).then(function(props) {
                return props && response.subrequest(pipelineName, "delete", props);
              });
            };
          });
        }));
      };

      UpdateAfterMixin.extendableProperty({
        updatePropsFunctions: {},
        afterEventFunctions: {}
      });

      UpdateAfterMixin._addUpdateAfterFunction = function(pipelineName, requestType, updatePropsFunction) {
        var base, base1;
        return ((base = ((base1 = this.extendUpdatePropsFunctions())[pipelineName] || (base1[pipelineName] = {})))[requestType] || (base[requestType] = [])).push(updatePropsFunction);
      };

      UpdateAfterMixin._addAfterEventFunction = function(pipelineName, requestType, afterEventFunction) {
        var base, base1;
        return ((base = ((base1 = this.extendAfterEventFunctions())[pipelineName] || (base1[pipelineName] = {})))[requestType] || (base[requestType] = [])).push(afterEventFunction);
      };

      UpdateAfterMixin._mergeUpdateProps = function(manyUpdateItemProps) {
        return object(compactFlatten(manyUpdateItemProps), {
          key: function(arg) {
            var key;
            key = arg.key;
            return key;
          },
          when: function(props) {
            return props;
          },
          "with": (function(_this) {
            return function(props, inputKey, into) {
              if (!props.key) {
                log.error({
                  "key not found for one or more updateItem entries": {
                    manyUpdateItemProps: manyUpdateItemProps
                  }
                });
                throw new Error((_this.getName()) + ".updateAfter: key required for each updateItem param set (see log for details)");
              }
              if (into[props.key]) {
                return deepMerge(into[props.key], props);
              } else {
                return props;
              }
            };
          })(this)
        });
      };

      UpdateAfterMixin._applyAllUpdates = function(response) {
        var updateRequestsByToUpdatePipeline;
        updateRequestsByToUpdatePipeline = response.context.updateRequestsByToUpdatePipeline;
        response.context.updateRequestsByToUpdatePipeline = null;
        if (updateRequestsByToUpdatePipeline) {
          return Promise.deepAll(updateRequestsByToUpdatePipeline).then((function(_this) {
            return function(resolvedUpdateRequestsByToUpdatePipeline) {
              return Promise.all(array(resolvedUpdateRequestsByToUpdatePipeline, function(updatePropsList, toUpdatePipelineName) {
                return Promise.all(array(_this._mergeUpdateProps(updatePropsList), function(props) {
                  return response.subrequest(toUpdatePipelineName, "update", {
                    props: props
                  });
                }));
              }));
            };
          })(this)).then((function(_this) {
            return function() {
              return _this._applyAllUpdates(response);
            };
          })(this));
        } else {
          return Promise.resolve();
        }
      };


      /*
      UpdateAfterMixinFilter provides the functionality of only triggering
      updates when the rootRequest(*) completes.
       */

      UpdateAfterMixin.filter({
        name: "UpdateAfterMixinFilter",
        group: "outter",
        filterFailures: true,
        before: {
          all: function(request) {
            request.context.updateAfterMixinDepth = (request.context.updateAfterMixinDepth || 0) + 1;
            return request;
          }
        },
        after: {
          all: function(request) {
            var p;
            p = request.context.updateAfterMixinDepth === 1 ? UpdateAfterMixin._applyAllUpdates(request) : Promise.resolve();
            return p.then(function() {
              request.context.updateAfterMixinDepth--;
              return request;
            });
          }
        }
      });

      UpdateAfterMixin.handleRequestAfterEvent = function(request) {
        var base, base1, ref1, ref2, requestType, toUpdatePipeline, toUpdatePipelineName, triggeringPipelineName;
        triggeringPipelineName = request.pipelineName, requestType = request.requestType;
        toUpdatePipeline = this.singleton;
        toUpdatePipelineName = toUpdatePipeline.pipelineName;
        ((base = ((base1 = request.context).updateRequestsByToUpdatePipeline || (base1.updateRequestsByToUpdatePipeline = {})))[toUpdatePipelineName] || (base[toUpdatePipelineName] = [])).push(array((ref1 = this.getUpdatePropsFunctions()[triggeringPipelineName]) != null ? ref1[requestType] : void 0, (function(_this) {
          return function(updateRequestPropsFunction) {
            return updateRequestPropsFunction.call(toUpdatePipeline, request);
          };
        })(this)));
        return Promise.deepAll(array((ref2 = this.getAfterEventFunctions()[triggeringPipelineName]) != null ? ref2[requestType] : void 0, (function(_this) {
          return function(afterEventFunction) {
            return afterEventFunction.call(toUpdatePipeline, request);
          };
        })(this)));
      };

      return UpdateAfterMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(41);

module.exports.includeInNamespace(__webpack_require__(449)).addModules({
  ArtEryBaseObject: __webpack_require__(79),
  Config: __webpack_require__(27),
  Filter: __webpack_require__(21),
  KeyFieldsMixin: __webpack_require__(253),
  Pipeline: __webpack_require__(254),
  PipelineQuery: __webpack_require__(255),
  PipelineRegistry: __webpack_require__(130),
  Request: __webpack_require__(81),
  RequestHandler: __webpack_require__(131),
  RequestResponseBase: __webpack_require__(82),
  Response: __webpack_require__(132),
  Session: __webpack_require__(133),
  UpdateAfterMixin: __webpack_require__(452)
});

__webpack_require__(80);


/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseClass, EventedMixin, EventedObject, defineModule, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log;

EventedMixin = __webpack_require__(259);

BaseClass = __webpack_require__(6).BaseClass;

defineModule(module, EventedObject = (function(superClass) {
  extend(EventedObject, superClass);

  function EventedObject() {
    log.error("EventedObject is DEPRICATED - use EventedMixin");
    EventedObject.__super__.constructor.apply(this, arguments);
  }

  return EventedObject;

})(EventedMixin(BaseClass)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(260);

module.exports.addModules({
  Event: __webpack_require__(134),
  EventedBaseMixin: __webpack_require__(258),
  EventedMixin: __webpack_require__(259),
  EventedObject: __webpack_require__(454),
  EventEpoch: __webpack_require__(256),
  EventManager: __webpack_require__(257)
});


/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(9)).vivifySubnamespace('Art');

__webpack_require__(260);


/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(71);

__webpack_require__(285);

__webpack_require__(459);

module.exports = __webpack_require__(464);


/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

(__webpack_require__(262)).namespace.includeInNamespace({
  FluxComponent: __webpack_require__(261)
});


/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(262);

module.exports.includeInNamespace(__webpack_require__(458)).addModules({
  FluxComponent: __webpack_require__(261)
});


/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, ErrorWithInfo, FluxModel, Foundation, InstanceFunctionBindingMixin, ModelRegistry, Promise, capitalize, compactFlatten, decapitalize, defineModule, emailRegexp, failure, fluxStore, formattedInspect, globalCount, inspect, isFailure, isFunction, isNumber, isPlainObject, isString, isoDateRegexp, log, merge, missing, nextTick, pending, pluralize, pureMerge, ref, shallowClone, success, time, urlRegexp, validStatus,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

ref = Foundation.CommunicationStatus, missing = ref.missing, success = ref.success, pending = ref.pending, failure = ref.failure, validStatus = ref.validStatus, defineModule = ref.defineModule, isFailure = ref.isFailure;

fluxStore = __webpack_require__(135).fluxStore;

ModelRegistry = __webpack_require__(83);

log = Foundation.log, BaseObject = Foundation.BaseObject, decapitalize = Foundation.decapitalize, pluralize = Foundation.pluralize, merge = Foundation.merge, shallowClone = Foundation.shallowClone, isString = Foundation.isString, emailRegexp = Foundation.emailRegexp, urlRegexp = Foundation.urlRegexp, isNumber = Foundation.isNumber, nextTick = Foundation.nextTick, capitalize = Foundation.capitalize, inspect = Foundation.inspect, isFunction = Foundation.isFunction, pureMerge = Foundation.pureMerge, isoDateRegexp = Foundation.isoDateRegexp, time = Foundation.time, globalCount = Foundation.globalCount, compactFlatten = Foundation.compactFlatten, InstanceFunctionBindingMixin = Foundation.InstanceFunctionBindingMixin, Promise = Foundation.Promise, formattedInspect = Foundation.formattedInspect, isPlainObject = Foundation.isPlainObject, ErrorWithInfo = Foundation.ErrorWithInfo, defineModule = Foundation.defineModule;

defineModule(module, FluxModel = (function(superClass) {
  extend(FluxModel, superClass);

  FluxModel.abstractClass();

  FluxModel.declarable({
    staleDataReloadSeconds: null,
    minNetworkFailureReloadSeconds: null,
    maxNetworkFailureReloadSeconds: 2e308,
    minServerFailureReloadSeconds: null,
    maxServerFailureReloadSeconds: 2e308
  });

  FluxModel.getter({
    autoReloadEnabled: function() {
      return this.getStaleDataReloadSeconds() > 0 || this.getMinNetworkFailureReloadSeconds() > 0 || this.getMinServerFailureReloadSeconds() > 0;
    }
  });

  FluxModel.register = function() {
    this.singletonClass();
    return ModelRegistry.register(this.getSingleton());
  };

  FluxModel.prototype.register = function() {
    return ModelRegistry.register(this);
  };

  FluxModel.postCreateConcreteClass = function(arg) {
    var hotReloaded;
    hotReloaded = arg.hotReloaded;
    if (hotReloaded) {
      this.singleton.bindFunctionsToInstance();
    } else {
      this.register();
    }
    return FluxModel.__super__.constructor.postCreateConcreteClass.apply(this, arguments);
  };


  /*
  INPUT: zero or more strings or arrays of strings
    - arbitrary nesting of arrays is OK
    - nulls are OK, they are ignored
  OUTPUT: null
  
  NOTE: @aliases can be called multiple times.
  
  example:
    class Post extends FluxModel
      @aliases "chapterPost"
  
  purpose:
    - declare alternative names to access this model.
    - allows you to use the shortest form of FluxComponent subscriptions for each alias:
        @subscriptions "chapterPost"
      in addition to the model's class name:
        @subscriptions "post"
   */

  FluxModel.aliases = function() {
    this._aliases = compactFlatten([arguments, this._aliases]);
    return null;
  };

  FluxModel._aliases = [];

  FluxModel.prototype.onNextReady = function(f) {
    return fluxStore.onNextReady(f);
  };

  function FluxModel(name) {
    FluxModel.__super__.constructor.apply(this, arguments);
    this._name = name || decapitalize(this["class"].getName());
    this.bindFunctionsToInstance();
    this._activeLoadingRequests = {};
  }

  FluxModel.classGetter({
    models: function() {
      return ModelRegistry.models;
    },
    fluxStore: function() {
      return fluxStore;
    }
  });

  FluxModel.getter({
    models: function() {
      return ModelRegistry.models;
    },
    fluxStore: function() {
      return fluxStore;
    },
    singlesModel: function() {
      return this._singlesModel || this;
    },
    fluxStoreEntries: function() {
      return fluxStore.getEntriesForModel(this.name);
    }
  });

  FluxModel.prototype.subscribe = function(fluxKey, subscriptionFunction) {
    log.error("DEPRICATED - use FluxSubscriptionsMixin and it's subscribe");
    return fluxStore.subscribe(this._name, fluxKey, subscriptionFunction);
  };

  FluxModel.getter("name", {
    modelName: function() {
      return this._name;
    }
  });


  /*
  load the requested data for the given key and update the fluxStore
  
  required:
    Should ALWAYS call fluxStore.update immediately OR once the data is available.
    Clients will assume that a call to "load" forces a reload of the data in the fluxStore.
  
  optional:
    If the data is immediately available, you can return the fluxRecord instead of "null"
    If load was called because of a new Component being mounted and its subscriptions initialized,
      returning the fluxRecord immediately will guarantee the Component has valid data for its
      first render.
  
  Note:
    Typically called automatically by the fluxStore when a Component subscribes to
    data from this model with the given key.
  
  The simplest possible load function:
    load: (key) -> @updateFluxStore key, {}
  
  The "load" function below is:
    Simplest "load" with immediate fluxRecord return.
    Immediate return means:
     - fluxStore.subscribe() will return the fluxRecord returned from this "load"
     - FluxComponent subscriptions will update state in time for the inital render.
  
  inputs:
    key: string
  
  side effects:
    expected to call fluxStore.update @_name, key, fluxRecord
      - when fluxRecord.status is no longer pending
      - optionally as progress is made loading the fluxRecord.data
  
  returns: null OR fluxRecord if the value is immediately available
    NOTE: load can return null or fluxRecord as it chooses. The client shouldn't
      rely on the fact that it returned a fluxRecord with a set of inputs, it might not
      the next time.
  
  Optionally, you can implement one of two altenative load functions with Promise support:
  
    loadData:       (key) ->
                      promise.then (data) ->
                        if data is null or undefined, status will be set to missing
                        otherwise, status will be success
                      promise.catch (a validStatus or error info, status becomes failure) ->
    loadFluxRecord: (key) -> promise.then (fluxRecord) ->
  
    @load will take care of updating FluxStore.
   */

  FluxModel.prototype.load = function(key) {
    if (this.loadData || this.loadFluxRecord) {
      this.loadPromise(key);
      return null;
    } else {
      return this.updateFluxStore(key, {
        status: missing
      });
    }
  };


  /*
  NOTE: @loadData or @loadFluxRecord should be implemented.
  @loadPromise is an alternative to @load
  
  Unlike @load, @loadPromise returns a promise that resolves when the load is done.
  
  The down-side is @loadPromise cannot immediately update the flux-store. If you have
  a model which stores its data locally, like ApplicationState, then override @load
  for immediate fluxStore updates.
  
  However, if your model always has to get the data asynchronously, override @loadData
  or @loadFluxRecord and use @loadPromise anytime you need to manually trigger a load.
  
  EFFECTS:
  - Triggers loadData or loadFluxRecord.
  - Puts the results in the fluxStore.
  - Elegently reduces multiple in-flight requests with the same key to one Promise.
    @loadData or @loadFluxRecord will only be invoked once per key while their
    returned promises are unresolved.
    NOTE: the block actually extends all the way through to the fluxStore being updated.
    That means you can immediately call @fluxStoreGet and get the latest data - when
    the promise resolves.
  
  OUT: promise.then (fluxRecord) ->
    fluxRecord: the latest, just-loaded data
    ERRORS: errors are encoded into the fluxRecord. The promise should always resolve.
   */

  FluxModel.prototype.loadPromise = function(key) {
    var p;
    if (p = this._activeLoadingRequests[key]) {
      log("saved 1 reload due to activeLoadingRequests! (model: " + this.name + ", key: " + key + ")");
      return p;
    }
    p = this.loadData ? Promise.then((function(_this) {
      return function() {
        return _this.loadingRecord(key);
      };
    })(this)).then((function(_this) {
      return function() {
        return _this.loadData(key);
      };
    })(this)).then((function(_this) {
      return function(data) {
        return _this.updateFluxStore(key, data != null ? {
          status: success,
          data: data
        } : {
          status: missing
        });
      };
    })(this))["catch"]((function(_this) {
      return function(error) {
        var info, ref1, status;
        status = validStatus(status = (error != null ? (ref1 = error.info) != null ? ref1.status : void 0 : void 0) || error) ? status : failure;
        info = error != null ? error.info : void 0;
        if (!(error instanceof Error)) {
          error = null;
        }
        return _this.updateFluxStore(key, {
          status: status,
          info: info,
          error: error
        });
      };
    })(this)) : this.loadFluxRecord ? this.loadFluxRecord(key).then((function(_this) {
      return function(fluxRecord) {
        return _this.updateFluxStore(key, fluxRecord);
      };
    })(this))["catch"]((function(_this) {
      return function(error) {
        return _this.updateFluxStore(key, {
          status: failure,
          error: error
        });
      };
    })(this)) : Promise.resolve(this.updateFluxStore(key, {
      status: missing
    }));
    return this._activeLoadingRequests[key] = p.then((function(_this) {
      return function(result) {
        _this.onNextReady();
        return result;
      };
    })(this)).then((function(_this) {
      return function(result) {
        _this._activeLoadingRequests[key] = null;
        return result;
      };
    })(this));
  };

  FluxModel.prototype.reload = function(key) {
    if (this.loadData || this.loadFluxRecord) {
      return this.loadPromise(key);
    } else {
      return this.load(key);
    }
  };

  FluxModel.prototype.loadingRecord = function(key) {
    var fluxRecord, ref1;
    if (isFailure((ref1 = (fluxRecord = this.fluxStoreGet(key))) != null ? ref1.status : void 0)) {
      return this.updateFluxStore(key, merge(fluxRecord, {
        status: pending
      }));
    }
  };

  FluxModel.prototype.updateFluxStore = function(key, fluxRecord) {
    return fluxStore.update(this._name, key, fluxRecord);
  };

  FluxModel.prototype.onModelRegistered = function(modelName) {
    return ModelRegistry.onModelRegistered(modelName);
  };

  FluxModel.prototype.fluxStoreGet = function(key) {
    return fluxStore.get(this._name, this.toKeyString(key));
  };

  FluxModel.prototype.get = function(key) {
    key = this.toKeyString(key);
    return Promise.then((function(_this) {
      return function() {
        var currentFluxRecord;
        if (currentFluxRecord = _this.fluxStoreGet(key)) {
          if (currentFluxRecord.status === pending) {
            currentFluxRecord = null;
          }
        }
        return currentFluxRecord || _this.loadPromise(key);
      };
    })(this)).then(function(fluxRecord) {
      var data, status;
      status = fluxRecord.status, data = fluxRecord.data;
      if (status !== success) {
        new ErrorWithInfo("FluxModel#get: Error getting data. Status: " + status + ".", {
          status: status,
          fluxRecord: fluxRecord
        });
      }
      return data;
    });
  };

  FluxModel.prototype.toKeyString = function(key) {
    if (isPlainObject(key)) {
      return this.dataToKeyString(key);
    } else if (isString(key)) {
      return key;
    } else {
      throw new Error("FluxModel " + this.name + ": Must implement custom toKeyString for non-string keys like: " + (formattedInspect(key)));
    }
  };

  FluxModel.prototype.dataToKeyString = function(obj) {
    throw new Error("FluxModel " + this.name + ": must override dataToKeyString for converting objects to key-strings.");
  };

  FluxModel.prototype.fluxStoreEntryUpdated = function(entry) {};

  FluxModel.prototype.fluxStoreEntryAdded = function(entry) {};

  FluxModel.prototype.fluxStoreEntryRemoved = function(entry) {};


  /*
  localStorage helper methods
   */

  FluxModel.prototype._localStoreKey = function(id) {
    return "fluxModel:" + this._name + ":" + id;
  };

  FluxModel.prototype._localStoreGet = function(id) {
    var data;
    if (data = localStorage.getItem(this._localStoreKey(id))) {
      return JSON.parse(data);
    } else {
      return null;
    }
  };

  FluxModel.prototype._localStoreSet = function(id, data) {
    return localStorage.setItem(this._localStoreKey(id), JSON.stringify(data));
  };

  return FluxModel;

})(InstanceFunctionBindingMixin(BaseObject)));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, CommunicationStatus, ModelRegistry, capitalize, defineModule, fluxStore, globalCount, isFailure, isFunction, isPlainObject, isString, log, mergeInfo, nextTick, ref, rubyTrue, success, time,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), isString = ref.isString, defineModule = ref.defineModule, isPlainObject = ref.isPlainObject, rubyTrue = ref.rubyTrue, CommunicationStatus = ref.CommunicationStatus, log = ref.log, isFunction = ref.isFunction, BaseObject = ref.BaseObject, nextTick = ref.nextTick, mergeInfo = ref.mergeInfo, capitalize = ref.capitalize, globalCount = ref.globalCount, time = ref.time;

success = CommunicationStatus.success, isFailure = CommunicationStatus.isFailure;

fluxStore = __webpack_require__(135).fluxStore;

ModelRegistry = __webpack_require__(83);

defineModule(module, function() {
  return function(superClass) {
    var FluxSubscriptionsMixin;
    return FluxSubscriptionsMixin = (function(superClass1) {
      var getRetryNow;

      extend(FluxSubscriptionsMixin, superClass1);

      function FluxSubscriptionsMixin() {
        FluxSubscriptionsMixin.__super__.constructor.apply(this, arguments);
        this._subscriptions = {};
      }

      FluxSubscriptionsMixin.getter({
        models: function() {
          return ModelRegistry.models;
        },
        subscriptions: function() {
          return this._subscriptions;
        }
      });


      /*
      subscribe OR update a subscription
      
      IN:
        subscriptionKey: string (REQUIRED - if no stateField OR modelName)
          Provide a unique key for each active subscription.
          To update the suscription, call @subscribe again with the same subscriptionKey.
          To unsubscribe, call @unsubscribe with the same subscriptionKey.
          DEFAULT: stateField || modelName
      
        modelName: lowerCamelCase string
          if modelName is null/undefined then
            - no subscription will be created.
            - @unsubscribe subscriptionKey will still happen
      
        key: valid input for models[modelName].toKeyString - usually it's a string
          if key is null/undefined then
            - no subscription will be created.
            - @unsubscribe subscriptionKey will still happen
      
        options:
           * if provided, will call @setState(stateField, ...) immediately and with every change
          stateField: string
      
          initialFluxRecord: fluxRecord-style object
      
           * get called with every change
          callback / updatesCallback:  (fluxRecord) -> ignored
      
        NOTE: One of options.stateField OR options.updatesCallback is REQUIRED.
      
      OUT: existingFluxRecord || initialFluxRecord || status: missing fluxRecord
      
      EFFECT:
        Establishes a FluxStore subscription for the given model and fluxKey.
        Upon any changes to the fluxRecord, will:
          call updatesCallback, if provided
          and/or @setStateFromFluxRecord if stateField was provided
      
        Will also call @setStateFromFluxRecord immediately, if stateField is provided,
          with either the initialFluxRecord, or the existing fluxRecord, if any
      
        If there was already a subscription in this object with they same subscriptionKey,
        then @unsubscribe subscriptionKey will be called before setting up the new subscription.
      
        NOTE:
          updateCallback only gets called when fluxRecord changes. It will not be called with the
          current value. HOWEVER, the current fluxRecord is returned from the subscribe call.
      
          If you need to update anything based on the current value, use the return result.
       */

      FluxSubscriptionsMixin.prototype.subscribe = function(subscriptionKey, modelName, key, options) {
        var allOptions, callback, fluxKey, initialFluxRecord, model, stateField, subscriptionFunction, updatesCallback;
        if (isPlainObject(allOptions = subscriptionKey)) {
          subscriptionKey = allOptions.subscriptionKey, modelName = allOptions.modelName, key = allOptions.key, stateField = allOptions.stateField, initialFluxRecord = allOptions.initialFluxRecord, updatesCallback = allOptions.updatesCallback, callback = allOptions.callback;
          updatesCallback || (updatesCallback = callback);
          subscriptionKey || (subscriptionKey = stateField || (modelName + " " + key));
        } else {
          stateField = options.stateField, initialFluxRecord = options.initialFluxRecord, updatesCallback = options.updatesCallback;
        }
        if (!isString(subscriptionKey)) {
          throw new Error("REQUIRED: subscriptionKey");
        }
        if (!(isString(stateField) || isFunction(updatesCallback))) {
          throw new Error("REQUIRED: updatesCallback or stateField");
        }
        this.unsubscribe(subscriptionKey);
        if (!(rubyTrue(key) && modelName)) {
          return this.setStateFromFluxRecord(stateField, initialFluxRecord || {
            status: success
          });
        }
        if (!(model = this.models[modelName])) {
          throw new Error("No model registered with the name: " + modelName + ". Registered models:\n  " + (Object.keys(this.models).join("\n  ")));
        }
        fluxKey = model.toKeyString(key);
        subscriptionFunction = (function(_this) {
          return function(fluxRecord) {
            if (typeof updatesCallback === "function") {
              updatesCallback(fluxRecord);
            }
            return _this.setStateFromFluxRecord(stateField, fluxRecord);
          };
        })(this);
        this._subscriptions[subscriptionKey] = {
          modelName: modelName,
          fluxKey: fluxKey,
          subscriptionFunction: subscriptionFunction
        };
        return this.setStateFromFluxRecord(stateField, fluxStore.subscribe(modelName, fluxKey, subscriptionFunction, initialFluxRecord), initialFluxRecord);
      };


      /*
      IN: same as @subscribe
      OUT: promise.then -> # subscription has been created
      USE:
        Primarilly useful for models which want to subscribe to
        other models when they are constructed. This solves the
        loading-order problem.
       */

      FluxSubscriptionsMixin.prototype.subscribeOnModelRegistered = function(subscriptionKeyOrOptions, modelName, fluxKey, options) {
        if (isPlainObject(subscriptionKeyOrOptions)) {
          modelName = subscriptionKeyOrOptions.modelName;
        }
        return ModelRegistry.onModelRegistered(modelName).then((function(_this) {
          return function() {
            return _this.subscribe(subscriptionKeyOrOptions, modelName, fluxKey, options);
          };
        })(this));
      };

      FluxSubscriptionsMixin.prototype.unsubscribe = function(subscriptionKey) {
        var fluxKey, modelName, subscription, subscriptionFunction;
        if (subscription = this._subscriptions[subscriptionKey]) {
          subscriptionFunction = subscription.subscriptionFunction, modelName = subscription.modelName, fluxKey = subscription.fluxKey;
          fluxStore.unsubscribe(modelName, fluxKey, subscriptionFunction);
          delete this._subscriptions[subscriptionKey];
        }
        return null;
      };

      FluxSubscriptionsMixin.prototype.unsubscribeAll = function() {
        var __, ref1, subscriptionKey;
        ref1 = this._subscriptions;
        for (subscriptionKey in ref1) {
          __ = ref1[subscriptionKey];
          this.unsubscribe(subscriptionKey);
        }
        return null;
      };

      getRetryNow = function(modelName, key) {
        return function() {
          return fluxStore._getEntry(modelName, key).reload();
        };
      };

      FluxSubscriptionsMixin.prototype.setStateFromFluxRecord = function(stateField, fluxRecord, initialFluxRecord) {
        var data, key, modelName, progress, ref1, ref2, ref3, reloadAt, status, tryCount;
        if ((fluxRecord != null ? fluxRecord.status : void 0) !== success && (initialFluxRecord != null ? initialFluxRecord.status : void 0) === success) {
          fluxRecord = initialFluxRecord;
        }
        if (stateField && isFunction(this.setState)) {
          if (fluxRecord) {
            status = (ref1 = fluxRecord.status) != null ? ref1 : null, progress = (ref2 = fluxRecord.progress) != null ? ref2 : null, data = (ref3 = fluxRecord.data) != null ? ref3 : null;
          }
          this.setState(stateField, data);
          this.setState(stateField + "Status", status);
          this.setState(stateField + "Progress", progress);
          this.setState(stateField + "FailureInfo", fluxRecord && isFailure(status) ? ((reloadAt = fluxRecord.reloadAt, tryCount = fluxRecord.tryCount, modelName = fluxRecord.modelName, key = fluxRecord.key, fluxRecord), {
            reloadAt: reloadAt,
            tryCount: tryCount,
            status: status,
            retryNow: getRetryNow(modelName, key)
          }) : null);
        }
        return fluxRecord;
      };

      return FluxSubscriptionsMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var FluxCore, FluxModel, FluxStore, FluxSubscriptionsMixin, ModelRegistry, _package, defineModule, fluxStore;

defineModule = __webpack_require__(2).defineModule;

FluxCore = __webpack_require__(84);

FluxStore = FluxCore.FluxStore, ModelRegistry = FluxCore.ModelRegistry, FluxModel = FluxCore.FluxModel, FluxSubscriptionsMixin = FluxCore.FluxSubscriptionsMixin;

fluxStore = FluxStore.fluxStore;

defineModule(module, [
  {
    FluxSubscriptionsMixin: FluxSubscriptionsMixin,
    FluxStore: FluxStore,
    FluxModel: FluxModel,
    ModelRegistry: ModelRegistry,
    ApplicationState: __webpack_require__(265),
    models: ModelRegistry.models,
    fluxStore: fluxStore,
    _reset: function() {
      fluxStore._reset();
      return ModelRegistry._reset();
    },
    "package": _package = __webpack_require__(331),
    version: _package.version
  }
]);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(266);

module.exports.addModules({
  ApplicationState: __webpack_require__(265)
});


/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(56);

module.exports.includeInNamespace(__webpack_require__(462));

__webpack_require__(84);

__webpack_require__(463);


/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(9)).vivifySubnamespace('Art');

__webpack_require__(56);


/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(471);


/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(473);


/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, Chart, Foundation, Matrix, inspect, log, point, rect, rgbColor;

Atomic = __webpack_require__(4);

Foundation = __webpack_require__(2);

point = Atomic.point, rgbColor = Atomic.rgbColor, rect = Atomic.rect, Matrix = Atomic.Matrix;

inspect = Foundation.inspect, log = Foundation.log;

module.exports = Chart = (function() {
  function Chart() {}

  Chart.bar = function(numbers, options) {
    var barArea, barColor, barWidth, bgColor, chartBgColor, drawArea, drawMatrix, fontSize, height, i, j, k, len, len1, margin, maxNumber, minWidth, out, percent, pixelsPerPoint, pos, range, size, textColor;
    if (options == null) {
      options = {};
    }
    range = options.range;
    pixelsPerPoint = options.pixelsPerPoint || 2;
    fontSize = options.fontSize || 10;
    margin = options.margin || (range ? fontSize * 1.4 : 0);
    bgColor = rgbColor(options.bgColor || rgbColor(1, 1, 1, 0));
    chartBgColor = rgbColor(options.chartBgColor || "#fff7f0");
    barColor = rgbColor(options.barColor || "rgba(0,0,0,.5)");
    textColor = rgbColor(options.textColor || "orange");
    minWidth = options.minWidth || 50;
    size = options.size || point(numbers.length * 4, 50 + 2 * margin);
    if (options.barWidth) {
      size = size.withX(numbers.length * options.barWidth);
    }
    if (size.x < minWidth) {
      size = size.withX(minWidth);
    }
    barWidth = size.x / numbers.length;
    drawMatrix = Matrix.scale(pixelsPerPoint);
    out = new Art.Canvas.Bitmap(size.mul(pixelsPerPoint));
    out.pixelsPerPoint = pixelsPerPoint;
    out.clear(bgColor);
    drawArea = rect(0, margin, size.w, size.h - 2 * margin);
    out.drawRectangle(drawMatrix, drawArea, chartBgColor);
    pos = drawArea.left;
    maxNumber = 0;
    for (j = 0, len = numbers.length; j < len; j++) {
      i = numbers[j];
      if (i > maxNumber) {
        maxNumber = i;
      }
    }
    for (k = 0, len1 = numbers.length; k < len1; k++) {
      i = numbers[k];
      percent = i / maxNumber;
      height = drawArea.h * percent;
      barArea = rect(pos, drawArea.bottom - height, barWidth, height).round();
      out.drawRectangle(drawMatrix, barArea, barColor);
      pos += barWidth;
    }
    if (range) {
      out.drawText(Matrix.translate(0, fontSize).mul(drawMatrix), "max: " + maxNumber, {
        size: fontSize,
        color: textColor
      });
      out.drawText(Matrix.translate(0, size.y).mul(drawMatrix), range[0], {
        size: fontSize,
        color: textColor
      });
      out.drawText(Matrix.translate(size).mul(drawMatrix), range[1], {
        size: fontSize,
        color: textColor,
        align: "right"
      });
    }
    return out;
  };

  return Chart;

})();


/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

var Foundation, console,
  slice = [].slice;

Foundation = __webpack_require__(2);

console = __webpack_require__(267).console;

module.exports = [
  {
    enable: function() {
      Foundation.Log.alternativeLogger = console;
      this.enabled = true;
      return console.show();
    },
    disable: function() {
      this.enabled = false;
      Foundation.Log.alternativeLogger = null;
      console.hide();
      return console.reset();
    },
    hide: function() {
      return console.hide();
    },
    show: function() {
      return console.show();
    },
    reset: function() {
      return console.reset();
    },
    increaseWidth: function() {
      return console.increaseWidth();
    },
    decreaseWidth: function() {
      return console.decreaseWidth();
    },
    foo: function() {
      return "foo";
    },
    getShown: function() {
      return console != null ? console.getShown() : void 0;
    },
    logCore: function() {
      var ref;
      return (ref = console.logCore).call.apply(ref, [console].concat(slice.call(arguments)));
    },
    logF: function() {
      var ref;
      return (ref = console.logF).call.apply(ref, [console].concat(slice.call(arguments)));
    },
    log: function() {
      var ref;
      return (ref = console.log).call.apply(ref, [console].concat(slice.call(arguments)));
    }
  }
];


/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, Component, Div, Foundation, createObjectTreeFactory, merge, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

ref = Foundation.Browser.DomElementFactories, Div = ref.Div, createObjectTreeFactory = ref.createObjectTreeFactory;

merge = Foundation.merge, BaseObject = Foundation.BaseObject;


/*
PseudoReact.Component
---------------------

Difference between this and real React:

  - There is no virtual-dom!
  - There is no life-cycle!
  - There is no @refs
  - Methods ARE NOT BOUND to instances

  - @setState and @state are minimally supported
    - setState is epoched, on a per-component basis
    - setting the state results in a full @rerender

  - @rerender is provided for manually rerendering

  - @rerender DOEST NOT DIFF! It just re-generates EVERYTHING.
    There are NO INCREMENTAL UPDATES within a Component.
    However, you can rerender a sub-component and the parent
    component will not need to be re-rendered.

  - @render returns an HTMLElement instead of a virtual-element.

  - Component-factories don't actually return components, they return HTMLElements.
    WHY? So they can be used in @render functions in the normal React-style.
 */

module.exports = Component = (function(superClass) {
  extend(Component, superClass);

  Component.postCreate = function() {
    return this.toComponentFactory();
  };

  Component.toComponentFactory = function() {
    return createObjectTreeFactory((function(_this) {
      return function(props, children) {
        props.children || (props.children = children);
        return (new _this(props)).rerender();
      };
    })(this));
  };

  function Component(props1) {
    this.props = props1 != null ? props1 : {};
    this.state = this.getInitialState();
    this._pendingState = null;
  }

  Component.prototype.getInitialState = function() {
    return {};
  };

  Component.prototype.getPendingState = function() {
    if (this._pendingState) {
      return this._pendingState;
    }
    this._queueApplyPendingState();
    return this._pendingState = {};
  };

  Component.prototype._queueApplyPendingState = function() {
    return setTimeout(((function(_this) {
      return function() {
        return _this._applyPendingState();
      };
    })(this)), 0);
  };

  Component.prototype._applyPendingState = function() {
    var k, ref1, v;
    ref1 = this._pendingState;
    for (k in ref1) {
      v = ref1[k];
      this.state[k] = v;
    }
    this.rerender();
    return this._pendingState = null;
  };

  Component.prototype._setState = function(k, v) {
    return this.getPendingState()[k] = v;
  };

  Component.prototype.setState = function(a, b) {
    var k, results, v;
    if (a.constructor === Object) {
      results = [];
      for (k in a) {
        v = a[k];
        results.push(this._setState(k, v));
      }
      return results;
    } else {
      return this._setState(a, b);
    }
  };

  Component.prototype.rerender = function() {
    var oldRootElement, ref1;
    oldRootElement = this._rootElement;
    this._render();
    if (oldRootElement != null) {
      if ((ref1 = oldRootElement.parentElement) != null) {
        ref1.replaceChild(this._rootElement, oldRootElement);
      }
    }
    return this._rootElement;
  };

  Component.prototype.render = function() {
    return Div();
  };

  Component.prototype._render = function() {
    return this._rootElement = this.render();
  };

  return Component;

})(BaseObject);


/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(85);

module.exports.includeInNamespace(__webpack_require__(469)).addModules({
  Chart: __webpack_require__(468),
  Console: __webpack_require__(267),
  Images: __webpack_require__(268),
  ToolBar: __webpack_require__(271)
});

__webpack_require__(269);


/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, HotLoader, log, peek, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), BaseObject = ref.BaseObject, peek = ref.peek, log = ref.log;

module.exports = HotLoader = (function(superClass) {
  extend(HotLoader, superClass);

  HotLoader.singletonClass();

  HotLoader.runHot = function(m, f) {
    return HotLoader.singleton.runHot(m, f);
  };

  HotLoader.getModuleState = function() {
    return peek(HotLoader.singleton._modulePersistantState);
  };

  function HotLoader() {
    this._modulePersistantState = [];
  }

  HotLoader.prototype.runHot = function(_module, f) {
    var base, res;
    if (_module != null ? _module.hot : void 0) {
      this._modulePersistantState.push(((base = _module.hot).data || (base.data = {
        modulePersistantState: {}
      })).modulePersistantState);
      _module.hot.accept();
      _module.hot.dispose(function(data) {
        return data.modulePersistantState = _module.hot.data.modulePersistantState;
      });
    }
    res = f(peek(this._modulePersistantState));
    if (_module != null ? _module.hot : void 0) {
      this._modulePersistantState.pop();
    }
    return res;
  };

  return HotLoader;

})(BaseObject);


/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(272);

module.exports.addModules({
  HotLoader: __webpack_require__(472)
});


/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var ArtFoundationConfig, Configurable, Promise, Validator, defineModule, mergeInto, ref, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), w = ref.w, Validator = ref.Validator, defineModule = ref.defineModule, mergeInto = ref.mergeInto, Promise = ref.Promise;

Configurable = __webpack_require__(113).Configurable;

defineModule(module, ArtFoundationConfig = (function(superClass) {
  extend(ArtFoundationConfig, superClass);

  function ArtFoundationConfig() {
    return ArtFoundationConfig.__super__.constructor.apply(this, arguments);
  }

  return ArtFoundationConfig;

})(Configurable));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var Browser, Promise, array, defineModule, hasProperties, log, present, ref;

ref = __webpack_require__(1), hasProperties = ref.hasProperties, defineModule = ref.defineModule, log = ref.log, present = ref.present, array = ref.array, Promise = ref.Promise;

defineModule(module, Browser = (function() {
  var encodeMailto, encodeUri, encodeUriQuery, getAgent, isMobileBrowserRegExp1, openLink, stripLeadingSlash, stripTrailingSlash, uriPathJoin;

  function Browser() {}

  isMobileBrowserRegExp1 = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i;

  Browser.getAgent = getAgent = function() {
    return navigator.userAgent || navigator.vendor || window.opera || "";
  };

  Browser.isMobileBrowser = function() {
    return isMobileBrowserRegExp1.test(getAgent());
  };

  Browser.isSafari = function() {
    return /^((?!chrome|android).)*safari/i.test(getAgent());
  };

  Browser.iOSDetect = function() {
    return /ipad|ipod|iphone/i.test(getAgent());
  };

  Browser.androidDetect = function() {
    return /android/i.test(getAgent());
  };

  Browser.iPhoneDetect = function() {
    return /iphone|ipod/i.test(getAgent());
  };

  Browser.iPadDetect = function() {
    return /ipad/i.test(getAgent());
  };

  Browser.nativeAppDetect = function() {
    return !!global.cordova;
  };

  Browser.isTouchDevice = function() {
    return document.documentElement.ontouchstart !== void 0;
  };

  Browser.getOrientationAngle = function() {
    var ref1, ref2, ref3;
    return (ref1 = (ref2 = global.screen) != null ? (ref3 = ref2.orientation) != null ? ref3.angle : void 0 : void 0) != null ? ref1 : global.orientation;
  };

  Browser.getDomReadyPromise = function() {
    return new Promise((function(_this) {
      return function(resolve) {
        var document;
        document = global.document;
        if (!document || document.readyState !== "loading") {
          return resolve();
        } else {
          return document.addEventListener("readystatechange", function() {
            if (document.readyState === "interactive") {
              return resolve();
            }
          });
        }
      };
    })(this));
  };

  Browser.openLink = openLink = function(link) {
    return global.open(link, '_blank');
  };

  Browser.encodeUriQuery = encodeUriQuery = function(query) {
    if (!hasProperties(query)) {
      return '';
    }
    return array(query, {
      when: function(v, k) {
        return (v != null) && present(v);
      },
      "with": function(v, k) {
        return k + "=" + (encodeURIComponent(v));
      }
    }).join("&");
  };

  Browser.stripLeadingSlash = stripLeadingSlash = function(a) {
    return a.match(/^\/?(.*)/)[1];
  };

  Browser.stripTrailingSlash = stripTrailingSlash = function(a) {
    return a.match(/(^.*[^\/])\/?$/)[1];
  };

  Browser.uriPathJoin = uriPathJoin = function(a, b) {
    if (!present(a)) {
      a = null;
    }
    if (!present(b)) {
      b = null;
    }
    if (a && b) {
      if (/\:$/.test(a)) {
        return "" + a + (stripLeadingSlash(b));
      } else {
        return (stripTrailingSlash(a)) + "/" + (stripLeadingSlash(b));
      }
    } else if (a) {
      return a;
    } else if (b) {
      return b;
    } else {
      return '';
    }
  };

  Browser.encodeUri = encodeUri = function(options) {
    var host, path, port, protocol, protocolHost, query, uri;
    host = options.host, path = options.path, port = options.port, uri = options.uri, protocol = options.protocol, query = options.query;
    if (!present(uri)) {
      protocol = present(protocol) ? protocol : '';
      host = present(host) ? host : '';
      protocolHost = host ? protocol + "://" + host : protocol ? protocol + ":" : '';
      port = (function() {
        if (present(port)) {
          if (!host) {
            throw new Error("host required when specifying port");
          }
          return ":" + port;
        } else {
          return '';
        }
      })();
      uri = "" + protocolHost + port;
    }
    query = encodeUriQuery(query);
    query = present(query) ? "?" + query : '';
    return "" + (uriPathJoin(uri, path)) + query;
  };

  Browser.encodeMailto = encodeMailto = function(options) {
    var bcc, body, cc, ref1, subject, to;
    cc = options.cc, bcc = options.bcc, subject = options.subject, body = options.body, to = (ref1 = options.to) != null ? ref1 : '';
    return encodeUri({
      protocol: "mailto",
      path: to,
      query: {
        cc: cc,
        bcc: bcc,
        subject: subject,
        body: body
      }
    });
  };

  Browser.sendEmail = function(options) {
    return openLink(encodeMailto(options));
  };

  Browser.startHtmlFileDownload = function(filename, url) {
    var element;
    element = document.createElement('a');
    element.setAttribute('target', '_blank');
    element.setAttribute('href', url);
    element.setAttribute('download', filename);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
    return console.log({
      element: element
    });
  };

  return Browser;

})());

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module), __webpack_require__(3)))

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, Cookie, StandardLib, getCookie, isPlainArray, isPlainObject, isString, log, setCookie,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(1);

ClassSystem = __webpack_require__(6);

log = StandardLib.log, isString = StandardLib.isString, isPlainArray = StandardLib.isPlainArray, isPlainObject = StandardLib.isPlainObject;

BaseObject = ClassSystem.BaseObject;

setCookie = function(cookieName, cookieValue, arg) {
  var cookieString, d, expires, path;
  expires = arg.expires, path = arg.path;
  if (!isString(cookieValue)) {
    if (!(isPlainArray(cookieValue) || isPlainObject(cookieValue))) {
      throw new Error("cookieValue must be a string, array or object");
    }
    cookieValue = JSON.stringify(cookieValue);
  }
  cookieString = cookieName + "=" + cookieValue;
  if (expires) {
    d = new Date();
    d.setTime(d.getTime() + expires * 24 * 60 * 60 * 1000);
    cookieString += "; expires=" + (d.toUTCString());
  }
  if (path) {
    cookieString += "; path=" + path;
  }
  return document.cookie = cookieString;
};

getCookie = function(cookieName) {
  var c, ca, i, len, name, value;
  name = cookieName + "=";
  ca = document.cookie.split(';');
  for (i = 0, len = ca.length; i < len; i++) {
    c = ca[i];
    while (' ' === c.charAt(0)) {
      c = c.substring(1);
    }
    if (0 === c.indexOf(name)) {
      value = c.substring(name.length, c.length);
      if (value.match(/^[{[]/)) {
        value = JSON.parse(value);
      }
      return value;
    }
  }
  return "";
};

module.exports = Cookie = (function(superClass) {
  extend(Cookie, superClass);

  function Cookie() {
    return Cookie.__super__.constructor.apply(this, arguments);
  }

  Cookie.set = function(name, value, options) {
    return setCookie(name, value, options);
  };

  Cookie.get = function(name) {
    return getCookie(name);
  };

  Cookie.remove = function(name, options) {
    return setCookie(name, {
      path: options.path,
      expires: -1
    });
  };

  return Cookie;

})(BaseObject);


/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

var File, Promise, StandardLib, createElementFromHtml;

StandardLib = __webpack_require__(1);

createElementFromHtml = __webpack_require__(275).createElementFromHtml;

Promise = StandardLib.Promise;

module.exports = File = (function() {
  function File() {}

  File.request = function(options) {
    if (options == null) {
      options = {};
    }
    return new Promise(function(resolve, reject) {
      var accept, body, fileInput, multiple, onChange, ref;
      accept = options.accept, multiple = options.multiple, onChange = options.onChange;
      if ((ref = this.hiddenDivForFileInput) != null) {
        ref.parentNode.removeChild(this.hiddenDivForFileInput);
      }
      this.hiddenDivForFileInput = createElementFromHtml("<div style='height: 0px;width: 0px; overflow:hidden; position:absolute;'/>");
      body = document.body;
      fileInput = createElementFromHtml("<input type='file' " + (accept ? 'accept=' + accept : void 0) + " " + (multiple ? 'multiple=true' : void 0) + "/>");
      this.hiddenDivForFileInput.appendChild(fileInput);
      body.appendChild(this.hiddenDivForFileInput);
      fileInput.onchange = function(e) {
        var file, fileList, fileSizes, fileTypes;
        fileList = (function() {
          var i, len, ref1, results;
          ref1 = fileInput.files;
          results = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            file = ref1[i];
            results.push(file);
          }
          return results;
        })();
        fileTypes = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = fileList.length; i < len; i++) {
            file = fileList[i];
            results.push(file.type);
          }
          return results;
        })();
        fileSizes = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = fileList.length; i < len; i++) {
            file = fileList[i];
            results.push(file.size);
          }
          return results;
        })();
        if (fileList.length > 0 && fileList[0]) {
          onChange && onChange(fileList);
          return resolve(fileList);
        } else {
          return reject("no files returned");
        }
      };
      return fileInput.click();
    });
  };

  return File;

})();


/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(277);

module.exports.includeInNamespace(__webpack_require__(475)).addModules({
  Cookie: __webpack_require__(476),
  Dom: __webpack_require__(275),
  DomElementFactories: __webpack_require__(276),
  File: __webpack_require__(477)
});


/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

var _package;

module.exports = [
  __webpack_require__(1), __webpack_require__(6), __webpack_require__(113), {
    Epoch: __webpack_require__(127).EpochClass
  }, __webpack_require__(274), __webpack_require__(283), {
    "package": _package = __webpack_require__(332),
    version: _package.version
  }
];


/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

var Analytics, BaseObject, ClassSystem, StandardLib, inspectLean,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(1);

ClassSystem = __webpack_require__(6);

BaseObject = ClassSystem.BaseObject;

inspectLean = StandardLib.inspectLean;

Analytics = (function(superClass) {
  extend(Analytics, superClass);

  function Analytics() {
    return Analytics.__super__.constructor.apply(this, arguments);
  }

  Analytics.defaultCategory = "Foundation.Analytics";

  Analytics.event = function(options) {
    var action, category, label, noninteraction, value;
    if (options == null) {
      options = {};
    }
    category = options.category || this.defaultCategory;
    action = options.action;
    label = options.label;
    value = options.value;
    noninteraction = !!options.noninteraction;
    if (self._gaq) {
      self._gaq.push(['_trackEvent', category, action, label, value, noninteraction]);
      return this.rawLog("ANALYTICS-EVENT: " + (inspectLean(options)));
    } else {
      return this.rawLog("(no)ANALYTICS-EVENT: " + (inspectLean(options)));
    }
  };

  return Analytics;

})(BaseObject);


/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, BatchLoader, ClassSystem, StandardLib, inspect, log, nextTick, timeout,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(1);

ClassSystem = __webpack_require__(6);

BaseObject = ClassSystem.BaseObject;

log = StandardLib.log, inspect = StandardLib.inspect, nextTick = StandardLib.nextTick, timeout = StandardLib.timeout;

module.exports = BatchLoader = (function(superClass) {
  extend(BatchLoader, superClass);

  function BatchLoader(loadFunction) {
    this.assets = {};
    this.loadingAssets = {};
    this.loadFunction = loadFunction;
  }

  BatchLoader.prototype.load = function(sources, onLoad) {
    if (typeof sources === "string") {
      sources = [sources];
    }
    return this.loadAssets(sources, onLoad);
  };

  BatchLoader.prototype.addAsset = function(source, asset) {
    var base;
    if (asset == null) {
      throw new Error("not a valid asset: " + (inspect(asset)));
    }
    delete this.loadingAssets[source];
    (base = this.assets)[source] || (base[source] = asset);
    return this.notifyListeners();
  };

  BatchLoader.getter({
    blankInfo: function() {
      return {
        loadedFromCache: 0,
        loadedAsynchronously: 0,
        alreadyLoadingAsynchronously: 0
      };
    }
  });

  BatchLoader.prototype.loadAssets = function(sources, onLoad) {
    var info;
    info = this.blankInfo;
    sources.forEach((function(_this) {
      return function(src) {
        if (_this.assets[src] != null) {
          return info.loadedFromCache++;
        } else if (_this.loadingAssets[src]) {
          info.loadedAsynchronously++;
          return info.alreadyLoadingAsynchronously++;
        } else {
          info.loadedAsynchronously++;
          _this.loadingAssets[src] = true;
          return _this.loadFunction(src, function(src, asset) {
            return _this.addAsset(src, asset);
          });
        }
      };
    })(this));
    this.addLoaderListener(sources, onLoad, info);
    return nextTick((function(_this) {
      return function() {
        return _this.notifyListeners();
      };
    })(this));
  };

  BatchLoader.prototype.addLoaderListener = function(sources, onLoad, info) {
    this.loadingListeners || (this.loadingListeners = []);
    return this.loadingListeners.push({
      sources: sources,
      onLoad: onLoad,
      info: info
    });
  };

  BatchLoader.prototype.notifyListeners = function() {
    var allLoaded, i, j, len, len1, listener, oldloadingListeners, ref, source;
    if (!this.loadingListeners) {
      return;
    }
    oldloadingListeners = this.loadingListeners;
    this.loadingListeners = [];
    for (i = 0, len = oldloadingListeners.length; i < len; i++) {
      listener = oldloadingListeners[i];
      allLoaded = true;
      ref = listener.sources;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        source = ref[j];
        if (!this.assets[source]) {
          allLoaded = false;
        }
      }
      if (allLoaded) {
        listener.onLoad(this.assets, listener.sources, listener.info);
      } else {
        this.loadingListeners.push(listener);
      }
    }
    return this.loadingListeners;
  };

  return BatchLoader;

})(BaseObject);


/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var defineModule, fastBind, isFunction, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

ref = __webpack_require__(1), defineModule = ref.defineModule, isFunction = ref.isFunction, fastBind = ref.fastBind, log = ref.log;

defineModule(module, function() {
  return function(superClass) {
    var InstanceFunctionBindingMixin;
    return InstanceFunctionBindingMixin = (function(superClass1) {
      extend(InstanceFunctionBindingMixin, superClass1);

      function InstanceFunctionBindingMixin() {
        return InstanceFunctionBindingMixin.__super__.constructor.apply(this, arguments);
      }

      InstanceFunctionBindingMixin.getFunctionsToBindList = function() {
        if (this.hasOwnProperty("_functionsToBindList")) {
          return this._functionsToBindList;
        } else {
          return this._functionsToBindList = this._getFunctionsToBindList();
        }
      };

      InstanceFunctionBindingMixin._getFunctionsToBindList = function() {
        var k, ref1, results, v;
        ref1 = this.prototype;
        results = [];
        for (k in ref1) {
          v = ref1[k];
          if (k !== "constructor" && isFunction(v) && this.propertyIsConcrete(k) && (!this.nonBindingFunctions || indexOf.call(this.nonBindingFunctions, k) < 0)) {
            results.push(k);
          }
        }
        return results;
      };

      InstanceFunctionBindingMixin.prototype.getBoundFunctionList = function() {
        return this._boundFunctionList;
      };

      InstanceFunctionBindingMixin.prototype.bindFunctionsToInstance = function() {
        var functionsToBindList, i, j, k, len, len1, prototype, ref1;
        functionsToBindList = this["class"].getFunctionsToBindList();
        if (this._boundFunctionList) {
          ref1 = this._boundFunctionList;
          for (i = 0, len = ref1.length; i < len; i++) {
            k = ref1[i];
            if (indexOf.call(functionsToBindList, k) < 0) {
              delete this[k];
            }
          }
        }
        prototype = this["class"].prototype;
        for (j = 0, len1 = functionsToBindList.length; j < len1; j++) {
          k = functionsToBindList[j];
          this[k] = fastBind(prototype[k], this);
        }
        return this._boundFunctionList = functionsToBindList;
      };

      return InstanceFunctionBindingMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

var AsyncLocalStorage, BaseObject, ClassSystem, JsonStore, Promise, isNumber, log, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), log = ref.log, Promise = ref.Promise, isNumber = ref.isNumber;

ClassSystem = __webpack_require__(6);

AsyncLocalStorage = __webpack_require__(278);

BaseObject = ClassSystem.BaseObject;

module.exports = JsonStore = (function(superClass) {
  extend(JsonStore, superClass);

  JsonStore.singletonClass();

  function JsonStore(store) {
    if (store == null) {
      store = AsyncLocalStorage;
    }
    this.store = store;
  }

  JsonStore.prototype.setItem = function(key, value) {
    var json;
    json = null;
    return this.store.getItem(key).then((function(_this) {
      return function(oldJson) {
        if (oldJson !== (json = JSON.stringify(value))) {
          _this.store.setItem(key, json).then(function() {
            return json;
          });
        }
        return null;
      };
    })(this))["catch"](function(error) {
      log.error({
        JsonStore_setItem: {
          key: key,
          value: value,
          json: json,
          error: error
        }
      });
      throw error;
    });
  };

  JsonStore.prototype.getItem = function(key) {
    return Promise.then((function(_this) {
      return function() {
        return _this.store.getItem(key);
      };
    })(this)).then((function(_this) {
      return function(json) {
        return json && JSON.parse(json);
      };
    })(this))["catch"](function(error) {
      log.error({
        JsonStore_getItem: {
          key: key,
          json: json,
          error: error
        }
      });
      throw error;
    });
  };

  JsonStore.prototype.removeItem = function(k) {
    return Promise.then((function(_this) {
      return function() {
        return _this.store.removeItem(k);
      };
    })(this));
  };

  JsonStore.prototype.clear = function() {
    return Promise.then((function(_this) {
      return function() {
        return _this.store.clear();
      };
    })(this));
  };

  JsonStore.prototype.key = function(i) {
    return Promise.then((function(_this) {
      return function() {
        return _this.store.key(i);
      };
    })(this));
  };

  JsonStore.prototype.getLength = function() {
    return Promise.then((function(_this) {
      return function() {
        if (isNumber(_this.store.length)) {
          return _this.store.length;
        } else {
          return _this.store.getLength();
        }
      };
    })(this));
  };

  return JsonStore;

})(BaseObject);


/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

var BaseObject, ClassSystem, StandardLib, Stat, inspect, max, min, round,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(1);

ClassSystem = __webpack_require__(6);

BaseObject = ClassSystem.BaseObject;

min = StandardLib.min, max = StandardLib.max, round = StandardLib.round, inspect = StandardLib.inspect;

module.exports = Stat = (function(superClass) {
  extend(Stat, superClass);

  function Stat() {
    this.reset();
  }

  Stat.prototype.reset = function() {
    this.values = [];
    this.sum = 0;
    return this.max = this.min = null;
  };

  Stat.getter({
    length: function() {
      return this.values.length;
    },
    average: function() {
      return this.sum / this.values.length;
    },
    median: function() {
      return this.values.slice().sort()[this.length / 2 | 0];
    }
  });

  Stat.prototype.percential = function(zeroToOneHundred) {
    var i, sorted;
    i = ((this.length - 1) * zeroToOneHundred / 100) | 0;
    sorted = this.values.slice().sort(function(v1, v2) {
      return v2 - v1;
    });
    return sorted[i];
  };

  Stat.prototype.histogram = function(divisions, min, max) {
    var bin, delta, hist, j, k, len, mul, ref, ref1, v;
    if (min == null) {
      min = this.min;
    }
    if (max == null) {
      max = this.max;
    }
    delta = max - min;
    mul = divisions / delta;
    hist = {};
    for (v = j = 0, ref = divisions; j < ref; v = j += 1) {
      hist[min + v / mul] = 0;
    }
    ref1 = this.values;
    for (k = 0, len = ref1.length; k < len; k++) {
      v = ref1[k];
      bin = (v - min) * mul | 0;
      if (bin < 0) {
        bin = 0;
      }
      if (bin >= divisions) {
        bin = divisions - 1;
      }
      hist[min + bin / mul]++;
    }
    return hist;
  };

  Stat.prototype.toString = function() {
    return inspect({
      length: this.length,
      average: this.average,
      median: this.median,
      min: this.min,
      max: this.max
    });
  };

  Stat.prototype.toInfoMap = function() {
    return {
      length: this.length,
      average: this.average,
      median: this.median,
      min: this.min,
      max: this.max,
      p90: this.percential(90),
      p95: this.percential(95),
      p99: this.percential(99)
    };
  };

  Stat.prototype.toIntInfoMap = function() {
    return {
      length: this.length,
      average: round(this.average),
      median: round(this.median),
      min: round(this.min),
      max: round(this.max),
      p90: round(this.percential(90)),
      p95: round(this.percential(95)),
      p99: round(this.percential(99))
    };
  };

  Stat.prototype.toIntString = function() {
    return inspect(this.toIntInfoMap());
  };

  Stat.prototype.add = function(v) {
    this.values.push(v);
    this.sum += v;
    if (this.values.length === 1) {
      return this.max = this.min = v;
    } else {
      this.max = max(this.max, v);
      return this.min = min(this.min, v);
    }
  };

  return Stat;

})(BaseObject);


/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = [
  [__webpack_require__(280), "executePromiseSequence"], __webpack_require__(86), __webpack_require__(279), __webpack_require__(136), {
    CommunicationStatus: __webpack_require__(19),
    RestClient: __webpack_require__(142),
    Validator: __webpack_require__(33).Validator
  }
];


/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {


/*
Transaction provides a manual, yet easy way to log the before and after values
of fields over many objects.

It is "manual" in that you must:

  Pre-specify all objects you wish to track.
  Specify the properties you wish to track for all objects and/or uniquely for each object.
  Pass in the "from" values or call saveFromValues
  Pass in the "to" values or call saveToValues

Once you have capture the "from" and "to" values of the transaction, you can:

  rollBack and set all properties to their "from" values
  rollForward and set all properties to their "to" values
  interpolate(p) and set all properties to their linearly interpolated value
    between their saved "from" (p=0) and "to" (p=1) values.
    If you use interpolate:
      to/from values should be pair-wise the same type
      only to/from values of the following types will be interpolated:
        numbers
        objects implementing: a.add(b), a.sub(b) and a.mul(number)
      Non-interpolatable types are handled as follows:
        switch p
          when 0 then set to "from" values
          when 1 then set to "to" values
          else left unchanged

Example initializers:

   * example-a: track obj's "foo" and "bar" properties
  new Transaction obj, properties: ["foo", "bar"]

   * same as example-a, but also initialize obj's from-values as obj.foo=1 and obj.bar=2
  new Transaction obj, from: foo:1, bar:2

   * same as example-a, but also initialize obj's to-values as obj.foo=1 and obj.bar=2
  new Transaction obj, to: foo:1, bar:2

   * track obj1 and obj2's "foo" and "bar" properties
  new Transaction [obj1, obj2], properties: ["foo", "bar"]

   * track:
   *   obj1's foo, bar, noo and mar properties, with both from and to values initialized
   *   obj2's goo, har, noo and mar properties, with both from and to values initialized
  new Transaction [
      [obj1,
        from: foo:1, bar:2
        to:   foo:2, bar:3
      ],
      [obj2,
        from: goo:1, har:2
        to:   goo:2, har:3
      ]
    ],
    from: noo:4, mar:5
    to:   noo:4, mar:5
 */
var BaseClass, Map, SingleObjectTransaction, Transaction, cloneByStructure, eq, inspect, mapToKeysArray, mapToValuesArray, ref, rubyTrue,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), rubyTrue = ref.rubyTrue, eq = ref.eq, inspect = ref.inspect, Map = ref.Map, cloneByStructure = ref.cloneByStructure, mapToKeysArray = ref.mapToKeysArray, mapToValuesArray = ref.mapToValuesArray;

BaseClass = __webpack_require__(6).BaseClass;

SingleObjectTransaction = __webpack_require__(281);

module.exports = Transaction = (function(superClass) {
  extend(Transaction, superClass);

  Transaction.SingleObjectTransaction = SingleObjectTransaction;

  function Transaction(objects, options) {
    if (options == null) {
      options = {};
    }
    Transaction.__super__.constructor.apply(this, arguments);
    this._objects = new Map;
    if (objects.constructor === Array) {
      this.addObjects(objects);
    } else {
      this.addObject(objects);
    }
    if (options.properties) {
      this.addProperties(options.properties);
    }
    if (options.property) {
      this.addProperties([options.property]);
    }
    if (options.from) {
      this.addFromValues(options.from);
    }
    if (options.to) {
      this.addToValues(options.to);
    }
    this.saveFromValues();
  }

  Transaction.prototype.inspect = function(inspector) {
    if (!inspector) {
      return ClassSystem.Inspect.inspect(this);
    }
    inspector.put(this.classPathName + ":");
    return this.inspectParts(inspector);
  };

  Transaction.prototype.inspectParts = function(inspector) {
    return this._objects.each((function(_this) {
      return function(k, v) {
        inspector.put("\n  ");
        return inspector.inspect(v);
      };
    })(this));
  };

  Transaction.getter({
    objects: function() {
      return mapToKeysArray(this._objects);
    }
  });

  Transaction.prototype.properties = function(obj) {
    return this._objects.get(obj).properties;
  };

  Transaction.prototype.from = function(obj) {
    return this._objects.get(obj).from;
  };

  Transaction.prototype.to = function(obj) {
    return this._objects.get(obj).to;
  };

  Transaction.prototype.rollBack = function() {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.rollBack();
      };
    })(this));
  };

  Transaction.prototype.rollForward = function() {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.rollForward();
      };
    })(this));
  };

  Transaction.prototype.interpolate = function(p) {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.interpolate(p);
      };
    })(this));
  };

  Transaction.prototype.optimize = function() {
    this.optimizeProperties();
    return this.optimizeObjects();
  };

  Transaction.getter({
    hasToValues: function() {
      var result;
      result = false;
      this._objects.forEach((function(_this) {
        return function(oi) {
          if (oi.hasToValues) {
            return result = true;
          }
        };
      })(this));
      return result;
    },
    valuesChanged: function() {
      var result;
      result = false;
      this._objects.forEach((function(_this) {
        return function(object) {
          if (object.valuesChanged) {
            return result = true;
          }
        };
      })(this));
      return result;
    }
  });

  Transaction.prototype.toString = function() {
    return (this.className + "\n  ") + (this._objects.map(function(obj, single) {
      return single.toString();
    })).join("  \n");
  };

  Transaction.prototype.addFromValues = function(from) {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.addFromValues(from);
      };
    })(this));
  };

  Transaction.prototype.addToValues = function(to) {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.addToValues(to);
      };
    })(this));
  };

  Transaction.prototype.addProperties = function(properties) {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.addProperties(properties);
      };
    })(this));
  };

  Transaction.prototype.addObject = function(obj) {
    var oi;
    oi = new SingleObjectTransaction(obj);
    return this._objects.set(oi.object, oi);
  };

  Transaction.prototype.addObjects = function(objects) {
    var i, len, obj, results;
    results = [];
    for (i = 0, len = objects.length; i < len; i++) {
      obj = objects[i];
      results.push(this.addObject(obj));
    }
    return results;
  };

  Transaction.prototype.saveFromValues = function() {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.saveFromValues();
      };
    })(this));
  };

  Transaction.prototype.saveToValues = function() {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.saveToValues();
      };
    })(this));
  };

  Transaction.prototype.optimizeProperties = function() {
    return this._objects.forEach((function(_this) {
      return function(oi) {
        return oi.optimizeProperties();
      };
    })(this));
  };

  Transaction.prototype.optimizeObjects = function() {
    var objs;
    objs = this._objects;
    this._objects = new Map;
    return objs.forEach((function(_this) {
      return function(oi) {
        if (!oi.noChanges) {
          return _this._objects.set(oi.object, oi);
        }
      };
    })(this));
  };

  return Transaction;

})(BaseClass);


/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(87);

module.exports.includeInNamespace(__webpack_require__(479)).addModules({
  ArtFoundationConfig: __webpack_require__(474),
  Binary: __webpack_require__(274)
});

__webpack_require__(478);

__webpack_require__(283);


/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

var ObjectTreeFactory, compactFlatten, fastBind, isClass, isFunction, isPlainObject, log, mergeIntoBasic, ref, ref1, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), compactFlatten = ref.compactFlatten, log = ref.log, upperCamelCase = ref.upperCamelCase, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, isClass = ref.isClass;

mergeIntoBasic = function(into, source) {
  var k, v;
  for (k in source) {
    v = source[k];
    into[k] = v;
  }
  return into;
};

ref1 = __webpack_require__(1), isFunction = ref1.isFunction, fastBind = ref1.fastBind;

module.exports = ObjectTreeFactory = (function() {
  var compactFlattenObjectTreeNodeNames, deepArgsProcessing, nodeNameRegexp, preprocessElementBasic;

  function ObjectTreeFactory() {}

  deepArgsProcessing = function(array, children) {
    var el, i, len;
    for (i = 0, len = array.length; i < len; i++) {
      el = array[i];
      if (el) {
        if (el.constructor === Array) {
          deepArgsProcessing(el, children);
        } else {
          children.push(el);
        }
      }
    }
    return null;
  };


  /*
  IN: any order of args which are:
    plainObject-options: (optional)
      mergePropsInto: (intoProps, fromProps) ->
        function to merge arguments 1 on into props
        default: mergeIntoBasic
  
      inspectedName: string
        for introspection:
          Factory.getName() == inspectedName
  
      class: a class
        if specified, additioanl properties will be set on the Factory function:
          Factory.class = class
          Factory._name = class.getName() + "Factory"
  
          all concrete class-methods are made available in the Factory
          (see BaseObject.abstractClass)
  
      bind: string or array of strings
        NODE: class must be set
        list of method-names to bind from class onto the factory
  
      preprocessElement: (element) -> element
        can do custom preprocssing of each argument to the factory.
  
  
        defualt: preprocessElementBasic (no-op)
  
    function-nodeFactory: (optional) ->
      IN:
        props:    plain object mapping props to prop-values
        children: flat, compacted array of children nodes
      OUT:
        node
  
    class-nodeClass: class Foo extends BaseObject
  
  OUT: objectTreeFactory = ->
    IN:
      Arguments are compacted and flattened
      The resulting list of arguments can be any combination of:
        plainObjects for props (merged in the order they appear)
        other objects which become the 'children'
  
    OUT:
      object-tree-node generated by the nodeFactory
   */

  preprocessElementBasic = function(a) {
    return a;
  };

  ObjectTreeFactory.createObjectTreeFactory = function() {
    var Factory, TreeFactoryNode, _children, _oneProps, _props, a, abstractClass, applyArgs, bindList, i, inspectedName, j, k, klass, len, len1, mergePropsInto, nodeFactory, options, preprocessElement, v;
    for (i = 0, len = arguments.length; i < len; i++) {
      a = arguments[i];
      if (a != null) {
        switch (false) {
          case !isClass(a):
            klass = a;
            break;
          case !isFunction(a):
            nodeFactory = a;
            break;
          case !isPlainObject(a):
            options = a;
        }
      }
    }
    options || (options = {});
    klass || (klass = options["class"]);
    nodeFactory || (nodeFactory = true ? (klass || (klass = TreeFactoryNode = (function(superClass) {
      extend(TreeFactoryNode, superClass);

      function TreeFactoryNode(props1, children1) {
        this.props = props1;
        this.children = children1;
      }

      return TreeFactoryNode;

    })(BaseObject)), function(props, children) {
      return new klass(props, children);
    }) : void 0);
    mergePropsInto = options.mergePropsInto, inspectedName = options.inspectedName, preprocessElement = options.preprocessElement;
    mergePropsInto || (mergePropsInto = mergeIntoBasic);
    preprocessElement || (preprocessElement = preprocessElementBasic);
    _children = _props = _oneProps = null;
    applyArgs = function(args) {
      var el, j, len1, results;
      results = [];
      for (j = 0, len1 = args.length; j < len1; j++) {
        el = args[j];
        if (el = preprocessElement(el)) {
          switch (el.constructor) {
            case Object:
              if (_oneProps) {
                _props = {};
                mergePropsInto(_props, _oneProps);
                _oneProps = null;
              }
              if (_props) {
                results.push(mergePropsInto(_props, el));
              } else {
                results.push(_oneProps = el);
              }
              break;
            case Array:
              results.push(applyArgs(el));
              break;
            default:
              results.push(_children.push(el));
          }
        }
      }
      return results;
    };
    Factory = function() {
      _oneProps = null;
      _props = null;
      _children = [];
      applyArgs(arguments);
      return nodeFactory(_props || _oneProps || {}, _children);
    };
    if (klass) {
      Factory["class"] = klass;
      klass.Factory = Factory;
      abstractClass = (typeof klass.getAbstractClass === "function" ? klass.getAbstractClass() : void 0) || Object;
      bindList = compactFlatten([
        (function() {
          var results;
          results = [];
          for (k in klass) {
            v = klass[k];
            if (!abstractClass[k] && isFunction(v)) {
              results.push(k);
            }
          }
          return results;
        })(), options.bind
      ]);
      inspectedName || (inspectedName = klass.getName() + "Factory");
      for (j = 0, len1 = bindList.length; j < len1; j++) {
        k = bindList[j];
        Factory[k] = fastBind(klass[k], klass);
      }
    }
    if (inspectedName) {
      Factory._name = inspectedName;
    }
    Factory.inspect = function() {
      return "<" + (inspectedName || 'ObjectTreeFactory') + ">";
    };
    return Factory;
  };


  /*
  IN:
    list: a string or abitrary structure of arrays, nulls and strings
      each string is split into tokens and each token is used as the nodeTypeName to create a Tree-factory
    nodeFactory: (nodeTypeName, props, children) -> node
      IN:
        nodeTypeName: node-type name
        props:    plain object mapping props to prop-values
        children: flat, compacted array of children nodes
      OUT:
        node
  OUT:
    map from nodeNames (upperCamelCased) to the factories returned from createObjectTreeFactory
  
  TODO:
    PERFORMANCE TEST:
      createObjectTreeFactoriesFromFactories
      vs
      createObjectTreeFactoriesFromFactoryFactories
  
      The latter is probably faster. It is also more powerful and generally cleaner.
   */

  ObjectTreeFactory.createObjectTreeFactories = function(options, list, nodeFactory) {
    var ref2;
    if (!nodeFactory) {
      ref2 = [options, list], list = ref2[0], nodeFactory = ref2[1];
      options = {};
    }
    if (nodeFactory.length === 1) {
      return ObjectTreeFactory._createObjectTreeFactoriesFromFactoryFactories(options, list, nodeFactory);
    } else {
      return ObjectTreeFactory._createObjectTreeFactoriesFromFactories(options, list, nodeFactory);
    }
  };

  ObjectTreeFactory._createObjectTreeFactoriesFromFactories = function(options, list, nodeFactory) {
    var fn, i, len, nodeTypeName, out, ref2, suffix;
    suffix = options.suffix || '';
    out = {};
    ref2 = compactFlattenObjectTreeNodeNames(list);
    fn = function(nodeTypeName) {
      options.inspectedName = nodeTypeName;
      return out[upperCamelCase(nodeTypeName) + suffix] = ObjectTreeFactory.createObjectTreeFactory(options, function(props, children) {
        return nodeFactory(nodeTypeName, props, children);
      });
    };
    for (i = 0, len = ref2.length; i < len; i++) {
      nodeTypeName = ref2[i];
      fn(nodeTypeName);
    }
    return out;
  };

  nodeNameRegexp = /[a-z0-9_]+/ig;

  ObjectTreeFactory._compactFlattenObjectTreeNodeNames = compactFlattenObjectTreeNodeNames = function(list) {
    var i, len, out, ref2, str;
    if (typeof list === "string") {
      return list.match(nodeNameRegexp);
    }
    out = [];
    ref2 = compactFlatten(list);
    for (i = 0, len = ref2.length; i < len; i++) {
      str = ref2[i];
      out = out.concat(str.match(nodeNameRegexp));
    }
    return out;
  };

  ObjectTreeFactory._createObjectTreeFactoriesFromFactoryFactories = function(options, list, nodeFactoryFactory) {
    var i, len, name, nodeFactory, nodeTypeName, out, ref2, suffix;
    suffix = options.suffix || '';
    out = {};
    ref2 = compactFlattenObjectTreeNodeNames(list);
    for (i = 0, len = ref2.length; i < len; i++) {
      nodeTypeName = ref2[i];
      nodeFactory = nodeFactoryFactory(nodeTypeName);
      name = upperCamelCase(nodeTypeName) + suffix;
      options.inspectedName = name;
      out[name] = ObjectTreeFactory.createObjectTreeFactory(options, nodeFactory);
    }
    return out;
  };

  return ObjectTreeFactory;

})();


/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(490);

module.exports.includeInNamespace(__webpack_require__(488));


/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

var ObjectTreeFactory,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.ObjectTreeFactory', ObjectTreeFactory = (function(superClass) {
  extend(ObjectTreeFactory, superClass);

  function ObjectTreeFactory() {
    return ObjectTreeFactory.__super__.constructor.apply(this, arguments);
  }

  ObjectTreeFactory.version = __webpack_require__(593).version;

  return ObjectTreeFactory;

})(Neptune.PackageNamespace));


/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(138);


/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(494);


/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var defineModule, log, point, ref,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(1), defineModule = ref.defineModule, log = ref.log;

point = __webpack_require__(4).point;

defineModule(module, function() {
  return function(superClass) {
    var PointerActionsMixin;
    return PointerActionsMixin = (function(superClass1) {
      extend(PointerActionsMixin, superClass1);

      function PointerActionsMixin() {
        this.dragPointerMoveHandler = bind(this.dragPointerMoveHandler, this);
        this.dragPointerDownHandler = bind(this.dragPointerDownHandler, this);
        PointerActionsMixin.__super__.constructor.apply(this, arguments);
        this._pointerDownAt = point();
      }

      PointerActionsMixin.stateFields({
        hover: false,
        pointerIsDown: false,
        mouseIsIn: false,
        dragOffset: point()
      });

      PointerActionsMixin.prototype.setHover = function(bool) {
        var base;
        this.setState("hover", bool);
        try {
          return typeof (base = this.hoverAction || this.props.hoverAction) === "function" ? base(bool, this.props) : void 0;
        } catch (error) {}
      };

      PointerActionsMixin.property("pointerDownAt");

      PointerActionsMixin.prototype.mouseIn = function() {
        this.setState({
          mouseIsIn: true
        });
        return this.setHover(true);
      };

      PointerActionsMixin.prototype.mouseOut = function() {
        this.setState({
          mouseIsIn: false
        });
        return this.setHover(this.pointerIsDown);
      };

      PointerActionsMixin.prototype.pointerDownHandler = function() {
        this.setState({
          pointerIsDown: true
        });
        return this.setHover(true);
      };

      PointerActionsMixin.prototype.pointerUp = function() {
        this.setState({
          pointerIsDown: false
        });
        return this.setHover(this.mouseIsIn);
      };

      PointerActionsMixin.getter({
        pointerDown: function() {
          return this.pointerIsDown;
        },
        buttonHandlers: function(customAction) {
          var element;
          element = this;
          return {
            mouseIn: this.mouseIn,
            mouseOut: this.mouseOut,
            pointerDown: this.pointerDownHandler,
            pointerIn: this.pointerDownHandler,
            pointerUp: this.pointerUp,
            pointerCancel: this.pointerUp,
            pointerOut: this.pointerUp,
            pointerUpInside: (function(_this) {
              return function(event) {
                var base, base1, ref1, ref2;
                event.target.capturePointerEvents();
                if (!_this.props.disabled) {
                  if (_this.doAction) {
                    log.error("DEPRICATED: @doAction is no longer supported, use @action");
                  }
                  return typeof (base = (ref1 = customAction != null ? customAction : _this.action) != null ? ref1 : _this.props.action) === "function" ? base(event, _this.props) : void 0;
                } else {
                  return typeof (base1 = (ref2 = _this.disabledAction) != null ? ref2 : _this.props.disabledAction) === "function" ? base1(event, _this.props) : void 0;
                }
              };
            })(this)
          };
        },
        pointerHandlers: function() {
          return this.buttonHandlers;
        },
        hoverHandlers: function() {
          return {
            mouseIn: this.mouseIn,
            mouseOut: this.mouseOut
          };
        },
        dragHandlers: function() {
          return {
            mouseIn: this.mouseIn,
            mouseOut: this.mouseOut,
            pointerDown: this.dragPointerDownHandler,
            pointerMove: this.dragPointerMoveHandler,
            pointerUp: this.dragPointerUpHandler
          };
        }
      });

      PointerActionsMixin.prototype.dragMove = function(event, dragDelta) {};

      PointerActionsMixin.prototype.dragStart = function(event) {};

      PointerActionsMixin.prototype.dragEnd = function(event, dragDelta) {};

      PointerActionsMixin.prototype.dragPointerDownHandler = function(event) {
        this.pointerDownAt = event.parentLocation;
        this.dragStart(event);
        this.pointerIsDown = true;
        return this.dragMove(event, this.dragOffset = point());
      };

      PointerActionsMixin.prototype.dragPointerMoveHandler = function(event) {
        return this.dragMove(event, this.dragOffset = event.parentLocation.sub(this.pointerDownAt));
      };

      PointerActionsMixin.prototype.dragPointerUpHandler = function(event) {
        this.dragEnd(event, event.parentLocation.sub(this.pointerDownAt));
        this.dragOffset = point();
        return this.pointerIsDown = false;
      };

      return PointerActionsMixin;

    })(superClass);
  };
});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(495);

module.exports.addModules({
  PointerActionsMixin: __webpack_require__(493)
});


/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

var Mixins,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(89)).addNamespace('Mixins', Mixins = (function(superClass) {
  extend(Mixins, superClass);

  function Mixins() {
    return Mixins.__super__.constructor.apply(this, arguments);
  }

  return Mixins;

})(Neptune.PackageNamespace));


/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

var Aim, Foundation, React, VirtualElement, createObjectTreeFactories, getNextPageIndexes, log, mergeInto, objectTreeFactoryOptions, standardArtEngineElementClassNames;

Foundation = __webpack_require__(2);

React = __webpack_require__(140);

log = Foundation.log, createObjectTreeFactories = Foundation.createObjectTreeFactories, mergeInto = Foundation.mergeInto;

VirtualElement = React.VirtualElement, objectTreeFactoryOptions = React.objectTreeFactoryOptions;

getNextPageIndexes = __webpack_require__(498).getNextPageIndexes;

standardArtEngineElementClassNames = "BitmapElement BlurElement CanvasElement ShapeElement Element FillElement OutlineElement PagingScrollElement RectangleElement ShadowElement TextElement TextInputElement ScrollElement";

module.exports = Aim = (function() {
  function Aim() {}

  Aim.createVirtualElementFactories = function(VirtualElementClass, elementClassNames) {
    if (elementClassNames == null) {
      elementClassNames = standardArtEngineElementClassNames;
    }
    mergeInto(this, createObjectTreeFactories(objectTreeFactoryOptions, elementClassNames, function(elementClassName) {
      return function(props, children) {
        return new VirtualElementClass(elementClassName, props, children);
      };
    }));
    this.bindHelperFunctions();
    return this;
  };

  Aim.bindHelperFunctions = function() {
    return this.PagingScrollElement.getNextPageIndexes = getNextPageIndexes;
  };

  return Aim;

})();


/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

var Aim, ArtEngineCore, CanvasElement, Element, ElementFactory, Engine, FullScreenApp, Promise, React, globalEpochCycle, isPlainObject, log, objectWithout, ref,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

ref = __webpack_require__(2), objectWithout = ref.objectWithout, log = ref.log, isPlainObject = ref.isPlainObject, Promise = ref.Promise;

Engine = __webpack_require__(71);

React = __webpack_require__(503);

ElementFactory = Engine.ElementFactory, Element = Engine.Element, CanvasElement = Engine.CanvasElement, FullScreenApp = Engine.FullScreenApp;

module.exports = React;

Aim = __webpack_require__(496);

if (ArtEngineCore = Neptune.Art.Engine.Core) {
  globalEpochCycle = ArtEngineCore.GlobalEpochCycle.globalEpochCycle;
}

React.addElementFactories = function(elementClassNames) {
  var factories, k, ref1, v;
  ref1 = factories = Aim.createVirtualElementFactories(React.VirtualElementArtEngine, elementClassNames);
  for (k in ref1) {
    v = ref1[k];
    React[k] || (React[k] = v);
  }
  return factories;
};

React.VirtualElementArtEngine = (function(superClass) {
  var addedOrChanged, elementTemp, removed;

  extend(VirtualElementArtEngine, superClass);

  function VirtualElementArtEngine() {
    return VirtualElementArtEngine.__super__.constructor.apply(this, arguments);
  }

  elementTemp = null;

  addedOrChanged = function(k, v) {
    if (k !== "children") {
      return elementTemp.setProperty(k, v);
    }
  };

  removed = function(k, v) {
    if (k !== "children") {
      return elementTemp.resetProperty(k);
    }
  };

  VirtualElementArtEngine.prototype._updateElementProps = function(newProps) {
    var out;
    elementTemp = this.element;
    out = this._updateElementPropsHelper(newProps, addedOrChanged, removed);
    elementTemp = null;
    return out;
  };

  VirtualElementArtEngine.prototype._setElementChildren = function(childElements) {
    return this.element.setChildren(childElements);
  };

  VirtualElementArtEngine.prototype._newElement = function(elementClassName, props, childElements, bindToOrCreateNewParentElementProps) {
    var element, start;
    start = globalEpochCycle != null ? globalEpochCycle.startTimePerformance() : void 0;
    if (props.children) {
      props = objectWithout(props, "children");
    }
    element = ElementFactory.newElement(this.elementClassName, props, childElements);
    if (bindToOrCreateNewParentElementProps) {
      if (bindToOrCreateNewParentElementProps instanceof Element) {
        bindToOrCreateNewParentElementProps.addChild(element);
      } else {
        props = merge(bindToOrCreateNewParentElementProps, {
          webgl: Browser.Parse.query().webgl === "true",
          children: [element]
        });
        new CanvasElement(props);
      }
    }
    element.creator = this;
    if (globalEpochCycle != null) {
      globalEpochCycle.endTimePerformance("reactAim", start);
    }
    return element;
  };

  VirtualElementArtEngine.prototype._newErrorElement = function() {
    return this._newElement("RectangleElement", {
      key: "ART_REACT_ERROR_CREATING_CHILD_PLACEHOLDER",
      color: "orange"
    });
  };

  return VirtualElementArtEngine;

})(React.VirtualElement);


/*
IN:
  options:
    MainComponent: the MainComponent-factory to start the app with. (required)
    prepare: null or promise (optional)
      Init will wait for the prepare-promise to finish before starting the app.
 */

React.initArtReactApp = function(options) {
  var MainComponent, prepare;
  MainComponent = options.MainComponent, prepare = options.prepare;
  if (!MainComponent) {
    throw new Error("MainComponent required");
  }
  options.title || (options.title = MainComponent.getName());
  return FullScreenApp.init(options).then(function() {
    return Promise.resolve(prepare);
  }).then(function() {
    return MainComponent.instantiateAsTopComponent();
  })["catch"](function(error) {
    return log.error("Art.React.initArtReactApp failed", error);
  });
};

React.addElementFactories();


/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

var Foundation, PagingScrollElement, bound, max, min;

Foundation = __webpack_require__(2);

max = Foundation.max, min = Foundation.min, bound = Foundation.bound;


/*
SBD: I'm not sure where best to put getNextPageIndexes, so I'm putting it here for now.
It is potentially needed by any react component using PagingScrollElement. I'd put it on the
actual PagingScrollElement Element class, but that class isn't loaded when doing React in
a web-worker.

getNextPageIndexes could be reusable with any PagingScrollElement where pages are indexed
and the maxPageIndex and minPageIndex are known. It's even OK if maxPageIndex and
minPageIndex change - as long as they don't change too much per frame.

IN:
  lastPageIndexes =
      firstPageIndex: 0
      lastPageIndex:  2

    essentially, this is the output from last call. For the first call, do 0 and 2

  currentGeometry =
      suggestedPagesBeforeFocusedPage: 1
      suggestedPagesAfterFocusedPage:  1

    set from currentGeometry from the last onScollChange event

  focusedPageIndex = integer;       the current focused page index
  maxKeep =          integer >= 0;  see below
  maxPrerender =     integer >= 0;  see below
  maxPageIndex =     integer;       see below
  minPageIndex =     0 (integer);   see below

OUT:
  null if nothing changed, else, returns the next range of pages to render for PagingScrollElement:
    firstPageIndex: integer
    lastPageIndex:  integer

Supports:
  minPageIndex / maxPageIndex: output page indexes will be: minPageIndex <= output page index <= maxPageIndex
  maxKeep: maximum number of already rendered pages to keep even though they are no longer
    in the suggested + prerender window
  maxPrerender: in addition to the suggestedPages from PagingScrollElement, render this many extra pages.
    This is useful if the pages trigger external network requests which ideally would be complete before
    the page is displayed on screen. If pages are showing up that are not fully loaded, increase this
    value.

    Down-sides:
      increased initial render time
      increased memory use

    Up-sides:
      should not significantly effect performance after initial render, even during scrolling
      gives external data requests triggered by page renders more time to complete before the page is onscreen
 */

module.exports = PagingScrollElement = (function() {
  function PagingScrollElement() {}

  PagingScrollElement.getNextPageIndexes = function(lastPageIndexes, suggestedPageSpread, focusedPageIndex, maxKeep, maxPrerender, maxPageIndex, minPageIndex) {
    var firstPageIndex, lastPageIndex, newFirstPageIndex, newLastPageIndex;
    if (minPageIndex == null) {
      minPageIndex = 0;
    }
    firstPageIndex = lastPageIndexes.firstPageIndex, lastPageIndex = lastPageIndexes.lastPageIndex;
    newFirstPageIndex = focusedPageIndex - suggestedPageSpread - maxPrerender;
    newLastPageIndex = focusedPageIndex + suggestedPageSpread + maxPrerender;
    if (firstPageIndex != null) {
      newFirstPageIndex = bound(firstPageIndex - 1, newFirstPageIndex, firstPageIndex + 1);
    }
    if (lastPageIndex != null) {
      newLastPageIndex = bound(lastPageIndex - 1, newLastPageIndex, lastPageIndex + 1);
    }
    firstPageIndex = max(minPageIndex, bound(newFirstPageIndex - maxKeep, firstPageIndex, newFirstPageIndex));
    lastPageIndex = min(maxPageIndex, bound(newLastPageIndex, lastPageIndex, newLastPageIndex + maxKeep));
    if (firstPageIndex === lastPageIndexes.firstPageIndex && lastPageIndex === lastPageIndexes.lastPageIndex) {
      return null;
    } else {
      return {
        firstPageIndex: firstPageIndex,
        lastPageIndex: lastPageIndex
      };
    }
  };

  return PagingScrollElement;

})();


/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

var Component, arrayWith, isPlainArray, isString, log, reactArtEngineEpoch, ref;

Component = __webpack_require__(137);

reactArtEngineEpoch = __webpack_require__(88).reactArtEngineEpoch;

ref = __webpack_require__(2), isPlainArray = ref.isPlainArray, isString = ref.isString, arrayWith = ref.arrayWith, log = ref.log;

module.exports = [
  [Component, "createAndInstantiateTopComponent", "createComponentFactory"], {
    instantiateTopComponent: function(componentInstance, bindToOrCreateNewParentElementProps) {
      console.warn("React.instantiateTopComponent is DEPRICATED. Use: componentInstance.instantiateAsTopComponent");
      return componentInstance.instantiateAsTopComponent(bindToOrCreateNewParentElementProps);
    },
    onNextReady: function(callback) {
      return reactArtEngineEpoch.onNextReady(callback);
    },
    objectTreeFactoryOptions: {
      mergePropsInto: function(into, props) {
        var k, oldValue, v;
        for (k in props) {
          v = props[k];
          into[k] = k === "text" && isPlainArray(v) && isPlainArray(oldValue = into[k]) ? oldValue.concat(v) : v;
        }
        return into;
      },
      preprocessElement: function(element) {
        if (isString(element)) {
          return {
            text: element
          };
        } else {
          return element;
        }
      }
    }
  }
];


/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

var Component, Foundation, HotStyleProps,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Component = __webpack_require__(137);

module.exports = HotStyleProps = (function(superClass) {
  extend(HotStyleProps, superClass);

  function HotStyleProps() {
    return HotStyleProps.__super__.constructor.apply(this, arguments);
  }

  HotStyleProps.postCreate = function(arg) {
    var hotReloaded;
    hotReloaded = arg.hotReloaded;
    if (hotReloaded) {
      Component.rerenderAll();
    }
    return HotStyleProps.__super__.constructor.postCreate.apply(this, arguments);
  };

  return HotStyleProps;

})(Foundation.BaseObject);


/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var BaseObject, Browser, Foundation, Promise, VirtualElement, VirtualNode, compactFlatten, defineModule, globalCount, inspect, isPlainObject, isWebWorker, keepIfRubyTrue, log, merge, objectDiff, objectHasKeys, propsEq, shallowClone, stackTime, time, toInspectedObjects,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

VirtualNode = __webpack_require__(139);

objectHasKeys = Foundation.objectHasKeys, toInspectedObjects = Foundation.toInspectedObjects, log = Foundation.log, compactFlatten = Foundation.compactFlatten, globalCount = Foundation.globalCount, time = Foundation.time, stackTime = Foundation.stackTime, BaseObject = Foundation.BaseObject, shallowClone = Foundation.shallowClone, inspect = Foundation.inspect, keepIfRubyTrue = Foundation.keepIfRubyTrue, stackTime = Foundation.stackTime, isPlainObject = Foundation.isPlainObject, compactFlatten = Foundation.compactFlatten, isWebWorker = Foundation.isWebWorker, objectDiff = Foundation.objectDiff, Browser = Foundation.Browser, merge = Foundation.merge, Promise = Foundation.Promise, propsEq = Foundation.propsEq, defineModule = Foundation.defineModule;

defineModule(module, VirtualElement = (function(superClass) {
  var emptyProps;

  extend(VirtualElement, superClass);

  VirtualElement.created = 0;

  VirtualElement.instantiated = 0;

  emptyProps = {};

  function VirtualElement(elementClassName, props, children) {
    VirtualElement.created++;
    this.elementClassName = elementClassName;
    VirtualElement.__super__.constructor.call(this, props || emptyProps);
    this.children = this._validateChildren(compactFlatten(children, keepIfRubyTrue));
  }

  VirtualElement.getter({
    inspectedName: function() {
      var elementClassName, key, ref;
      ref = this, key = ref.key, elementClassName = ref.elementClassName;
      return "Virtual-" + elementClassName + (key ? "-" + key : '');
    },
    inspectedObjects: function() {
      var obj;
      return (
        obj = {},
        obj["" + this.inspectedName] = this.inspectedObjectsContents,
        obj
      );
    },
    inspectedObjectsContents: function() {
      if (this.children.length > 0) {
        return compactFlatten([
          {
            props: this.props
          }, toInspectedObjects(this.children)
        ]);
      } else {
        return {
          props: this.props
        };
      }
    }
  });


  /*
  EFFECT: execute the function 'f' with the Concrete-Element associated with this VirtualElement.
  IN: f = (concreteElement) -> x
  OUT: promise.then (x) ->
  
  OVERRIDE: OK
  
  PURPOSE: This is provided for the web-worker React so you can access the concrete element even though it is
    in another context. In that case, "f" will be serialized and any closure will be lost...
   */

  VirtualElement.prototype.withElement = function(f) {
    return new Promise((function(_this) {
      return function(resolve) {
        return resolve(f(_this.element));
      };
    })(this));
  };

  VirtualElement.prototype._updateElementProps = function(newProps) {};

  VirtualElement.prototype._setElementChildren = function(childElements) {};

  VirtualElement.prototype._newElement = function(elementClassName, props, childElements, bindToOrCreateNewParentElementProps) {
    return elementClassName;
  };

  VirtualElement.prototype._newErrorElement = function() {
    return null;
  };

  VirtualElement.prototype._findOldChildToUpdate = function(child) {
    var i, j, len, oldChild, oldChildren;
    oldChildren = this.children;
    for (i = j = 0, len = oldChildren.length; j < len; i = ++j) {
      oldChild = oldChildren[i];
      if (oldChild) {
        if (oldChild._canUpdateFrom(child)) {
          oldChildren[i] = null;
          return oldChild;
        }
      }
    }
    return null;
  };

  VirtualElement.prototype._canUpdateFrom = function(b) {
    return this.elementClassName === b.elementClassName && this.key === b.key;
  };


  /*
  _fastUpdateChildren
    if no Nodes were added, removed or changed "types"
      _updateFrom newChild for all oldChildren
      return true
    else
       * use _slowUpdateChildren instead
      return false
   */

  VirtualElement.prototype._fastUpdateChildren = function(newChildren) {
    var i, j, k, len, len1, oldChild, oldChildren;
    oldChildren = this.children;
    if (oldChildren.length !== newChildren.length) {
      return false;
    }
    for (i = j = 0, len = oldChildren.length; j < len; i = ++j) {
      oldChild = oldChildren[i];
      if (!oldChild._canUpdateFrom(newChildren[i])) {
        return false;
      }
    }
    for (i = k = 0, len1 = oldChildren.length; k < len1; i = ++k) {
      oldChild = oldChildren[i];
      oldChild._updateFrom(newChildren[i]);
    }
    return true;
  };

  VirtualElement.prototype._slowUpdateChildren = function(newChildren) {
    var child, childElements, finalChild, i, j, len, newChild, oldChild, oldChildren;
    oldChildren = this.children;
    childElements = (function() {
      var j, len, results;
      results = [];
      for (i = j = 0, len = newChildren.length; j < len; i = ++j) {
        newChild = newChildren[i];
        finalChild = (oldChild = this._findOldChildToUpdate(newChild)) ? newChildren[i] = oldChild._updateFrom(newChild) : newChild._instantiate(this._parentComponent);
        results.push(finalChild.element);
      }
      return results;
    }).call(this);
    for (j = 0, len = oldChildren.length; j < len; j++) {
      child = oldChildren[j];
      if (child) {
        child._unmount();
      }
    }
    this._setElementChildren(childElements);
    return this.children = newChildren;
  };


  /*
  returns true if children changed
    if true, element.setChildren was called
    if false, the children individually may change, but
      this element's children are the same set
   */

  VirtualElement.prototype._updateChildren = function(newChildren) {
    if (this._fastUpdateChildren(newChildren)) {
      return false;
    } else {
      this._slowUpdateChildren(newChildren);
      return true;
    }
  };

  VirtualElement.prototype._unmount = function() {
    var child, j, len, ref, results;
    ref = this.children;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      results.push(child._unmount());
    }
    return results;
  };

  VirtualElement.prototype._updateFrom = function(newNode) {
    var childrenChanged, propsChanged;
    VirtualElement.__super__._updateFrom.apply(this, arguments);
    if (!this.element) {
      return;
    }
    propsChanged = this._updateElementProps(newNode.props);
    childrenChanged = this._updateChildren(newNode.children);
    return this;
  };


  /*
  create element or componentInstance
  fully generate Virtual-AIM subbranch
  fully create all AIM elements
  returns this
   */

  VirtualElement.prototype._instantiate = function(parentComponent, bindToOrCreateNewParentElementProps) {
    var child, childElements, childIndex, error;
    VirtualElement.__super__._instantiate.apply(this, arguments);
    VirtualElement.instantiated++;
    childElements = (function() {
      var j, len, ref, results;
      ref = this.children;
      results = [];
      for (childIndex = j = 0, len = ref.length; j < len; childIndex = ++j) {
        child = ref[childIndex];
        try {
          child._instantiate(parentComponent);
          results.push(child.element);
        } catch (error1) {
          error = error1;
          log.error(error);
          log.error({
            "Error instantiating child": {
              childIndex: childIndex,
              error: error,
              child: child,
              elementClassName: this.elementClassName,
              props: this.props
            }
          });
          results.push(this._newErrorElement());
        }
      }
      return results;
    }).call(this);
    this.element = this._newElement(this.elementClassName, this.props, childElements, bindToOrCreateNewParentElementProps);
    return this;
  };

  VirtualElement.prototype._updateElementPropsHelper = function(newProps, addedOrChanged, removed) {
    var newPropsLength, noChange, noChangeCount, oldProps, oldPropsLength;
    oldPropsLength = this.getPropsLength();
    oldProps = this.props;
    noChangeCount = 0;
    noChange = function() {
      return noChangeCount++;
    };
    newPropsLength = this.setPropsLength(objectDiff(newProps, oldProps, addedOrChanged, removed, addedOrChanged, noChange, propsEq));
    if (newPropsLength === noChangeCount && oldPropsLength === newPropsLength) {
      return false;
    } else {
      this.props = this._rawProps = newProps;
      return true;
    }
  };

  return VirtualElement;

})(VirtualNode));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(140);


/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(89);

module.exports.includeInNamespace(__webpack_require__(502));

__webpack_require__(140);


/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(9)).vivifySubnamespace('Art');

__webpack_require__(89);


/***/ }),
/* 505 */
/***/ (function(module, exports) {




/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

var BaseClass, Promise, RequestError, RestClient, StandardLib, aborted, appendQuery, capitalizedDashCase, decodeHttpStatus, each, failureTypes, formattedInspect, isNumber, log, merge, networkFailure, object, objectKeyCount, objectWithout, present, ref, ref1, serverFailure, success, timeout, w,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

StandardLib = __webpack_require__(1);

ref = __webpack_require__(1), objectWithout = ref.objectWithout, formattedInspect = ref.formattedInspect, present = ref.present, Promise = ref.Promise, merge = ref.merge, isNumber = ref.isNumber, timeout = ref.timeout, log = ref.log, objectKeyCount = ref.objectKeyCount, appendQuery = ref.appendQuery, object = ref.object, RequestError = ref.RequestError, object = ref.object, w = ref.w, capitalizedDashCase = ref.capitalizedDashCase, each = ref.each;

ref1 = __webpack_require__(19), networkFailure = ref1.networkFailure, success = ref1.success, serverFailure = ref1.serverFailure, aborted = ref1.aborted, failureTypes = ref1.failureTypes, decodeHttpStatus = ref1.decodeHttpStatus;

BaseClass = __webpack_require__(6).BaseClass;

__webpack_require__(505);

module.exports = RestClient = (function(superClass) {
  var legalVerbs, normalizeHeaders;

  extend(RestClient, superClass);

  function RestClient() {
    return RestClient.__super__.constructor.apply(this, arguments);
  }

  RestClient.singletonClass();

  RestClient.RestClientClass = RestClient;

  RestClient.legalVerbs = legalVerbs = {};

  each(w("get put post delete head"), function(v) {
    var upper;
    upper = v.toUpperCase();
    return legalVerbs[v.toLowerCase()] = legalVerbs[upper] = upper;
  });

  RestClient.get = function(url, options) {
    return RestClient.singleton.get(url, options);
  };

  RestClient.put = function(url, data, options) {
    return RestClient.singleton.put(url, data, options);
  };

  RestClient.post = function(url, data, options) {
    return RestClient.singleton.post(url, data, options);
  };

  RestClient["delete"] = function(url, options) {
    return RestClient.singleton["delete"](url, options);
  };

  RestClient.getArrayBuffer = function(url, options) {
    return RestClient.singleton.getArrayBuffer(url, options);
  };

  RestClient.getJson = function(url, options) {
    return RestClient.singleton.getJson(url, options);
  };

  RestClient.deleteJson = function(url, options) {
    return RestClient.singleton.deleteJson(url, options);
  };

  RestClient.putJson = function(url, data, options) {
    return RestClient.singleton.putJson(url, data, options);
  };

  RestClient.postJson = function(url, data, options) {
    return RestClient.singleton.postJson(url, data, options);
  };

  RestClient.restRequest = function(options) {
    return RestClient.singleton.restRequest(options);
  };

  RestClient.restJsonRequest = function(options) {
    return RestClient.singleton.restJsonRequest(options);
  };


  /*
  get/put/post/delete
  
  IN:
    url: valid url string
  
    data: (only on PUT/POST requests)
      data to send
      NOTE: must be null if using formData
  
    options:
  
      formData: plain object of key-value pairs to submit as form-data
        You can even use this for "get" requests.
        NOTE: "data" must be null if using "formData"
  
      headers: plain object of additional HTTP headers to set
  
      onProgress: (restRequestStatus) -> null
        called each time progress is made
        NOTE: restRequestStatus.progress contains a 0-to-1 number that indicates how much progress has been made.
          progress indicates DOWNLOAD progress for GET requests and UPLOAD progress for all others.
  
      responseType: "arraybuffer", "blob", "document", "json", or "text"
        default: "text"
        NOTE: "json" is handled manually since IE11 and iOS7 don't support the "json" option.
        https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
  
  OUT: Promise:
    resolved: (responseData) ->
    rejected: (restRequestStatus) ->
  
  responseData:
    a String, or the type specified by the responseType option
  
  restRequestStatus:
    event:    # the HTML event object
    request:  # the XMLHttpRequest
    options:  # the restRequest options: verb, url, data, headers, onProgress, responseType, formData
    httpStatus:   # the HTML status code, if the request completed
    response: # responseData
    status:       a valid CommunicationStatus
    error:    # Error object or string-explaination of why the request was rejected
    progress:
      a value between 0 and 1
      If the progress is indeterminant, this is 0
      If this isn't an onProgress event, this is the amount of progress
      that was made up to the point of the event.
   */

  RestClient.prototype.get = function(url, options) {
    return this.restRequest(merge(options, {
      verb: "GET",
      url: url
    }));
  };

  RestClient.prototype.put = function(url, data, options) {
    return this.restRequest(merge(options, {
      verb: "PUT",
      url: url,
      data: data
    }));
  };

  RestClient.prototype.post = function(url, data, options) {
    return this.restRequest(merge(options, {
      verb: "POST",
      url: url,
      data: data
    }));
  };

  RestClient.prototype["delete"] = function(url, options) {
    return this.restRequest(merge(options, {
      verb: "DELETE",
      url: url
    }));
  };

  RestClient.prototype.getArrayBuffer = function(url, options) {
    return this.restRequest(merge(options, {
      verb: "GET",
      url: url,
      responseType: "arraybuffer"
    }));
  };


  /*
  get/put/post/deleteJson
  
  same as get/put/post/delete above
  
  except:
    sent data should be plain objects which are JSON.stringified
    response data is automatically JSON.parsed
  
    additional options are set:
      responseType: "json"
      headers:      Accept: 'application/json'
   */

  RestClient.prototype.getJson = function(url, options) {
    return this.restJsonRequest(merge(options, {
      verb: "get",
      url: url
    }));
  };

  RestClient.prototype.deleteJson = function(url, options) {
    return this.restJsonRequest(merge(options, {
      verb: "delete",
      url: url
    }));
  };

  RestClient.prototype.putJson = function(url, data, options) {
    return this.restJsonRequest(merge(options, {
      verb: "put",
      url: url,
      data: data
    }));
  };

  RestClient.prototype.postJson = function(url, data, options) {
    return this.restJsonRequest(merge(options, {
      verb: "post",
      url: url,
      data: data
    }));
  };


  /*
  IN:
    options:
      verb: "GET", "PUT", "POST"
      method: alias for verb
  
      data: data to restRequest - passed to xmlHttpRequest.restRequest
      body: alias for data
  
      plus all the options for get/put/post listed above
      showProgressAfter: milliseconds (default: 100)
        only show progress after # milliseconds
  
      onProgress: (requestStatus) ->
        see "All callbacks" below for details about inputs.
        Note that onProgress is triggered a little differently than
        the normal XMLHttpRequest progress events:
          - it will only be called after showProgressAfter ms
          - it is guaranteed to be called after showProgressAfter ms if the request hasn't completed
          - if the request completes before showProgressAfter ms, it will never be called
  
  OUT: see get/put/post above
  
  All callbacks look like this: (requestStatus) ->
    requestStatus:
      request:  XMLHttpRequest
      progress: number # between 0 and 1
      options:  options # passed-in options object
      event:    the most recent event
      response: # the processed response data, if ready
      error:    # if any
      httpStatus:   number # HTTP status code, if the request is complete
  
  EFFECT:
   */

  RestClient.prototype.restRequest = function(options) {
    var body, data, formData, headers, k, method, onProgress, query, responseType, showProgressAfter, specifiedVerb, url, v, verb, verbose;
    verb = options.verb, verbose = options.verbose, method = options.method, url = options.url, data = options.data, body = options.body, query = options.query, headers = options.headers, onProgress = options.onProgress, responseType = options.responseType, formData = options.formData, showProgressAfter = options.showProgressAfter;
    if (!isNumber(showProgressAfter)) {
      showProgressAfter = 100;
    }
    method || (method = verb);
    body || (body = data);
    if (!(method = RestClient.legalVerbs[specifiedVerb = method])) {
      throw new Error("invalid method: " + specifiedVerb);
    }
    if (formData) {
      if (body) {
        throw new Error("can't specify both 'body' and 'formData'");
      }
      body = new FormData;
      for (k in formData) {
        v = formData[k];
        body.append(k, v);
      }
    } else {
      body = (body != null ? typeof body.toArrayBuffer === "function" ? body.toArrayBuffer() : void 0 : void 0) || body;
    }
    if (method === "GET" && body) {
      log.error({
        RestClient_restRequest: {
          info: "can't GET with body",
          options: options
        }
      });
      throw new Error("With their ultimate wisdom, the gods decree: NO DATA WITH GET");
    }
    if (query) {
      url = appendQuery(url, query);
    }
    return this._normalizedRestRequest({
      verbose: verbose,
      method: method,
      url: url,
      body: body,
      onProgress: onProgress,
      responseType: responseType,
      showProgressAfter: showProgressAfter,
      headers: normalizeHeaders(headers)
    });
  };

  RestClient.normalizeHeaders = normalizeHeaders = function(headers) {
    return object(headers, {
      key: function(v, k) {
        return capitalizedDashCase(k);
      }
    });
  };

  RestClient.prototype.restJsonRequest = function(options) {
    var data, headers, method, verb;
    verb = options.verb, method = options.method, data = options.data, headers = options.headers;
    verb = RestClient.legalVerbs[verb || method];
    if (data && objectKeyCount(data) === 0) {
      data = null;
    }
    if (verb === "GET" && options.data) {
      options = merge(options, {
        url: appendQuery(options.url, object(data, function(v) {
          return JSON.stringify(v);
        }))
      });
      data = null;
    } else {
      data && (data = JSON.stringify(data));
    }
    return this.restRequest(merge(options, {
      responseType: "json",
      headers: merge({
        Accept: 'application/json',
        "Content-Type": 'application/json'
      }, headers),
      data: data
    }));
  };

  RestClient.prototype._normalizedRestRequest = function(options) {
    var body, headers, method, onProgress, responseType, showProgressAfter, url, verbose;
    method = options.method, url = options.url, body = options.body, headers = options.headers, onProgress = options.onProgress, responseType = options.responseType, showProgressAfter = options.showProgressAfter, verbose = options.verbose;
    return new Promise(function(resolve, reject) {
      var fail, getErrorResponse, getResponse, initialProgressCalled, k, lastProgressEvent, progressCallbackInternal, request, requestResolved, restRequestStatus, v;
      fail = function(props) {
        return reject(new RequestError(merge(props, {
          sourceLib: "ArtRestClient",
          body: body,
          headers: headers,
          responseType: responseType,
          key: url,
          type: method,
          responseUrl: request.responseURL,
          progress: restRequestStatus.progress
        })));
      };
      restRequestStatus = {
        request: request = new XMLHttpRequest,
        progress: 0,
        options: options,
        abort: function() {
          request.abort();
          return fail({
            status: aborted,
            message: "XMLHttpRequest aborted"
          });
        }
      };
      getErrorResponse = function() {
        var error;
        try {
          return getResponse();
        } catch (error1) {
          error = error1;
          return {
            status: serverFailure,
            rawResponse: request.response,
            message: "ArtRestClient: Error parsing server's response: " + error + "\nrawResponse: " + request.response
          };
        }
      };
      getResponse = function() {
        var response;
        response = request.response;
        if (response && responseType === "json") {
          return JSON.parse(response);
        } else {
          return response;
        }
      };
      request.open(method, url, true);
      if (present(responseType) && responseType !== "json") {
        request.responseType = responseType;
      }
      if (headers) {
        for (k in headers) {
          v = headers[k];
          request.setRequestHeader(k, v);
        }
      }
      requestResolved = false;
      request.addEventListener("error", function(event) {
        requestResolved = true;
        return fail({
          status: networkFailure,
          message: "XMLHttpRequest error event triggered",
          data: {
            event: event
          }
        });
      });
      request.addEventListener("load", function(event) {
        var decodedHttpStatus, httpStatus, message;
        requestResolved = true;
        decodedHttpStatus = decodeHttpStatus(httpStatus = request.status);
        if (!((decodedHttpStatus.status === success) && ((function() {
          try {
            resolve(getResponse());
            return true;
          } catch (error1) {}
        })()))) {
          message = decodedHttpStatus.status === success ? (decodedHttpStatus.status = serverFailure, "error processing successful response") : void 0;
          return fail(merge(decodedHttpStatus, {
            message: message,
            event: event,
            data: getErrorResponse()
          }));
        }
      });
      if (onProgress) {
        initialProgressCalled = showProgressAfter <= 0;
        lastProgressEvent = null;
        timeout(showProgressAfter, function() {
          initialProgressCalled = true;
          return progressCallbackInternal(lastProgressEvent || {});
        });
        progressCallbackInternal = function(event) {
          var loaded, ref2, total;
          ref2 = lastProgressEvent = event, total = ref2.total, loaded = ref2.loaded;
          if (initialProgressCalled && !requestResolved) {
            return typeof onProgress === "function" ? onProgress(restRequestStatus = merge(restRequestStatus, {
              event: event,
              progress: total > 0 ? loaded / total : 0
            })) : void 0;
          }
        };
        if (method === "GET") {
          request.addEventListener("progress", progressCallbackInternal);
        } else {
          request.upload.addEventListener("progress", progressCallbackInternal);
        }
      }
      if (verbose) {
        log("ArtRestClient: " + method + " " + url);
      }
      return request.send(body);
    });
  };

  return RestClient;

})(BaseClass);


/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(508);

module.exports.includeInNamespace(__webpack_require__(506));


/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

var RestClient,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.RestClient', RestClient = (function(superClass) {
  extend(RestClient, superClass);

  function RestClient() {
    return RestClient.__super__.constructor.apply(this, arguments);
  }

  RestClient.version = __webpack_require__(595).version;

  return RestClient;

})(Neptune.PackageNamespace));


/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

var ref, ref1, ref2;

module.exports = (ref = typeof Neptune !== "undefined" && Neptune !== null ? (ref1 = Neptune.Art) != null ? (ref2 = ref1.StandardLib) != null ? ref2.Core : void 0 : void 0 : void 0) != null ? ref : __webpack_require__(16);


/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(43);


/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = [__webpack_require__(90), __webpack_require__(289), __webpack_require__(288), __webpack_require__(43)];


/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {


/*
TODO: refactor so nothing in inspect/* uses BaseObject
Then, move into StandardLib.
 */
module.exports = [[__webpack_require__(148), "shallowInspect inspectLean inspect"], __webpack_require__(293), __webpack_require__(147), __webpack_require__(296), __webpack_require__(91)];


/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

var Array, MinimalBaseObject,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MinimalBaseObject = __webpack_require__(31);

module.exports = Array = (function(superClass) {
  extend(Array, superClass);

  function Array(inspectedArray) {
    Array.__super__.constructor.apply(this, arguments);
    this.array = inspectedArray;
  }

  Array.getter({
    arrayOfStrings: function() {
      var i, len, ref, results, v;
      ref = this.array;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        v = ref[i];
        results.push(v.toString());
      }
      return results;
    },
    children: function() {
      return this.array.slice();
    }
  });

  Array.prototype.delimitedString = function(delimiter) {
    if (delimiter == null) {
      delimiter = ", ";
    }
    return this.arrayOfStrings.join(", ");
  };

  Array.prototype.toString = function() {
    return "[" + (this.delimitedString()) + "]";
  };

  return Array;

})(MinimalBaseObject);


/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

var Core, MinimalBaseObject,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MinimalBaseObject = __webpack_require__(31);

module.exports = Core = (function(superClass) {
  extend(Core, superClass);

  function Core(value) {
    Core.__super__.constructor.apply(this, arguments);
    this.value = value;
    if (value && value.constructor.name === "HTMLImageElement") {
      this.image = value;
    }
  }

  Core.getter({
    children: function() {
      return null;
    }
  });

  Core.prototype.toString = function() {
    return "" + this.value;
  };

  return Core;

})(MinimalBaseObject);


/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

var MinimalBaseObject, Object,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MinimalBaseObject = __webpack_require__(31);

module.exports = Object = (function(superClass) {
  extend(Object, superClass);

  function Object(properties, instanceOf, originalObject) {
    this.properties = properties;
    this.instanceOf = instanceOf;
    this.originalObject = originalObject;
    Object.__super__.constructor.apply(this, arguments);
    this.length = this.properties ? self.Object.keys(this.properties).length : 0;
  }

  Object.getter({
    arrayOfStrings: function() {
      var k, ref, results, v;
      ref = this.properties;
      results = [];
      for (k in ref) {
        v = ref[k];
        results.push(k + ": " + v);
      }
      return results;
    },
    children: function() {
      var k, ref, ret, v;
      ret = {};
      ref = this.properties;
      for (k in ref) {
        v = ref[k];
        ret[k] = v;
      }
      return ret;
    }
  });

  Object.prototype.delimitedString = function(delimiter) {
    if (delimiter == null) {
      delimiter = ", ";
    }
    return this.arrayOfStrings.join(", ");
  };

  Object.prototype.toString = function() {
    if (this.inspected) {
      return this.inspected;
    } else if (this.instanceOf) {
      return "{" + this.instanceOf + " " + (this.delimitedString()) + "}";
    } else {
      return "{" + (this.delimitedString()) + "}";
    }
  };

  return Object;

})(MinimalBaseObject);


/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

var MinimalBaseObject, String, escapeJavascriptString,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MinimalBaseObject = __webpack_require__(31);

escapeJavascriptString = __webpack_require__(32).escapeJavascriptString;

module.exports = String = (function(superClass) {
  extend(String, superClass);

  function String(clonedString) {
    String.__super__.constructor.apply(this, arguments);
    this.string = clonedString;
  }

  String.prototype.toString = function() {
    return escapeJavascriptString(this.string);
  };

  return String;

})(MinimalBaseObject);


/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

var Inspected, Inspector2, Map, MinimalBaseObject, escapeJavascriptString, isArray, isBrowserObject, isClass, isDate, isFunction, isHTMLImageElement, isObject, isPlainObject, isRegExp, isString, objectName, parentString, ref,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

MinimalBaseObject = __webpack_require__(31);

Map = __webpack_require__(94);

Inspected = __webpack_require__(294);

escapeJavascriptString = __webpack_require__(32).escapeJavascriptString;

ref = __webpack_require__(12), isString = ref.isString, isArray = ref.isArray, isFunction = ref.isFunction, isObject = ref.isObject, isPlainObject = ref.isPlainObject, isClass = ref.isClass, isDate = ref.isDate, isRegExp = ref.isRegExp, objectName = ref.objectName, isBrowserObject = ref.isBrowserObject;

isHTMLImageElement = self.HTMLImageElement ? function(obj) {
  return obj instanceof HTMLImageElement;
} : function() {
  return false;
};

parentString = (function(_this) {
  return function(distance) {
    switch (distance) {
      case 0:
        return "parent";
      case 1:
        return "grandparent";
      case 2:
        return "great grandparent";
      default:
        return "great^" + (distance - 1) + " grandparent";
    }
  };
})(this);

module.exports = Inspector2 = (function(superClass) {
  extend(Inspector2, superClass);

  function Inspector2(options) {
    if (options == null) {
      options = {};
    }
    this.inspectObject = bind(this.inspectObject, this);
    this.inspectWithToImage = bind(this.inspectWithToImage, this);
    this.inspectHTMLImageElement = bind(this.inspectHTMLImageElement, this);
    this.inspectArray = bind(this.inspectArray, this);
    this.withImages = options.withImages;
    this.maxLength = options.maxLength || 1000;
    this.allowCustomInspectors = !options.noCustomInspectors;
    this.maxDepth = options.maxDepth != null ? options.maxDepth : 10;
    this.outArray = [];
    this.length = 0;
    this.depth = 0;
    this.inspectingMap = new Map;
  }

  Inspector2.prototype.inspectArray = function(array) {
    var a;
    return new Inspected.Array((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = array.length; i < len; i++) {
        a = array[i];
        results.push(this.inspectInternal(a));
      }
      return results;
    }).call(this));
  };

  Inspector2.prototype.inspectHTMLImageElement = function(obj) {
    var res;
    res = new Inspected.Object({}, "HTMLImageElement", obj);
    if (!(res.image = obj).complete) {
      this.addPendingTask();
      obj.onload = (function(_this) {
        return function() {
          return _this.completePendingTask();
        };
      })(this);
    }
    return res;
  };

  Inspector2.prototype.inspectWithToImage = function(obj) {
    var name, res;
    name = objectName(obj);
    if (typeof obj.classPathName === "string") {
      name = obj.classPathName;
    }
    if (name === "Object") {
      name = null;
    }
    res = new Inspected.Object({}, name, obj);
    this.addPendingTask();
    obj.toImage().then((function(_this) {
      return function(image) {
        res.image = image;
        return _this.completePendingTask();
      };
    })(this));
    return res;
  };

  Inspector2.prototype.inspectObject = function(obj, recurse) {
    var attributes, i, k, keys, len, name, res, result;
    if (recurse == null) {
      recurse = true;
    }
    attributes = [];
    keys = Object.keys(obj);
    name = objectName(obj);
    if (isFunction(obj) && keys.length === 0) {
      return new Inspected.Core(name + "()");
    } else {
      if (typeof obj.classPathName === "string") {
        name = obj.classPathName;
      }
      if (name === "Object") {
        name = null;
      }
      result = {};
      if (recurse) {
        for (i = 0, len = keys.length; i < len; i++) {
          k = keys[i];
          result[k] = this.inspectInternal(obj[k]);
        }
      }
      res = new Inspected.Object(result, name, obj);
      if (isFunction(obj.inspect)) {
        res.inspected = obj.inspect();
      }
      return res;
    }
  };

  Inspector2.prototype.addPendingTask = function() {
    return this.pendingTasks++;
  };

  Inspector2.prototype.completePendingTask = function() {
    this.pendingTasks--;
    if (this.pendingTasks === 0) {
      return this.completionCallBack();
    }
  };

  Inspector2.prototype.inspectByType = function(obj) {
    if (isFunction(obj != null ? obj.getInspectedObjects : void 0)) {
      obj = obj.getInspectedObjects();
    }
    if (obj === null || obj === void 0 || obj === true || obj === false || typeof obj === "number") {
      return new Inspected.Core(obj);
    } else if (obj === self) {
      return new Inspected.Core("self");
    } else if (isRegExp(obj)) {
      return new Inspected.Core(obj.toString());
    } else if (isString(obj)) {
      return new Inspected.String(obj);
    } else if (isArray(obj)) {
      return this.inspectArray(obj);
    } else if (isClass(obj)) {
      return new Inspected.Core(objectName(obj));
    } else if (isHTMLImageElement(obj)) {
      return this.inspectHTMLImageElement(obj);
    } else if (isDate(obj)) {
      return new Inspected.Core(obj.toString());
    } else if (isBrowserObject(obj)) {
      return new Inspected.Core(objectName(obj));
    } else if (this.withImages && typeof obj.toImage === "function" && !isFunction(obj)) {
      return this.inspectWithToImage(obj);
    } else if (isPlainObject(obj) || isFunction(obj)) {
      return this.inspectObject(obj);
    } else if (isObject(obj)) {
      return this.inspectObject(obj, false);
    } else {
      return new Inspected.Core(objectName(obj));
    }
  };

  Inspector2.prototype.inspectInternal = function(obj) {
    var objDepth, res;
    if (objDepth = this.inspectingMap.get(obj)) {
      return new Inspected.Core("<" + (parentString(this.depth - objDepth)) + ">");
    } else if (this.depth >= this.maxDepth) {
      return new Inspected.Core("<maxDepth reached: " + this.maxDepth + ">");
    } else {
      this.depth++;
      this.inspectingMap.set(obj, this.depth);
      res = this.inspectByType(obj);
      this.inspectingMap["delete"](obj);
      this.depth--;
      return res;
    }
  };

  Inspector2.prototype.inspect = function(obj, callBack) {
    var res;
    this.pendingTasks = 0;
    if (this.withImages && typeof callBack !== "function") {
      throw new Error("callBack required if withImages requested");
    }
    this.completionCallBack = (function(_this) {
      return function() {
        return callBack && callBack(res);
      };
    })(this);
    res = this.inspectInternal(obj);
    if (this.pendingTasks === 0) {
      this.completionCallBack();
    }
    return res;
  };

  return Inspector2;

})(MinimalBaseObject);


/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

var Promise, PromiseWorkerPool, log;

Promise = __webpack_require__(45);

log = __webpack_require__(149).log;


/*
  usage:

  pwp = new PromiseWorkerPool
    numWorkers: 10

   * queue all your jobs
  pwp.queue (jobIndex, totalJobCount) -> work, optionally returning promise
     * jobIndex is the order the worker was queued in

   * start the queue
  pwp.then (results) ->
     * results is the results from all your workerPromises in the same order they were queued
 */

module.exports = PromiseWorkerPool = (function() {
  function PromiseWorkerPool(numWorkers1) {
    this.numWorkers = numWorkers1 != null ? numWorkers1 : 10;
    this._queue = [];
  }

  PromiseWorkerPool.prototype.queue = function(job) {
    if (this._startPromise) {
      throw new Error("already started");
    }
    this._queue.push(job);
    return this;
  };

  PromiseWorkerPool.prototype.start = function() {
    return this._startPromise || (this._startPromise = Promise.then((function(_this) {
      return function() {
        var doNextAction, jobIndex, numJobs, numWorkers, results, workerPromises;
        jobIndex = 0;
        doNextAction = function() {
          var currentJobIndex, job;
          if (_this._queue.length > (currentJobIndex = jobIndex)) {
            jobIndex++;
            if (job = _this._queue[currentJobIndex]) {
              _this._queue[currentJobIndex] = null;
              return Promise.then(function() {
                return job(currentJobIndex, numJobs);
              }).then(function(result) {
                return results[currentJobIndex] = result;
              }).then(doNextAction);
            } else {
              return Promise.then(doNextAction);
            }
          } else {
            return Promise.resolve("queue done");
          }
        };
        results = new Array(numJobs = _this._queue.length);
        workerPromises = [];
        numWorkers = _this.numWorkers;
        while (workerPromises.length < numWorkers) {
          workerPromises.push(doNextAction());
        }
        return Promise.all(workerPromises).then(function() {
          return results;
        });
      };
    })(this)));
  };

  PromiseWorkerPool.prototype.then = function(a, b) {
    return this.start().then(a, b);
  };

  PromiseWorkerPool.prototype["catch"] = function(a) {
    return this.start()["catch"](a);
  };

  return PromiseWorkerPool;

})();


/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var RequestError, compactFlatten, defineModule, formattedInspect, isFunction, merge, mergeInto, objectWithout, ref, upperCamelCase,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

defineModule = __webpack_require__(42).defineModule;

formattedInspect = __webpack_require__(30).formattedInspect;

ref = __webpack_require__(16), mergeInto = ref.mergeInto, isFunction = ref.isFunction, upperCamelCase = ref.upperCamelCase, compactFlatten = ref.compactFlatten, merge = ref.merge;

objectWithout = __webpack_require__(59).objectWithout;


/*
TODO:
  Rename: ErrorWithProps
  Rename: @info => @props

  Only
 */

defineModule(module, RequestError = (function(superClass) {
  extend(RequestError, superClass);


  /*
  IN:
    props:
      message:  error-message
      type:     request-type (for REST, the Method/Verb)
      key:      request-key (for REST, the URL)
      status:   string, see: ArtCommunicationStatus for valid strings
      data:     error-response-data, if any
   */

  function RequestError(props) {
    var message, ref1, responseData, responseDataString, sourceLib;
    RequestError.__super__.constructor.apply(this, arguments);
    ref1 = this.props = merge(props), sourceLib = ref1.sourceLib, message = ref1.message, this.requestData = ref1.requestData, this.type = ref1.type, this.key = ref1.key, this.status = ref1.status, this.data = ref1.data, responseData = ref1.responseData;
    this.responseData = this.data || (this.data = responseData);
    this.name = upperCamelCase((sourceLib || "") + " RequestError");
    if (this.props.data) {
      delete this.props.data;
      this.props.data = this.responseData;
    }
    responseDataString = this.data && formattedInspect({
      data: this.data
    });
    this.message = message || compactFlatten([
      (this.status || "failure") + ":", (responseDataString != null ? responseDataString.length : void 0) < 80 && !this.requestData ? [this.type, this.key, responseDataString] : "\n\n" + formattedInspect(merge({
        type: this.type,
        key: this.key,
        requestData: this.requestData,
        responseData: this.responseData
      }))
    ]).join(' ');
    if (this.props.stack) {
      this.stack = this.props.stack;
      this.props = objectWithout(this.props, "stack");
    } else if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = (new Error).stack;
    }
    this.info = this.props;
  }

  RequestError.prototype.toString = function() {
    return [
      this.name + " " + this.message, formattedInspect({
        props: this.props
      })
    ].join("\n\n");
  };

  return RequestError;

})(Error));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)(module)))

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = [
  __webpack_require__(16), [__webpack_require__(45), "testPromise", "containsPromises", "deepAll"], __webpack_require__(57), __webpack_require__(143), __webpack_require__(59), __webpack_require__(32), __webpack_require__(146), __webpack_require__(292), __webpack_require__(298), __webpack_require__(297), __webpack_require__(44), __webpack_require__(58), __webpack_require__(95), __webpack_require__(299), __webpack_require__(46), __webpack_require__(301), __webpack_require__(302), __webpack_require__(150), __webpack_require__(12), __webpack_require__(42), __webpack_require__(93), __webpack_require__(30), __webpack_require__(287), __webpack_require__(149), __webpack_require__(144), __webpack_require__(145), {
    PushBackTimer: __webpack_require__(300)
  }
];


/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(152);

module.exports.includeInNamespace(__webpack_require__(520)).addModules({
  ArrayExtensions: __webpack_require__(57),
  AsyncExtensions: __webpack_require__(143),
  CallStack: __webpack_require__(144),
  Clone: __webpack_require__(287),
  CommonJs: __webpack_require__(42),
  DateExtensions: __webpack_require__(145),
  Environment: __webpack_require__(58),
  Eq: __webpack_require__(146),
  ErrorWithInfo: __webpack_require__(291),
  Function: __webpack_require__(292),
  Iteration: __webpack_require__(93),
  Log: __webpack_require__(149),
  Map: __webpack_require__(94),
  MapExtensions: __webpack_require__(297),
  MathExtensions: __webpack_require__(44),
  MinimalBaseObject: __webpack_require__(31),
  ObjectDiff: __webpack_require__(298),
  ObjectExtensions: __webpack_require__(59),
  ParseUrl: __webpack_require__(95),
  Promise: __webpack_require__(45),
  PromisedFileReader: __webpack_require__(299),
  PromiseWorkerPool: __webpack_require__(518),
  RegExpExtensions: __webpack_require__(46),
  RequestError: __webpack_require__(519),
  ReschedulableTimer: __webpack_require__(300),
  Ruby: __webpack_require__(301),
  ShallowClone: __webpack_require__(302),
  StringExtensions: __webpack_require__(32),
  Time: __webpack_require__(150),
  TypesExtended: __webpack_require__(12),
  Unique: __webpack_require__(151)
});

__webpack_require__(16);

__webpack_require__(30);


/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

var Canvas, Engine, EryFlux, Flux, React, isNode, merge, ref;

ref = __webpack_require__(1), merge = ref.merge, isNode = ref.isNode;

if (isNode) {
  throw new Error("For Node, use: art-suite/Node");
}

module.exports = [
  merge(__webpack_require__(303), Canvas = __webpack_require__(11), Engine = __webpack_require__(71), React = __webpack_require__(285), Flux = __webpack_require__(457), EryFlux = __webpack_require__(445), __webpack_require__(492), {
    Canvas: Canvas,
    Engine: Engine,
    React: React,
    Flux: Flux,
    EryFlux: EryFlux
  }), {
    initArtSuiteApp: React.initArtReactApp
  }
];


/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(524);

module.exports.includeInNamespace(__webpack_require__(522)).addModules({
  Core: __webpack_require__(303)
});


/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

var Suite,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.Suite', Suite = (function(superClass) {
  extend(Suite, superClass);

  function Suite() {
    return Suite.__super__.constructor.apply(this, arguments);
  }

  Suite.version = __webpack_require__(597).version;

  return Suite;

})(Neptune.PackageNamespace));


/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

var Atomic, BaseObject, Bitmap, Foundation, Layout, Matrix, Metrics, Rectangle, ceil, emptyOptions, flatten, float32Eq, float32Eq0, floor, inspect, isMatrix, isNumber, log, matrix, max, merge, min, nearInfinity, nearInfinityResult, peek, point, pureMerge, rect, shouldUseSafariLineWidthBugFix, time, toFontCss, useSafariLineWidthFix,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Foundation = __webpack_require__(2);

Bitmap = __webpack_require__(11).Bitmap;

Atomic = __webpack_require__(4);

Metrics = __webpack_require__(304);

isMatrix = Atomic.isMatrix, rect = Atomic.rect, matrix = Atomic.matrix, Matrix = Atomic.Matrix, Rectangle = Atomic.Rectangle, point = Atomic.point;

floor = Math.floor, ceil = Math.ceil;

log = Foundation.log, inspect = Foundation.inspect, pureMerge = Foundation.pureMerge, flatten = Foundation.flatten, BaseObject = Foundation.BaseObject, nearInfinity = Foundation.nearInfinity, nearInfinityResult = Foundation.nearInfinityResult, peek = Foundation.peek, min = Foundation.min, max = Foundation.max, merge = Foundation.merge, time = Foundation.time, isNumber = Foundation.isNumber, float32Eq = Foundation.float32Eq, float32Eq0 = Foundation.float32Eq0;

toFontCss = Metrics.toFontCss;

emptyOptions = {};

module.exports = Layout = (function(superClass) {
  var defaultLayoutOptions, defaultText, wordStringToHash;

  extend(Layout, superClass);

  Layout.defaultText = defaultText = "";

  Layout.defaultLayoutOptions = defaultLayoutOptions = {
    leading: 1.25,
    paragraphLeading: null,
    align: point("left"),
    layoutMode: "textualBaseline",
    overflow: "ellipsis",
    maxLines: void 0
  };

  wordStringToHash = function(wordString) {
    var j, len, ref, ret, word;
    ret = {};
    ref = wordString.split(/\s+/);
    for (j = 0, len = ref.length; j < len; j++) {
      word = ref[j];
      ret[word] = true;
    }
    return ret;
  };

  Layout.validLayoutOptions = {
    layoutMode: wordStringToHash("textual textualBaseline tight tight0"),
    overflow: wordStringToHash("ellipsis visible clipped")
  };

  function Layout(text, fontOptions, layoutOptions, layoutAreaWidth, layoutAreaHeight) {
    if (layoutAreaWidth == null) {
      layoutAreaWidth = nearInfinity;
    }
    if (layoutAreaHeight == null) {
      layoutAreaHeight = nearInfinity;
    }
    if (!(isNumber(layoutAreaWidth) && isNumber(layoutAreaHeight))) {
      throw new Error("layoutAreaWidth, layoutAreaHeight must be numbers: " + (inspect(layoutAreaHeight)));
    }
    this._layoutAreaWidth = layoutAreaWidth;
    this._layoutAreaHeight = layoutAreaHeight;
    this._fontOptions = Metrics.normalizeFontOptions(fontOptions || {});
    this._layoutOptions = layoutOptions = pureMerge(defaultLayoutOptions, layoutOptions);
    this._text = text || defaultText;
    this._textLines = text.split("\n");
    if (layoutOptions.wordWrapWidth) {
      console.error("Art.Text.Layout#wordWrapWidth is depricated. Pass layoutAreaWidth and layoutAreaHeight into constructor.");
    }
    this._maxHeight = layoutOptions.maxHeight;
    this._overflow = layoutOptions.overflow;
    this._clipped = this._overflow === "clipped";
    this._ellipsis = this._overflow === "ellipsis";
    this._align = point(layoutOptions.align);
    this._leading = layoutOptions.leading;
    this._paragraphLeading = layoutOptions.paragraphLeading;
    this._maxLines = layoutOptions.maxLines;
    this._layoutMode = layoutOptions.layoutMode;
    this._resetLayout();
    this._left = this._right = this._top = this._bottom = 0;
  }

  Layout.getter("text align leading");

  Layout.getter({
    fontStyle: function() {
      return this._fontOptions.fontStyle;
    },
    fontVariant: function() {
      return this._fontOptions.fontVariant;
    },
    fontWeight: function() {
      return this._fontOptions.fontWeight;
    },
    fontFamily: function() {
      return this._fontOptions.fontFamily;
    },
    fontSize: function() {
      return this._fontOptions.fontSize;
    },
    leading: function() {
      return this._leading;
    },
    paragraphLeading: function() {
      return this._paragraphLeading;
    },
    align: function() {
      return this._align;
    },
    layoutMode: function() {
      return this._layoutMode;
    },
    fragments: function() {
      this._updateLayout();
      return this._fragments;
    },
    size: function() {
      this._updateLayout();
      return this._size || (this._size = point(this._right - this._left, this._bottom - this._top));
    },
    area: function() {
      this._updateLayout();
      return this._area || (this._area = rect(this._left, this._top, this._right - this._left, this._bottom - this._top));
    },
    drawArea: function() {
      this._updateLayout();
      return this._drawArea || (this._drawArea = this._computeDrawArea());
    },
    fontCss: function() {
      return this._fontCss || (this._fontCss = toFontCss(this._fontOptions));
    },
    lineCount: function() {
      this._updateLayout();
      return this._fragments.length;
    }
  });

  Layout.prototype._getFragmentLogicalAreas = function(layoutHeight) {
    var j, layoutArea, len, ref, results;
    ref = this.fragments;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      layoutArea = ref[j].layoutArea;
      results.push(layoutArea);
    }
    return results;
  };

  Layout.prototype.draw = function(target, where, options) {
    var context, ref, scaler;
    if (options == null) {
      options = emptyOptions;
    }
    context = target.context2D;
    if (!context) {
      return this.drawToNonArtBitmap(target, where, options);
    }
    this._updateLayout();
    if (options.stroke && useSafariLineWidthFix && isMatrix(where)) {
      scaler = max(where.sx, where.sy);
      options.lineWidth = ((ref = options.lineWidth) != null ? ref : 1) * scaler;
    }
    if (target._setupDraw(where, options)) {
      context.font = this.getFontCss();
      context.textAlign = 'left';
      context.textBaseline = 'alphabetic';
      if (options.stroke) {
        this._strokeAllFragments(context);
      } else {
        this._fillAllFragments(context);
      }
      return target._cleanupDraw(options);
    }
  };

  Layout.prototype.stroke = function(target, where, options) {
    if (options == null) {
      options = emptyOptions;
    }
    return this.draw(target, where, merge(options, {
      stroke: true
    }));
  };

  Layout.prototype.drawToNonArtBitmap = function(target, where, options) {
    var bitmap2D, scale;
    if (options == null) {
      options = emptyOptions;
    }
    scale = where.exactScale;
    bitmap2D = new Bitmap(this.getSize().mul(scale));
    this.draw(bitmap2D, Matrix.scale(scale), options);
    return target.drawBitmap(Matrix.scale(scale.inv).mul(where), bitmap2D);
  };

  Layout.prototype.newBitmap = function(options) {
    var scale, size;
    if (options == null) {
      options = emptyOptions;
    }
    size = options.size || this.getSize();
    if (this._align.x > 0 && this._layoutAreaWidth < nearInfinityResult) {
      size = size.withX(this._layoutAreaWidth);
    }
    if (this._align.y > 0 && this._layoutAreaHeight < nearInfinityResult) {
      size = size.withY(this._layoutAreaHeight);
    }
    if (scale = options.scale) {
      size = size.mul(scale);
    }
    return new Bitmap(size);
  };

  Layout.prototype.toBitmap = function(options) {
    var bitmap, drawMatrix, scale;
    if (options == null) {
      options = emptyOptions;
    }
    drawMatrix = options.drawMatrix || new Matrix;
    if (scale = options.scale) {
      drawMatrix = drawMatrix.mul(Matrix.scale(scale));
    }
    bitmap = this.newBitmap(options);
    this.draw(bitmap, drawMatrix, options);
    return bitmap;
  };

  Layout.prototype._fillAllFragments = function(context) {
    var frag, j, len, ref, results;
    ref = this.fragments;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      frag = ref[j];
      results.push(context.fillText(frag.text, frag.getTextX(), frag.getTextY()));
    }
    return results;
  };

  Layout.prototype._strokeAllFragments = function(context) {
    var frag, j, len, ref, results;
    ref = this.fragments;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      frag = ref[j];
      results.push(context.strokeText(frag.text, frag.getTextX(), frag.getTextY()));
    }
    return results;
  };

  Layout.prototype._drawFragmentAreas = function(context) {
    var fontSize, frag, j, layoutArea, len, ref, results;
    fontSize = this.getFontSize();
    ref = this.fragments;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      frag = ref[j];
      layoutArea = frag.layoutArea;
      results.push(context.fillRect(layoutArea.x, layoutArea.y, layoutArea.w, layoutArea.h));
    }
    return results;
  };

  Layout.prototype._computeDrawArea = function() {
    var bottom, fragment, fragments, i, j, left, len, right, top;
    fragments = this.fragments;
    if (fragments.length === 1) {
      return fragments[0].alignedDrawArea;
    } else {
      left = top = right = bottom = 0;
      for (i = j = 0, len = fragments.length; j < len; i = ++j) {
        fragment = fragments[i];
        if (i === 0) {
          left = fragment.getAlignedDrawAreaLeft();
          top = fragment.getAlignedDrawAreaTop();
          right = fragment.getAlignedDrawAreaRight();
          bottom = fragment.getAlignedDrawAreaBottom();
        } else {
          left = min(left, fragment.getAlignedDrawAreaLeft());
          top = min(top, fragment.getAlignedDrawAreaTop());
          right = max(right, fragment.getAlignedDrawAreaRight());
          bottom = max(bottom, fragment.getAlignedDrawAreaBottom());
        }
      }
      return new Rectangle(left, top, right - left, bottom - top);
    }
  };

  Layout.prototype._alignFragments = function() {
    var _align, _layoutAreaHeight, _layoutAreaWidth, area, frag, j, len, offsetY, ref, ref1, results, xAlign, yAlign;
    ref = this, _layoutAreaWidth = ref._layoutAreaWidth, _layoutAreaHeight = ref._layoutAreaHeight, _align = ref._align, area = ref.area;
    xAlign = _align.x;
    yAlign = _align.y;
    if (_layoutAreaWidth >= nearInfinityResult) {
      xAlign = 0;
    }
    if (_layoutAreaHeight >= nearInfinityResult) {
      yAlign = 0;
    }
    offsetY = (_layoutAreaHeight - area.h) * yAlign;
    if (float32Eq0(offsetY) && float32Eq0(xAlign)) {
      return;
    }
    ref1 = this.fragments;
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      frag = ref1[j];
      frag.alignmentOffsetX = (_layoutAreaWidth - frag.layoutW) * xAlign;
      results.push(frag.alignmentOffsetY = offsetY);
    }
    return results;
  };

  Layout.prototype._setArea = function(fragment) {
    this._top = fragment.getTop();
    this._left = fragment.getLeft();
    this._bottom = fragment.getBottom();
    return this._right = fragment.getRight();
  };

  Layout.prototype._expandArea = function(fragment) {
    this._top = min(this._top, fragment.getTop());
    this._left = min(this._left, fragment.getLeft());
    this._bottom = max(this._bottom, fragment.getBottom());
    return this._right = max(this._right, fragment.getRight());
  };

  Layout.prototype._generateFragments = function() {
    var _fontOptions, _layoutAreaWidth, _layoutMode, _textLines, fontCss, fragment, fragments, ref, text, wrappedFragments;
    ref = this, _fontOptions = ref._fontOptions, _layoutAreaWidth = ref._layoutAreaWidth, _layoutMode = ref._layoutMode, _textLines = ref._textLines, _fontOptions = ref._fontOptions;
    fontCss = this.getFontCss();
    return this._fragments = (function() {
      var j, k, l, len, len1, len2, results;
      if (_layoutAreaWidth < nearInfinityResult && (_layoutMode === "textual" || _layoutMode === "textualBaseline")) {
        fragments = [];
        for (j = 0, len = _textLines.length; j < len; j++) {
          text = _textLines[j];
          wrappedFragments = Metrics.wrap(text, _fontOptions, _layoutAreaWidth, fontCss, _layoutMode);
          for (k = 0, len1 = wrappedFragments.length; k < len1; k++) {
            fragment = wrappedFragments[k];
            fragments.push(fragment);
          }
        }
        return fragments;
      } else {
        results = [];
        for (l = 0, len2 = _textLines.length; l < len2; l++) {
          text = _textLines[l];
          results.push(Metrics.get(text, _fontOptions, _layoutMode, fontCss));
        }
        return results;
      }
    })();
  };

  Layout.prototype._layoutFragments = function() {
    var _clipped, _ellipsis, _layoutAreaHeight, _layoutAreaWidth, _maxLines, allFragments, effectiveLeading, effectiveParagraphLeadingDelta, fragment, i, j, len, m, offsetX, offsetY, ref, ref1, ref2, text, textWithEllipsis;
    ref = this, _layoutAreaWidth = ref._layoutAreaWidth, _layoutAreaHeight = ref._layoutAreaHeight, _maxLines = ref._maxLines, _clipped = ref._clipped, _ellipsis = ref._ellipsis;
    offsetX = 0;
    offsetY = 0;
    effectiveLeading = this.getFontSize() * this.getLeading();
    effectiveParagraphLeadingDelta = (((ref1 = this.getParagraphLeading()) != null ? ref1 : this.getLeading()) * this.getFontSize()) - effectiveLeading;
    allFragments = this._fragments;
    if (_maxLines && _maxLines < this._fragments.length) {
      this._fragments = this._fragments.slice(0, _maxLines);
    }
    ref2 = this._fragments;
    for (i = j = 0, len = ref2.length; j < len; i = ++j) {
      fragment = ref2[i];
      if (i > 0 && fragment.firstFragment) {
        offsetY += effectiveParagraphLeadingDelta;
      }
      fragment.move(offsetX, offsetY);
      if (i === 0) {
        this._setArea(fragment);
      } else {
        if (_clipped) {
          if (fragment.getTop() - this._top > _layoutAreaHeight) {
            this._fragments = this._fragments.slice(0, i);
            break;
          }
        } else if (_ellipsis) {
          if (fragment.getBottom() - this._top > _layoutAreaHeight) {
            this._fragments = this._fragments.slice(0, i);
            break;
          }
        }
        this._expandArea(fragment);
      }
      offsetY += effectiveLeading;
    }
    if (_ellipsis && this._fragments.length < allFragments.length) {
      text = peek(this._fragments).text;
      if (text[text.length - 1] === ".") {
        text = text.slice(0, text.length - 1);
      }
      textWithEllipsis = text + "";
      while (text.length > 0 && (m = Metrics.get(textWithEllipsis, this._fontOptions, this._layoutMode, this.getFontCss())).layoutW > _layoutAreaWidth) {
        text = text.slice(0, text.length - 1);
        textWithEllipsis = text + "";
      }
      if (m) {
        m.setLayoutLocationFrom(peek(this._fragments));
        this._fragments[this._fragments.length - 1] = m;
        return this._expandArea(m);
      }
    }
  };

  Layout.prototype._resetLayout = function() {
    return this._fragments = this._area = this._size = this._drawArea = null;
  };

  Layout.prototype._updateLayout = function() {
    if (this._fragments) {
      return;
    }
    this._resetLayout();
    this._generateFragments();
    this._layoutFragments();
    return this._alignFragments();
  };

  Layout.setter({
    width: function(width) {
      this._updateLayout();
      if (!float32Eq(width, this._layoutAreaWidth)) {
        this._layoutAreaWidth = width;
        this._area = null;
        this._size = null;
        this._drawArea = null;
        this._alignFragments();
      }
      return null;
    }
  });

  return Layout;

})(BaseObject);

useSafariLineWidthFix = false;

shouldUseSafariLineWidthBugFix = function() {
  var bitmap, layout, middle, ref, x, y;
  layout = new Layout("-", {
    fontFamily: "Times New Roman",
    fontSize: 32
  }, {
    layoutMode: "tight"
  });
  bitmap = layout.toBitmap({
    stroke: true,
    lineWidth: 5,
    scale: 5
  });
  ref = bitmap.size, x = ref.x, y = ref.y;
  middle = x * (y / 2 | 0) + (x / 2 | 0);
  return bitmap.getImageDataArray("alpha")[middle] === 0;
};

if (Foundation.Browser.isSafari()) {
  useSafariLineWidthFix = shouldUseSafariLineWidthBugFix();
}


/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(527);

module.exports.addModules({
  Layout: __webpack_require__(525),
  Metrics: __webpack_require__(304),
  TextLayoutFragment: __webpack_require__(305)
});


/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

var Text,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.Text', Text = (function(superClass) {
  extend(Text, superClass);

  function Text() {
    return Text.__super__.constructor.apply(this, arguments);
  }

  Text.version = __webpack_require__(598).version;

  return Text;

})(Neptune.PackageNamespace));


/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

var normalizeFieldProps, normalizeFields, ref;

ref = __webpack_require__(307), normalizeFieldProps = ref.normalizeFieldProps, normalizeFields = ref.normalizeFields;

module.exports = {
  normalizeFieldProps: normalizeFieldProps,
  normalizeFields: normalizeFields
};


/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(530);

module.exports.includeInNamespace(__webpack_require__(528)).addModules({
  DataTypes: __webpack_require__(96),
  FieldTypes: __webpack_require__(306),
  Validator: __webpack_require__(307)
});


/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

var Validation,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = (__webpack_require__(9)).addNamespace('Art.Validation', Validation = (function(superClass) {
  extend(Validation, superClass);

  function Validation() {
    return Validation.__super__.constructor.apply(this, arguments);
  }

  Validation.version = __webpack_require__(599).version;

  return Validation;

})(Neptune.PackageNamespace));


/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(529);


/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

var Art, Neptune,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Neptune = __webpack_require__(9);

module.exports = Neptune.Art || Neptune.addNamespace('Art', Art = (function(superClass) {
  extend(Art, superClass);

  function Art() {
    return Art.__super__.constructor.apply(this, arguments);
  }

  return Art;

})(Neptune.Base));


/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

var Xbd, XbdTag, _package;

Xbd = __webpack_require__(154);

XbdTag = __webpack_require__(310);

module.exports = [
  [XbdTag, "fromXbd", "createTagFactories"], {
    parse: XbdTag.fromXbd,
    "package": _package = __webpack_require__(600),
    version: _package.version
  }
];


/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(154).includeInNamespace(__webpack_require__(533)).addModules({
  XbdDictionary: __webpack_require__(309),
  XbdTag: __webpack_require__(310)
});


/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var g;

g = typeof window !== "undefined" && window !== null ? window : typeof self !== "undefined" && self !== null ? self : global;

g.global = g;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

var each, extendedEach, isArrayIterable;

isArrayIterable = __webpack_require__(312).isArrayIterable;


/*
Notes:

Comprehension loop variables are always going to mask any variables
defined in a higher scope.

With e/ee we put all the when, with and key blocks in the same function,
so they naturally share one loop-scope.
 */

module.exports = {

  /*
  IN:
    source:
      array-like (source.length is a number >= 0)
      null or undefined
      otherwise, properties are iterated
  
    out: the value that will be returned.
      out is initialized to source if out == undefined.
      This is for convenience and code-reduction in the "each-without-into-set" case.
  
    withBlock: (currentIterationValue, currentIterationKey, returning) -> ignored
  
  USE: object, array, each
   */
  each: each = function(source, out, withBlock) {
    var i, k, len, v;
    if (out == null) {
      out = source;
    }
    if (source != null) {
      if (isArrayIterable(source)) {
        for (k = i = 0, len = source.length; i < len; k = ++i) {
          v = source[k];
          withBlock(v, k, out);
        }
      } else {
        for (k in source) {
          v = source[k];
          withBlock(v, k, out);
        }
      }
    }
    return out;
  },
  e: each,

  /*
  enhanced-each
  
  Different from each :
    updating-out:   out is updated with the result of every withBlock call
    break-support:  withBlock is passed a forth argument: setShouldBreak
  
    NOTE: out is only initialized to source, if out == undefined. Any updated out
    could be set to undefined and that would be returned.
  
  setShouldBreak:
    IN: ()
    OUT: the undefined value
    EFFECT: this will be the last call to withBlock &
      the value returned by this last call will be the result
      of ee.
  
  This should be enough for all features:
    - "return" - requires a setShouldReturn function in the enclosing scope, and setShouldBreak
    - "next" - becomes a return-statement in withBlock - this works with the basic "e"
    - "break" - setShouldBreak();return out;
    - "break value" - setShouldBreak();return value;
    - "reduce" iteration - needs updating-out
    - "find" iteration - needs break-with-value
  
  Cons:
    possible performance and code-size hit:
    - ee requires more code in the withBlock: {...; return out;}
    - ee creates a setShouldBreak function every time
  
    But, with testing, we may decided those don't really matter.
  
  EXAMPLES:
  
    find v from o with v > 10
  
    Caf.ee o, null, (v, k, out, brk) ->
      brk v if v > 10
  
  
    reduce v1, v2 from o with f v1, v2
  
     * I think we need to remove the out = source default.
  
    Caf.ee o, undefined, (v2, k, v1, brk) ->
      if v1 == undefined
        v2
      else
        f v1, v2
  
     * example: object v from o with v + 1
    Caf.e(o, {}, function(v, k, into) {
      return into[k] = v + 1;
    });
  
     * example: object v from o when v > 3 with v + 1
    Caf.e(o, {}, function(v, k, into) {
      if( v > 3 ) {
        return into[k] = v + 1;
      };
    });
  
     * example: object o
    Caf.e(o, {}, function(v, k, into) {
      return into[k] = v;
    });
   */
  extendedEach: extendedEach = function(source, out, withBlock) {
    var i, k, len, setShouldBreak, shouldBreak, v;
    if (out === "undefined") {
      out = source;
    }
    if (source != null) {
      shouldBreak = false;
      setShouldBreak = function() {
        shouldBreak = true;
        return void 0;
      };
      if (isArrayIterable(source)) {
        for (k = i = 0, len = source.length; i < len; k = ++i) {
          v = source[k];
          out = withBlock(v, k, out, setShouldBreak);
          if (shouldBreak) {
            break;
          }
        }
      } else {
        for (k in source) {
          v = source[k];
          out = withBlock(v, k, out, setShouldBreak);
          if (shouldBreak) {
            break;
          }
        }
      }
    }
    return out;
  },
  ee: extendedEach
};


/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

var existsTest, isArrayIterable, returnFirst, returnSecond, returnTrue;

isArrayIterable = __webpack_require__(312).isArrayIterable;

existsTest = function(a) {
  return a != null;
};

returnTrue = function() {
  return true;
};

returnFirst = function(a) {
  return a;
};

returnSecond = function(a, b) {
  return b;
};

module.exports = {
  find: function(source, withClause, whenClause) {
    var i, j, k, l, len, len1, len2, result, v;
    if (source != null) {
      if (!(whenClause || withClause)) {
        whenClause = existsTest;
      }
      if (isArrayIterable(source)) {
        switch (false) {
          case !(whenClause && withClause):
            for (k = i = 0, len = source.length; i < len; k = ++i) {
              v = source[k];
              if (whenClause(v, k)) {
                return withClause(v, k);
              }
            }
            break;
          case !whenClause:
            for (k = j = 0, len1 = source.length; j < len1; k = ++j) {
              v = source[k];
              if (whenClause(v, k)) {
                return v;
              }
            }
            break;
          case !withClause:
            for (k = l = 0, len2 = source.length; l < len2; k = ++l) {
              v = source[k];
              if (result = withClause(v, k)) {
                return result;
              }
            }
        }
      } else {
        switch (false) {
          case !(whenClause && withClause):
            for (k in source) {
              v = source[k];
              if (whenClause(v, k)) {
                return withClause(v, k);
              }
            }
            break;
          case !whenClause:
            for (k in source) {
              v = source[k];
              if (whenClause(v, k)) {
                return v;
              }
            }
            break;
          case !withClause:
            for (k in source) {
              v = source[k];
              if (result = withClause(v, k)) {
                return result;
              }
            }
        }
      }
    }
  },
  object: function(source, withClause, whenClause, into, keyClause) {
    var i, k, len, v;
    if (withClause == null) {
      withClause = returnFirst;
    }
    if (whenClause == null) {
      whenClause = returnTrue;
    }
    if (into == null) {
      into = {};
    }
    if (isArrayIterable(source)) {
      if (keyClause == null) {
        keyClause = returnFirst;
      }
      for (k = i = 0, len = source.length; i < len; k = ++i) {
        v = source[k];
        if (whenClause(v, k)) {
          into[keyClause(v, k)] = withClause(v, k);
        }
      }
    } else {
      if (keyClause == null) {
        keyClause = returnSecond;
      }
      for (k in source) {
        v = source[k];
        if (whenClause(v, k)) {
          into[keyClause(v, k)] = withClause(v, k);
        }
      }
    }
    return into;
  },
  array: function(source, withClause, whenClause, into) {
    var i, k, len, v;
    if (withClause == null) {
      withClause = returnFirst;
    }
    if (whenClause == null) {
      whenClause = returnTrue;
    }
    if (into == null) {
      into = [];
    }
    if (isArrayIterable(source)) {
      for (k = i = 0, len = source.length; i < len; k = ++i) {
        v = source[k];
        if (whenClause(v, k)) {
          into.push(withClause(v, k));
        }
      }
    } else {
      for (k in source) {
        v = source[k];
        if (whenClause(v, k)) {
          into.push(withClause(v, k));
        }
      }
    }
    return into;
  },
  each2: function(source, withClause, whenClause, into) {
    var i, k, len, v;
    if (withClause == null) {
      withClause = returnFirst;
    }
    if (whenClause == null) {
      whenClause = returnTrue;
    }
    if (into == null) {
      into = source;
    }
    if (isArrayIterable(source)) {
      for (k = i = 0, len = source.length; i < len; k = ++i) {
        v = source[k];
        if (whenClause(v, k)) {
          withClause(v, k);
        }
      }
    } else {
      for (k in source) {
        v = source[k];
        if (whenClause(v, k)) {
          withClause(v, k);
        }
      }
    }
    return into;
  },

  /*
  IN:
    fromValue:  number (required)
    toValue:    number (required)
    byValue:    number (optional)
    into:       object implementing .push(v) (optional)
    withClause: (v) -> value-to-push
    whenCluase: (v) -> truish
    til:        t/f; if true, will stop just before v == toValue
   */
  arrayRange: function(fromValue, toValue, withClause, whenClause, byValue, til, into) {
    var v;
    if (withClause == null) {
      withClause = returnFirst;
    }
    if (whenClause == null) {
      whenClause = returnTrue;
    }
    if (into == null) {
      into = [];
    }
    if (byValue === 0) {
      throw new Error("CaffeineScript array-range comprehension: 'by' is zero. (from: " + fromValue + ", to: " + toValue + ")");
    }
    if (byValue == null) {
      byValue = fromValue < toValue ? 1 : -1;
    }
    v = fromValue;
    if (til) {
      if (byValue > 0) {
        while (v < toValue) {
          if (whenClause(v)) {
            into.push(withClause(v));
          }
          v += byValue;
        }
      } else {
        while (v > toValue) {
          if (whenClause(v)) {
            into.push(withClause(v));
          }
          v += byValue;
        }
      }
    } else {
      if (byValue > 0) {
        while (v <= toValue) {
          if (whenClause(v)) {
            into.push(withClause(v));
          }
          v += byValue;
        }
      } else {
        while (v >= toValue) {
          if (whenClause(v)) {
            into.push(withClause(v));
          }
          v += byValue;
        }
      }
    }
    return into;
  }
};


/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var _import, compactFlatten, getSuper, isDirectPrototypeOf, isFalse, isFunction, isPlainArray, isPlainObject, isTrue, ref, throwImportError,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

ref = __webpack_require__(311), compactFlatten = ref.compactFlatten, isPlainArray = ref.isPlainArray, isPlainObject = ref.isPlainObject;

__webpack_require__(535);

global.__definingModule = null;

throwImportError = function(notFound, importNames, libs) {
  var i, importFileName, importFrom, len, lib, line, ref1, ref2;
  importFrom = ((function() {
    var i, len, results;
    results = [];
    for (i = 0, len = libs.length; i < len; i++) {
      lib = libs[i];
      if (lib === global) {
        results.push("global");
      } else if (lib != null) {
        results.push(lib.namespacePath || (typeof lib.getName === "function" ? lib.getName() : void 0) || ("{" + (Object.keys(lib).join(', ')) + "}"));
      } else {
        results.push('null');
      }
    }
    return results;
  })()).join('\n  ');
  ref1 = (new Error).stack.split("\n");
  for (i = 0, len = ref1.length; i < len; i++) {
    line = ref1[i];
    if (!(line.match(/^\s/) && !line.match(/caffeine-script-runtime/))) {
      continue;
    }
    importFileName = ((ref2 = line.match(/\(([^()]+)/)) != null ? ref2[1] : void 0) || line;
    break;
  }
  console.warn("CaffineScript imports not found:\n  " + (notFound.join('\n  ')) + "\n\nimporting from:\n  " + importFrom + "\n\nsource:\n  " + importFileName + "\n");
  throw new Error("CaffineScript imports not found: " + (notFound.join(', ')));
};

module.exports = {
  "in": function(a, b) {
    return indexOf.call(b, a) >= 0;
  },
  mod: function(a, b) {
    return modulo(a, b);
  },
  div: function(a, b) {
    return Math.floor(a / b);
  },
  pow: function(a, b) {
    return Math.pow(a, b);
  },
  existsOr: function(a, b) {
    return a != null ? a : b();
  },
  exists: function(a) {
    return (a !== null && a !== void 0) || void 0;
  },
  is: function(a, b) {
    return a === b || ((a != null) && (b != null) && a.constructor === b);
  },

  /*
  Implements the 'import' function.
  
  IN:
    importNames: array of strings of identifiers to import
    libs: array of objects to import from, first has highest priority.
  
  OUT: and object with one property per importName
   */
  "import": _import = function(importNames, libs) {
    var i, importName, j, len, lib, notFound, out, v;
    out = {};
    notFound = null;
    libs = compactFlatten(libs);
    for (i = 0, len = importNames.length; i < len; i++) {
      importName = importNames[i];
      for (j = libs.length - 1; j >= 0; j += -1) {
        lib = libs[j];
        if ((v = lib[importName]) != null) {
          out[importName] = v;
          break;
        }
      }
      if (out[importName] == null) {
        (notFound || (notFound = [])).push(importName);
      }
    }
    if (notFound != null) {
      throwImportError(notFound, importNames, libs);
    }
    return out;
  },

  /*
  IN:
    importNames: array of strings
    libs: array of objects to import from, with arbitrary subarray nesting
    toInvoke: function
  
  EFFECT:
    for each import-name, libs are searched in reverse order for a value with that name.
      if no value is found, an error is down with and information is provided.
  
    toInvoke is called with each of the values found in order as arugments.
    the value form toInvoke is returned
  
  EXAMPLE:
    importInvoke(["a", "b"], [a:1, b:2], toInvoke)
    EFFECT: return toInvoke 1, 2
   */
  importInvoke: function(importNames, libs, toInvoke) {
    var importName, importValue, importValues, lib, notFound, v;
    notFound = null;
    libs = compactFlatten(libs);
    importValues = (function() {
      var i, j, len, results;
      results = [];
      for (i = 0, len = importNames.length; i < len; i++) {
        importName = importNames[i];
        importValue = null;
        for (j = libs.length - 1; j >= 0; j += -1) {
          lib = libs[j];
          if ((v = lib[importName]) != null) {
            importValue = v;
            break;
          }
        }
        results.push(importValue != null ? importValue : (notFound || (notFound = [])).push(importName));
      }
      return results;
    })();
    if (notFound != null) {
      throwImportError(notFound, importNames, libs);
    }
    return toInvoke.apply(null, importValues);
  },
  isTrue: isTrue = function(a) {
    return (a != null) && a !== false;
  },
  isFalse: isFalse = function(a) {
    return a === false || (a == null);
  },
  isFunction: isFunction = function(a) {
    return typeof a === "function";
  },
  isDirectPrototypeOf: isDirectPrototypeOf = function(o, prototype) {
    return !isFunction(o) && prototype.constructor === o.constructor;
  },
  toString: function(a) {
    if (a != null) {
      if (isPlainArray(a)) {
        return a.join('');
      } else if (isFunction(a != null ? a.toString : void 0)) {
        return a.toString();
      } else {

      }
    } else {
      return '';
    }
  },
  gt: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a > b;
    } else {
      return a.gt(b);
    }
  },
  lt: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a < b;
    } else {
      return a.lt(b);
    }
  },
  lte: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a <= b;
    } else {
      return a.lte(b);
    }
  },
  gte: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a >= b;
    } else {
      return a.gte(b);
    }
  },
  add: function(a, b) {
    if ((typeof a === "number" && typeof b === "number") || (typeof a === "string" && typeof b === "string")) {
      return a + b;
    } else {
      return a.add(b);
    }
  },
  sub: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a - b;
    } else {
      return a.sub(b);
    }
  },
  mul: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a * b;
    } else {
      return a.mul(b);
    }
  },
  div: function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a / b;
    } else {
      return a.div(b);
    }
  },

  /*
  All about getSuper in ES6 land:
  
    class A {}
    class B extends A {}
    class C extends B {}
  
    a = new A
    b = new B
    c = new C
  
    getSuper(B) == A
    getSuper(C) == B
  
    getSuper(A.prototype) == Object.prototype
    getSuper(B.prototype) == A.prototype
    getSuper(C.prototype) == B.prototype
  
    getSuper(b) == A.prototype
    getSuper(c) == B.prototype
  
  prototype map:
  
  KEY:
    <->
       <-- .constructor
       --> .prototype
    ^  Object.prototypeOf
  
  MAP:
    A <-> aPrototype
  
    ^     ^     ^
    |     |     a
    |     |
  
    B <-> bPrototype
  
    ^     ^     ^
    |     |     b
    |     |
  
    C <-> cPrototype
  
                ^
                c
  
  Definition of super:
  
    if instance then prototype's prototype
    else prototype
   */
  getSuper: getSuper = function(o) {
    var _super, out;
    if (!((typeof o === "object") || (typeof o === "function"))) {
      throw new Error("getSuper expecting an object");
    }
    _super = Object.getPrototypeOf(o);
    out = _super === Function.prototype && o.__super__ ? o.__super__.constructor : isDirectPrototypeOf(o, _super) ? Object.getPrototypeOf(_super) : _super;
    return out;
  },

  /*
  IN:
    klass a new class-function object
    init: (klass) -> outKlass
  
  OUT: if isF outKlass.createWithPostCreate
    outKlass.createWithPostCreate outKlass
  OR
    outKlass (from init)
  
  EFFECT:
    outKlass.createWithPostCreate?(outKlass) ? outKlass
   */
  defClass: function(klass, init) {
    var ref1;
    if (init != null) {
      init.call(klass, klass, getSuper(klass), getSuper(klass.prototype));
    }
    return (ref1 = typeof klass.createWithPostCreate === "function" ? klass.createWithPostCreate(klass) : void 0) != null ? ref1 : klass;
  },
  getModuleBeingDefined: function() {
    return global.__definingModule;
  },

  /*
  IN:
    defineFunciton ||
   */
  defMod: function(_module, a) {
    var lastModule, result;
    lastModule = global.__definingModule;
    global.__definingModule = _module;
    result = _module.exports = a();
    global.__definingModule = lastModule;
    return result;
  },
  i: _import,
  t: isTrue,
  f: isFalse,
  isF: isFunction
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

var k, out, ref, ref1, ref2, ref3, v;

module.exports = out = {};

ref = __webpack_require__(311);
for (k in ref) {
  v = ref[k];
  out[k] = v;
}

ref1 = __webpack_require__(536);
for (k in ref1) {
  v = ref1[k];
  out[k] = v;
}

ref2 = __webpack_require__(537);
for (k in ref2) {
  v = ref2[k];
  out[k] = v;
}

ref3 = __webpack_require__(538);
for (k in ref3) {
  v = ref3[k];
  out[k] = v;
}


/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(541);


/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var Namespace, Neptune, version,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

__webpack_require__(544);

__webpack_require__(543);

version = (__webpack_require__(601)).version;

if (global.Neptune) {
  throw new Error("Load NeptuneNamespaces(" + version + ") FAILED. Another version already loaded: " + global.Neptune.version);
}

module.exports = global.Neptune = Neptune = (function(superClass) {
  extend(Neptune, superClass);

  function Neptune() {
    return Neptune.__super__.constructor.apply(this, arguments);
  }

  Namespace.namespace = Namespace.Neptune = Neptune;

  Neptune.Namespace = Namespace;

  Neptune.PackageNamespace = __webpack_require__(542);

  Neptune.namespacePath = "Neptune";

  Neptune.namespace = null;

  Neptune.version = version;

  Neptune.Base = Namespace;

  Neptune.isNode = __webpack_require__(322);

  return Neptune;

})(Namespace = __webpack_require__(313));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

var PackageNamespace,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = PackageNamespace = (function(superClass) {
  extend(PackageNamespace, superClass);

  function PackageNamespace() {
    return PackageNamespace.__super__.constructor.apply(this, arguments);
  }

  return PackageNamespace;

})(__webpack_require__(313));


/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {if ((function() {}).name == null) {
  Object.defineProperty(global.Function.prototype, 'name', {
    get: function() {
      var matches, name;
      name = (matches = this.toString().match(/^\s*function\s*([^\s(]+)/)) ? matches[1] : "";
      Object.defineProperty(this, 'name', {
        value: name
      });
      return name;
    }
  });
}

global.Function.prototype.getName = function() {
  if (this._name && this.hasOwnProperty("_name")) {
    return this._name;
  } else {
    return this.name || "anonymousFunction";
  }
};

global.Function.prototype.hasName = function() {
  return !!((this._name && this.hasOwnProperty("_name")) || this.name);
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var g;

g = typeof window !== "undefined" && window !== null ? window : typeof self !== "undefined" && self !== null ? self : global;

g.self || (g.self = g);

g.global || (g.global = g);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(354);


/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(316);

module.exports.addModules({
  NavState: __webpack_require__(358),
  Status: __webpack_require__(359),
  ViewState: __webpack_require__(360)
});


/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(97);

module.exports.addModules({
  Main: __webpack_require__(357),
  StandardImport: __webpack_require__(18),
  StyleProps: __webpack_require__(173)
});

__webpack_require__(314);

__webpack_require__(546);


/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var elliptic = __webpack_require__(13);
var BN = __webpack_require__(10);

module.exports = function createECDH(curve) {
	return new ECDH(curve);
};

var aliases = {
	secp256k1: {
		name: 'secp256k1',
		byteLength: 32
	},
	secp224r1: {
		name: 'p224',
		byteLength: 28
	},
	prime256v1: {
		name: 'p256',
		byteLength: 32
	},
	prime192v1: {
		name: 'p192',
		byteLength: 24
	},
	ed25519: {
		name: 'ed25519',
		byteLength: 32
	},
	secp384r1: {
		name: 'p384',
		byteLength: 48
	},
	secp521r1: {
		name: 'p521',
		byteLength: 66
	}
};

aliases.p224 = aliases.secp224r1;
aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
aliases.p384 = aliases.secp384r1;
aliases.p521 = aliases.secp521r1;

function ECDH(curve) {
	this.curveType = aliases[curve];
	if (!this.curveType ) {
		this.curveType = {
			name: curve
		};
	}
	this.curve = new elliptic.ec(this.curveType.name);
	this.keys = void 0;
}

ECDH.prototype.generateKeys = function (enc, format) {
	this.keys = this.curve.genKeyPair();
	return this.getPublicKey(enc, format);
};

ECDH.prototype.computeSecret = function (other, inenc, enc) {
	inenc = inenc || 'utf8';
	if (!Buffer.isBuffer(other)) {
		other = new Buffer(other, inenc);
	}
	var otherPub = this.curve.keyFromPublic(other).getPublic();
	var out = otherPub.mul(this.keys.getPrivate()).getX();
	return formatReturnValue(out, enc, this.curveType.byteLength);
};

ECDH.prototype.getPublicKey = function (enc, format) {
	var key = this.keys.getPublic(format === 'compressed', true);
	if (format === 'hybrid') {
		if (key[key.length - 1] % 2) {
			key[0] = 7;
		} else {
			key [0] = 6;
		}
	}
	return formatReturnValue(key, enc);
};

ECDH.prototype.getPrivateKey = function (enc) {
	return formatReturnValue(this.keys.getPrivate(), enc);
};

ECDH.prototype.setPublicKey = function (pub, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(pub)) {
		pub = new Buffer(pub, enc);
	}
	this.keys._importPublic(pub);
	return this;
};

ECDH.prototype.setPrivateKey = function (priv, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(priv)) {
		priv = new Buffer(priv, enc);
	}
	var _priv = new BN(priv);
	_priv = _priv.toString(16);
	this.keys._importPrivate(_priv);
	return this;
};

function formatReturnValue(bn, enc, len) {
	if (!Array.isArray(bn)) {
		bn = bn.toArray();
	}
	var buf = new Buffer(bn);
	if (len && buf.length < len) {
		var zeros = new Buffer(len - buf.length);
		zeros.fill(0);
		buf = Buffer.concat([zeros, buf]);
	}
	if (!enc) {
		return buf;
	} else {
		return buf.toString(enc);
	}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var intSize = 4
var zeroBuffer = new Buffer(intSize)
zeroBuffer.fill(0)

var charSize = 8
var hashSize = 16

function toArray (buf) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize))
    buf = Buffer.concat([buf, zeroBuffer], len)
  }

  var arr = new Array(buf.length >>> 2)
  for (var i = 0, j = 0; i < buf.length; i += intSize, j++) {
    arr[j] = buf.readInt32LE(i)
  }

  return arr
}

module.exports = function hash (buf, fn) {
  var arr = fn(toArray(buf), buf.length * charSize)
  buf = new Buffer(hashSize)
  for (var i = 0; i < arr.length; i++) {
    buf.writeInt32LE(arr[i], i << 2, true)
  }
  return buf
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var inherits = __webpack_require__(7)
var Buffer = __webpack_require__(47).Buffer

var Base = __webpack_require__(25)

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac


/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(552)(false);
// imports


// module
exports.push([module.i, "@charset \"UTF-8\";\n.domConsole {\n  }\n  .domConsole img {\n    image-rendering: -moz-crisp-edges;\n    image-rendering: -o-crisp-edges;\n    image-rendering: -webkit-optimize-contrast;\n    image-rendering: crisp-edges;\n    -ms-interpolation-mode: nearest-neighbor;\n    border: 1px solid rgba(255, 255, 255, 0); }\n    .domConsole img:hover {\n      border: 1px solid #bbbbbb; }\n  .domConsole ul {\n    list-style-type: none; }\n  .domConsole .collapsable {\n    cursor: pointer;\n    margin: 0;\n    padding: 0;\n    padding-left: 12px;\n    margin-bottom: 5px;\n    position: relative;\n    border-left: 1px solid transparent; }\n    .domConsole .collapsable:before {\n      content: \"\\25BE\";\n      position: absolute;\n      left: 2px;\n      top: 0;\n      bottom: 0; }\n    .domConsole .collapsable:hover {\n      border-left: 1px solid #cccc44;\n      border-radius: 5px; }\n  .domConsole .collapsable.closed {\n    overflow: hidden;\n    height: 14px;\n  }\n  .domConsole .collapsable.closed.array:before {\n    content: \"\\25B9\"; }\n  .domConsole .collapsable.open.array:before {\n    content: \"\\25BF\"; }\n  .domConsole .collapsable.closed.object:before {\n    content: \"\\25B8\"; }\n  .domConsole .collapsable.open.object:before {\n    content: \"\\25BE\"; }\n  .domConsole pre {\n    margin: 0;\n    color: #555555; }\n  .domConsole .logLine {\n    font-family: \"Courier\";\n    font-size: 12px;\n    color: #aaaaaa;\n    border-right: 2px solid transparent; }\n    .domConsole .logLine .literal {\n      color: green; }\n    .domConsole .logLine .errorLiteral {\n      color: red; }\n    .domConsole .logLine .warningLiteral {\n      color: yellow; }\n    .domConsole .logLine .object .key {\n      color: #bbbb00; }\n    .domConsole .logLine:hover {\n      border-right: 2px solid #e0e0e0; }\n  .domConsole h1 {\n    margin-bottom: 20px;\n    margin-top: 40px; }\n  .domConsole h2 {\n    margin-bottom: 15px;\n    margin-top: 30px; }\n  .domConsole h3 {\n    margin-bottom: 10px;\n    margin-top: 20px; }\n  .domConsole h1 .logLine {\n    font-size: 24px;\n    border-bottom: 4px solid #e0e0e0; }\n  .domConsole h2 .logLine {\n    font-size: 20px;\n    border-bottom: 3px solid #e0e0e0; }\n  .domConsole h3 .logLine {\n    font-size: 16px;\n    border-bottom: 2px solid #e0e0e0; }\n", ""]);

// exports


/***/ }),
/* 552 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(15);
var inherits = __webpack_require__(7);

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};


/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(15);

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};


/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(15);
var inherits = __webpack_require__(7);

var des = __webpack_require__(155);
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};


/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(15);
var inherits = __webpack_require__(7);

var des = __webpack_require__(155);
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;


/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};


/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var generatePrime = __webpack_require__(323)
var primes = __webpack_require__(602)

var DH = __webpack_require__(559)

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var BN = __webpack_require__(10);
var MillerRabin = __webpack_require__(335);
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = __webpack_require__(323);
var randomBytes = __webpack_require__(63);
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(10);
var elliptic = __webpack_require__(13);
var utils = elliptic.utils;
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};


/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(100);
var elliptic = __webpack_require__(13);
var BN = __webpack_require__(10);
var inherits = __webpack_require__(7);
var Base = curve.base;

var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - 1) / (d y^2 + 1)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.one);
  var rhs = y2.redMul(this.d).redAdd(this.one);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
         this.y.cmp(this.z) === 0;
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.c.redMul(this.z)).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
  return false;
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;


/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(100);
var BN = __webpack_require__(10);
var inherits = __webpack_require__(7);
var Base = curve.base;

var elliptic = __webpack_require__(13);
var utils = elliptic.utils;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};


/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curve = __webpack_require__(100);
var elliptic = __webpack_require__(13);
var BN = __webpack_require__(10);
var inherits = __webpack_require__(7);
var Base = curve.base;

var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
  return false;
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};


/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var curves = exports;

var hash = __webpack_require__(157);
var elliptic = __webpack_require__(13);

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = __webpack_require__(571);
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});


/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(10);
var HmacDRBG = __webpack_require__(581);
var elliptic = __webpack_require__(13);
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = __webpack_require__(566);
var Signature = __webpack_require__(567);

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};


/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(10);
var elliptic = __webpack_require__(13);
var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};


/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(10);

var elliptic = __webpack_require__(13);
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};


/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(157);
var elliptic = __webpack_require__(13);
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = __webpack_require__(569);
var Signature = __webpack_require__(570);

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = elliptic.curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};


/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var elliptic = __webpack_require__(13);
var utils = elliptic.utils;
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;


/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BN = __webpack_require__(10);
var elliptic = __webpack_require__(13);
var utils = elliptic.utils;
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;


/***/ }),
/* 571 */
/***/ (function(module, exports) {

module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};


/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = exports;
var BN = __webpack_require__(10);
var minAssert = __webpack_require__(15);
var minUtils = __webpack_require__(336);

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;



/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
var Transform = __webpack_require__(163).Transform
var inherits = __webpack_require__(7)

function HashBase (blockSize) {
  Transform.call(this)

  this._block = new Buffer(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    if (encoding !== 'buffer') chunk = new Buffer(chunk, encoding)
    this.update(chunk)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this._digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = new Buffer(data, encoding || 'binary')

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function (data) {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)
  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(22);
var assert = __webpack_require__(15);

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(22);
var common = __webpack_require__(62);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(578);
exports.sha224 = __webpack_require__(579);
exports.sha256 = __webpack_require__(324);
exports.sha384 = __webpack_require__(580);
exports.sha512 = __webpack_require__(325);


/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(22);
var common = __webpack_require__(62);
var shaCommon = __webpack_require__(326);

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(22);
var SHA256 = __webpack_require__(324);

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(22);

var SHA512 = __webpack_require__(325);

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hash = __webpack_require__(157);
var utils = __webpack_require__(336);
var assert = __webpack_require__(15);

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};


/***/ }),
/* 582 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 583 */
/***/ (function(module, exports, __webpack_require__) {

var Q = __webpack_require__(613);
module.exports = function(dbName) {
  var version;
  var doUpgrade;
  var objectStores;

  var debug = false;

  this.setDebug = function() {
    debug = true;
    return this;
  };

  this.setVersion = function(pVersion) {
    version = pVersion;
    return this;
  };

  this.setDoUpgrade = function(pDoUpgrade) {
    doUpgrade = pDoUpgrade;
    return this;
  };

  this.addObjectStore = function(store) {
    if(!objectStores) {
      objectStores = [];
    }

    objectStores.push(store);
    return this;
  };

  this.build = function() {
    if(!doUpgrade) {
      doUpgrade = function(db) {
        objectStores.forEach(function(objStore) {
          var objectStore = db.createObjectStore(objStore.name, objStore.keyType);

          if(objStore.indexes) {
            objStore.indexes.forEach(function(index) {
              objectStore.createIndex(index.name, index.keyPath, index.options);
            });
          }
        });
      };
    }

    var indexeddb = new Indexeddb(dbName, version, doUpgrade);

    if(objectStores) {
      objectStores.forEach(function(store) {
        var objectStore = new ObjectStore(indexeddb.getDb(), store.name);
        indexeddb[store.name] = objectStore;

        if(store.indexes) {
          store.indexes.forEach(function(index) {
            indexeddb[store.name + 'By' + capitalize(index.name)] =
              new Index(indexeddb.getDb(), store.name, index.name);
          });
        }
      });
    }

    if(debug) {
      var global = Function('return this')();
      global['indexeddbPromised_'+dbName] = indexeddb;
    }

    return indexeddb;
  };

  function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  return this;
};

var ObjectStore = function(db, storeName) {
  this.db = db;
  this.storeName = storeName;

  return this;
}

ObjectStore.prototype.getStoreOrIndex = function(objectStore) {
  return objectStore;
};

ObjectStore.prototype.add = function(record, key) {
  var self = this;
  var deferTransaction = Q.defer();
  var resultAdd;
  var operationError;

  this.db.then(function(db) {
    return db.transaction(self.storeName, "readwrite");
  })
  .then(function(transaction) {
    transaction.oncomplete = function(event) {
      deferTransaction.resolve(resultAdd);
    };

    transaction.onerror = function(event) {
      deferTransaction.reject(new Error(operationError || event.target.errorCode || null));
    };

    var objectStore = transaction.objectStore(self.storeName);
    var storeOrIndex = self.getStoreOrIndex(objectStore);
    var request = storeOrIndex.add(record, key);

    request.onsuccess = function(event) {
      resultAdd = event.target.result;
    };
    request.onerror = function(event) {
      operationError = event.target.errorCode;
    };
  });

  return deferTransaction.promise;
};

ObjectStore.prototype.count = function() {
  var self = this;
  var deferTransaction = Q.defer();
  var count;
  var operationError;

  return this.db.then(function(db) {
    return db.transaction(self.storeName);
  })
  .then(function(transaction) {
    transaction.oncomplete = function(event) {
      deferTransaction.resolve(count);
    };

    transaction.onerror = function(event) {
      deferTransaction.reject(new Error(operationError || event.target.errorCode || null));
    };

    var objectStore = transaction.objectStore(self.storeName);
    var storeOrIndex = self.getStoreOrIndex(objectStore);
    var request = storeOrIndex.count();

    request.onerror = function(event) {
      operationError = event.target.errorCode;
    };

    request.onsuccess = function(event) {
      count = event.target.result;
    };

    return deferTransaction.promise;
  });
}

ObjectStore.prototype.get = function(key) {
  var self = this;
  var deferTransaction = Q.defer();
  var getResult;
  var operationError;

  return this.db.then(function(db) {
    return db.transaction(self.storeName);
  })
  .then(function(transaction) {
    transaction.oncomplete = function(event) {
      deferTransaction.resolve(getResult);
    };

    transaction.onerror = function(event) {
      deferTransaction.reject(new Error(operationError || event.target.errorCode || null));
    };

    var objectStore = transaction.objectStore(self.storeName);
    var storeOrIndex = self.getStoreOrIndex(objectStore);
    var request = storeOrIndex.get(key);

    request.onerror = function(event) {
      operationError = event.target.errorCode;
    };
    request.onsuccess = function(event) {
      getResult = event.target.result;
    };

    return deferTransaction.promise;
  });
};

ObjectStore.prototype.delete = function(key) {
  var self = this;
  var deferTransaction = Q.defer();
  var operationError;

  return this.db.then(function(db) {
    return db.transaction(self.storeName, 'readwrite');
  })
  .then(function(transaction) {
    transaction.oncomplete = function(event) {
      deferTransaction.resolve(null);
    };

    transaction.onerror = function(event) {
      deferTransaction.reject(new Error(operationError || event.target.errorCode || null));
    };

    var objectStore = transaction.objectStore(self.storeName);
    var storeOrIndex = self.getStoreOrIndex(objectStore);
    var request = storeOrIndex.delete(key);

    request.onerror = function(event) {
      operationError = event.target.errorCode;
    };

    return deferTransaction.promise;
  });
};

ObjectStore.prototype.clear = function() {
  var self = this;
  var deferTransaction = Q.defer();
  var operationError;

  return this.db.then(function(db) {
    return db.transaction(self.storeName, 'readwrite');
  })
  .then(function(transaction) {
    transaction.oncomplete = function(event) {
      deferTransaction.resolve(null);
    };

    transaction.onerror = function(event) {
      deferTransaction.reject(new Error(operationError || event.target.errorCode || null));
    };

    var objectStore = transaction.objectStore(self.storeName);
    var storeOrIndex = self.getStoreOrIndex(objectStore);
    var request = storeOrIndex.clear();

    request.onerror = function(event) {
      operationError = event.target.errorCode;
    };

    return deferTransaction.promise;
  });
};

ObjectStore.prototype.put = function(record, key) {
  var self = this;
  var deferTransaction = Q.defer();
  var putResult;
  var operationError;

  this.db.then(function(db) {
    return db.transaction(self.storeName, "readwrite");
  })
  .then(function(transaction) {
    transaction.oncomplete = function(event) {
      deferTransaction.resolve(putResult);
    };

    transaction.onerror = function(event) {
      deferTransaction.reject(new Error(operationError || event.target.errorCode || null));
    };

    var objectStore = transaction.objectStore(self.storeName);
    var storeOrIndex = self.getStoreOrIndex(objectStore);
    var request = storeOrIndex.put(record, key);

    request.onsuccess = function(event) {
      putResult = event.target.result;
    };

    request.onerror = function(event) {
      operationError = event.target.errorCode;
    };

  });

  return deferTransaction.promise;
};

ObjectStore.prototype.getAll = function() {
  var self = this;
  var deferTransaction = Q.defer();
  var result = [];
  var operationError;

  this.db.then(function(db) {
    var transaction = db.transaction(self.storeName);

    transaction.oncomplete = function(event) {
      deferTransaction.resolve(result);
    };

    transaction.onerror = function(event) {
      deferTransaction.reject(new Error(operationError || event.target.errorCode || null));
    };

    var objectStore = transaction.objectStore(self.storeName);
    var cursor = self.getStoreOrIndex(objectStore)
    .openCursor();

    cursor.onsuccess = function(event) {
      var cursorResult = event.target.result;
      if(cursorResult) {
        result.push(cursorResult.value);
        cursorResult.continue();
      }
    };

    cursor.onerror = function(event) {
      operationError = event.target.errorCode;
    };

  });

  return deferTransaction.promise;
};

ObjectStore.prototype.getAllKeys = function() {
  var self = this;
  var deferTransaction = Q.defer();
  var result = [];
  var operationError;

  this.db.then(function(db) {
    var transaction = db.transaction(self.storeName);

    transaction.oncomplete = function(event) {
      deferTransaction.resolve(result);
    };

    transaction.onerror = function(event) {
      deferTransaction.reject(new Error(operationError || event.target.errorCode || null));
    };

    var objectStore = transaction.objectStore(self.storeName);
    var cursor = self.getStoreOrIndex(objectStore)
    .openCursor();

    cursor.onsuccess = function(event) {
      var cursorResult = event.target.result;
      if(cursorResult) {
        result.push(cursorResult.key);
        cursorResult.continue();
      }
    };

    cursor.onerror = function(event) {
      operationError = event.target.errorCode;
    };
  });

  return deferTransaction.promise;
};

ObjectStore.prototype.openCursor = function(idbKeyRange, direction) {
  var self = this;

  return this.db.then(function(db) {
    var transaction = db.transaction(self.storeName);
    var objectStore = transaction.objectStore(self.storeName);

    return new Cursor(self.getStoreOrIndex(objectStore), idbKeyRange, direction);
  });
};

ObjectStore.prototype.openProgressiveCursor = function(idbKeyRange, direction) {
  var self = this;

  var countDone = Q.defer();
  var defers = [];

  return this.db.then(function(db) {
    self.db = db;

    var transaction = db.transaction(self.storeName);
    var objectStore = transaction.objectStore(self.storeName);

    var countRequest = objectStore.count(idbKeyRange);
    countRequest.onsuccess = function() {
      defers.length = countRequest.result;
      for(var i=0;i < defers.length;i++) {
        defers[i] = Q.defer();
      }
      countDone.resolve(defers);
    };

    return countDone.promise;
  })
  .then(function(defers) {
    // Need to create a new transaction because the previous one won't be active
    var transaction = self.db.transaction(self.storeName);
    var objectStore = transaction.objectStore(self.storeName);

    return new ProgressiveCursor(self.getStoreOrIndex(objectStore), idbKeyRange, direction, defers);
  });
};

var Index = function(db, storeName, indexName) {
  ObjectStore.call(this, db, storeName);

  this.indexName = indexName;

  return this;
};

Index.prototype = Object.create(ObjectStore.prototype);
Index.prototype.getStoreOrIndex = function(objectStore) {
  return objectStore.index(this.indexName);
};
Index.prototype.constructor = Index;

var Cursor = function(objectStore, idbKeyRange, direction) {
  var defer = Q.defer();
  var result = [];

  var cursor = objectStore.openCursor(idbKeyRange, direction);

  cursor.onsuccess = function(event) {
    var cursorResult = event.target.result;
    if(cursorResult) {
      result.push({key: cursorResult.key, value: cursorResult.value});
      cursorResult.continue();
    } else {
      this[Symbol.iterator] = function* () {
        var i = 0;
        while(i < result.length) {
          yield result[i];
          i++;
        }
      };
      defer.resolve(this);
    }
  };

  cursor.onerror = function(event) {
    defer.reject(new Error(event.target.errorCode || null));
  };

  return defer.promise;
};

var ProgressiveCursor = function(objectStore, idbKeyRange, direction, defers) {

  var self = this;

  var records = [];

  defers.forEach(function(defer) {
    records.push(defer.promise);
  });

  this[Symbol.iterator] = function* () {
    var recordsCount = records.length;
    for(var i=0;i < recordsCount;i++) {
      var record = records.shift();
      yield record;
    }
  };

  objectStore.openCursor(idbKeyRange, direction)
  .onsuccess = function(event) {
    var cursorResult = event.target.result;
    if(cursorResult) {
      var defer = defers.shift();
      defer.resolve({key: cursorResult.key, value: cursorResult.value});
      cursorResult.continue();
    }
  };

  return this;
};

var Indexeddb = function(dbName, version, doUpgrade) {
  var openDbDeferred = Q.defer();

  var db = openDbDeferred.promise;
  this.db = db;

  var request;

  if(version) {
    request = window.indexedDB.open(dbName, version);
  } else {
    request = window.indexedDB.open(dbName);
  }

  request.onupgradeneeded = function(event) {
    var db = event.target.result;
    if(doUpgrade) {
      doUpgrade(db);
    }
  };
  request.onerror = function(event) {
    openDbDeferred.reject(new Error(event.target.errorCode || null));
  };
  request.onsuccess = function(event) {
    openDbDeferred.resolve(event.target.result);
  };

  return this;
}

Indexeddb.prototype.getDb = function() {
  return this.db;
};

Indexeddb.prototype.execTransaction = function(operations, objectStores, mode) {

  var execute = function(db) {
    var queue = Q([]);
    var tx = db.transaction(objectStores, mode);

    operations.forEach(function(operation) {
      var deferred = Q.defer();
      queue = queue.then(function(resultsAccumulator) {
        resultsAccumulator.push(deferred.promise)
        return resultsAccumulator;
      });
      var request = operation(tx);

      if(!request) {
        deferred.resolve(null);
      } else if('onsuccess' in request && 'onerror' in request) {
        request.onsuccess = function(event) {
          deferred.resolve(event.target.result);
        };
        request.oncomplete = function(event) {
          deferred.resolve(event.target.result);
        };
        request.onerror = function(event) {
          deferred.reject(new Error(event.target.errorCode || null));
        };
      } else {
        deferred.resolve(request);
      }
    });

    return Q.all(queue);
  };

  return this.db.then(execute);
};


/***/ }),
/* 584 */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),
/* 585 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-communication-status":"*","art-config":"*","art-rest-client":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.2","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.2.1","commander":"^2.15.1","css-loader":"^0.28.4","dateformat":"^3.0.3","detect-node":"^2.0.3","fs-extra":"^5.0.0","glob":"^7.1.2","glob-promise":"^3.4.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Art.Binary","license":"ISC","name":"art-binary","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"0.2.1"}

/***/ }),
/* 586 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-atomic":"git://github.com/imikimi/art-atomic.git","art-build-configurator":"^1.8.1","art-class-system":"^1.0.1","art-config":"^1.0.0","art-foundation":"git://github.com/imikimi/art-foundation.git","art-standard-lib":"^1.1.0","art-testbench":"^1.0.0","bluebird":"^3.5.0","caffeine-script":"^0.38.1","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^1.1.4","chai":"^4.0.1","coffee-loader":"^0.7.2","coffee-script":"^1.12.3","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.26.1","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"^1.9.1","script-loader":"^0.7.0","style-loader":"^0.13.1","webfontloader":"^1.6.26","webpack":"^2.2.1","webpack-dev-server":"^2.3.0","webpack-merge":"^3.0.0","webpack-node-externals":"^1.6.0"},"license":"ISC","name":"art-canvas","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress"},"version":"1.19.2"}

/***/ }),
/* 587 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Enhances javascript/coffeescript classes with features of more evolved class-based languages primarily through a new BaseClass.","license":"ISC","name":"art-class-system","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.10.11"}

/***/ }),
/* 588 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Simplified system of statuses for HTTP and any other network protocol","license":"ISC","name":"art-communication-status","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.5.2"}

/***/ }),
/* 589 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-events":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"A powerful yet simple tool for configuring all your libraries consistently.","license":"ISC","name":"art-config","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.9.0"}

/***/ }),
/* 590 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Art.Epoch","license":"ISC","name":"art-epoched-state","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.0.1"}

/***/ }),
/* 591 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","indexeddb-promised":"^1.3.1","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Art.Ery.IndexedDb","license":"ISC","name":"art-ery-indexed-db","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress"},"version":"0.1.2"}

/***/ }),
/* 592 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-epoched-state":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Epoched event system","license":"ISC","name":"art-events","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.2.4"}

/***/ }),
/* 593 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Create Declarative frameworks that output tree structures with properties (e.g. ArtReact)","license":"ISC","name":"art-object-tree-factory","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.2.0"}

/***/ }),
/* 594 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-engine":"git://github.com/imikimi/art-engine.git","art-engine-remote":"git://github.com/imikimi/art-engine-remote.git","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.2","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.2.1","commander":"^2.15.1","css-loader":"^0.28.4","dateformat":"^3.0.3","detect-node":"^2.0.3","fs-extra":"^5.0.0","glob":"^7.1.2","glob-promise":"^3.4.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Art.React is inspired by Facebook's React. In fact, it is much the same. However, ArtReact is designed from the ground up to run with the Art.Engine.","license":"ISC","name":"art-react","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress"},"version":"1.19.1"}

/***/ }),
/* 595 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-communication-status":"^1.0.0","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.2","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.2.1","commander":"^2.15.1","css-loader":"^0.28.4","dateformat":"^3.0.3","detect-node":"^2.0.3","fs-extra":"^5.0.0","glob":"^7.1.2","glob-promise":"^3.4.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0","xhr2":"^0.1.4"},"description":"Promise-based rest-client library. Makes HTTP/HTTPS easy in both NODE and BROWSER.","license":"ISC","name":"art-rest-client","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.6.4"}

/***/ }),
/* 596 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.2","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.2.1","commander":"^2.15.1","css-loader":"^0.28.4","dateformat":"^3.0.3","detect-node":"^2.0.3","fs-extra":"^5.0.0","glob":"^7.1.2","glob-promise":"^3.4.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"The Standard Library for JavaScript that aught to be.","license":"ISC","name":"art-standard-lib","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.36.0"}

/***/ }),
/* 597 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-canvas":"git://github.com/imikimi/art-canvas.git","art-class-system":"*","art-config":"*","art-engine":"git://github.com/imikimi/art-engine.git","art-ery":"git://github.com/imikimi/art-ery.git","art-events":"git://github.com/imikimi/art-events.git","art-flux":"git://github.com/imikimi/art-flux.git","art-foundation":"git://github.com/imikimi/art-foundation.git","art-react":"git://github.com/imikimi/art-react.git","art-standard-lib":"*","art-testbench":"*","art-text":"git://github.com/imikimi/art-text.git","art-validation":"*","art-xbd":"git://github.com/imikimi/art-xbd.git","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"All the Art.* Packages you need for writing Apps in one require.","license":"ISC","name":"art-suite","script":{"testInBrowser":"webpack-dev-server --progress"},"scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress"},"version":"1.7.0"}

/***/ }),
/* 598 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-canvas":"git://github.com/imikimi/art-canvas.git","art-class-system":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Art.Text","license":"ISC","name":"art-text","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress","testInBrowser":"webpack-dev-server --progress"},"version":"1.1.4"}

/***/ }),
/* 599 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-build-configurator":"*","art-class-system":"*","art-communication-status":"*","art-config":"*","art-standard-lib":"*","art-testbench":"*","bluebird":"^3.5.0","caffeine-script":"*","caffeine-script-runtime":"*","case-sensitive-paths-webpack-plugin":"^2.1.1","chai":"^4.0.1","coffee-loader":"^0.7.3","coffee-script":"^1.12.6","colors":"^1.1.2","commander":"^2.9.0","css-loader":"^0.28.4","dateformat":"^2.0.0","detect-node":"^2.0.3","fs-extra":"^3.0.1","glob":"^7.1.2","glob-promise":"^3.1.0","json-loader":"^0.5.4","mocha":"^3.4.2","neptune-namespaces":"*","script-loader":"^0.7.0","style-loader":"^0.18.1","webpack":"^2.6.1","webpack-dev-server":"^2.4.5","webpack-merge":"^4.1.0","webpack-node-externals":"^1.6.0"},"description":"Validate object props.","license":"ISC","name":"art-validation","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"1.6.4"}

/***/ }),
/* 600 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-class-system":"^1.0.1","art-config":"^1.0.0","art-foundation":"git://github.com/imikimi/art-foundation.git","art-standard-lib":"^1.1.0","art-testbench":"^1.0.0","case-sensitive-paths-webpack-plugin":"^1.1.4","coffee-loader":"^0.7.2","coffee-script":"^1.12.3","css-loader":"^0.26.1","json-loader":"^0.5.4","neptune-namespaces":"^1.9.1","script-loader":"^0.7.0","style-loader":"^0.13.1","webpack":"^2.2.1","webpack-dev-server":"^2.3.0","webpack-merge":"^3.0.0"},"license":"ISC","name":"art-xbd","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"webpack-dev-server --progress"},"version":"1.0.1"}

/***/ }),
/* 601 */
/***/ (function(module, exports) {

module.exports = {"author":"Shane Brinkman-Davis Delamore, Imikimi LLC","dependencies":{"art-standard-lib":"*","coffee-script":"*"},"description":"Neptune.Namespaces.Runtime","license":"ISC","name":"neptune-namespaces-runtime","scripts":{"build":"webpack --progress","start":"webpack-dev-server --hot --inline --progress","test":"nn -s;mocha -u tdd --compilers coffee:coffee-script/register","testInBrowser":"webpack-dev-server --progress"},"version":"3.0.7"}

/***/ }),
/* 602 */
/***/ (function(module, exports) {

module.exports = {"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}

/***/ }),
/* 603 */
/***/ (function(module, exports) {

module.exports = {"_from":"elliptic@^6.0.0","_id":"elliptic@6.4.0","_inBundle":false,"_integrity":"sha1-ysmvh2LIWDYYcAPI3+GT5eLq5d8=","_location":"/elliptic","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"elliptic@^6.0.0","name":"elliptic","escapedName":"elliptic","rawSpec":"^6.0.0","saveSpec":null,"fetchSpec":"^6.0.0"},"_requiredBy":["/browserify-sign","/create-ecdh"],"_resolved":"https://registry.npmjs.org/elliptic/-/elliptic-6.4.0.tgz","_shasum":"cac9af8762c85836187003c8dfe193e5e2eae5df","_spec":"elliptic@^6.0.0","_where":"/Users/shanebdavis/imikimi/npm/node_modules/browserify-sign","author":{"name":"Fedor Indutny","email":"fedor@indutny.com"},"bugs":{"url":"https://github.com/indutny/elliptic/issues"},"bundleDependencies":false,"dependencies":{"bn.js":"^4.4.0","brorand":"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0","inherits":"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"},"deprecated":false,"description":"EC cryptography","devDependencies":{"brfs":"^1.4.3","coveralls":"^2.11.3","grunt":"^0.4.5","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^8.6.2","istanbul":"^0.4.2","jscs":"^2.9.0","jshint":"^2.6.0","mocha":"^2.1.0"},"files":["lib"],"homepage":"https://github.com/indutny/elliptic","keywords":["EC","Elliptic","curve","Cryptography"],"license":"MIT","main":"lib/elliptic.js","name":"elliptic","repository":{"type":"git","url":"git+ssh://git@github.com/indutny/elliptic.git"},"scripts":{"jscs":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","jshint":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","lint":"npm run jscs && npm run jshint","test":"npm run lint && npm run unit","unit":"istanbul test _mocha --reporter=spec test/index.js","version":"grunt dist && git add dist/"},"version":"6.4.0"}

/***/ }),
/* 604 */
/***/ (function(module, exports) {

module.exports = {"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"}

/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global define, KeyboardEvent, module */

(function () {

  var keyboardeventKeyPolyfill = {
    polyfill: polyfill,
    keys: {
      3: 'Cancel',
      6: 'Help',
      8: 'Backspace',
      9: 'Tab',
      12: 'Clear',
      13: 'Enter',
      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Escape',
      28: 'Convert',
      29: 'NonConvert',
      30: 'Accept',
      31: 'ModeChange',
      32: ' ',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'ArrowLeft',
      38: 'ArrowUp',
      39: 'ArrowRight',
      40: 'ArrowDown',
      41: 'Select',
      42: 'Print',
      43: 'Execute',
      44: 'PrintScreen',
      45: 'Insert',
      46: 'Delete',
      48: ['0', ')'],
      49: ['1', '!'],
      50: ['2', '@'],
      51: ['3', '#'],
      52: ['4', '$'],
      53: ['5', '%'],
      54: ['6', '^'],
      55: ['7', '&'],
      56: ['8', '*'],
      57: ['9', '('],
      91: 'OS',
      93: 'ContextMenu',
      144: 'NumLock',
      145: 'ScrollLock',
      181: 'VolumeMute',
      182: 'VolumeDown',
      183: 'VolumeUp',
      186: [';', ':'],
      187: ['=', '+'],
      188: [',', '<'],
      189: ['-', '_'],
      190: ['.', '>'],
      191: ['/', '?'],
      192: ['`', '~'],
      219: ['[', '{'],
      220: ['\\', '|'],
      221: [']', '}'],
      222: ["'", '"'],
      224: 'Meta',
      225: 'AltGraph',
      246: 'Attn',
      247: 'CrSel',
      248: 'ExSel',
      249: 'EraseEof',
      250: 'Play',
      251: 'ZoomOut'
    }
  };

  // Function keys (F1-24).
  var i;
  for (i = 1; i < 25; i++) {
    keyboardeventKeyPolyfill.keys[111 + i] = 'F' + i;
  }

  // Printable ASCII characters.
  var letter = '';
  for (i = 65; i < 91; i++) {
    letter = String.fromCharCode(i);
    keyboardeventKeyPolyfill.keys[i] = [letter.toLowerCase(), letter.toUpperCase()];
  }

  function polyfill () {
    if (!('KeyboardEvent' in window) ||
        'key' in KeyboardEvent.prototype) {
      return false;
    }

    // Polyfill `key` on `KeyboardEvent`.
    var proto = {
      get: function (x) {
        var key = keyboardeventKeyPolyfill.keys[this.which || this.keyCode];

        if (Array.isArray(key)) {
          key = key[+this.shiftKey];
        }

        return key;
      }
    };
    Object.defineProperty(KeyboardEvent.prototype, 'key', proto);
    return proto;
  }

  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (keyboardeventKeyPolyfill),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
    module.exports = keyboardeventKeyPolyfill;
  } else if (window) {
    window.keyboardeventKeyPolyfill = keyboardeventKeyPolyfill;
  }

})();


/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.


var asn1 = __webpack_require__(50)

exports.certificate = __webpack_require__(607)

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})


/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen



var asn = __webpack_require__(50)

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate


/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED\n\r?DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\n\r?\n\r?([0-9A-z\n\r\+\/\=]+)\n\r?/m
var startRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----\n/m
var fullRegex = /^-----BEGIN ((?:.* KEY)|CERTIFICATE)-----\n\r?([0-9A-z\n\r\+\/\=]+)\n\r?-----END \1-----$/m
var evp = __webpack_require__(101)
var ciphers = __webpack_require__(108)
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/\r?\n/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = new Buffer(match[2], 'hex')
    var cipherText = new Buffer(match[3].replace(/\r?\n/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {var checkParameters = __webpack_require__(340)
var defaultEncoding = __webpack_require__(339)
var sync = __webpack_require__(341)
var Buffer = __webpack_require__(47).Buffer

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  'sha': 'SHA-1',
  'sha-1': 'SHA-1',
  'sha1': 'SHA-1',
  'sha256': 'SHA-256',
  'sha-256': 'SHA-256',
  'sha384': 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'sha512': 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}
function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}
function resolvePromise (promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out)
    })
  }, function (e) {
    process.nextTick(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  checkParameters(iterations, keylen)
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]
  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
  }
  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) {
      return browserPbkdf2(password, salt, iterations, keylen, algo)
    } else {
      return sync(password, salt, iterations, keylen, digest)
    }
  }), callback)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(23)))

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

exports.publicEncrypt = __webpack_require__(612);
exports.privateDecrypt = __webpack_require__(611);

exports.privateEncrypt = function privateEncrypt(key, buf) {
  return exports.publicEncrypt(key, buf, true);
};

exports.publicDecrypt = function publicDecrypt(key, buf) {
  return exports.privateDecrypt(key, buf, true);
};

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var parseKeys = __webpack_require__(103);
var mgf = __webpack_require__(342);
var xor = __webpack_require__(344);
var bn = __webpack_require__(10);
var crt = __webpack_require__(109);
var createHash = __webpack_require__(61);
var withPublic = __webpack_require__(343);
module.exports = function privateDecrypt(private_key, enc, reverse) {
  var padding;
  if (private_key.padding) {
    padding = private_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  
  var key = parseKeys(private_key);
  var k = key.modulus.byteLength();
  if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error');
  }
  var msg;
  if (reverse) {
    msg = withPublic(new bn(enc), key);
  } else {
    msg = crt(enc, key);
  }
  var zBuffer = new Buffer(k - msg.length);
  zBuffer.fill(0);
  msg = Buffer.concat([zBuffer, msg], k);
  if (padding === 4) {
    return oaep(key, msg);
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error('unknown padding');
  }
};

function oaep(key, msg){
  var n = key.modulus;
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (msg[0] !== 0) {
    throw new Error('decryption error');
  }
  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb =  msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error');
  }
  var i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error');
  }
  return db.slice(i);
}

function pkcs1(key, msg, reverse){
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  var ps = msg.slice(2, i - 1);
  var p2 = msg.slice(i - 1, i);

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)){
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error('decryption error');
  }
  return  msg.slice(i);
}
function compare(a, b){
  a = new Buffer(a);
  b = new Buffer(b);
  var dif = 0;
  var len = a.length;
  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }
  var i = -1;
  while (++i < len) {
    dif += (a[i] ^ b[i]);
  }
  return dif;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 612 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var parseKeys = __webpack_require__(103);
var randomBytes = __webpack_require__(63);
var createHash = __webpack_require__(61);
var mgf = __webpack_require__(342);
var xor = __webpack_require__(344);
var bn = __webpack_require__(10);
var withPublic = __webpack_require__(343);
var crt = __webpack_require__(109);

var constants = {
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_PKCS1_PADDIN: 1,
  RSA_NO_PADDING: 3
};

module.exports = function publicEncrypt(public_key, msg, reverse) {
  var padding;
  if (public_key.padding) {
    padding = public_key.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  var key = parseKeys(public_key);
  var paddedMsg;
  if (padding === 4) {
    paddedMsg = oaep(key, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    paddedMsg = new bn(msg);
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus');
    }
  } else {
    throw new Error('unknown padding');
  }
  if (reverse) {
    return crt(paddedMsg, key);
  } else {
    return withPublic(paddedMsg, key);
  }
};

function oaep(key, msg){
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long');
  }
  var ps = new Buffer(k - mLen - hLen2 - 2);
  ps.fill(0);
  var dblen = k - hLen - 1;
  var seed = randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
}
function pkcs1(key, msg, reverse){
  var mLen = msg.length;
  var k = key.modulus.byteLength();
  if (mLen > k - 11) {
    throw new Error('message too long');
  }
  var ps;
  if (reverse) {
    ps = new Buffer(k - mLen - 3);
    ps.fill(0xff);
  } else {
    ps = nonZero(k - mLen - 3);
  }
  return new bn(Buffer.concat([new Buffer([0, reverse?1:2]), ps, new Buffer([0]), msg], k));
}
function nonZero(len, crypto) {
  var out = new Buffer(len);
  var i = 0;
  var cache = randomBytes(len*2);
  var cur = 0;
  var num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len*2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (true) {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.toString()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you dont need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Millers explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {
    obj[prop] = descriptor.value;
    return obj;
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
                object_defineProperty(error, "__minimumStackCounter__", {value: p.stackCounter, configurable: true});
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        var stack = filterStackString(concatedStacks);
        object_defineProperty(error, "stack", {value: stack, configurable: true});
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * The counter is used to determine the stopping point for building
 * long stack traces. In makeStackTraceLong we walk backwards through
 * the linked list of promises, only stacks which were created before
 * the rejection are concatenated.
 */
var longStackCounter = 1;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            promise.stackCounter = longStackCounter++;
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;

        if (Q.longStackSupport && hasStacks) {
            // Only hold a reference to the new promise if long stacks
            // are enabled to reduce memory usage
            promise.source = newPromise;
        }

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Q can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If its a fulfilled promise, the fulfillment value is nearer.
 * If its a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected(err) {
            pendingCount--;
            if (pendingCount === 0) {
                err.message = ("Q can't get fulfillment value from any promise, all " +
                    "promises were rejected. Last error message: " + err.message);
                deferred.reject(err);
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    if (!callback || typeof callback.apply !== "function") {
        throw new Error("Q can't apply finally callback");
    }
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    if (callback === undefined) {
        throw new Error("Q can't wrap an undefined function");
    }
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(23), __webpack_require__(165).setImmediate))

/***/ }),
/* 614 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(34);


/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(346);

/*<replacement>*/
var util = __webpack_require__(60);
util.inherits = __webpack_require__(7);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(159).Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(160).PassThrough


/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(160).Transform


/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(158);


/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3), __webpack_require__(23)))

/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = __webpack_require__(7)
var Hash = __webpack_require__(48)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(7)
var Hash = __webpack_require__(48)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(7)
var Sha256 = __webpack_require__(349)
var Hash = __webpack_require__(48)

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var inherits = __webpack_require__(7)
var SHA512 = __webpack_require__(350)
var Hash = __webpack_require__(48)

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(551);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(626)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../../node_modules/css-loader/index.js!./style.css", function() {
			var newContent = require("!!../../../../../node_modules/css-loader/index.js!./style.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(627);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 627 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(353);
var bytesToUuid = __webpack_require__(352);

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(353);
var bytesToUuid = __webpack_require__(352);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

var indexOf = __webpack_require__(584);

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};


/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* Web Font Loader v1.6.28 - (c) Adobe Systems, Google. License: Apache 2.0 */(function(){function aa(a,b,c){return a.call.apply(a.bind,arguments)}function ba(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function p(a,b,c){p=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?aa:ba;return p.apply(null,arguments)}var q=Date.now||function(){return+new Date};function ca(a,b){this.a=a;this.o=b||a;this.c=this.o.document}var da=!!window.FontFace;function t(a,b,c,d){b=a.c.createElement(b);if(c)for(var e in c)c.hasOwnProperty(e)&&("style"==e?b.style.cssText=c[e]:b.setAttribute(e,c[e]));d&&b.appendChild(a.c.createTextNode(d));return b}function u(a,b,c){a=a.c.getElementsByTagName(b)[0];a||(a=document.documentElement);a.insertBefore(c,a.lastChild)}function v(a){a.parentNode&&a.parentNode.removeChild(a)}
function w(a,b,c){b=b||[];c=c||[];for(var d=a.className.split(/\s+/),e=0;e<b.length;e+=1){for(var f=!1,g=0;g<d.length;g+=1)if(b[e]===d[g]){f=!0;break}f||d.push(b[e])}b=[];for(e=0;e<d.length;e+=1){f=!1;for(g=0;g<c.length;g+=1)if(d[e]===c[g]){f=!0;break}f||b.push(d[e])}a.className=b.join(" ").replace(/\s+/g," ").replace(/^\s+|\s+$/,"")}function y(a,b){for(var c=a.className.split(/\s+/),d=0,e=c.length;d<e;d++)if(c[d]==b)return!0;return!1}
function ea(a){return a.o.location.hostname||a.a.location.hostname}function z(a,b,c){function d(){m&&e&&f&&(m(g),m=null)}b=t(a,"link",{rel:"stylesheet",href:b,media:"all"});var e=!1,f=!0,g=null,m=c||null;da?(b.onload=function(){e=!0;d()},b.onerror=function(){e=!0;g=Error("Stylesheet failed to load");d()}):setTimeout(function(){e=!0;d()},0);u(a,"head",b)}
function A(a,b,c,d){var e=a.c.getElementsByTagName("head")[0];if(e){var f=t(a,"script",{src:b}),g=!1;f.onload=f.onreadystatechange=function(){g||this.readyState&&"loaded"!=this.readyState&&"complete"!=this.readyState||(g=!0,c&&c(null),f.onload=f.onreadystatechange=null,"HEAD"==f.parentNode.tagName&&e.removeChild(f))};e.appendChild(f);setTimeout(function(){g||(g=!0,c&&c(Error("Script load timeout")))},d||5E3);return f}return null};function B(){this.a=0;this.c=null}function C(a){a.a++;return function(){a.a--;D(a)}}function E(a,b){a.c=b;D(a)}function D(a){0==a.a&&a.c&&(a.c(),a.c=null)};function F(a){this.a=a||"-"}F.prototype.c=function(a){for(var b=[],c=0;c<arguments.length;c++)b.push(arguments[c].replace(/[\W_]+/g,"").toLowerCase());return b.join(this.a)};function G(a,b){this.c=a;this.f=4;this.a="n";var c=(b||"n4").match(/^([nio])([1-9])$/i);c&&(this.a=c[1],this.f=parseInt(c[2],10))}function fa(a){return H(a)+" "+(a.f+"00")+" 300px "+I(a.c)}function I(a){var b=[];a=a.split(/,\s*/);for(var c=0;c<a.length;c++){var d=a[c].replace(/['"]/g,"");-1!=d.indexOf(" ")||/^\d/.test(d)?b.push("'"+d+"'"):b.push(d)}return b.join(",")}function J(a){return a.a+a.f}function H(a){var b="normal";"o"===a.a?b="oblique":"i"===a.a&&(b="italic");return b}
function ga(a){var b=4,c="n",d=null;a&&((d=a.match(/(normal|oblique|italic)/i))&&d[1]&&(c=d[1].substr(0,1).toLowerCase()),(d=a.match(/([1-9]00|normal|bold)/i))&&d[1]&&(/bold/i.test(d[1])?b=7:/[1-9]00/.test(d[1])&&(b=parseInt(d[1].substr(0,1),10))));return c+b};function ha(a,b){this.c=a;this.f=a.o.document.documentElement;this.h=b;this.a=new F("-");this.j=!1!==b.events;this.g=!1!==b.classes}function ia(a){a.g&&w(a.f,[a.a.c("wf","loading")]);K(a,"loading")}function L(a){if(a.g){var b=y(a.f,a.a.c("wf","active")),c=[],d=[a.a.c("wf","loading")];b||c.push(a.a.c("wf","inactive"));w(a.f,c,d)}K(a,"inactive")}function K(a,b,c){if(a.j&&a.h[b])if(c)a.h[b](c.c,J(c));else a.h[b]()};function ja(){this.c={}}function ka(a,b,c){var d=[],e;for(e in b)if(b.hasOwnProperty(e)){var f=a.c[e];f&&d.push(f(b[e],c))}return d};function M(a,b){this.c=a;this.f=b;this.a=t(this.c,"span",{"aria-hidden":"true"},this.f)}function N(a){u(a.c,"body",a.a)}function O(a){return"display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:"+I(a.c)+";"+("font-style:"+H(a)+";font-weight:"+(a.f+"00")+";")};function P(a,b,c,d,e,f){this.g=a;this.j=b;this.a=d;this.c=c;this.f=e||3E3;this.h=f||void 0}P.prototype.start=function(){var a=this.c.o.document,b=this,c=q(),d=new Promise(function(d,e){function f(){q()-c>=b.f?e():a.fonts.load(fa(b.a),b.h).then(function(a){1<=a.length?d():setTimeout(f,25)},function(){e()})}f()}),e=null,f=new Promise(function(a,d){e=setTimeout(d,b.f)});Promise.race([f,d]).then(function(){e&&(clearTimeout(e),e=null);b.g(b.a)},function(){b.j(b.a)})};function Q(a,b,c,d,e,f,g){this.v=a;this.B=b;this.c=c;this.a=d;this.s=g||"BESbswy";this.f={};this.w=e||3E3;this.u=f||null;this.m=this.j=this.h=this.g=null;this.g=new M(this.c,this.s);this.h=new M(this.c,this.s);this.j=new M(this.c,this.s);this.m=new M(this.c,this.s);a=new G(this.a.c+",serif",J(this.a));a=O(a);this.g.a.style.cssText=a;a=new G(this.a.c+",sans-serif",J(this.a));a=O(a);this.h.a.style.cssText=a;a=new G("serif",J(this.a));a=O(a);this.j.a.style.cssText=a;a=new G("sans-serif",J(this.a));a=
O(a);this.m.a.style.cssText=a;N(this.g);N(this.h);N(this.j);N(this.m)}var R={D:"serif",C:"sans-serif"},S=null;function T(){if(null===S){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);S=!!a&&(536>parseInt(a[1],10)||536===parseInt(a[1],10)&&11>=parseInt(a[2],10))}return S}Q.prototype.start=function(){this.f.serif=this.j.a.offsetWidth;this.f["sans-serif"]=this.m.a.offsetWidth;this.A=q();U(this)};
function la(a,b,c){for(var d in R)if(R.hasOwnProperty(d)&&b===a.f[R[d]]&&c===a.f[R[d]])return!0;return!1}function U(a){var b=a.g.a.offsetWidth,c=a.h.a.offsetWidth,d;(d=b===a.f.serif&&c===a.f["sans-serif"])||(d=T()&&la(a,b,c));d?q()-a.A>=a.w?T()&&la(a,b,c)&&(null===a.u||a.u.hasOwnProperty(a.a.c))?V(a,a.v):V(a,a.B):ma(a):V(a,a.v)}function ma(a){setTimeout(p(function(){U(this)},a),50)}function V(a,b){setTimeout(p(function(){v(this.g.a);v(this.h.a);v(this.j.a);v(this.m.a);b(this.a)},a),0)};function W(a,b,c){this.c=a;this.a=b;this.f=0;this.m=this.j=!1;this.s=c}var X=null;W.prototype.g=function(a){var b=this.a;b.g&&w(b.f,[b.a.c("wf",a.c,J(a).toString(),"active")],[b.a.c("wf",a.c,J(a).toString(),"loading"),b.a.c("wf",a.c,J(a).toString(),"inactive")]);K(b,"fontactive",a);this.m=!0;na(this)};
W.prototype.h=function(a){var b=this.a;if(b.g){var c=y(b.f,b.a.c("wf",a.c,J(a).toString(),"active")),d=[],e=[b.a.c("wf",a.c,J(a).toString(),"loading")];c||d.push(b.a.c("wf",a.c,J(a).toString(),"inactive"));w(b.f,d,e)}K(b,"fontinactive",a);na(this)};function na(a){0==--a.f&&a.j&&(a.m?(a=a.a,a.g&&w(a.f,[a.a.c("wf","active")],[a.a.c("wf","loading"),a.a.c("wf","inactive")]),K(a,"active")):L(a.a))};function oa(a){this.j=a;this.a=new ja;this.h=0;this.f=this.g=!0}oa.prototype.load=function(a){this.c=new ca(this.j,a.context||this.j);this.g=!1!==a.events;this.f=!1!==a.classes;pa(this,new ha(this.c,a),a)};
function qa(a,b,c,d,e){var f=0==--a.h;(a.f||a.g)&&setTimeout(function(){var a=e||null,m=d||null||{};if(0===c.length&&f)L(b.a);else{b.f+=c.length;f&&(b.j=f);var h,l=[];for(h=0;h<c.length;h++){var k=c[h],n=m[k.c],r=b.a,x=k;r.g&&w(r.f,[r.a.c("wf",x.c,J(x).toString(),"loading")]);K(r,"fontloading",x);r=null;if(null===X)if(window.FontFace){var x=/Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),xa=/OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent)&&/Apple/.exec(window.navigator.vendor);
X=x?42<parseInt(x[1],10):xa?!1:!0}else X=!1;X?r=new P(p(b.g,b),p(b.h,b),b.c,k,b.s,n):r=new Q(p(b.g,b),p(b.h,b),b.c,k,b.s,a,n);l.push(r)}for(h=0;h<l.length;h++)l[h].start()}},0)}function pa(a,b,c){var d=[],e=c.timeout;ia(b);var d=ka(a.a,c,a.c),f=new W(a.c,b,e);a.h=d.length;b=0;for(c=d.length;b<c;b++)d[b].load(function(b,d,c){qa(a,f,b,d,c)})};function ra(a,b){this.c=a;this.a=b}
ra.prototype.load=function(a){function b(){if(f["__mti_fntLst"+d]){var c=f["__mti_fntLst"+d](),e=[],h;if(c)for(var l=0;l<c.length;l++){var k=c[l].fontfamily;void 0!=c[l].fontStyle&&void 0!=c[l].fontWeight?(h=c[l].fontStyle+c[l].fontWeight,e.push(new G(k,h))):e.push(new G(k))}a(e)}else setTimeout(function(){b()},50)}var c=this,d=c.a.projectId,e=c.a.version;if(d){var f=c.c.o;A(this.c,(c.a.api||"https://fast.fonts.net/jsapi")+"/"+d+".js"+(e?"?v="+e:""),function(e){e?a([]):(f["__MonotypeConfiguration__"+
d]=function(){return c.a},b())}).id="__MonotypeAPIScript__"+d}else a([])};function sa(a,b){this.c=a;this.a=b}sa.prototype.load=function(a){var b,c,d=this.a.urls||[],e=this.a.families||[],f=this.a.testStrings||{},g=new B;b=0;for(c=d.length;b<c;b++)z(this.c,d[b],C(g));var m=[];b=0;for(c=e.length;b<c;b++)if(d=e[b].split(":"),d[1])for(var h=d[1].split(","),l=0;l<h.length;l+=1)m.push(new G(d[0],h[l]));else m.push(new G(d[0]));E(g,function(){a(m,f)})};function ta(a,b){a?this.c=a:this.c=ua;this.a=[];this.f=[];this.g=b||""}var ua="https://fonts.googleapis.com/css";function va(a,b){for(var c=b.length,d=0;d<c;d++){var e=b[d].split(":");3==e.length&&a.f.push(e.pop());var f="";2==e.length&&""!=e[1]&&(f=":");a.a.push(e.join(f))}}
function wa(a){if(0==a.a.length)throw Error("No fonts to load!");if(-1!=a.c.indexOf("kit="))return a.c;for(var b=a.a.length,c=[],d=0;d<b;d++)c.push(a.a[d].replace(/ /g,"+"));b=a.c+"?family="+c.join("%7C");0<a.f.length&&(b+="&subset="+a.f.join(","));0<a.g.length&&(b+="&text="+encodeURIComponent(a.g));return b};function ya(a){this.f=a;this.a=[];this.c={}}
var za={latin:"BESbswy","latin-ext":"\u00e7\u00f6\u00fc\u011f\u015f",cyrillic:"\u0439\u044f\u0416",greek:"\u03b1\u03b2\u03a3",khmer:"\u1780\u1781\u1782",Hanuman:"\u1780\u1781\u1782"},Aa={thin:"1",extralight:"2","extra-light":"2",ultralight:"2","ultra-light":"2",light:"3",regular:"4",book:"4",medium:"5","semi-bold":"6",semibold:"6","demi-bold":"6",demibold:"6",bold:"7","extra-bold":"8",extrabold:"8","ultra-bold":"8",ultrabold:"8",black:"9",heavy:"9",l:"3",r:"4",b:"7"},Ba={i:"i",italic:"i",n:"n",normal:"n"},
Ca=/^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
function Da(a){for(var b=a.f.length,c=0;c<b;c++){var d=a.f[c].split(":"),e=d[0].replace(/\+/g," "),f=["n4"];if(2<=d.length){var g;var m=d[1];g=[];if(m)for(var m=m.split(","),h=m.length,l=0;l<h;l++){var k;k=m[l];if(k.match(/^[\w-]+$/)){var n=Ca.exec(k.toLowerCase());if(null==n)k="";else{k=n[2];k=null==k||""==k?"n":Ba[k];n=n[1];if(null==n||""==n)n="4";else var r=Aa[n],n=r?r:isNaN(n)?"4":n.substr(0,1);k=[k,n].join("")}}else k="";k&&g.push(k)}0<g.length&&(f=g);3==d.length&&(d=d[2],g=[],d=d?d.split(","):
g,0<d.length&&(d=za[d[0]])&&(a.c[e]=d))}a.c[e]||(d=za[e])&&(a.c[e]=d);for(d=0;d<f.length;d+=1)a.a.push(new G(e,f[d]))}};function Ea(a,b){this.c=a;this.a=b}var Fa={Arimo:!0,Cousine:!0,Tinos:!0};Ea.prototype.load=function(a){var b=new B,c=this.c,d=new ta(this.a.api,this.a.text),e=this.a.families;va(d,e);var f=new ya(e);Da(f);z(c,wa(d),C(b));E(b,function(){a(f.a,f.c,Fa)})};function Ga(a,b){this.c=a;this.a=b}Ga.prototype.load=function(a){var b=this.a.id,c=this.c.o;b?A(this.c,(this.a.api||"https://use.typekit.net")+"/"+b+".js",function(b){if(b)a([]);else if(c.Typekit&&c.Typekit.config&&c.Typekit.config.fn){b=c.Typekit.config.fn;for(var e=[],f=0;f<b.length;f+=2)for(var g=b[f],m=b[f+1],h=0;h<m.length;h++)e.push(new G(g,m[h]));try{c.Typekit.load({events:!1,classes:!1,async:!0})}catch(l){}a(e)}},2E3):a([])};function Ha(a,b){this.c=a;this.f=b;this.a=[]}Ha.prototype.load=function(a){var b=this.f.id,c=this.c.o,d=this;b?(c.__webfontfontdeckmodule__||(c.__webfontfontdeckmodule__={}),c.__webfontfontdeckmodule__[b]=function(b,c){for(var g=0,m=c.fonts.length;g<m;++g){var h=c.fonts[g];d.a.push(new G(h.name,ga("font-weight:"+h.weight+";font-style:"+h.style)))}a(d.a)},A(this.c,(this.f.api||"https://f.fontdeck.com/s/css/js/")+ea(this.c)+"/"+b+".js",function(b){b&&a([])})):a([])};var Y=new oa(window);Y.a.c.custom=function(a,b){return new sa(b,a)};Y.a.c.fontdeck=function(a,b){return new Ha(b,a)};Y.a.c.monotype=function(a,b){return new ra(b,a)};Y.a.c.typekit=function(a,b){return new Ga(b,a)};Y.a.c.google=function(a,b){return new Ea(b,a)};var Z={load:p(Y.load,Y)}; true?!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return Z}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):"undefined"!==typeof module&&module.exports?module.exports=Z:(window.WebFont=Z,window.WebFontConfig&&Y.load(window.WebFontConfig));}());


/***/ }),
/* 633 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 634 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 635 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })
/******/ ]);